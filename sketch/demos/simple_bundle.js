/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demos/simple.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demos/simple.js":
/*!*************************!*\
  !*** ./demos/simple.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_index__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const sketch = function(p) {
  let modelState; // Store the hidden states of rnn's neurons.
  const temperature = 0.45; // Controls the amount of uncertainty of the model.
  let modelLoaded = false;

  let dx, dy; // Offsets of the pen strokes, in pixels.
  let x, y; // Absolute coordinates on the screen of where the pen is.
  let pen = [0,0,0]; // Current pen state, [pen_down, pen_up, pen_end].
  let previousPen = [1, 0, 0]; // Previous pen state.
  const PEN = {DOWN: 0, UP: 1, END: 2};

  // Load the model.
  const model = new _src_index__WEBPACK_IMPORTED_MODULE_0__["SketchRNN"]('https://storage.googleapis.com/quickdraw-models/sketchRNN/large_models/bird.gen.json');


  /*
   * Main p5 code
   */
  p.setup = function() {
    const containerSize = document.getElementById('sketch').getBoundingClientRect();
    // Initialize the canvas.
    const screenWidth = Math.floor(containerSize.width);
    const screenHeight = p.windowHeight / 2;
    p.createCanvas(screenWidth, screenHeight);
    p.frameRate(60);

    model.initialize().then(function() {
      // Initialize the scale factor for the model. Bigger -> large outputs
      model.setPixelFactor(3.0);
      modelLoaded = true;
      restart();
      console.log('SketchRNN model loaded.');
    });
  };

  // Drawing loop.
  p.draw = function() {
    if (!modelLoaded) {
      return;
    }

    // If we finished the previous drawing, start a new one.
    if (previousPen[PEN.END] === 1) {
      restart();
    }

    // New state.
    [dx, dy, ...pen] = sampleNewState();

    // Only draw on the paper if the pen is still touching the paper.
    if (previousPen[PEN.DOWN] == 1) {
      p.line(x, y, x+dx, y+dy); // Draw line connecting prev point to current point.
    }

    // Update the absolute coordinates from the offsets
    x += dx;
    y += dy;

    // Update the previous pen's state to the current one we just sampled.
    previousPen = pen;
  };

  /*
   * Helpers.
   */
  function sampleNewState() {
    // Using the previous pen states, and hidden state, get next hidden state
    // the below line takes the most CPU power, especially for large models.
    modelState = model.update([dx, dy, ...pen], modelState);

    // Get the parameters of the probability distribution (pdf) from hidden state.
    const pdf = model.getPDF(modelState, temperature);

    // Sample the next pen's states from our probability distribution.
    return model.sample(pdf);
  }

  function setupNewDrawing() {
    p.background(255, 255, 255, 255);
    x = p.width / 2.0;
    y = p.height / 3.0;
    const lineColor = p.color(p.random(64, 224), p.random(64, 224), p.random(64, 224));

    p.strokeWeight(3.0);
    p.stroke(lineColor);
  }

  function restart() {
    [dx, dy, ...pen] = model.zeroInput();  // Reset the pen state.
    modelState = model.zeroState();  // Reset the model state.
    setupNewDrawing();
  }
};

new p5(sketch, 'sketch');


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js ***!
  \**************************************************************************/
/*! exports provided: GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return GraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return loadGraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DataType,SaverDef,__assign=function(){return(__assign=Object.assign||function(e){for(var t,a=1,r=arguments.length;a<r;a++)for(var n in t=arguments[a])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)};function __awaiter(e,t,a,r){return new(a||(a=Promise))(function(n,s){function o(e){try{i(r.next(e))}catch(e){s(e)}}function p(e){try{i(r.throw(e))}catch(e){s(e)}}function i(e){e.done?n(e.value):new a(function(t){t(e.value)}).then(o,p)}i((r=r.apply(e,t||[])).next())})}function __generator(e,t){var a,r,n,s,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:p(0),throw:p(1),return:p(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function p(s){return function(p){return function(s){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,r&&(n=2&s[0]?r.return:s[0]?r.throw||((n=r.return)&&n.call(r),0):r.next)&&!(n=n.call(r,s[1])).done)return n;switch(r=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(n=(n=o.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){o.label=s[1];break}if(6===s[0]&&o.label<n[1]){o.label=n[1],n=s;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(s);break}n[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{a=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,p])}}}function getParamValue(e,t,a,r){var n=t.inputParams[e];if(n&&void 0!==n.inputIndexStart){var s=n.inputIndexStart,o=0===n.inputIndexEnd?void 0:void 0===n.inputIndexEnd?s+1:n.inputIndexEnd;if("tensor"===n.type)return getTensor(t.inputNames[n.inputIndexStart],a,r);if("tensors"===n.type)return t.inputNames.slice(s,o).map(function(e){return getTensor(e,a,r)});var p=Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0],a,r).dataSync());return"number"===n.type?p[0]:p}var i=t.attrParams[e];return i&&i.value}function getTensor(e,t,a){var r=parseNodeName(e),n=r[0],s=r[1],o=a.currentContextIds.find(function(e){return!!t[getNodeNameWithContextId(n,e)]});return void 0!==o?t[getNodeNameWithContextId(n,o)][s]:void 0}function getTensorsForCurrentContenxt(e,t,a){return t[getNodeNameWithContextId(e,a.currentContextId)]}function getNodeNameAndIndex(e,t){var a=parseNodeName(e),r=a[0],n=a[1];return[getNodeNameWithContextId(r,t&&t.currentContextId),n]}function getNodeNameWithContextId(e,t){return t?e+"-"+t:e}function parseNodeName(e){var t=e.lastIndexOf(":");return-1===t?[e,0]:[e.substring(0,t),Number(e.substring(t+1))]}function split$1(e,t){for(var a=[],r=0;r<e.length;r+=t)a.push(e.slice(r,r+t));return a}!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(DataType||(DataType={})),function(e){!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(SaverDef||(SaverDef={}));var json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],image$1=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],spectral=Object.freeze({json:json$14}),json$15=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$15}),CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"],OperationMapper=function(){function e(){var e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image$1,graph,matrices,normalization,reduction,sliceJoin,spectral,transformation],t=[].concat.apply([],e.map(function(e){return e.json}));this.opMappers=t.reduce(function(e,t){return e[t.tfOpName]=t,e},{})}return Object.defineProperty(e,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),e.prototype.isControlFlow=function(e){return CONTROL_FLOW_OPS.some(function(t){return t===e.op})},e.prototype.isDynamicShape=function(e){return DYNAMIC_SHAPE_OPS.some(function(t){return t===e.op})},e.prototype.transformGraph=function(e){var t=this,a=!1,r=!1,n=[],s=[],o=e.node.reduce(function(e,o){return e[o.name]=t.mapNode(o),t.isControlFlow(o)&&(a=!0),t.isDynamicShape(o)&&(r=!0),"Placeholder"===o.op&&n.push(e[o.name]),"Const"===o.op&&s.push(e[o.name]),e},{}),p=[],i=[];return Object.keys(o).forEach(function(e){var t=o[e];t.inputNames.forEach(function(e){var a=getNodeNameAndIndex(e)[0];t.inputs.push(o[a]),o[a].children.push(t)}),0===t.inputs.length&&p.push(t)}),Object.keys(o).forEach(function(e){var t=o[e];0===t.children.length&&i.push(t)}),{nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,withControlFlow:a,withDynamicShape:r}},e.prototype.mapNode=function(e){var t=this,a=this.opMappers[e.op];if(void 0===a)throw new Error("Tensorflow Op is not supported: "+e.op);var r={name:e.name,op:e.op,category:a.category,inputNames:(e.input||[]).map(function(e){return e.startsWith("^")?e.substr(1):e}),inputs:[],children:[],inputParams:{},attrParams:{}};return null==e.attr&&(e.attr={}),null!=a.inputs&&(r.inputParams=a.inputs.reduce(function(e,t){return e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e},{})),null!=a.attrs&&(r.attrParams=a.attrs.reduce(function(a,r){var n=r.type,s=void 0;switch(r.type){case"string":void 0===(s=t.getStringParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getStringParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":void 0===(s=t.getNumberParam(e.attr,r.tfName,r.defaultValue||0))&&r.tfDeprecatedName&&(s=t.getNumberParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":void 0===(s=t.getNumericArrayParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getNumericArrayParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":void 0===(s=t.getBoolParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getBoolParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":void 0===(s=t.getTensorShapeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getTensorShapeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":void 0===(s=t.getDtypeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getDtypeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+r.type+" for op: "+e.op)}return a[r.name]={value:s,type:n},a},{})),r},e.prototype.decodeBase64=function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")},e.prototype.getStringParam=function(e,t,a,r){void 0===r&&(r=!1);var n=e[t];if(void 0!==n){var s=Array.isArray(n.s)?String.fromCharCode.apply(null,n.s):this.decodeBase64(n.s);return r?s:s.toLowerCase()}return a},e.prototype.getBoolParam=function(e,t,a){var r=e[t];return r?r.b:a},e.prototype.getNumberParam=function(e,t,a){var r=e[t]||{},n=r.i?r.i:r.f?r.f:a;return"number"==typeof n?n:parseInt(n,10)},e.prototype.getDtypeParam=function(e,t,a){var r=e[t];if(r&&r.type){var n=r.type;switch("string"==typeof r.type&&(n=DataType[r.type]),n){case DataType.DT_FLOAT:return"float32";case DataType.DT_INT32:return"int32";case DataType.DT_BOOL:return"bool";default:return a}}return a},e.prototype.getTensorShapeParam=function(e,t,a){var r=e[t];if(r&&r.shape){if(r.shape.unknownRank)return;if(null!=r.shape.dim)return r.shape.dim.map(function(e){return"number"==typeof e.size?e.size:parseInt(e.size,10)})}return a},e.prototype.getNumericArrayParam=function(e,t,a){var r=e[t];return r?(r.list.f&&r.list.f.length?r.list.f:r.list.i).map(function(e){return"number"==typeof e?e:parseInt(e,10)}):a},e}(),executeOp=function(e,t,a){switch(e.op){case"BiasAdd":case"Add":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"AddN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"])(getParamValue("tensors",e,t,a))];case"FloorMod":case"Mod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Mul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"RealDiv":case"Div":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"FloorDiv":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Sub":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Minimum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Maximum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Pow":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"SquaredDifference":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$1=function(e,t,a){switch(e.op){case"Abs":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(getParamValue("x",e,t,a))];case"Acos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"])(getParamValue("x",e,t,a))];case"Acosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"])(getParamValue("x",e,t,a))];case"Asin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"])(getParamValue("x",e,t,a))];case"Asinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"])(getParamValue("x",e,t,a))];case"Atan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"])(getParamValue("x",e,t,a))];case"Atan2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case"Atanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"])(getParamValue("x",e,t,a))];case"Ceil":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"])(getParamValue("x",e,t,a))];case"Cos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"])(getParamValue("x",e,t,a))];case"Cosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"])(getParamValue("x",e,t,a))];case"Elu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(getParamValue("x",e,t,a))];case"Erf":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"])(getParamValue("x",e,t,a))];case"Exp":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"])(getParamValue("x",e,t,a))];case"Expm1":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"])(getParamValue("x",e,t,a))];case"Floor":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(getParamValue("x",e,t,a))];case"Log":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(getParamValue("x",e,t,a))];case"Log1p":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"])(getParamValue("x",e,t,a))];case"Neg":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(getParamValue("x",e,t,a))];case"Reciprocal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"])(getParamValue("x",e,t,a))];case"Relu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(getParamValue("x",e,t,a))];case"Round":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"])(getParamValue("x",e,t,a))];case"Selu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(getParamValue("x",e,t,a))];case"Sigmoid":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(getParamValue("x",e,t,a))];case"Sin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"])(getParamValue("x",e,t,a))];case"Sign":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"])(getParamValue("x",e,t,a))];case"Sinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"])(getParamValue("x",e,t,a))];case"Softplus":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(getParamValue("x",e,t,a))];case"Sqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(getParamValue("x",e,t,a))];case"Square":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"])(getParamValue("x",e,t,a))];case"Tanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(getParamValue("x",e,t,a))];case"Tan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"])(getParamValue("x",e,t,a))];case"Relu6":case"ClipByValue":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(getParamValue("x",e,t,a),getParamValue("clipValueMin",e,t,a),getParamValue("clipValueMax",e,t,a))];case"Rsqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"])(getTensor(e.inputNames[0],t,a))];case"Prod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),getParamValue("axes",e,t,a))];case"LeakyRelu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(getParamValue("x",e,t,a),getParamValue("alpha",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},TensorArray=function(){function e(t,a,r,n,s,o,p){this.name=t,this.dtype=a,this.maxSize=r,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=p,this.tensors=[],this.closed_=!1,this.id=e.nextId++}return Object.defineProperty(e.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),e.prototype.clearAndClose=function(){this.tensors.forEach(function(e){return e.tensor.dispose()}),this.tensors=[],this.closed_=!0},e.prototype.size=function(){return this.tensors.length},e.prototype.read=function(e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||e>=this.tensors.length)throw new Error("Tried to read from index "+e+", but array size is: "+this.tensors.length);var t=this.tensors[e];if(t.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+e+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor},e.prototype.readMany=function(e){var t=this;return e.map(function(e){return t.read(e)})},e.prototype.write=function(e,t){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index "+e+", but array is not resizeable and size is: "+this.maxSize);var a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+",\n          because the value dtype is "+t.dtype+", but TensorArray dtype is "+this.dtype+".");if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),this.assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+e+"."),a&&a.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been read.");if(a&&a.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been written.");a.tensor=t,a.written=!0,this.tensors[e]=a},e.prototype.writeMany=function(e,t){var a=this;if(e.length!==t.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+e.length+" is not the same as tensors size: "+t.length+".");e.forEach(function(e,r){return a.write(e,t[r])})},e.prototype.gather=function(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+t);if(!e){e=[];for(var a=0;a<this.size();a++)e.push(a)}if(0===e.length)return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));var r=this.readMany(e);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(r,0)},e.prototype.concat=function(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+e);if(0===this.size())return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));for(var t=[],a=0;a<this.size();a++)t.push(a);var r=this.readMany(t);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+r[0].shape+")"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(r,0)},e.prototype.scatter=function(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+t.shape[0]);var a=Math.max.apply(Math,e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error("Max index must be < array size ("+a+"  vs. "+this.maxSize+")");this.writeMany(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t,0))},e.prototype.split=function(e,t){var a=this;if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);var r=0,n=e.map(function(e){return r+=e});if(r!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+r+", and tensor's shape is: "+t.shape);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+e.length+"), and the TensorArray is not marked as dynamically resizeable");var s=0===r?0:t.size/r,o=[];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t=t.reshape([1,r,s]);for(var p=0;p<e.length;++p){var i=[0,0===p?0:n[p-1],0],u=[1,e[p],s];o[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(t,i,u).reshape(a.elementShape)}return o});for(var p=[],i=0;i<e.length;i++)p[i]=i;this.writeMany(p,o)},e.prototype.assertShapesMatchAllowUndefinedSize=function(e,t,a){void 0===a&&(a=""),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(this.shapesEqualAllowUndefinedSize(e,t),function(){return a+" Shapes "+e+" and "+t+" must match"})},e.prototype.shapesEqualAllowUndefinedSize=function(e,t){if(e.length!==t.length)return!1;for(var a=0;a<e.length;a++)if(-1!==e[a]&&-1!==t[a]&&e[a]!==t[a])return!1;return!0},e.nextId=0,e}();function executeOp$2(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c,l,d,y,f,h,g,N,x,b,V,P,T,O,v,S,_,w,A,D,E,I,M,C,k,j,z;return __generator(this,function(F){switch(F.label){case 0:switch(e.op){case"LoopCond":return[3,1];case"Switch":return[3,2];case"Merge":return[3,4];case"Enter":return[3,5];case"Exit":return[3,6];case"NextIteration":return[3,7];case"TensorArrayV3":return[3,8];case"TensorArrayWriteV3":return[3,9];case"TensorArrayReadV3":return[3,10];case"TensorArrayGatherV3":return[3,11];case"TensorArrayScatterV3":return[3,12];case"TensorArrayConcatV3":return[3,13];case"TensorArraySplitV3":return[3,14];case"TensorArraySizeV3":return[3,15];case"TensorArrayCloseV3":return[3,16]}return[3,17];case 1:return[2,[getParamValue("pred",e,t,a).clone()]];case 2:return r=getParamValue("pred",e,t,a),n=getParamValue("data",e,t,a),[4,r.data()];case 3:return[2,F.sent()[0]?[void 0,n.clone()]:[n.clone(),void 0]];case 4:return[2,(s=e.inputNames.find(function(e){return void 0!==getTensor(e,t,a)}))?[getTensor(s,t,a).clone()]:void 0];case 5:return o=getParamValue("frameName",e,t,a),p=getParamValue("tensor",e,t,a),a.enterFrame(o),[2,[p.clone()]];case 6:return i=getParamValue("tensor",e,t,a),a.exitFrame(),[2,[i.clone()]];case 7:return u=getParamValue("tensor",e,t,a),a.nextIteration(),[2,[u.clone()]];case 8:return m=getParamValue("size",e,t,a),c=getParamValue("dtype",e,t,a),l=getParamValue("elementShape",e,t,a),d=getParamValue("dynamicSize",e,t,a),y=getParamValue("clearAfterRead",e,t,a),f=getParamValue("identicalElementShapes",e,t,a),h=getParamValue("name",e,t,a),g=new TensorArray(h,c,m,l,f,d,y),a.addTensorArray(g),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(g.id),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 9:return N=getParamValue("tensorArrayId",e,t,a),x=getParamValue("index",e,t,a),b=getParamValue("tensor",e,t,a),a.getTensorArray(N).write(x,b),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 10:return V=getParamValue("tensorArrayId",e,t,a),P=getParamValue("index",e,t,a),[2,[a.getTensorArray(V).read(P)]];case 11:return T=getParamValue("tensorArrayId",e,t,a),O=getParamValue("indices",e,t,a),v=getParamValue("dtype",e,t,a),[2,[a.getTensorArray(T).gather(O,v)]];case 12:return S=getParamValue("tensorArrayId",e,t,a),_=getParamValue("indices",e,t,a),w=getParamValue("tensor",e,t,a),a.getTensorArray(S).scatter(_,w),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 13:return A=getParamValue("tensorArrayId",e,t,a),D=a.getTensorArray(A),E=getParamValue("dtype",e,t,a),[2,[D.concat(E)]];case 14:return I=getParamValue("tensorArrayId",e,t,a),M=getParamValue("tensor",e,t,a),C=getParamValue("lengths",e,t,a),a.getTensorArray(I).split(C,M),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 15:return k=getParamValue("tensorArrayId",e,t,a),j=a.getTensorArray(k),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(j.size(),"int32")]];case 16:return z=getParamValue("tensorArrayId",e,t,a),a.getTensorArray(z).clearAndClose(),[2,[]];case 17:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$3=function(e,t,a){switch(e.op){case"Conv1D":var r=getParamValue("stride",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase(),o=getParamValue("dilation",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),r,n,s,o)];case"Conv2D":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();var p=getParamValue("dilations",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"Conv2DBackpropInput":case"Conv2dTranspose":var i=getParamValue("outputShape",e,t,a);r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),i,[r[1],r[2]],n)];case"DepthwiseConv2dNative":case"DepthwiseConv2d":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),p=getParamValue("dilations",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(getParamValue("input",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"AvgPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);var u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];case"MaxPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$4=function(e,t,a){switch(e.op){case"Fill":var r=getParamValue("shape",e,t,a),n=getParamValue("dtype",e,t,a),s=getParamValue("value",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(r,s,n)];case"LinSpace":var o=getParamValue("start",e,t,a),p=getParamValue("stop",e,t,a),i=getParamValue("num",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"])(o,p,i)];case"OneHot":var u=getParamValue("indices",e,t,a),m=getParamValue("depth",e,t,a),c=getParamValue("onValue",e,t,a),l=getParamValue("offValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(u,m,c,l)];case"Ones":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"OnesLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(getParamValue("x",e,t,a))];case"RandomUniform":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(getParamValue("shape",e,t,a),getParamValue("minval",e,t,a),getParamValue("maxval",e,t,a),getParamValue("dtype",e,t,a))];case"Range":o=getParamValue("start",e,t,a);var d=getParamValue("stop",e,t,a),y=getParamValue("step",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"])(o,d,y,getParamValue("dtype",e,t,a))];case"TruncatedNormal":r=getParamValue("shape",e,t,a);var f=getParamValue("mean",e,t,a),h=getParamValue("stdDev",e,t,a),g=getParamValue("seed",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(r,f,h,getParamValue("dtype",e,t,a),g)];case"Zeros":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"ZerosLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$5(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p;return __generator(this,function(i){switch(i.label){case 0:switch(e.op){case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":return[3,1];case"Where":return[3,3];case"ListDiff":return[3,5]}return[3,7];case 1:return r=getParamValue("boxes",e,t,a),n=getParamValue("scores",e,t,a),s=getParamValue("maxOutputSize",e,t,a),o=getParamValue("iouThreshold",e,t,a),p=getParamValue("scoreThreshold",e,t,a),[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].nonMaxSuppressionAsync(r,n,s,o,p)];case 2:return[2,[i.sent()]];case 3:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"])(getParamValue("condition",e,t,a))];case 4:return[2,[i.sent()]];case 5:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case 6:return[2,i.sent()];case 7:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$6=function(e,t,a){switch(e.op){case"TopKV2":var r=getParamValue("x",e,t,a),n=getParamValue("k",e,t,a),s=getParamValue("sorted",e,t,a),o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"])(r,n,s);return[o.values,o.indices];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$7=function(e,t,a){switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":var r=getParamValue("default",e,t,a);return[getTensor(e.name,t,a)||r];case"Placeholder":return[getTensor(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[getParamValue("x",e,t,a).clone()];case"IdentityN":return getParamValue("x",e,t,a).map(function(e){return e.clone()});case"Snapshot":return[getParamValue("x",e,t,a).clone()];case"Shape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(getParamValue("x",e,t,a).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,a).map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e.shape)});case"Size":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).size,"int32")];case"Rank":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).rank,"int32")];case"NoOp":return[];case"Print":var n=getParamValue("x",e,t,a),s=getParamValue("data",e,t,a),o=getParamValue("message",e,t,a),p=getParamValue("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(var i=0;i<s.length;i++)console.log(Array.prototype.slice.call(s[i].dataSync()).slice(0,p));return[n];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$8=function(e,t,a){switch(e.op){case"ResizeBilinear":var r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(r,[n[0],n[1]],s)];case"ResizeNearestNeighbor":r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeNearestNeighbor(r,[n[0],n[1]],s)];case"CropAndResize":var o=getParamValue("image",e,t,a),p=getParamValue("boxes",e,t,a),i=getParamValue("boxInd",e,t,a),u=getParamValue("cropSize",e,t,a),m=getParamValue("method",e,t,a),c=getParamValue("extrapolationValue",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(o,p,i,u,m,c)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$9=function(e,t,a){switch(e.op){case"Equal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"NotEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Greater":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"GreaterEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Less":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LessEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalAnd":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalNot":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"])(getParamValue("a",e,t,a))];case"LogicalOr":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Select":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(getParamValue("condition",e,t,a),getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$10=function(e,t,a){switch(e.op){case"BatchMatMul":case"MatMul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a),getParamValue("transposeA",e,t,a),getParamValue("transposeB",e,t,a))];case"Transpose":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getParamValue("x",e,t,a),getParamValue("perm",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$11=function(e,t,a){switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"])(getParamValue("x",e,t,a),getParamValue("mean",e,t,a),getParamValue("variance",e,t,a),getParamValue("offset",e,t,a),getParamValue("scale",e,t,a),getParamValue("epsilon",e,t,a))];case"LRN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"])(getParamValue("x",e,t,a),getParamValue("radius",e,t,a),getParamValue("bias",e,t,a),getParamValue("alpha",e,t,a),getParamValue("beta",e,t,a))];case"Softmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(getParamValue("x",e,t,a))];case"LogSoftmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"])(getParamValue("x",e,t,a))];case"SparseToDense":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(getParamValue("sparseIndices",e,t,a),getParamValue("outputShape",e,t,a),getParamValue("sparseValues",e,t,a),getParamValue("defaultValue",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$12=function(e,t,a){switch(e.op){case"Max":var r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(getParamValue("x",e,t,a),r,n)];case"Mean":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(getParamValue("x",e,t,a),r,n)];case"Min":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(getParamValue("x",e,t,a),r,n)];case"Sum":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(getParamValue("x",e,t,a),r,n)];case"All":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(getParamValue("x",e,t,a),r,n)];case"Any":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(getParamValue("x",e,t,a),r,n)];case"ArgMax":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(getParamValue("x",e,t,a),r)];case"ArgMin":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"])(getParamValue("x",e,t,a),r)];case"Prod":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),r,n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$13=function(e,t,a){switch(e.op){case"ConcatV2":case"Concat":var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(n,r)];case"GatherV2":case"Gather":r=getParamValue("axis",e,t,a);var s=getParamValue("x",e,t,a),o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(s,o.asType("int32"),r)];case"ReverseV2":case"Reverse":r=getParamValue("axis",e,t,a),s=getParamValue("x",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(s,r)];case"Slice":var p=getParamValue("begin",e,t,a),i=getParamValue("size",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(getParamValue("x",e,t,a),p,i)];case"StridedSlice":p=getParamValue("begin",e,t,a);var u=getParamValue("end",e,t,a),m=getParamValue("strides",e,t,a),c=getParamValue("beginMask",e,t,a),l=getParamValue("endMask",e,t,a),d=getParamValue("ellipsisMask",e,t,a),y=getParamValue("newAxisMask",e,t,a),f=getParamValue("shrinkAxisMask",e,t,a),h=getParamValue("x",e,t,a);if(1===p.length&&h.shape.length>1)for(var g=1;g<h.shape.length;g++)p.push(0),u.push(h.shape[g]),m.push(m[0]);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"])(h,p,u,m,c,l,d,y,f)];case"Pack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a),s=n[0].shape,o=n[0].squeeze().shape,p=n.map(function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,s);if(!t&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.squeeze().shape,o))throw new Error("the input tensors shape does not match");return t?e:e.reshape(s)});return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(p,r)]});case"Unpack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensor",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(n,r)});case"Tile":var N=getParamValue("reps",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(getParamValue("x",e,t,a),N)];case"Split":case"SplitV":r=getParamValue("axis",e,t,a);var x=getParamValue("numOrSizeSplits",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(getParamValue("x",e,t,a),x,r);case"ScatterNd":o=getParamValue("indices",e,t,a);var b=getParamValue("values",e,t,a),V=getParamValue("shape",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"])(o,b,V)];case"GatherNd":var P=getParamValue("x",e,t,a);o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"])(P,o)];case"SparseToDense":o=getParamValue("sparseIndices",e,t,a),V=getParamValue("outputShape",e,t,a);var T=getParamValue("sparseValues",e,t,a),O=getParamValue("defaultValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(o,T,V,T.dtype===O.dtype?O:O.asType(T.dtype))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$14=function(e,t,a){switch(e.op){case"FFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"])(getParamValue("x",e,t,a))];case"IFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"])(getParamValue("x",e,t,a))];case"RFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"])(getParamValue("x",e,t,a))];case"IRFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$15=function(e,t,a){switch(e.op){case"Cast":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(getParamValue("x",e,t,a),getParamValue("dtype",e,t,a))];case"ExpandDims":var r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(getParamValue("x",e,t,a),r)];case"Squeeze":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(getParamValue("x",e,t,a),r)];case"Reshape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"])(getParamValue("x",e,t,a),getParamValue("shape",e,t,a))];case"PadV2":case"Pad":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(getParamValue("x",e,t,a),split$1(getParamValue("padding",e,t,a),2),getParamValue("constantValue",e,t,a))];case"SpaceToBatchND":var n=getParamValue("blockShape",e,t,a),s=split$1(getParamValue("paddings",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"])(getParamValue("x",e,t,a),n,s)];case"BatchToSpaceND":n=getParamValue("blockShape",e,t,a);var o=split$1(getParamValue("crops",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"])(getParamValue("x",e,t,a),n,o)];case"DepthToSpace":var p=getParamValue("blockSize",e,t,a),i=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"])(getParamValue("x",e,t,a),p,i)];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$16(e,t,a){var r=function(e,t,a){switch(e.category){case"arithmetic":return executeOp(e,t,a);case"basic_math":return executeOp$1(e,t,a);case"control":return executeOp$2(e,t,a);case"convolution":return executeOp$3(e,t,a);case"creation":return executeOp$4(e,t,a);case"dynamic":return executeOp$5(e,t,a);case"evaluation":return executeOp$6(e,t,a);case"image":return executeOp$8(e,t,a);case"graph":return executeOp$7(e,t,a);case"logical":return executeOp$9(e,t,a);case"matrices":return executeOp$10(e,t,a);case"normalization":return executeOp$11(e,t,a);case"reduction":return executeOp$12(e,t,a);case"slice_join":return executeOp$13(e,t,a);case"spectral":return executeOp$14(e,t,a);case"transformation":return executeOp$15(e,t,a);default:throw TypeError("Node type "+e.op+" is not implemented")}}(e,t,a);return r instanceof Promise?r.then(function(e){return[].concat(e)}):[].concat(r)}var ExecutionContext=function(){function e(e,t){this.weightMap=e,this.tensorArrayMap=t,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return e.prototype.newFrame=function(e,t){return{id:e,frameName:t,iterationId:0}},Object.defineProperty(e.prototype,"currentContext",{get:function(){return this.contexts},set:function(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),e.prototype.generateCurrentContextIds=function(){for(var e=[],t=0;t<this.contexts.length-1;t++){var a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e},e.prototype.contextIdforContexts=function(e){return e?e.map(function(e){return 0===e.id&&0===e.iterationId?"":e.frameName+"-"+e.iterationId}).join("/"):""},e.prototype.enterFrame=function(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},e.prototype.exitFrame=function(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},e.prototype.nextIteration=function(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},e.prototype.getWeight=function(e){return this.weightMap[e]},e.prototype.addTensorArray=function(e){this.tensorArrayMap[e.id]=e},e.prototype.getTensorArray=function(e){return this.tensorArrayMap[e]},e}(),GraphExecutor=function(){function e(e){this.graph=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this.placeholders=e.placeholders,this._outputs=e.outputs,this.compile()}return Object.defineProperty(e.prototype,"weightMap",{get:function(){return this._weightMap},set:function(e){var t=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})});this.weightIds=[].concat.apply([],t),this._weightMap=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.placeholders.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this._outputs.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.outputs.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:!0,configurable:!0}),e.prototype.compile=function(e){if(!this.graph.withControlFlow&&!this.graph.withDynamicShape){var t=[],a=e||this.graph.placeholders,r=a.map(function(e){return e.name}).sort().join(this.SEPERATOR);if(!this.compiledMap.get(r)){for(var n=a.concat(this.graph.weights),s={};n.length>0;){var o=n.pop();s[o.name]=!0,t.push(o),o.children.forEach(function(e){!s[e.name]&&e.inputNames.every(function(e){var t=getNodeNameAndIndex(e)[0];return s[t]})&&n.push(e)})}this.compiledMap.set(r,t)}}},e.prototype.execute=function(e,t,a){var r=this;void 0===t&&(t=!0);var n=Object.keys(e).sort();this.checkInput(e,t),this.checkInputShapeAndType(e,t),this.compile(n.map(function(e){return r.graph.nodes[e]}));var s=this.calculateOutputs(a);this.checkOutput(this.compiledMap.get(n.join(this.SEPERATOR)),s);var o={};return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=new ExecutionContext(r._weightMap,o),a=__assign({},r.weightMap,e),p=r.getFrozenTensorIds(a),i={},u=r.compiledMap.get(n.join(r.SEPERATOR)),m=0;m<u.length;m++){var c=u[m];if(a[c.name]||(a[c.name]=executeOp$16(c,a,t),r.checkTensorForDisposal(c.name,c,a,t,p,s,i)),s.every(function(e){return!!a[e]}))break}return r.findOutputs(a,t,s)})},e.prototype.getFrozenTensorIds=function(e){var t=[].concat.apply([],Object.keys(e).map(function(t){return e[t]}).map(function(e){return e.map(function(e){return e.id})}));return new Set(t)},e.prototype.checkTensorForDisposal=function(e,t,a,r,n,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(a[e].forEach(function(e){null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(function(e){if("control"!==e.category){var t=getTensorsForCurrentContenxt(e.name,a,r);null!=t&&t.forEach(function(e){if(e&&!n.has(e.id)){var t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r,n,s,o,p,i,u,m=this;return __generator(this,function(c){switch(c.label){case 0:return this.checkInput(e,!1),this.checkInputShapeAndType(e,!1),a={},r=new ExecutionContext(this._weightMap,a),n=this.calculateOutputs(t),[4,this.executeWithControlFlow(e,r,n)];case 1:return s=c.sent(),o=this.findOutputs(s,r,t),p=Object.keys(o).map(function(e){return o[e].id}),i=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})}),u=[].concat.apply([],i),Object.keys(s).forEach(function(e){s[e].forEach(function(e){e&&!e.isDisposed&&-1===p.indexOf(e.id)&&-1===u.indexOf(e.id)&&-1===m.weightIds.indexOf(e.id)&&e.dispose()})}),[2,o]}})})},e.prototype.executeWithControlFlow=function(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c=this;return __generator(this,function(l){switch(l.label){case 0:r=Object.keys(e),n=r.map(function(e){return c.graph.nodes[e]}),s=n.concat(this.graph.weights).map(function(e){return{node:e,contexts:t.currentContext}}),o=__assign({},this.weightMap,e),p={},i=this.getFrozenTensorIds(o),u={},l.label=1;case 1:return s.length>0?(m=this.processStack(n,s,t,o,u,i,a,p),[4,Promise.all(m)]):[3,3];case 2:return l.sent(),[3,1];case 3:return[2,o]}})})},e.prototype.processStack=function(e,t,a,r,n,s,o,p){for(var i=this,u=[],m=function(){var m=t.pop();a.currentContext=m.contexts;var l="";if("Enter"===m.node.op&&getParamValue("isConstant",m.node,r,a)&&(l=getNodeNameAndIndex(m.node.name,a)[0]),-1===e.indexOf(m.node)){var d=executeOp$16(m.node,r,a);l||(l=getNodeNameAndIndex(m.node.name,a)[0]);var y=a.currentContext;d instanceof Promise?u.push(d.then(function(e){return r[l]=e,a.currentContext=y,i.checkTensorForDisposal(l,m.node,r,a,s,o,p),i.processChildNodes(m.node,t,a,r,n),e})):(r[l]=d,c.checkTensorForDisposal(l,m.node,r,a,s,o,p),c.processChildNodes(m.node,t,a,r,n))}else c.processChildNodes(m.node,t,a,r,n)},c=this;t.length>0;)m();return u},e.prototype.processChildNodes=function(e,t,a,r,n){e.children.forEach(function(e){var s=getNodeNameAndIndex(e.name,a)[0];n[s]||("Merge"===e.op?e.inputNames.some(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})))})},e.prototype.calculateOutputs=function(e){return!e||e instanceof Array||(e=[e]),e||this.graph.outputs.map(function(e){return e.name})},e.prototype.findOutputs=function(e,t,a){return this.calculateOutputs(a).reduce(function(a,r){return a[r]=getTensor(r,e,t),a},{})},e.prototype.dispose=function(){var e=this;Object.keys(this.weightMap).forEach(function(t){return e.weightMap[t].forEach(function(e){return e.dispose()})})},e.prototype.checkInputShapeAndType=function(e,t){void 0===t&&(t=!0),this.placeholders.forEach(function(a){var r=e[a.name];if(t||r){var n=r[0];if(a.attrParams.shape&&a.attrParams.shape.value){var s=a.attrParams.shape.value,o=s.length===n.shape.length&&n.shape.every(function(e,t){return-1===s[t]||s[t]===e});_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o,function(){return"The shape of dict['"+a.name+"'] provided in model.execute(dict) must be ["+s+"], but was ["+n.shape+"]"})}a.attrParams.dtype&&a.attrParams.dtype.value&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.dtype===a.attrParams.dtype.value,function(){return"The dtype of dict['"+a.name+"'] provided in model.execute(dict) must be "+a.attrParams.dtype.value+", but was "+n.dtype})}})},e.prototype.checkInput=function(e,t){var a=this;void 0===t&&(t=!0);var r=Object.keys(e),n=[],s=[];this.inputNodes.forEach(function(e){-1===r.indexOf(e)&&n.push(e)}),r.forEach(function(e){-1===a.inputNodes.indexOf(e)&&s.push(e)});var o=s.filter(function(e){return!a.graph.nodes[e]});if(n.length>0&&t)throw new Error("The dict provided in model.execute(dict) has the keys ["+r+"], but is missing the required keys: ["+n+"].");if(s.length>0&&t)throw new Error("The dict provided in model.execute(dict) has unused keys: ["+s+"]. Please provide only the following keys: ["+this.inputNodes+"].");if(o.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+o+"] not part of model graph.")},e.prototype.checkOutput=function(e,t){var a=e.map(function(e){return e.name}),r=[];if(t.forEach(function(e){var t=parseNodeName(e)[0];-1===a.indexOf(t)&&r.push(t)}),r.length>0)throw new Error("The following outputs are not generated by the execution: ["+r+"].")},e}(),TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json",GraphModel=function(){function e(e,t){void 0===t&&(t={}),this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={})}return Object.defineProperty(e.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),e.prototype.findIOHandler=function(){var e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions);else{var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e,this.loadOptions.onProgress);if(0===t.length)t.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one ("+t.length+") load handlers for URL '"+[e]+"'");this.handler=t[0]}},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,a;return __generator(this,function(r){switch(r.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return e=r.sent(),t=e.modelTopology,this.version=t.versions.producer+"."+t.versions.minConsumer,a=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(e.weightData,e.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),[2,!0]}})})},e.prototype.predict=function(e,t){return this.execute_(e,!0,this.outputNodes)},e.prototype.constructTensorMap=function(e){var t=e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?[e]:e;if(t.length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the graph model has "+this.inputNodes.length+" placeholders, while there are "+t.length+" input tensors.");return this.inputNodes.reduce(function(e,a,r){return e[a]=t[r],e},{})},e.prototype.execute=function(e,t){return this.execute_(e,!1,t)},e.prototype.execute_=function(e,t,a){if(void 0===t&&(t=!0),a=a||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)throw new Error("The model contains control flow or dynamic shape ops, please use executeAsync method");var r=this.executor.execute(this.convertTensorMapToTensorsMap(e),t,a),n=Object.keys(r);return Array.isArray(a)&&a.length>1?a.map(function(e){return r[e]}):r[n[0]]},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r;return __generator(this,function(n){switch(n.label){case 0:if(!this.executor.isControlFlowModel&&!this.executor.isDynamicShapeModel)throw new Error("The model does not contain control flow or dynamic shape ops, please use execute method for better performance.");return t=t||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(e),t)];case 1:return a=n.sent(),r=Object.keys(a),[2,Array.isArray(t)&&t.length>1?t.map(function(e){return a[e]}):a[r[0]]]}})})},e.prototype.convertTensorMapToTensorsMap=function(e){return Object.keys(e).reduce(function(t,a){return t[a]=[e[a]],t},{})},e.prototype.dispose=function(){this.executor.dispose()},e}();function loadGraphModel(e,t){return void 0===t&&(t={}),__awaiter(this,void 0,void 0,function(){var a;return __generator(this,function(r){switch(r.label){case 0:if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");return null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=""+e+DEFAULT_MODEL_NAME+TFHUB_SEARCH_PARAM),[4,(a=new GraphModel(e,t)).load()];case 1:return r.sent(),[2,a]}})})}var version="1.1.2";
//# sourceMappingURL=tf-converter.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/*! exports provided: AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global, Buffer, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return Ah; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return Th; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return Dh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return Oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return Yn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return Qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return Mh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return Ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return Fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return vt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return ft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return lt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return dt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return Vi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return Gi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return Hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return $u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return Cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return Eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return Ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return Hi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return $i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return Ki; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return $e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return Al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return Ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return Fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return Bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return Os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return As; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return Ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return Ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return Ir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return vh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return Nr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return Ar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return Xi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return Yi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return Tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return On; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return cr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return Xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return Ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return Js; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return Qs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return Qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return Ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return Dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return De; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return Or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return Zs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return Te; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return Be; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return Oe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return Ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return Xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return Vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return Ae; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return Ie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return Ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return Zi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return es; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return Mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return Fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return Hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return Ge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return ns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return Yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return vc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return ze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return Cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return En; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return Mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return Fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return Bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return Pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return $l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return Hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return Bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return Mn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return hh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return Ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return ps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return Pe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return Lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return Wu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return Uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return $n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return El; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return rs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return as; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return Dn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return Su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return Nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return Qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return Ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return Iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return Zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return el; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return Au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return Dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return Tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return Fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return Wh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return Rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return Vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return Gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return Br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return Gn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return Kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return An; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return Pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return Lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return Wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return Ur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return zr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return Du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return Me; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return Vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return Gr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return Ue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return ss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return He; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return Ve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return Hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return Pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return us; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return ls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return Bn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return Ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return xh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return We; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return Jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return hs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return vs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return Tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return gs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return $r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return Ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return Wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return Kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return ws; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return Ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return Tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return Cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return Fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return Pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return Ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return Wn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return Un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return Vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return It; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return Sh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return Fe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return Xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return Le; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return Ph; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return Cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return Yr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return Il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return Qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return Rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return Sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return wt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return Nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return Nh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return kh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return Xn; });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}var n=function(){return(n=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function r(t,e,n,r){return new(n||(n=Promise))(function(o,a){function i(t){try{u(r.next(t))}catch(t){a(t)}}function s(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){t.done?o(t.value):new n(function(e){e(t.value)}).then(i,s)}u((r=r.apply(t,e||[])).next())})}function o(t,e){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(t,i)}catch(t){a=[6,t],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var a,i=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){var r=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+r+"."),this.set(t,r)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=s(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var n=e.split(":"),r=n[0],o=n[1];t.urlFlags[r]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(r,o)})}},t}();function s(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")}),e}function u(t){a=t}var l=Object.freeze({Environment:i,getQueryParams:s,get ENV(){return a},setEnvironmentGlobal:u});function c(t){for(var e=t.length,n=0,r=0;e>0;)r=Math.random()*e|0,n=t[--e],t[e]=t[r],t[r]=n}function h(t,e,n){return Math.max(t,Math.min(e,n))}function p(t){return t%2==0?t:t+1}function f(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return e}function d(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function v(t,e,n){void 0===n&&(n=""),d(x(t,e),function(){return n+" Shapes "+t+" and "+e+" must match"})}function m(t){d(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})}function g(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||_(t))for(var n=0;n<t.length;++n)g(t[n],e);else e.push(t);return e}function y(t){if(0===t.length)return 1;for(var e=t[0],n=1;n<t.length;n++)e*=t[n];return e}function x(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function w(t){return t%1==0}function b(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)}function C(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function E(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function R(t,e,n){return void 0===e&&(e=function(t){return 0}),new Promise(function(r,o){var a=0,i=function(){if(t())r();else{var s=e(++a);null!=n&&a>=n?o():setTimeout(i,s)}};i()})}function S(t,e){for(var n=1,r=-1,o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(-1===t[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+o);r=o}else if(t[o]<0)throw Error("Shapes can not be < 0. Found "+t[o]+" at dim "+o);if(-1===r){if(e>0&&e!==n)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===n)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%n!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+n);var a=t.slice();return a[r]=e/n,a}function N(t,e){var n=e.length;return d((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-n&&t<n}),function(){return"All values in axis param must be in range [-"+n+", "+n+") but got axis "+t}),d(t.every(function(t){return w(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?n+t:t})}function k(t,e){for(var n=[],r=[],o=null==e?null:N(e,t).sort(),a=0,i=0;i<t.length;++i){if(null!=o){if(o[a]===i&&1!==t[i])throw new Error("Can't squeeze axis "+i+" since its dim '"+t[i]+"' is not 1");(null==o[a]||o[a]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),o[a]<=i&&a++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function I(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function A(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function T(t,e,n){if("float32"===e)for(var r=0;r<t.length;r++){var o=t[r];if(isNaN(o)||!isFinite(o))throw Error("The result of the '"+n+"' is "+o+".")}}function D(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+e+" being uploaded contains "+r+".")}}function O(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function _(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function M(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function F(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e}function B(t){return"string"==typeof t||t instanceof String}function P(t){return"boolean"==typeof t}function L(t){return"number"==typeof t}function W(t){return Array.isArray(t)?W(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":L(t)?"float32":B(t)?"string":P(t)?"bool":"float32"}function U(t){return!!(t&&t.constructor&&t.call&&t.apply)}function z(t,e){for(var n=e;n<t;++n)if(t%n==0)return n;return t}function V(t){var e=t.length;if(e<2)return[];var n=new Array(e-1);n[e-2]=t[e-1];for(var r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function G(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=g(t)),n&&D(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var r=new Uint8Array(t.length),o=0;o<r.length;++o)0!==Math.round(t[o])&&(r[o]=1);return r}throw new Error("Unknown data type "+e)}function q(t,e){if(0===t.length)return e[0];var n=t.reduce(function(t,e){return t*e});if(0===n)return[];if(n!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,n,r){var o=new Array;if(1===n.length)for(var a=n[0],i=0;i<a;i++)o[i]=r[e+i];else{a=n[0];var s=n.slice(1),u=s.reduce(function(t,e){return t*e});for(i=0;i<a;i++)o[i]=t(e+i*u,s,r)}return o}(0,t,e)}function H(t,e){for(var n=$(t,e),r=0;r<n.length;r++)n[r]=1;return n}function $(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function j(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")}function K(t){t.forEach(function(e){d(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})}var X,Y=function(){if(null!=a.global.fetch)return a.global.fetch;if(a.get("IS_NODE"))return Q.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")},Q={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 0)}};function J(t,e){return null==X&&(X=Y()),X(t,e)}var Z=Object.freeze({shuffle:c,clamp:h,nearestLargerEven:p,sum:f,randUniform:function(t,e){var n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){for(var n=0,r=0;r<t.length;r++){var o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:d,assertShapesMatch:v,assertNonNull:m,flatten:g,sizeFromShape:y,isScalarShape:function(t){return 0===t.length},arraysEqual:x,isInt:w,tanh:b,sizeToSquarishShape:C,createShuffledIndices:function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return c(e),e},rightPad:E,repeatedTry:R,inferFromImplicitShape:S,parseAxisParam:N,squeezeShape:k,getTypedArrayFromDType:I,getArrayFromDType:A,checkComputationForErrors:T,checkConversionForErrors:D,hasEncodingLoss:O,isTypedArray:_,bytesPerElement:M,bytesFromStringArray:F,isString:B,isBoolean:P,isNumber:L,inferDtype:W,isFunction:U,nearestDivisor:z,computeStrides:V,toTypedArray:G,toNestedArray:q,makeOnesTypedArray:H,makeZerosTypedArray:$,now:j,assertNonNegativeIntegerDimensions:K,getNodeFetch:Q,get systemFetch(){return X},fetch:J}),tt=function(){function t(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new et)}return t.prototype.profileKernel=function(t,e){var n,r=this,o=this.backendTimer.time(function(){n=e()});return(Array.isArray(n)?n:[n]).forEach(function(e){var n=e.dataSync();T(n,e.dtype,t),o.then(function(o){var a="";null!=o.getExtraProfileInfo&&(a=o.getExtraProfileInfo()),r.logger.logKernelProfile(t,e,n,o.kernelMs,a)})}),n},t}(),et=function(){function t(){}return t.prototype.logKernelProfile=function(t,e,n,r,o){var a=E(r+"ms",9),i=E(t,25),s=e.rank,u=e.size,l=E(e.shape.toString(),14);console.log("%c"+i+"\t%c"+a+"\t%c"+s+"D "+l+"\t%c"+u+"\t%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green")},t}(),nt=20,rt=3,ot=7;function at(t,e,n,r){var o=V(e),a=function(t,e,n,r){var o=y(e),a=r[r.length-1],i=new Array(a).fill(0),s=e.length,u="complex64"===n?ut(t):t;if(s>1)for(var l=0;l<o/a;l++)for(var c=l*a,h=0;h<a;h++)i[h]=Math.max(i[h],it(u[c+h],0,n).length);return i}(t,e,n,o),i=e.length,s=function t(e,n,r,o,a,i){void 0===i&&(i=!0);var s="complex64"===r?2:1;var u=n[0];var l=n.length;if(0===l){if("complex64"===r){var c=ut(e);return[it(c[0],0,r)]}return"bool"===r?[st(e[0])]:[e[0].toString()]}if(1===l){if(u>nt){var h=rt*s,p=Array.from(e.slice(0,h)),f=Array.from(e.slice(u-rt*s,u));return"complex64"===r&&(p=ut(p),f=ut(f)),["["+p.map(function(t,e){return it(t,a[e],r)}).join(", ")+", ..., "+f.map(function(t,e){return it(t,a[u-rt+e],r)}).join(", ")+"]"]}var d="complex64"===r?ut(e):Array.from(e);return["["+d.map(function(t,e){return it(t,a[e],r)}).join(", ")+"]"]}var v=n.slice(1);var m=o.slice(1);var g=o[0]*s;var y=[];if(u>nt){for(var x=0;x<rt;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,!1))}y.push("...");for(var x=u-rt;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}}else for(var x=0;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}var C=2===l?",":"";y[0]="["+y[0]+C;for(var x=1;x<y.length-1;x++)y[x]=" "+y[x]+C;var E=",\n";for(var x=2;x<l;x++)E+="\n";y[y.length-1]=" "+y[y.length-1]+"]"+(i?"":E);return y}(t,e,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+i),u.push("  shape: ["+e+"]"),u.push("  values:")),u.push(s.map(function(t){return"    "+t}).join("\n")),u.join("\n")}function it(t,e,n){return E(Array.isArray(t)?parseFloat(t[0].toFixed(ot))+" + "+parseFloat(t[1].toFixed(ot))+"j":B(t)?"'"+t+"'":"bool"===n?st(t):parseFloat(t.toFixed(ot)).toString(),e)}function st(t){return 0===t?"false":"true"}function ut(t){for(var e=[],n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var lt=function(){function t(t,e,n){var r=this;if(this.dtype=e,this.shape=t.slice(),this.size=y(t),null!=n){var o=n.length;d(o===this.size,function(){return"Length of values '"+o+"' does not match the size inferred by the shape '"+r.size+"'."})}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||A(e,this.size),this.strides=V(t)}return t.prototype.set=function(t){for(var e=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),d(n.length===this.rank,function(){return"The number of provided coordinates ("+n.length+") must match the rank ("+e.rank+")"});var o=this.locToIndex(n);this.values[o]=t},t.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];0===t.length&&(t=[0]);for(var n=0,r=0,o=t;r<o.length;r++){var a=o[r];if(a<0||a>=this.shape[n]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}n++}for(var s=t[t.length-1],u=0;u<t.length-1;++u)s+=this.strides[u]*t[u];return this.values[s]},t.prototype.locToIndex=function(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];for(var e=t[t.length-1],n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e},t.prototype.indexToLoc=function(t){if(0===this.rank)return[];if(1===this.rank)return[t];for(var e=new Array(this.shape.length),n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return ft.make(this.shape,{values:this.values},this.dtype)},t}(),ct=null,ht=null,pt=null;var ft=function(){function t(t,e,n,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=y(t),this.strides=V(t),this.dataId=null!=r?r:{},this.id=ct().nextTensorId(),this.rankType=this.rank<5?this.rank.toString():"higher",ct().registerTensor(this,o),null!=n&&ct().write(this.dataId,n)}return t.make=function(e,n,r,o){return new t(e,r,n.values,n.dataId,o)},t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),d(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},t.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])},t.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])},t.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),this.reshape([t,e,n,r,o])},t.prototype.asType=function(t){return this.throwIfDisposed(),ht.cast(this,t)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,ht.buffer(this.shape,this.dtype,t)]}})})},t.prototype.bufferSync=function(){return ht.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,q(this.shape,t)]}})})},t.prototype.arraySync=function(){return q(this.shape,this.dataSync())},t.prototype.data=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return this.throwIfDisposed(),[2,ct().read(this.dataId)]})})},t.prototype.dataSync=function(){return this.throwIfDisposed(),ct().readSync(this.dataId)},t.prototype.dispose=function(){this.isDisposed||(ct().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(t){return void 0===t&&(t=!1),ht.print(this,t)},t.prototype.reshape=function(t){return this.throwIfDisposed(),ht.reshape(this,t)},t.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},t.prototype.expandDims=function(t){return void 0===t&&(t=0),ht.expandDims(this,t)},t.prototype.cumsum=function(t,e,n){return void 0===t&&(t=0),void 0===e&&(e=!1),void 0===n&&(n=!1),ht.cumsum(this,t,e,n)},t.prototype.squeeze=function(t){return this.throwIfDisposed(),ht.squeeze(this,t)},t.prototype.clone=function(){return this.throwIfDisposed(),ht.clone(this)},t.prototype.oneHot=function(t,e,n){return this.throwIfDisposed(),ht.oneHot(this,t,e,n)},t.prototype.toString=function(t){return void 0===t&&(t=!1),at(this.dataSync(),this.shape,this.dtype,t)},t.prototype.tile=function(t){return this.throwIfDisposed(),ht.tile(this,t)},t.prototype.gather=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.gather(this,t,e)},t.prototype.matMul=function(t,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),ht.matMul(this,t,e,n)},t.prototype.dot=function(t){return this.throwIfDisposed(),ht.dot(this,t)},t.prototype.norm=function(t,e,n){return void 0===t&&(t="euclidean"),void 0===e&&(e=null),void 0===n&&(n=!1),this.throwIfDisposed(),ht.norm(this,t,e,n)},t.prototype.slice=function(t,e){return this.throwIfDisposed(),ht.slice(this,t,e)},t.prototype.reverse=function(t){return this.throwIfDisposed(),ht.reverse(this,t)},t.prototype.concat=function(e,n){return void 0===n&&(n=0),this.throwIfDisposed(),e instanceof t&&(e=[e]),ht.concat([this].concat(e),n)},t.prototype.split=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.split(this,t,e)},t.prototype.stack=function(t,e){return void 0===e&&(e=0),ht.stack([this,t],e)},t.prototype.unstack=function(t){return void 0===t&&(t=0),ht.unstack(this,t)},t.prototype.pad=function(t,e){return void 0===e&&(e=0),ht.pad(this,t,e)},t.prototype.batchNormalization=function(t,e,n,r,o){return void 0===n&&(n=.001),pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,o,r,n)},t.prototype.batchNorm=function(t,e,n,r,o){return void 0===o&&(o=.001),this.throwIfDisposed(),ht.batchNorm(this,t,e,n,r,o)},t.prototype.all=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.all(this,t,e)},t.prototype.any=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.any(this,t,e)},t.prototype.logSumExp=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.logSumExp(this,t,e)},t.prototype.sum=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.sum(this,t,e)},t.prototype.prod=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.prod(this,t,e)},t.prototype.mean=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.mean(this,t,e)},t.prototype.min=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.min(this,t,e)},t.prototype.max=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.max(this,t,e)},t.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMin(this,t)},t.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMax(this,t)},t.prototype.cast=function(t){return this.throwIfDisposed(),ht.cast(this,t)},t.prototype.add=function(t){return this.throwIfDisposed(),ht.add(this,t)},t.prototype.addStrict=function(t){return this.throwIfDisposed(),ht.addStrict(this,t)},t.prototype.atan2=function(t){return this.throwIfDisposed(),ht.atan2(this,t)},t.prototype.sub=function(t){return this.throwIfDisposed(),ht.sub(this,t)},t.prototype.subStrict=function(t){return this.throwIfDisposed(),ht.subStrict(this,t)},t.prototype.pow=function(t){return this.throwIfDisposed(),ht.pow(this,t)},t.prototype.powStrict=function(t){return this.throwIfDisposed(),ht.powStrict(this,t)},t.prototype.mul=function(t){return this.throwIfDisposed(),ht.mul(this,t)},t.prototype.mulStrict=function(t){return this.throwIfDisposed(),ht.mulStrict(this,t)},t.prototype.div=function(t){return this.throwIfDisposed(),ht.div(this,t)},t.prototype.floorDiv=function(t){return this.throwIfDisposed(),ht.floorDiv(this,t)},t.prototype.divStrict=function(t){return this.throwIfDisposed(),ht.divStrict(this,t)},t.prototype.minimum=function(t){return this.throwIfDisposed(),ht.minimum(this,t)},t.prototype.minimumStrict=function(t){return this.throwIfDisposed(),ht.minimumStrict(this,t)},t.prototype.maximum=function(t){return this.throwIfDisposed(),ht.maximum(this,t)},t.prototype.maximumStrict=function(t){return this.throwIfDisposed(),ht.maximumStrict(this,t)},t.prototype.mod=function(t){return this.throwIfDisposed(),ht.mod(this,t)},t.prototype.modStrict=function(t){return this.throwIfDisposed(),ht.modStrict(this,t)},t.prototype.squaredDifference=function(t){return this.throwIfDisposed(),ht.squaredDifference(this,t)},t.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),ht.squaredDifferenceStrict(this,t)},t.prototype.transpose=function(t){return this.throwIfDisposed(),ht.transpose(this,t)},t.prototype.notEqual=function(t){return this.throwIfDisposed(),ht.notEqual(this,t)},t.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),ht.notEqualStrict(this,t)},t.prototype.less=function(t){return this.throwIfDisposed(),ht.less(this,t)},t.prototype.lessStrict=function(t){return this.throwIfDisposed(),ht.lessStrict(this,t)},t.prototype.equal=function(t){return this.throwIfDisposed(),ht.equal(this,t)},t.prototype.equalStrict=function(t){return this.throwIfDisposed(),ht.equalStrict(this,t)},t.prototype.lessEqual=function(t){return this.throwIfDisposed(),ht.lessEqual(this,t)},t.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),ht.lessEqualStrict(this,t)},t.prototype.greater=function(t){return this.throwIfDisposed(),ht.greater(this,t)},t.prototype.greaterStrict=function(t){return this.throwIfDisposed(),ht.greaterStrict(this,t)},t.prototype.greaterEqual=function(t){return this.throwIfDisposed(),ht.greaterEqual(this,t)},t.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),ht.greaterEqualStrict(this,t)},t.prototype.logicalAnd=function(t){return this.throwIfDisposed(),ht.logicalAnd(this,t)},t.prototype.logicalOr=function(t){return this.throwIfDisposed(),ht.logicalOr(this,t)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),ht.logicalNot(this)},t.prototype.logicalXor=function(t){return this.throwIfDisposed(),ht.logicalXor(this,t)},t.prototype.where=function(t,e){return this.throwIfDisposed(),ht.where(t,this,e)},t.prototype.neg=function(){return this.throwIfDisposed(),ht.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),ht.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),ht.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),ht.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),ht.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),ht.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),ht.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),ht.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),ht.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),ht.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),ht.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),ht.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),ht.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),ht.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),ht.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),ht.abs(this)},t.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),ht.clipByValue(this,t,e)},t.prototype.relu=function(){return this.throwIfDisposed(),ht.relu(this)},t.prototype.elu=function(){return this.throwIfDisposed(),ht.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),ht.selu(this)},t.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),ht.leakyRelu(this,t)},t.prototype.prelu=function(t){return this.throwIfDisposed(),ht.prelu(this,t)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),ht.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),ht.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),ht.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),ht.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),ht.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),ht.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),ht.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),ht.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),ht.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),ht.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),ht.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),ht.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),ht.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),ht.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),ht.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),ht.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),ht.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),ht.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),ht.round(this)},t.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),ht.step(this,t)},t.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.softmax(this,t)},t.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.logSoftmax(this,t)},t.prototype.resizeBilinear=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeBilinear(this,t,e)},t.prototype.resizeNearestNeighbor=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeNearestNeighbor(this,t,e)},t.prototype.conv1d=function(t,e,n,r,o,a){return void 0===r&&(r="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),ht.conv1d(this,t,e,n,r,o,a)},t.prototype.conv2d=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.conv2d(this,t,e,n,r,o,a)},t.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),ht.conv2dTranspose(this,t,e,n,r,o)},t.prototype.depthwiseConv2D=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.depthwiseConv2d(this,t,e,n,r,o,a)},t.prototype.separableConv2d=function(t,e,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),ht.separableConv2d(this,t,e,n,r,o,a)},t.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),ht.avgPool(this,t,e,n,r)},t.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),ht.maxPool(this,t,e,n,r)},t.prototype.localResponseNormalization=function(t,e,n,r){return void 0===t&&(t=5),void 0===e&&(e=1),void 0===n&&(n=1),void 0===r&&(r=.5),ht.localResponseNormalization(this,t,e,n,r)},t.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),ht.pool(this,t,e,n,r,o)},t.prototype.variable=function(t,e,n){return void 0===t&&(t=!0),this.throwIfDisposed(),dt.variable(this,t,e,n)},t.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),ht.unsortedSegmentSum(this,t,e)},t.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ht.batchToSpaceND(this,t,e)},t.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),ht.spaceToBatchND(this,t,e)},t.prototype.topk=function(t,e){return void 0===t&&(t=1),void 0===e&&(e=!0),this.throwIfDisposed(),ht.topk(this,t,e)},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s){return void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),this.throwIfDisposed(),ht.stridedSlice(this,t,e,n,r,o,a,i,s)},t.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),ht.depthToSpace(this,t,e)},t.prototype.fft=function(){return this.throwIfDisposed(),ht.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),ht.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),ht.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),ht.spectral.irfft(this)},t}();Object.defineProperty(ft,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype}});var dt=function(t){function n(e,n,r){void 0===n&&(n=!0);var o=t.call(this,e.shape,e.dtype,null,e.dataId)||this;o.trainable=n,o.name=r,null==o.name&&(o.name=ct().nextVariableId().toString());try{ct().registerVariable(o)}catch(t){throw ct().disposeTensor(o),t}return o}return e(n,t),n.variable=function(t,e,r,o){return void 0===e&&(e=!0),null!=o&&o!==t.dtype&&(t=t.asType(o)),new n(t,e,r)},n.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!x(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");ct().disposeTensor(this),this.dataId=t.dataId,ct().registerTensor(this)},n}(ft);Object.defineProperty(dt,Symbol.hasInstance,{value:function(t){return t instanceof ft&&null!=t.assign&&t.assign instanceof Function}});var vt,mt,gt,yt,xt,wt=dt.variable;!function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(vt||(vt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(mt||(mt={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(gt||(gt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(yt||(yt={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(xt||(xt={}));var bt={float32:yt,int32:mt,bool:gt,complex64:xt};function Ct(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast "+t+" with "+e)}return bt[t][e]}function Et(t){return Ct(t,"int32")}function Rt(t,e){if(t.dtype===e.dtype)return[t,e];var n=Ct(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function St(t,e){d(t.dtype===e.dtype,function(){return"The dtypes of the first("+t.dtype+") and second("+e.dtype+") input must match"})}function Nt(t){var e=[];return function t(e,n,r){if(null==e)return;if(e instanceof ft)return void n.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;var a=e;for(var i in a){var s=a[i];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}var kt,It=Object.freeze({makeTypesMatch:Rt,assertTypesMatch:St,isTensorInList:function(t,e){for(var n=0;n<e.length;n++)if(e[n].id===t.id)return!0;return!1},getTensorsInContainer:Nt}),At=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},t}(),Tt=function(){function t(t){this.ENV=t,this.registry={},this.registryFactory={},this.state=new At}return t.prototype.ready=function(){return r(this,void 0,void 0,function(){var t,e,n;return o(this,function(r){switch(r.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];t=this.getSortedBackends(),e=0,r.label=1;case 1:return e<t.length?(n=t[e],[4,this.initializeBackend(n).success]):[3,4];case 2:if(r.sent())return this.setBackend(n),[2];r.label=3;case 3:return e++,[3,1];case 4:throw new Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");if(null==this.backendInstance){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;if(this.initializeBackend(t).asyncInit)return null}return this.registry[t]},t.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},t.prototype.registerBackend=function(t,e,n){return void 0===n&&(n=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)},t.prototype.setBackend=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:if(null==this.registryFactory[t])throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,null!=this.registry[t]?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),n=e.success,e.asyncInit?[4,n]:[3,2]);case 1:return r=o.sent(),[3,3];case 2:r=n,o.label=3;case 3:if(!r)return[2,!1];o.label=4;case 4:return this.backendInstance=this.registry[t],this.profiler=new tt(this.backendInstance),[2,!0]}})})},t.prototype.initializeBackend=function(t){var e=this,n=Dt.registryFactory[t];if(null==n)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var r=n.factory();if(Promise.resolve(r)===r){var o=r.then(function(n){return e.registry[t]=n,e.pendingBackendInit=null,!0}).catch(function(n){return e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(n.stack||n.message),!1});return this.pendingBackendInit=o,{success:o,asyncInit:!0}}return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(e){return console.warn("Initialization of backend "+t+" failed"),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");t in this.registry&&(this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t]},t.prototype.getSortedBackends=function(){var t=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(e,n){return t.registryFactory[n].priority-t.registryFactory[e].priority})},t.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var n=t[e],r=this.initializeBackend(n),o=r.success,a=r.asyncInit;if(a||o)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(t){this.write(t,this.readSync(t))},t.prototype.tidy=function(t,e){var n,r=this,o=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}return this.scopedRun(function(){return r.startScope(o)},function(){return r.endScope(n)},function(){return(n=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n})},t.prototype.scopedRun=function(t,e,n){t();try{var r=n();return e(),r}catch(t){throw e(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(t){var e=ft.make(t.shape,{dataId:t.dataId},t.dtype);return this.addTapeNode([t],e,function(t){return[t.toFloat()]}),e},t.prototype.runKernel=function(t,e,n){var r,o=this,a=[],i=this.isTapeOn(),s=null!=this.state.activeScope?this.state.activeScope.name:"",u=function(t){i&&(a=t.map(function(t){return o.keep(o.clone(t))}))},l=this.state.numBytes,c=this.state.numTensors;if(this.scopedRun(function(){return o.state.kernelDepth++},function(){return o.state.kernelDepth--},function(){r=o.ENV.getBool("DEBUG")?o.profiler.profileKernel(s,function(){return t(o.backend,u)}):t(o.backend,u)}),i){var h={id:this.state.nextTapeNodeId++,name:s,inputs:e,outputs:Array.isArray(r)?r:[r],saved:a};null!=n&&(h.gradient=function(t){return n(t,a)}),this.state.activeTape.push(h)}return this.state.profiling&&this.state.activeProfile.kernels.push({name:s,bytesAdded:this.state.numBytes-l,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-c,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(function(t){return e[t].shape}),outputShape:Array.isArray(r)?r.map(function(t){return t.shape}):r.shape}),r},t.prototype.registerTensor=function(t,e){var n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;var r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*M(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:null!=e?e:this.backend,dtype:t.dtype,shape:t.shape,bytes:r,refCount:0}),this.state.numBytes+=r,null!=e?e.register(t.dataId,t.shape,t.dtype):this.backend.register(t.dataId,t.shape,t.dtype)}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof dt||this.track(t)},t.prototype.registerVariable=function(t){if(null!=this.state.registeredVariables[t.name])throw new Error("Variable with name "+t.name+" was already registered");this.state.registeredVariables[t.name]=t},t.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeTensor(e),delete this.state.registeredVariables[t]}},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},t.prototype.profile=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){return this.state.profiling=!0,e=this.state.numBytes,n=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(t){return t.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,[2,this.state.activeProfile]})})},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(t,e,n){var r={};t.forEach(function(t,e){r[e]=t});var o={id:this.state.nextTapeNodeId++,name:this.state.activeScope.name,inputs:r,outputs:[e],gradient:function(t){var e=n(t),r={};return e.forEach(function(t,e){r[e]=function(){return t}}),r}};this.state.activeTape.push(o)},t.prototype.keep=function(t){return t.kept=!0,t},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},t.prototype.endScope=function(t){for(var e=this,n=Nt(t),r=new Set(n.map(function(t){return t.id})),o=0;o<this.state.activeScope.track.length;o++){var a=this.state.activeScope.track[o];a.kept||r.has(a.id)||a.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(function(t){t.kept||t.scopeId!==i.id||e.track(t)})},t.prototype.gradients=function(t,e,n,r){var o=this;if(void 0===r&&(r=!1),d(e.length>0,function(){return"gradients() received an empty list of xs."}),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");var a=this.scopedRun(function(){return o.startTape()},function(){return o.endTape()},function(){return o.tidy("forward",t)});d(a instanceof ft,function(){return"The result y returned by f() must be a tensor."});var i=function(t,e,n){for(var r={},o={},a=0;a<e.length;a++)r[e[a].id]=!0;for(a=0;a<t.length;a++){var i=(d=t[a]).inputs;for(var s in i){for(var u=i[s],l=!1,c=0;c<e.length;c++)if(r[u.id]){d.outputs.forEach(function(t){return r[t.id]=!0}),l=!0,o[d.id]=!0;break}if(l)break}}var h={};h[n.id]=!0;var p={};for(a=t.length-1;a>=0;a--)for(i=(d=t[a]).inputs,c=0;c<d.outputs.length;c++)if(h[d.outputs[c].id]){for(var s in i)h[i[s].id]=!0,p[d.id]=!0;break}var f=[];for(a=0;a<t.length;a++){var d;if(o[(d=t[a]).id]&&p[d.id]){var v={};for(var s in d.inputs){var m=d.inputs[s];r[m.id]&&(v[s]=m)}var g=Object.assign({},d);g.inputs=v,g.outputs=d.outputs,f.push(g)}}return f}(this.state.activeTape,e,a);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var t,r,s={};s[a.id]=null==n?(t=a.shape,r=H(y(t),"float32"),ft.make(t,{values:r})):n,function(t,e,n){for(var r=function(r){var o=e[r],a=[];if(o.outputs.forEach(function(e){var n=t[e.id];if(null!=n)a.push(n);else{var r=ft.make(e.shape,{values:$(e.size,e.dtype)},e.dtype);a.push(r)}}),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+o.name+".");var i=o.gradient(1===o.outputs.length?a[0]:a),s=function(e){if(!(e in i))throw new Error("Cannot backprop through input "+e+". Available gradients found: "+Object.keys(i)+".");var r=n(function(){return i[e]()});if("float32"!==r.dtype)throw new Error("Error in gradient for op "+o.name+". The gradient of input "+e+" must have 'float32' dtype, but has '"+r.dtype+"'");var a=o.inputs[e];if(!x(r.shape,a.shape))throw new Error("Error in gradient for op "+o.name+". The gradient of input '"+e+"' has shape '"+r.shape+"', which does not match the shape of the input '"+a.shape+"'");if(null==t[a.id])t[a.id]=r;else{var s=t[a.id];t[a.id]=s.add(r),s.dispose()}};for(var u in o.inputs)s(u)},o=e.length-1;o>=0;o--)r(o)}(s,i,function(t){return o.tidy(t)});var u=e.map(function(t){return s[t.id]});return 0===o.state.gradientDepth&&(o.state.activeTape.forEach(function(t){for(var e in t.saved)t.saved[e].dispose()}),o.state.activeTape=null),{value:a,grads:u}})},t.prototype.customGrad=function(t){var e=this;return d(U(t),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var n,r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];d(r.every(function(t){return t instanceof ft}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var a={};return r.forEach(function(t,e){a[e]=t}),e.runKernel(function(e,o){return d((n=t.apply(void 0,r.concat([o]))).value instanceof ft,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),d(U(n.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),n.value},a,function(t,e){var o=n.gradFunc(t,e),a=Array.isArray(o)?o:[o];d(a.length===r.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),d(a.every(function(t){return t instanceof ft}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var i={};return a.forEach(function(t,e){i[e]=function(){return t}}),i})}},t.prototype.write=function(t,e){var n=this.state.tensorInfo.get(t);if("string"===n.dtype){var r=F(e);this.state.numBytes+=r-n.bytes,n.bytes=r}this.backend!==n.backend&&(n.backend.disposeData(t),n.backend=this.backend,this.backend.register(t,n.shape,n.dtype)),this.backend.write(t,e)},t.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},t.prototype.fromPixels=function(t,e){return this.backend.fromPixels(t,e)},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){switch(r.label){case 0:return e=j(),[4,this.backend.time(t)];case 1:return(n=r.sent()).wallMs=j()-e,[2,n]}})})},t.prototype.track=function(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var t in this.state.dispose(),this.ENV.reset(),this.state=new At,this.registry)this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null},t.nextTensorId=0,t.nextVariableId=0,t}();var Dt=function(){var t=function(){if(null==kt){var t=void 0;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else{if("undefined"==typeof process)throw new Error("Could not find a global object");t=process}kt=t}return kt}();if(null==t._tfengine){var e=new i(t);t._tfengine=new Tt(e)}return u(t._tfengine.ENV),ct=function(){return t._tfengine},t._tfengine}();function Ot(){return"undefined"!=typeof window}a.registerFlag("DEBUG",function(){return!1},function(t){t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),a.registerFlag("IS_BROWSER",function(){return Ot()}),a.registerFlag("IS_NODE",function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node}),a.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),a.registerFlag("PROD",function(){return!1}),a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return!a.getBool("PROD")}),a.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),a.registerFlag("IS_TEST",function(){return!1});var _t={},Mt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ft(t){t in _t||(_t[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=document.createElement("canvas");if(e.addEventListener("webglcontextlost",function(e){e.preventDefault(),delete _t[t]},!1),1===t)return e.getContext("webgl",Mt)||e.getContext("experimental-webgl",Mt);return e.getContext("webgl2",Mt)}(t));var e=_t[t];return e.isContextLost()?(delete _t[t],Ft(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_t[t])}function Bt(t,e,n){var r=n();return e&&function(t){var e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+Ut(t,e))}(t),r}var Pt=5.96e-8,Lt=65504;function Wt(t){return!!(a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Pt<Math.abs(t)&&Math.abs(t)<Lt)}function Ut(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function zt(t,e,n){return he(t,e,function(){return t.getExtension(n)},'Extension "'+n+'" not supported on this browser.')}function Vt(t,e,n){var r=he(t,e,function(){return t.createShader(t.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function Gt(t,e,n){var r=he(t,e,function(){return t.createShader(t.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw function(t,e){var n=$t.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);for(var r=+n[1],o=t.split("\n"),a=o.length.toString().length+2,i=o.map(function(t,e){return E((e+1).toString(),a)+t}),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var l=i.slice(0,r-1),c=i.slice(r-1,r),h=i.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+E(c[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var qt,Ht,$t=/ERROR: [0-9]+:([0-9]+):/g;function jt(t,e){return he(t,e,function(){return t.createProgram()},"Unable to create WebGLProgram.")}function Kt(t,e,n){if(Bt(t,e,function(){return t.linkProgram(n)}),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Xt(t,e,n){if(Bt(t,e,function(){return t.validateProgram(n)}),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function Yt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Qt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Jt(){return 2===a.getNumber("WEBGL_VERSION")?1:4}function Zt(t,e){return he(t,e,function(){return t.createTexture()},"Unable to create WebGLTexture.")}function te(t,e){var n=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){var r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+n+"x"+n+"]")+".")}}function ee(t,e){return he(t,e,function(){return t.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function ne(t,e,n,r,o,a,i,s){var u=t.getAttribLocation(n,r);return-1!==u&&(Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,o)}),Bt(t,e,function(){return t.vertexAttribPointer(u,a,t.FLOAT,!1,i,s)}),Bt(t,e,function(){return t.enableVertexAttribArray(u)}),!0)}function re(t,e,n,r){pe(t,r),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)})}function oe(t,e,n,r){return he(t,e,function(){return t.getUniformLocation(n,r)},'uniform "'+r+'" not present in program.')}function ae(t,e,n){return t.getUniformLocation(e,n)}function ie(t,e,n,r,o,a){Bt(t,e,function(){return re(t,e,r,a)}),Bt(t,e,function(){return t.uniform1i(o,a)})}function se(t,e,n,r){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,r)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)})}function ue(t,e,n){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,n)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)})}function le(t){var e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ce(t,e))}function ce(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function he(t,e,n,r){var o=Bt(t,e,function(){return n()});if(null==o)throw new Error(r);return o}function pe(t,e){var n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function fe(t,e){return void 0===e&&(e=2),y(t.slice(0,t.length-e))}function de(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function ve(t,e){var n;void 0===e&&(e=!1);var r=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(r*=2,1===(t=t.map(function(e,n){return n>=t.length-2?p(t[n]):t[n]})).length&&(t=[2,t[0]])),2!==t.length){var o=k(t);t=o.newShape}var i=y(t);if(t.length<=1&&i<=r)return[1,i];if(2===t.length&&t[0]<=r&&t[1]<=r)return t;if(3===t.length&&t[0]*t[1]<=r&&t[2]<=r)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=r&&t[1]*t[2]<=r)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=r&&t[3]<=r)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=r&&t[1]*t[2]*t[3]<=r)return[t[0],t[1]*t[2]*t[3]];if(e){var s=fe(t),u=2,l=2;return t.length&&(u=(n=de(t))[0],l=n[1]),C(i=s*(u/2)*(l/2)).map(function(t){return 2*t})}return C(i)}function me(t){return t%2==0}function ge(t,e){if(x(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){var n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(me(n)&&me(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&me(t[0])&&me(e[0])}function ye(t){if(null==qt){var e=Ft(t);qt=e.getParameter(e.MAX_TEXTURE_SIZE)}return qt}function xe(t){if(null==Ht){var e=Ft(t);Ht=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ht)}function we(t){if(0===t)return 0;var e=Ft(t);return be(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:be(e,"EXT_disjoint_timer_query")?1:0}function be(t,e){return null!=t.getExtension(e)}function Ce(t){try{if(null!=Ft(t))return!0}catch(t){return!1}return!1}function Ee(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Re(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1;if(!be(e,"WEBGL_color_buffer_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Se(t,e){var n=t.createFramebuffer(),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);var o=2===e?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,o,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(n),a}function Ne(t){return 2===t&&null!=Ft(t).fenceSync}var ke=Object.freeze({callAndCheck:Bt,canBeRepresented:Wt,getWebGLErrorMessage:Ut,getExtensionOrThrow:zt,createVertexShader:Vt,createFragmentShader:Gt,createProgram:jt,linkProgram:Kt,validateProgram:Xt,createStaticVertexBuffer:Yt,createStaticIndexBuffer:Qt,getNumChannels:Jt,createTexture:Zt,validateTextureSize:te,createFramebuffer:ee,bindVertexBufferToProgramAttribute:ne,bindTextureUnit:re,unbindTextureUnit:function(t,e,n){pe(t,n),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+n)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:oe,getProgramUniformLocation:ae,bindTextureToProgramUniformSampler:ie,bindCanvasToFramebuffer:function(t,e){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),Bt(t,e,function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)}),Bt(t,e,function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)})},bindColorTextureToFramebuffer:se,unbindColorTextureFromFramebuffer:ue,validateFramebuffer:le,getFramebufferErrorMessage:ce,getBatchDim:fe,getRowsCols:de,getTextureShapeFromLogicalShape:ve,isReshapeFree:ge,get MAX_TEXTURE_SIZE(){return qt},get MAX_TEXTURES_IN_SHADER(){return Ht},getWebGLMaxTextureSize:ye,getMaxTexturesInShader:xe,getWebGLDisjointQueryTimerVersion:we,isWebGLVersionEnabled:Ce,isRenderToFloatTextureEnabled:Ee,isDownloadFloatTextureEnabled:Re,isWebGLFenceEnabled:Ne});function Ie(){a.set("PROD",!0)}function Ae(){a.set("DEBUG",!0)}function Te(){a.set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function De(t){a.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Oe(){Dt.disposeVariables()}function _e(){return Dt.memory()}function Me(t){return Dt.profile(t)}function Fe(t,e){return Dt.tidy(t,e)}function Be(t){Nt(t).forEach(function(t){return t.dispose()})}function Pe(t){return Dt.keep(t)}function Le(t){return Dt.time(t)}function We(t){return Dt.setBackend(t)}function Ue(){return Dt.ready()}function ze(){return Dt.backendName}function Ve(t){Dt.removeBackend(t)}function Ge(t){return Dt.findBackend(t)}function qe(t){return Dt.findBackendFactory(t)}function He(t,e,n){return void 0===n&&(n=1),Dt.registerBackend(t,e,n)}function $e(){return Dt.backend}function je(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];a.getBool("IS_TEST")||console.warn.apply(console,t)}function Ke(t,e,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(e.slice(0))).push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);for(var a=e.length,i=0;i<a;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(a+1))}return o}function Xe(t,e,n){void 0===n&&(n=!0);var r=[];if(n){r.push(e);for(var o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{var a=[],i=[];for(o=1;o<t;++o)o>=2*e+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i)}return r}function Ye(t,e,n,r){void 0===r&&(r=!0);var o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(var a=1;a<t.length;++a)a<=e.length?r?o.push(e[a-1]*t[a]):o.push(t[a]/e[a-1]):o.push(t[a]);return o}function Qe(t,e){for(var n=[0],r=0;r<e;++r)n.push(t[r][0]);return n}function Je(t,e,n){for(var r=t.slice(0,1),o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function Ze(t,e){for(var n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function tn(t,e){for(var n=[],r=t.length,o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map(function(e){return t[e]})]}function en(t,e){return function(t,e,n){for(var r=t.length+e.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(t[a++]):o.push(e[i++]);return o}(t,e.map(function(t){return 1}),e)}function nn(t,e,n){d(Ze(e,n),function(){return t+" supports only inner-most axes for now. Got axes "+e+" and rank-"+n+" input."})}function rn(t,e){if(Ze(t,e))return null;for(var n=[],r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(function(t){return n.push(t)}),n}function on(t){return t.map(function(t,e){return[e,t]}).sort(function(t,e){return t[1]-e[1]}).map(function(t){return t[0]})}function an(t,e){for(var n=[],r=e-t;r<e;++r)n.push(r);return n}function sn(t,e){for(var n=t[0].slice(),r=1;r<t.length;r++)n[e]+=t[r][e];return n}function un(t,e){if(t.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>t.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+t.rank);if(0===t.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+t.shape+".");for(var n=e.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=t.shape,s=n.slice();s.pop();var u=1;for(a=r;a<t.rank;++a)u*=i[a],s.push(i[a]);var l=V(t.shape).map(function(t){return t/u}).concat([1]).slice(0,r);return[s,o,u,l]}a.registerFlag("HAS_WEBGL",function(){return a.getNumber("WEBGL_VERSION")>0}),a.registerFlag("WEBGL_VERSION",function(){return Ce(2)?2:Ce(1)?1:0}),a.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===a.get("WEBGL_VERSION")}),a.registerFlag("WEBGL_CPU_FORWARD",function(){return!1}),a.registerFlag("WEBGL_PACK",function(){return a.getBool("HAS_WEBGL")}),a.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_CLIP",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_REDUCE",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_LAZILY_UNPACK",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_CONV_IM2COL",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return ye(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return xe(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var t=a.getNumber("WEBGL_VERSION");return 0===t?0:we(t)}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(t=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))));var t}),a.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return Ee(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Re(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return Ne(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),pt=De;var ln=30;function cn(t){return t<=ln?t:z(t,Math.floor(Math.sqrt(t)))}function hn(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}!function(t,e,n){var r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+e.shape+", shape: "+t+", sliceDim: "+r+", and batchDim: "+o+".";if(n.rank<o)throw new Error(a+" update.rank < "+o+". ");if(t.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+t.length-r)throw new Error(a+" update.rank != "+(o+t.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+" updates.shape["+i+"] ("+n.shape[i]+") != indices.shape["+i+"] ("+e.shape[i]+").");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==t[i+r])throw new Error(a+" updates.shape["+(i+o)+"] ("+n.shape[i+o]+") != shape["+(i+o)+"] ("+t[i+o]+")")}(n,e,t)}function pn(t,e,n){for(var r=e.rank>1?e.shape[e.rank-1]:1,o=n.length,a=1,i=r;i<o;++i)a*=n[i];var s=r<1?1:r;return{sliceRank:r,numUpdates:e.size/s,sliceSize:a,strides:V(n.slice(0,r)).concat([1]),outputSize:y(n)}}function fn(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");for(var l=[],c=[],h=[],p=0;p<t.length;p++)l[p]=dn(o,e,r,t,p),c[p]=vn(a,n,r,t,p),u&1<<p&&(c[p]=l[p]+1,h.push(p));var f=new Array(t.length).fill(0);return f=f.map(function(t,e){for(var n=0,o=r[e]||1,a=l[e];!(o>0?a>=c[e]:a<=c[e]);a+=o)n+=1;return n}),[l,f,h]}function dn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=h(0,a,s-1)}function vn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=i>0?h(0,a,s):h(-1,a,s-1)}function mn(t,e,n){for(var r=n.length,o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function gn(t,e){for(var n=t.length>0?t[t.length-1]:1,r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function yn(t){var e=t;if(_(t))return[t.length];if(!Array.isArray(t))return[];for(var n=[];Array.isArray(e)||_(e);)n.push(e.length),e=e[0];return Array.isArray(t)&&a.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){r=r||[];if(!Array.isArray(e)&&!_(e))return void d(0===n.length,function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array/TypedArray of "+n[0]+" elements"});d(n.length>0,function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"});d(e.length===n[0],function(){return"Element arr["+r.join("][")+"] should have "+n[0]+" elements, but has "+e.length+" elements"});var o=n.slice(1);for(var a=0;a<e.length;++a)t(e[a],o,r.concat(a))}(t,n,[]),n}function xn(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+t+" tensor, but got "+e+" tensor")}function wn(t,e,n,r){if(void 0===r&&(r="numeric"),t instanceof ft)return xn(r,t.dtype,e,n),t;var o=W(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),xn(r,o,e,n),null==t||!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){var i=null==t?"null":t.constructor.name;throw new Error("Argument '"+e+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+i+"'")}var s=yn(t);_(t)||Array.isArray(t)||(t=[t]);var u="string"!==o?G(t,o,a.getBool("DEBUG")):g(t);return ft.make(s,{values:u},o)}function bn(t,e,n,r){if(void 0===r&&(r="numeric"),!Array.isArray(t))throw new Error("Argument "+e+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return t.map(function(t,r){return wn(t,e+"["+r+"]",n)},r)}function Cn(t){return d(U(t),function(){return"The f passed in grad(f) must be a function"}),function(e,n){var r=wn(e,"x","tf.grad",null),o=null!=n?wn(n,"dy","tf.grad"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t(r)},[r],o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),In(a),a[0]})}}function En(t){return d(U(t),function(){return"The f passed in grads(f) must be a function"}),function(e,n){d(Array.isArray(e),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var r=bn(e,"args","tf.grads",null),o=null!=n?wn(n,"dy","tf.grads"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t.apply(void 0,r)},r,o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(a),a})}}function Rn(t){return d(U(t),function(){return"The f passed in valueAndGrad(f) must be a function"}),function(e,n){d(e instanceof ft,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var r=Dt.gradients(function(){return t(e)},[e],n),o=r.grads,a=r.value;return In(o),{grad:o[0],value:a}}}function Sn(t){return d(U(t),function(){return"The f passed in valueAndGrads(f) must be a function"}),function(e,n){d(Array.isArray(e)&&e.every(function(t){return t instanceof ft}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});var r=Dt.gradients(function(){return t.apply(void 0,e)},e,n);return null!=n&&v(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(r.grads),r}}function Nn(t,e){if(d(U(t),function(){return"The f passed in variableGrads(f) must be a function"}),d(null==e||Array.isArray(e)&&e.every(function(t){return t instanceof dt}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}),null==e)for(var n in e=[],Dt.registeredVariables)e.push(Dt.registeredVariables[n]);var r=e.length;d((e=e.filter(function(t){return t.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+r+" variables is trainable."});var o=Dt.gradients(t,e,null,!0),a=o.value,i=o.grads;d(i.some(function(t){return null!=t}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),d(0===a.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+a.rank+" tensor"});var s={};return e.forEach(function(t,e){null!=i[e]&&(s[t.name]=i[e])}),{value:a,grads:s}}function kn(t){return Dt.customGrad(t)}function In(t){if(t.filter(function(t){return null==t}).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function An(t){var e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));var o=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];Dt.startScope(n);try{var o=r.apply(void 0,t);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Dt.endScope(o),o}catch(t){throw Dt.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}var Tn=An({softmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","softmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+e);return kn(function(t,n){var r=t.logSumExp([e],!0),o=t.toFloat().sub(r).exp();return n([o]),{value:o,gradFunc:function(t,n){var r=n[0],o=t.mul(r);return o.sub(o.sum([e],!0).mul(r))}}})(n)}}),Dn=An({logSoftmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+e);return kn(function(t,n){var r=t.max(e,!0),o=t.sub(r),a=o.toFloat().sub(o.exp().sum(e,!0).log());return n([a]),{value:a,gradFunc:function(t,n){var r=n[0].exp();return t.sub(t.sum(e,!0).mul(r))}}})(n)}});var On=An({complex_:function(t,e){var n=wn(t,"real","complex"),r=wn(e,"imag","complex");return v(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex()."),Dt.runKernel(function(t){return t.complex(n,r)},{$real:n,$imag:r})}}),_n=An({real_:function(t){var e=wn(t,"input","real");return Dt.runKernel(function(t){return t.real(e)},{$input:e})}}),Mn=An({imag_:function(t){var e=wn(t,"input","imag");return Dt.runKernel(function(t){return t.imag(e)},{$input:e})}});function Fn(t,e,n){if(null==n&&(n=W(t)),"complex64"===n)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");var r=yn(t);if(null!=e){K(e);var o=y(e),i=y(r);d(o===i,function(){return"Based on the provided shape, ["+e+"], the tensor should have "+o+" values but has "+i});for(var s=0;s<r.length;++s){var u=r[s],l=s!==r.length-1||u!==y(e.slice(s));d(r[s]===e[s]||!l,function(){return"Error creating a new Tensor. Inferred shape ("+r+") does not match the provided shape ("+e+"). "})}}return _(t)||Array.isArray(t)||(t=[t]),e=e||r,t="string"!==n?G(t,n,a.getBool("DEBUG")):g(t),ft.make(e,{values:t},n)}function Bn(t,e){if((_(t)||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");return Fn(t,[],e)}function Pn(t,e){m(t);var n=yn(t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fn(t,n,e)}function Ln(t,e,n){if(m(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var r=yn(t);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Fn(t,e=e||r,n)}function Wn(t,e,n){if(m(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var r=yn(t);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Un(t,e,n){if(m(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var r=yn(t);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function zn(t,e,n){if(m(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var r=yn(t);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Vn(t,e,n){if(m(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var r=yn(t);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Gn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=Gn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=H(y(t),e);return ft.make(t,{values:o},e)}function qn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=qn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=$(y(t),e);return ft.make(t,{values:o},e)}function Hn(t,e,n){return Dt.runKernel(function(r){return r.fill(t,e,n)},{})}function $n(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return Dt.runKernel(function(r){return r.linspace(t,e,n)},{})}function jn(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r="float32"),0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return qn([0],r);var o=$(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return Pn(o,r)}var Kn=An({onesLike_:function(t){var e=wn(t,"x","onesLike");if("complex64"===e.dtype){var n=Kn(_n(e)),r=Xn(Mn(e));return On(n,r)}return Dt.runKernel(function(t){return t.onesLike(e)},{$x:e},null)}}),Xn=An({zerosLike_:function(t){var e=wn(t,"x","zerosLike");return Dt.runKernel(function(t){return t.zerosLike(e)},{$x:e},null)}}),Yn=function(){function t(t){this.dataMover=t,this.data=new WeakMap}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(t),this.data.get(t)},t.prototype.set=function(t,e){this.data.set(t,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.data.delete(t)},t}(),Qn=function(){function t(){}return t.prototype.time=function(t){throw new Error("Not yet implemented.")},t.prototype.read=function(t){throw new Error("Not yet implemented.")},t.prototype.readSync=function(t){throw new Error("Not yet implemented.")},t.prototype.disposeData=function(t){throw new Error("Not yet implemented.")},t.prototype.write=function(t,e){throw new Error("Not yet implemented.")},t.prototype.fromPixels=function(t,e){throw new Error("Not yet implemented.")},t.prototype.register=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.memory=function(){throw new Error("Not yet implemented.")},t.prototype.floatPrecision=function(){throw new Error("Not yet implemented")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.slice=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){throw new Error("Not yet implemented")},t.prototype.unstack=function(t,e){throw new Error("Not yet implemented")},t.prototype.reverse=function(t,e){throw new Error("Not yet implemented")},t.prototype.concat=function(t,e){throw new Error("Not yet implemented")},t.prototype.neg=function(t){throw new Error("Not yet implemented")},t.prototype.add=function(t,e){throw new Error("Not yet implemented")},t.prototype.addN=function(t){throw new Error("Not yet implemented")},t.prototype.subtract=function(t,e){throw new Error("Not yet implemented")},t.prototype.multiply=function(t,e){throw new Error("Not yet implemented")},t.prototype.realDivide=function(t,e){throw new Error("Not yet implemented")},t.prototype.floorDiv=function(t,e){throw new Error("Not yet implemented")},t.prototype.sum=function(t,e){throw new Error("Not yet implemented")},t.prototype.prod=function(t,e){throw new Error("Not yet implemented")},t.prototype.unsortedSegmentSum=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.argMin=function(t,e){throw new Error("Not yet implemented")},t.prototype.argMax=function(t,e){throw new Error("Not yet implemented")},t.prototype.equal=function(t,e){throw new Error("Not yet implemented")},t.prototype.notEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.less=function(t,e){throw new Error("Not yet implemented")},t.prototype.lessEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.greater=function(t,e){throw new Error("Not yet implemented")},t.prototype.greaterEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalNot=function(t){throw new Error("Not yet implemented")},t.prototype.logicalAnd=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalOr=function(t,e){throw new Error("Not yet implemented")},t.prototype.where=function(t){throw new Error("Not yet implemented")},t.prototype.select=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.topk=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.min=function(t,e){throw new Error("Not yet implemented")},t.prototype.minimum=function(t,e){throw new Error("Not yet implemented")},t.prototype.mod=function(t,e){throw new Error("Not yet implemented")},t.prototype.max=function(t,e){throw new Error("Not yet implemented")},t.prototype.maximum=function(t,e){throw new Error("Not yet implemented")},t.prototype.all=function(t,e){throw new Error("Not yet implemented")},t.prototype.any=function(t,e){throw new Error("Not yet implemented")},t.prototype.squaredDifference=function(t,e){throw new Error("Not yet implemented")},t.prototype.ceil=function(t){throw new Error("Not yet implemented")},t.prototype.floor=function(t){throw new Error("Not yet implemented")},t.prototype.round=function(t){throw new Error("Not yet implemented")},t.prototype.sign=function(t){throw new Error("Not yet implemented")},t.prototype.isNaN=function(t){throw new Error("Not yet implemented")},t.prototype.isInf=function(t){throw new Error("Not yet implemented")},t.prototype.isFinite=function(t){throw new Error("Not yet implemented")},t.prototype.pow=function(t,e){throw new Error("Not yet implemented")},t.prototype.exp=function(t){throw new Error("Not yet implemented")},t.prototype.expm1=function(t){throw new Error("Not yet implemented")},t.prototype.log=function(t){throw new Error("Not yet implemented")},t.prototype.log1p=function(t){throw new Error("Not yet implemented")},t.prototype.sqrt=function(t){throw new Error("Not yet implemented")},t.prototype.rsqrt=function(t){throw new Error("Not yet implemented")},t.prototype.square=function(t){throw new Error("Not yet implemented")},t.prototype.reciprocal=function(t){throw new Error("Not yet implemented")},t.prototype.relu=function(t){throw new Error("Not yet implemented")},t.prototype.prelu=function(t,e){throw new Error("Not yet implemented")},t.prototype.elu=function(t){throw new Error("Not yet implemented")},t.prototype.eluDer=function(t,e){throw new Error("Not yet implemented")},t.prototype.selu=function(t){throw new Error("Not yet implemented")},t.prototype.int=function(t){throw new Error("Not yet implemented")},t.prototype.clip=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.abs=function(t){throw new Error("Not yet implemented")},t.prototype.complexAbs=function(t){throw new Error("Not yet implemented")},t.prototype.sigmoid=function(t){throw new Error("Not yet implemented")},t.prototype.softplus=function(t){throw new Error("Not yet implemented")},t.prototype.sin=function(t){throw new Error("Not yet implemented")},t.prototype.cos=function(t){throw new Error("Not yet implemented")},t.prototype.tan=function(t){throw new Error("Not yet implemented")},t.prototype.asin=function(t){throw new Error("Not yet implemented")},t.prototype.acos=function(t){throw new Error("Not yet implemented")},t.prototype.atan=function(t){throw new Error("Not yet implemented")},t.prototype.atan2=function(t,e){throw new Error("Not yet implemented")},t.prototype.sinh=function(t){throw new Error("Not yet implemented")},t.prototype.cosh=function(t){throw new Error("Not yet implemented")},t.prototype.tanh=function(t){throw new Error("Not yet implemented")},t.prototype.asinh=function(t){throw new Error("Not yet implemented")},t.prototype.acosh=function(t){throw new Error("Not yet implemented")},t.prototype.atanh=function(t){throw new Error("Not yet implemented")},t.prototype.erf=function(t){throw new Error("Not yet implemented")},t.prototype.step=function(t,e){throw new Error("Not yet implemented")},t.prototype.conv2d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2D=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.maxPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.maxPoolBackprop=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.avgPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.avgPoolBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.reshape=function(t,e){throw new Error("Not yet implemented")},t.prototype.cast=function(t,e){throw new Error("Not yet implemented")},t.prototype.tile=function(t,e){throw new Error("Not yet implemented")},t.prototype.pad=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.transpose=function(t,e){throw new Error("Not yet implemented")},t.prototype.gather=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.gatherND=function(t,e){throw new Error("Not yet implemented")},t.prototype.scatterND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchToSpaceND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.spaceToBatchND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeBilinear=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeBilinearBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighbor=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchNormalization=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){throw new Error("Not yet implemented")},t.prototype.multinomial=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.oneHot=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.cumsum=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.fft=function(t){throw new Error("Not yet implemented")},t.prototype.ifft=function(t){throw new Error("Not yet implemented")},t.prototype.complex=function(t,e){throw new Error("Not yet implemented")},t.prototype.real=function(t){throw new Error("Not yet implemented")},t.prototype.imag=function(t){throw new Error("Not yet implemented")},t.prototype.cropAndResize=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.depthToSpace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.split=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.sparseToDense=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fill=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.onesLike=function(t){throw new Error("Not yet implemented")},t.prototype.zerosLike=function(t){throw new Error("Not yet implemented")},t.prototype.linspace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.dispose=function(){throw new Error("Not yet implemented")},t}();function Jn(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();var r=qn(t.shape),o=t.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!O(t.dtype,e))return ft.make(t.shape,{dataId:t.dataId},e);if("complex64"===t.dtype){var i=n.real(t);a=i.cast(e);return i.dispose(),a}if("int32"===e)return n.int(t);if("bool"===e){var s=Bn(0,t.dtype);a=n.notEqual(t,s);return s.dispose(),a}throw new Error("Error in Cast: unknown dtype argument ("+e+")")}function Zn(t,e){return ft.make(e,{dataId:t.dataId},t.dtype)}function tr(t,e,n){var r=(e-t)/(n-1),o=$(n,"float32");o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return Pn(o,"float32")}function er(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+t.length+", imag: "+e.length+".");for(var n=new Float32Array(2*t.length),r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function nr(t,e){return{real:t[2*e],imag:t[2*e+1]}}function rr(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function or(t,e,n){var r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function ar(t,e,n,r,o){for(var a=Array.from(e).map(function(t,e){return{score:t,boxIndex:e}}).filter(function(t){return t.score>o}).sort(function(t,e){return e.score-t.score}),i=[],s=0;s<a.length;s++){var u=a[s],l=u.score,c=u.boxIndex;if(l<o)break;for(var h=!1,p=i.length-1;p>=0;--p){if(ir(t,c,i[p])>=r){h=!0;break}}if(!h&&(i.push(c),i.length>=n))break}return Pn(i,"int32")}function ir(t,e,n){var r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),p=Math.max(o[1],o[3]),f=(s-a)*(u-i),d=(h-l)*(p-c);if(f<=0||d<=0)return 0;var v=Math.max(a,l),m=Math.max(i,c),g=Math.min(s,h),y=Math.min(u,p),x=Math.max(g-v,0)*Math.max(y-m,0);return x/(f+d-x)}function sr(t,e,n){var r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map(function(e){o[n]=e;var a=t.slice(r,o);return r[n]+=e,a})}function ur(t,e,n,r,o){for(var a=e[e.length-1],i=[t.length/a,a],s=i[0],u=i[1],l=I(n,s*r),c=I("int32",s*r),h=0;h<s;h++){for(var p=h*u,f=t.subarray(p,p+u),d=[],v=0;v<f.length;v++)d.push({value:f[v],index:v});d.sort(function(t,e){return e.value-t.value});var m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(v=0;v<r;v++)g[v]=d[v].value,y[v]=d[v].index}var x=e.slice();return x[x.length-1]=r,[Fn(l,x,n),Fn(c,x,"int32")]}var lr=An({concat_:function(t,e){void 0===e&&(e=0),d(t.length>=1,function(){return"Pass at least one tensor to concat"});var n=bn(t,"tensors","concat");e=N(e,n[0].shape)[0];var r=sn(n.map(function(t){return t.shape}),e);if(0===y(r))return Fn([],r);if(1===(n=n.filter(function(t){return t.size>0})).length)return n[0];var o=n.map(function(t){return t.shape});!function(t,e){var n=t[0].length;t.forEach(function(t,e){d(t.length===n,function(){return"Error in concat"+n+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+n+")"})}),d(e>=0&&e<n,function(){return"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+"."});var r=t[0];t.forEach(function(t,o){for(var a=0;a<n;a++)d(a===e||t[a]===r[a],function(){return"Error in concat"+n+"D: Shape of tensors["+o+"] ("+t+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+o+"."})})}(o,e);var a=n;return Dt.runKernel(function(t){return t.concat(n,e)},a,function(t){var n=o.map(function(t){return t[e]});return dr(t,n,e).map(function(t){return function(){return t}})})}}),cr=An({concat1d_:function(t){return lr(t,0)}}),hr=An({concat2d_:function(t,e){return lr(t,e)}}),pr=An({concat3d_:function(t,e){return lr(t,e)}}),fr=An({concat4d_:function(t,e){return lr(t,e)}}),dr=An({split_:function(t,e,n){void 0===n&&(n=0);var r,o=wn(t,"x","split");return n=N(n,o.shape)[0],"number"==typeof e?(d(o.shape[n]%e==0,function(){return"Number of splits must evenly divide the axis."}),r=new Array(e).fill(o.shape[n]/e)):(d(o.shape[n]===e.reduce(function(t,e){return t+e}),function(){return"The sum of sizes must match the size of the axis dimension."}),r=e),Dt.runKernel(function(t){return t.split(o,r,n)},{$x:o},function(t){return{$x:function(){return lr(t,n)}}})}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function vr(t,e){return t(e={exports:{}},e.exports),e.exports}var mr=vr(function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+1.1102230246251565e-16*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.alea=a}(0,t,!1)}),gr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a}(0,t,!1)}),yr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a}(0,t,!1)}),xr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.x&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a}(0,t,!1)}),wr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,a=e.i;return e.w=r=r+1640531527|0,n=o[a+34&127],t=o[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,o,a,i,s=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,a=-32;a<u;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(e&&e.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;t.w=i,t.X=s,t.i=o}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.X&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a}(0,t,!1)}),br=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a}(0,t,!1)}),Cr=vr(function(t){!function(e,n){var r,o=this,a=256,i=6,s="random",u=n.pow(a,i),l=n.pow(2,52),c=2*l,h=a-1;function p(t,h,p){var g=[],y=v(function t(e,n){var r,o=[],a=typeof e;if(n&&"object"==a)for(r in e)try{o.push(t(e[r],n-1))}catch(t){}return o.length?o:"string"==a?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(a):(t=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(t)),m(t)}catch(t){var n=o.navigator,i=n&&n.plugins;return[+new Date,o,i,o.screen,m(e)]}}():t,3),g),x=new f(g),w=function(){for(var t=x.g(i),e=u,n=0;t<l;)t=(t+n)*a,e*=a,n=x.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|x.g(4)},w.quick=function(){return x.g(4)/4294967296},w.double=w,v(m(x.S),e),(h.pass||p||function(t,e,r,o){return o&&(o.S&&d(o,x),t.state=function(){return d(x,{})}),r?(n[s]=t,e):t})(w,y,"global"in h?h.global:this==n,h.state)}function f(t){var e,n=t.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=h&i+t[o%n]+(e=s[o])],s[i]=e;(r.g=function(t){for(var e,n=0,o=r.i,i=r.j,s=r.S;t--;)e=s[o=h&o+1],n=n*a+s[h&(s[o]=s[i=h&i+e])+(s[i]=e)];return r.i=o,r.j=i,n})(a)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function v(t,e){for(var n,r=t+"",o=0;o<r.length;)e[h&o]=h&(n^=19*e[h&o])+r.charCodeAt(o++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(n["seed"+s]=p,v(n.random(),e),t.exports){t.exports=p;try{r=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}}([],Math)});Cr.alea=mr,Cr.xor128=gr,Cr.xorwow=yr,Cr.xorshift7=xr,Cr.xor4096=wr,Cr.tychei=br;var Er=Cr.alea,Rr=function(){function t(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=Er(a.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),Sr=function(){function t(t,e,n,r){void 0===t&&(t=0),void 0===e&&(e=1),void 0===r&&(r=Math.random());var o=this;if(this.canReturnFloat=function(){return null==o.dtype||"float32"===o.dtype},this.min=t,this.range=e-t,this.dtype=n,!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=Er(r.toString())}return t.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function Nr(t,e,n){return void 0===e&&(e="float32"),e=e||"float32",K(t),new lt(t,e,n)}function kr(t,e){void 0===e&&(e=!1),console.log(t.toString(e))}var Ir=An({batchToSpaceND_:function(t,e,n){var r=wn(t,"x","batchToSpaceND"),o=e.reduce(function(t,e){return t*e});return d(r.rank>=1+e.length,function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+e.length}),d(n.length===e.length,function(){return"crops.length is "+n.length+" but should be equal to blockShape.length  "+e.length}),d(r.shape[0]%o==0,function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+e.join(" * ")+" === "+o}),Dt.runKernel(function(t){return t.batchToSpaceND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.spaceToBatchND(e,n)}}})}}),Ar=An({cast_:function(t,e){var n=wn(t,"x","cast");return Dt.runKernel(function(t){return t.cast(n,e)},{$x:n},function(t){return{$x:function(){return t.clone()}}})}}),Tr=An({clone_:function(t){var e=wn(t,"x","clone",null);return Dt.runKernel(function(t){return ft.make(e.shape,{dataId:e.dataId},e.dtype)},{$x:e},function(t){return{$x:function(){return t.toFloat()}}})}}),Dr=An({cumsum_:function(t,e,n,r){void 0===e&&(e=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=wn(t,"x","cumsum"),a=rn([e|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=an(1,o.rank)[0],u=Dt.runKernel(function(t){return t.cumsum(i,s,n,r)},{permutedX:i},function(t){return{permutedX:function(){return t.cumsum(e,n,!r)}}});return null!=a&&(u=u.transpose(a)),u}}),Or=An({depthToSpace_:function(t,e,n){void 0===n&&(n="NHWC");var r=wn(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return d(o*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+e+"  for depthToSpace with input shape\n      "+r.shape}),d(a*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+e+" for depthToSpace with input shape\n          "+r.shape}),d(i%(e*e)==0,function(){return"Dimension size must be evenly divisible by "+e*e+" but is "+i+" for depthToSpace with input shape "+r.shape}),Dt.runKernel(function(t){return t.depthToSpace(r,e,n)},{$x:r})}}),_r=An({expandDims_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","expandDims");d(e<=n.rank,function(){return"Axis must be <= rank of the tensor"});var r=n.shape.slice();return e<0&&(d(-(n.rank+1)<=e,function(){return"Axis must be in the interval ["+-(n.rank+1)+", "+n.rank+"]"}),e=n.rank+e+1),r.splice(e,0,1),Hr(n,r)}}),Mr=An({eye_:function(t,e,n,r){void 0===r&&(r="float32"),null==e&&(e=t);for(var o=Nr([t,e],r),a=t<=e?t:e,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(t,e);if(null==n)return s;if(1===n.length)return Xr(_r(s,0),[n[0],1,1]);if(2===n.length)return Xr(_r(_r(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Xr(_r(_r(_r(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}}),Fr=An({multinomial_:function(t,e,n,r){void 0===r&&(r=!1);var o=wn(t,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=Dt.runKernel(function(t){return t.multinomial(s,r,e,n)},{logits2D:s});return 1===i?u.as1D():u}}),Br=An({oneHot_:function(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r=0),e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);var o=wn(t,"indices","oneHot","int32"),a=o.shape.concat([e]);return o=o.flatten(),Dt.runKernel(function(t){return t.oneHot(o,e,n,r)},{$indices:o},function(t){return{$indices:function(){return qn(o.shape,"float32")}}}).reshape(a)}}),Pr=An({pad_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o=e.map(function(t){return t[0]});return Dt.runKernel(function(t){return t.pad(r,e,n)},{$x:r},function(t){return{$x:function(){return t.slice(o,r.shape)}}})}}),Lr=An({pad1d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length,function(){return"Invalid number of paddings. Must be length of 2."}),Pr(t,[e],n)}}),Wr=An({pad2d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length&&2===e[0].length&&2===e[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Ur=An({pad3d_:function(t,e,n){return void 0===n&&(n=0),d(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),zr=An({pad4d_:function(t,e,n){return void 0===n&&(n=0),d(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Vr=An({rand_:function(t,e,n){var r=y(t),o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);o=new Uint8Array(r)}for(var a=0;a<r;a++)o[a]=e();return ft.make(t,{values:o},n)}}),Gr=An({randomNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!1,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),qr=An({randomUniform_:function(t,e,n,r,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===r&&(r="float32");for(var a=Nr(t,r),i=new Sr(e,n,null,o),s=0;s<a.values.length;s++)a.values[s]=i.nextValue();return a.toTensor()}}),Hr=An({reshape_:function(t,e){var n=wn(t,"x","reshape",null);return e=S(e,n.size),d(n.size===y(e),function(){return"new shape and old shape must have the same number of elements."}),Dt.runKernel(function(t){return t.reshape(n,e)},{$x:n},function(t){return{$x:function(){return t.reshape(n.shape)}}})}}),$r=An({spaceToBatchND_:function(t,e,n){var r=wn(t,"x","spaceToBatchND");return d(r.rank>=1+e.length,function(){return"input rank "+r.rank+" should be > than [blockShape] "+e.length}),d(n.length===e.length,function(){return"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+e.length}),d(r.shape.reduce(function(t,r,o){return o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t},!0),function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+e.toString()}),Dt.runKernel(function(t){return t.spaceToBatchND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.batchToSpaceND(e,n)}}})}}),jr=An({squeeze_:function(t,e){var n=wn(t,"x","squeeze");return Hr(n,k(n.shape,e).newShape)}}),Kr=An({stack_:function(t,e){void 0===e&&(e=0);var n=bn(t,"tensors","stack");if(d(n.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===n.length)return n[0].expandDims(e);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;d(e<=r,function(){return"Axis must be <= rank of the tensor"}),n.forEach(function(t){v(o,t.shape,"All tensors passed to stack must have matching shapes")}),n.forEach(function(t){d(a===t.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var i=n.map(function(t){return t.expandDims(e)});return lr(i,e)}}),Xr=An({tile_:function(t,e){var n=wn(t,"x","tile");return d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of reps "+e+"."}),Dt.runKernel(function(t,r){var o=t.tile(n,e);return r([n]),o},{$x:n},function(t,n){var r=n[0];return{$x:function(){var n=Xn(r);if(1===r.rank)for(var o=0;o<e[0];++o)n=n.add(t.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<e[0];++o)for(var a=0;a<e[1];++a)n=n.add(t.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(var i=0;i<e[2];++i)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(i=0;i<e[2];++i)for(var s=0;s<e[3];++s)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}})}}),Yr=An({truncatedNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!0,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Qr=An({unstack_:function(t,e){void 0===e&&(e=0),e=e||0;var n=wn(t,"x","unstack");return d(e>=-n.shape.length&&e<n.shape.length,function(){return"Axis = "+e+" is not in [-"+n.shape.length+", "+n.shape.length+")"}),e<0&&(e+=n.shape.length),Dt.runKernel(function(t){return t.unstack(n,e)},{$x:n},function(t){return{$x:function(){return Kr(t,e)}}})}}),Jr=function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return n=wn(t,"x","setdiff1d"),r=wn(e,"y","setdiff1d"),d(n.dtype===r.dtype,function(){return"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+r.dtype+")."}),d(1===n.rank,function(){return"x should be 1D tensor, but got x ("+n.shape+")."}),d(1===r.rank,function(){return"y should be 1D tensor, but got y ("+r.shape+")."}),[4,n.data()];case 1:return a=o.sent(),[4,r.data()];case 2:for(i=o.sent(),s=new Set(i),u=0,h=0;h<a.length;h++)s.has(a[h])||u++;for(l=new lt([u],n.dtype),c=new lt([u],"int32"),h=0,p=0;h<a.length;h++)s.has(a[h])||(l.values[p]=a[h],c.values[p]=h,p++);return[2,[l.toTensor(),c.toTensor()]]}})})};function Zr(t,e){for(var n=[],r=0;r<e.length;r++)e[r]&&n.push(r);var o=Nr(t,"int32"),a=Nr([n.length,t.length],"int32");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*t.length;a.values.set(i,s)}return a.toTensor()}var to=function(){return function(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("float v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "}}(),eo=function(){return function(t,e){this.outputShape=[],this.usesPackedTextures=!0,this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("vec4 v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "}}(),no=function(){return function(t,e,n){this.variableNames=["A"];var r=t.windowSize,o=t.batchSize,a=t.inSize,i=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===e?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}();function ro(t,e){return["x","y","z","w","u","v"].slice(0,e).map(function(e){return t+"."+e})}function oo(t,e){return 1===e?[t]:ro(t,e)}function ao(t,e){for(var n=t.length,r=[],o=0;o<n;o++){var a=n-1-o,i=t[a]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(a)}return r}function io(t,e){for(var n=[],r=0;r<e.length;r++){var o=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==o||1===o&&i>1)&&n.unshift(a)}return n}function so(t,e){for(var n=[],r=Math.max(t.length,e.length),o=0;o<r;o++){var a=t[t.length-o-1];null==a&&(a=1);var i=e[e.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+t+" and "+e+".");n.unshift(a)}}return n}function uo(){var t,e,n,r,o,i,s,u,l,c;return 2===a.getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",o="texture",i="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 0. || val == 0.) ? false : true;\n      }\n    ",l="\n      const float INFINITY = uintBitsToFloat(uint(0x7f800000));\n    ",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",o="texture2D",i="gl_FragColor",s="",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:i,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function lo(t,e,n){void 0===n&&(n="index");var r=V(e);return r.map(function(e,o){return"int "+t[o]+" = "+n+" / "+e+"; "+(o===r.length-1?"int "+t[o+1]+" = "+n+" - "+t[o]+" * "+e:"index -= "+t[o]+" * "+e)+";"}).join("")}function co(t){return 1===t.length?""+t[0]:"vec"+t.length+"("+t.join(",")+")"}function ho(t,e,n,r){var o=[];t.forEach(function(t){var e=y(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?o.push("uniform float "+t.name+(e>1?"["+e+"]":"")+";"):(o.push("uniform sampler2D "+t.name+";"),o.push("uniform int offset"+t.name+";"))});var a,i,s=o.join("\n"),u=t.map(function(t){return function(t,e,n){void 0===n&&(n=!1);var r="";r+=n?fo(t):po(t);var o=t.shapeInfo.logicalShape,a=e.logicalShape;o.length<=a.length&&(r+=n?function(t,e){var n,r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",i=t.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=ao(t.shapeInfo.logicalShape,e.logicalShape),l=bo(s),c=s-i,h=["x","y","z","w","u","v"];n=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map(function(t){return"coords."+h[t+c]+" = 0;"}).join("\n");var p="";p=s<2&&i>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+h[e+c]}).join(", ");var f="return outputValue;",d=1===y(t.shapeInfo.logicalShape),v=1===y(e.logicalShape);if(1!==i||d||v){if(d&&!v)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var m=i-2,g=i-1;u.indexOf(m)>-1&&u.indexOf(g)>-1?f="return vec4(outputValue.x);":u.indexOf(m)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(g)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+l+" coords = getOutputCoords();\n      "+n+"\n      vec4 outputValue = get"+o+"("+p+");\n      "+f+"\n    }\n  "}(t,e):function(t,e){var n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,s=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&s===u&&null==t.shapeInfo.flatOffset&&x(i,a))return"\n      float "+o+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ";var l,c=bo(u),h=ao(t.shapeInfo.logicalShape,e.logicalShape),p=u-s,f=["x","y","z","w","u","v"];l=0===s?"":u<2&&h.length>=1?"coords = 0;":h.map(function(t){return"coords."+f[t+p]+" = 0;"}).join("\n");var d="";d=u<2&&s>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+f[e+p]}).join(", ");return"\n    float "+o+"() {\n      "+c+" coords = getOutputCoords();\n      "+l+"\n      return get"+r+"("+d+");\n    }\n  "}(t,e));return r}(t,e,r)}).join("\n"),l=e.texShape,c=uo(),h=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+t.texture2D+"(textureSampler, uv).r;\n    }\n  "}(c),p=function(t){return t.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+t.varyingFs+" vec2 resultUV;\n    "+t.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    #define isnan(value) isnan_custom(value)\n    "+t.defineSpecialNaN+"\n    bvec4 isnan_custom(vec4 val) {\n      return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n    }\n\n    "+t.defineSpecialInf+"\n    "+t.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+vo+"\n    "+mo+"\n    "+go+"\n  "}(c);return e.isPacked?(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return resTexRC.x * "+n[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";var r=Math.ceil(t[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=t,r=e,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Math.ceil(n[2]/2),i=a*Math.ceil(n[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+o[0]+", "+o[1]+"));\n      int index = resTexRC.x * "+o[1]+" + resTexRC.y;\n\n      int b = index / "+i+";\n      index -= b * "+i+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(t,e){for(var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2),a=o,i="",s="b, r, c",u=2;u<t.length-1;u++)a*=t[t.length-u-1],i="\n      int b"+u+" = index / "+a+";\n      index -= b"+u+" * "+a+";\n    "+i,s="b"+u+", "+s;return"\n    ivec"+t.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+t.length+"("+s+");\n    }\n  "}(t,e)}var n,r,o,a,i}(e.logicalShape,l),i=function(t){return"\n    void setOutput(vec4 val) {\n      "+t.output+" = val;\n    }\n  "}(c)):(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){if(1===e[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ";if(1===e[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ";if(1===t[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===t[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+t[1]+";\n      int c = index - r * "+t[1]+";\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=e,r=lo(["r","c","d"],t),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(t,e){var n=lo(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(t,e);case 5:return function(t,e){var n=lo(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(t,e);case 6:return function(t,e){var n=lo(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n,r}(e.logicalShape,l),i=function(t){return"\n    void setOutput(float val) {\n      "+t.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(c)),r&&(p+=yo),[p,h,i,s,a,u,n].join("\n")}function po(t){var e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"float "+n+"() {return "+e+";}";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===o&&1===a)return"\n      float "+n+"() {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=t.shapeInfo.texShape,s=i[0],u=i[1],l=xo(e);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+s+", "+u+", "+l+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+wo(t)+"\n      }\n    ";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=xo(e);if(1===a)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+i+") + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+i+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+a+", index + "+i+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape;if(null!=o&&x(e,o)){var a=o[0],i=o[1];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n      return sampleTexture("+n+", uv);\n    }\n  "}var s=k(e),u=s.newShape,l=s.keptDims,c=u;if(c.length<e.length){var h=Co(t,c);return"\n      "+po(h)+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+Eo(["row","col"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+e[1]+", 1)));\n        "+wo(t)+"\n      }\n    ";var p=o[0],f=o[1],d=xo(n);if(1===f)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";if(1===p)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+f+".0, 0.5);\n      return sampleTexture("+n+", uv);\n    }\n  ";return"\n  float "+r+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+e[1]+" + col + "+d+";\n    vec2 uv = uvFromFlat("+p+", "+f+", index);\n    return sampleTexture("+n+", uv);\n  }\n"}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[1]*e[2],a=e[2],i=k(e),s=i.newShape,u=i.keptDims,l=s;if(l.length<e.length){var c=Co(t,l);return"\n        "+po(c)+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+Eo(["row","col","depth"],u)+");\n        }\n      "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.texShape,p=h[0],f=h[1],d=t.shapeInfo.flatOffset;if(f===o&&null==d)return"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+f+".0, "+p+".0);\n          return sampleTexture("+n+", uv);\n        }\n      ";if(f===a&&null==d)return"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+f+".0, "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";var v=xo(n);return"\n      float "+r+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+o+" + col * "+a+" + depth + "+v+";\n        vec2 uv = uvFromFlat("+p+", "+f+", index);\n        return sampleTexture("+n+", uv);\n      }\n  "}(t);case 4:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[3],a=e[2]*o,i=e[1]*a,s=k(e),u=s.newShape,l=s.keptDims;if(u.length<e.length){var c=Co(t,u);return"\n      "+po(c)+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+Eo(["row","col","depth","depth2"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1];if(d===i&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(d===o&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var v=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+i+" + col * "+a+" +\n          depth * "+o+" + depth2;\n      vec2 uv = uvFromFlat("+f+", "+d+", index + "+v+");\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 5:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],a=e[3]*o,i=e[2]*a,s=e[1]*i,u=k(e),l=u.newShape,c=u.keptDims;if(l.length<e.length){var h=Co(t,l);return"\n      "+po(h)+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        "+wo(t)+"\n      }\n    ";var p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],v=f[1];if(v===s&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(v===o&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+",\n               "+e[2]*e[3]+", "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var m=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+i+" + depth * "+a+" +\n          depth2 * "+o+" + depth3 + "+m+";\n      vec2 uv = uvFromFlat("+d+", "+v+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 6:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=k(e),a=o.newShape,i=o.keptDims;if(a.length<e.length){var s=Co(t,a);return"\n      "+po(s)+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3","depth4"],i)+");\n      }\n    "}var u=e[5],l=e[4]*u,c=e[3]*l,h=e[2]*c,p=e[1]*h;if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+p+", "+h+", "+c+", "+l+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+u+", 1)));\n        "+wo(t)+"\n      }\n    ";var f=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,v=d[0],m=d[1];if(m===p&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+h+", "+c+", "+l+", "+u+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(m===u&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var g=xo(n);return"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+p+" + col * "+h+" + depth * "+c+" +\n          depth2 * "+l+" + depth3 * "+u+" + depth4 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+m+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function fo(t){var e,n,r;switch(t.shapeInfo.logicalShape.length){case 0:return e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=uo(),"\n    vec4 "+n+"() {\n      return "+r.texture2D+"("+e+", halfCR);\n    }\n  ";case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=uo();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+a.texture2D+"("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],s=uo();if(null!=o&&x(e,o))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return "+s.texture2D+"("+n+", uv);\n      }\n    ";var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(e[1]/2);return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+l+", "+u[0]+", "+u[1]+", row, col);\n      return "+s.texture2D+"("+n+", uv);\n    }\n  "}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){var i=e.slice(1),s=Co(t,i);return"\n        "+fo(s)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+Eo(["b","row","col"],[1,2])+");\n        }\n      "}var u=a[0],l=a[1],c=Math.ceil(e[2]/2),h=c*Math.ceil(e[1]/2),p=uo();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+u+", "+l+", "+h+", "+c+", b, row, col);\n      return "+p.texture2D+"("+n+", uv);\n    }\n  "}(t);default:return function(t){for(var e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=i[0],u=i[1],l=Math.ceil(e[n-1]/2),c=l*Math.ceil(e[n-2]/2),h="int b, int row, int col",p="b * "+c+" + (row / 2) * "+l+" + (col / 2)",f=2;f<n-1;f++)h="int b"+f+", "+h,c*=e[n-f-1],p="b"+f+" * "+c+" + "+p;var d=uo();return"\n    vec4 "+o+"("+h+") {\n      int index = "+p+";\n      int texR = index / "+u+";\n      int texC = index - texR * "+u+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+u+", "+s+");\n      return "+d.texture2D+"("+r+", uv);\n    }\n  "}(t)}}var vo="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mo="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",go="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yo="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xo(t){return"offset"+t}function wo(t){var e=t.name,n=y(t.shapeInfo.logicalShape);return n<2?"return "+e+";":"\n    for (int i = 0; i < "+n+"; i++) {\n      if (i == index) {\n        return "+e+"[i];\n      }\n    }\n  "}function bo(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function Co(t,e){var n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Eo(t,e){return e.map(function(e){return t[e]}).join(", ")}var Ro=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,d(t.length>2,function(){return"Packed arg"+(n.charAt(0).toUpperCase()+n.slice(1))+" supports only inputs with rank above 2."});var o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i,s,u=this.outputShape,l=u.length,c=bo(l),h=oo("coords",l);if(1===a){var p=bo(s=l+1);i="\n        "+p+" sourceLocR = "+p+"("+h.join()+", 0);\n        ++"+h[l-1]+";\n        "+p+" sourceLocG = "+p+"("+h.join()+", 0);\n        ++"+h[l-2]+";\n        "+p+" sourceLocA = "+p+"("+h.join()+", 0);\n        --"+h[l-1]+";\n        "+p+" sourceLocB = "+p+"("+h.join()+", 0);\n        --"+h[l-2]+";"}else s=l,i="\n        "+c+" sourceLocR = coords;\n        ++"+h[l-1]+";\n        "+c+" sourceLocG = coords;\n        ++"+h[l-2]+";\n        "+c+" sourceLocA = coords;\n        --"+h[l-1]+";\n        "+c+" sourceLocB = coords;\n        --"+h[l-2]+";";var f=["x","y","z","w","u","v"].slice(0,s),v="."+f[s-1],m=f.map(function(t){return"int "+t}),g=oo("sourceLocR",s-1).concat("inIdx.r"),y=oo("sourceLocG",s-1).concat("inIdx.g"),x=oo("sourceLocB",s-1).concat("inIdx.b"),w=oo("sourceLocA",s-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",C=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+y.join()+"),\n                             getBestIndicesAChannel("+x.join()+"),\n                             getBestIndicesAChannel("+w.join()+")));",E="vec4(\n            getAChannel("+g.join()+"),\n            hasNextCol ? getAChannel("+y.join()+") : 0.,\n            hasNextRow ? getAChannel("+x.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+w.join()+") : 0.)",R=r?"":"\n      float getBestIndicesAChannel("+m.join()+") {\n        return getChannel(getBestIndicesA("+f.join()+"),\n                                          vec2("+f.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+m.join()+") {\n        return getChannel(getA("+f.join()+"),\n                               vec2("+f.slice(-2).join()+"));\n      }\n      "+R+"\n      void main() {\n        "+c+" coords = getOutputCoords();\n        bool hasNextCol = "+h[l-1]+" < "+(u[l-1]-1)+";\n        bool hasNextRow = "+h[l-2]+" < "+(u[l-2]-1)+";\n        "+i+"\n        ivec4 srcIdx = ivec4(sourceLocR"+v+", sourceLocG"+v+",\n          sourceLocB"+v+", sourceLocA"+v+") * "+e+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+E+";\n\n        for (int i = 0; i < "+e+"; i++) {\n          inIdx = srcIdx;\n          "+C+"\n          vec4 candidate = "+E+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+b+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "}}(),So=function(){return function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=s-1-t.padInfo.top,c=u-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float avgMultiplier = float("+h+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),No=function(){return function(t,e,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="0.0";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),ko=function(){return function(t,e,n,r,o,a){this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="vec4(0.0)";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+i+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}(),Io="return areal * breal - aimag * bimag;",Ao="return areal * bimag + aimag * breal;",To=function(){return function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=so(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),Do="return a + b;",Oo="return a - b;",_o="return a * b;",Mo=function(){return function(t,e,n){this.variableNames=["A","B"],this.outputShape=so(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}}(),Fo=function(){return function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.outputShape=so(e,n);var o=this.outputShape.length,a="";if(r)if(0===o||1===y(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+bo(o)+" coords = getOutputCoords();\n        ",1===o)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var i=oo("coords",o);a+="\n            bool nextRowOutOfBounds =\n              ("+i[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+i[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "}}(),Bo=function(){function t(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, min, max));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Po=function(){function t(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(min), vec4(max)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Lo=function(){return function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(),Wo=function(){return function(t){this.outputShape=[],this.outputShape=sn(t,1),this.variableNames=t.map(function(t,e){return"T"+e});var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var a=e.length,i=e[e.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "}}(),Uo=function(){return function(t,e){this.usesPackedTextures=!0,this.outputShape=[],this.outputShape=sn(t,e);var n=this.outputShape,r=n.length,o=bo(r),a=oo("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(function(t,e){return"T"+e});var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var l=i[e],c="vec2("+i.slice(-2).join()+")",h=i.join(),p="if ("+l+" < "+s[0]+")\n          return getChannel(getT0("+h+"), "+c+");";for(u=1;u<s.length;u++){var f=s[u-1];p+="\n        else if ("+l+" < "+s[u]+") {\n          "+l+" -= "+f+";\n          return getChannel(getT"+u+"("+h+"), "+c+");\n        }"}var d=s.length;p+="\n        else {\n          "+l+" -= "+s[s.length-1]+";\n          return getChannel(getT"+d+"("+h+"), "+c+");\n        }",this.userCode="\n      float getValue("+i.map(function(t){return"int "+t})+") {\n        "+p+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n        if (++"+a[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+a+");\n        }\n        if (++"+a[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+a+");\n        }\n        if ("+a[r-2]+" < "+n[r-2]+" &&\n            --"+a[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "}}(),zo=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Vo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Go=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yF = 0; yF < "+t.outDepth+"; yF++) {\n            int xF = wF + yF * "+e+" - "+o+";\n\n            if (xF < 0 || xF >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+a+";\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+i+";\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),qo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.front,u=n-1-t.padInfo.top,l=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+l+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+e+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+t.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+e+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ho=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$o=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),jo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.top,n=t.padInfo.left,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.filterHeight,u=t.filterWidth,l=4*Math.floor(t.inChannels/4),c=t.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+r+", "+o+");\n      const ivec2 pads = ivec2("+e+", "+n+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+"; wR++) {\n          int xR = xRCorner + wR * "+a+";\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+u+"; wC++) {\n            int xC = xCCorner + wC * "+i+";\n\n            if (xC < 0 || xC >= "+t.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+l+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(1===c)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+l+") *\n                getW(wR, wC, "+l+", d2);\n            } else if ("+(2===c)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(3===c)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1),\n                getX(batch, xR, xC, "+l+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2),\n                getW(wR, wC, "+l+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ko=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),d=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+e+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+c+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+p+"; wC++) {\n              int xC = xCCorner + wC * "+l+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+f+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===d)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+f+") *\n                  getW(wF, wR, wC, "+f+", d2);\n              } else if ("+(2===d)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===d)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1),\n                  getX(batch, xF, xR, xC, "+f+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2),\n                  getW(wF, wR, wC, "+f+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Xo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+h+";\n        int q = d2 - d1 * "+h+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+s+";\n\n          if (xR < 0 || xR >= "+e+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+c+"; wC++) {\n            int xC = xCCorner + wC * "+u+";\n\n            if (xC < 0 || xC >= "+n+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Yo=function(){return function(t){this.variableNames=["x","W"],this.usesPackedTextures=!0,this.outputShape=t.outShape;for(var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=c,f="int xR; int xC; int xCOffset;",d=0;d<l;d++)for(var v=0;v<c;v++)f+="\n          vec4 xTexelR"+d+"C"+2*v+" = vec4(0.);\n          vec4 wR"+d+"C"+v+" = vec4(0.);\n          vec4 xR"+d+"C"+v+" = vec4(0.);";for(d=0;d<l;d++)for(var m=0;m<h;m++){if(f+="\n          xR = xRCorner + "+d*s+";\n          xC = xCCorner + "+(v=2*m)*u+";\n        ",1===i){if(v<c&&(f+=o%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR"+d+"C"+v+" = vec4(previous.zw, xTexelR"+d+"C"+v+".xy);\n                } else {\n                  xR"+d+"C"+v+" = vec4(0, 0, xTexelR"+d+"C"+v+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+e+" && xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = xTexelR"+d+"C"+v+";\n              ",v+1<c)){var g=o%2==0?p(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(f+="\n                  xCOffset = xC + "+o%2+" + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",u>1&&(f+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+e+" &&\n                      xCOffset >= 0 && xCOffset < "+n+") {\n                      xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+d+"C"+v+" = vec4(0.);\n                    }\n                  "),f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".xy);\n                "):f+="\n                  xCOffset = xC + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+d+"C"+(v+1)+" = xTexelR"+d+"C"+(v+2)+";\n                "}}else v<c&&(f+="\n              if(xR >= 0 && xR < "+e+") {\n            ",o%2==1?(f+="\n                xCOffset = xC + 1 - "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n              ",v+1<c&&(f+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+i+";\n                  if(xCOffset >= 0 && xCOffset < "+n+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+d+"C"+(v+1)+" = vec4(xTexelR"+d+"C"+(v+2)+".xy, final.xy);\n                ")):(f+="\n                if(xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".xy, xTexelR"+d+"C"+(v+2)+".xy);\n              ",v+1<c&&(f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n                ")),f+="}");v<c&&(f+="\n            vec4 wTexelR"+d+"C"+v+" = getW("+d+", "+v+", d1, q);\n            wR"+d+"C"+v+" = vec4(wTexelR"+d+"C"+v+".xz, wTexelR"+d+"C"+v+".xz);\n          ",v+1<c&&(f+="\n              vec4 wTexelR"+d+"C"+(v+1)+" = getW("+d+", "+(v+1)+", d1, q);\n              wR"+d+"C"+(v+1)+" =\n                vec4(wTexelR"+d+"C"+(v+1)+".xz, wTexelR"+d+"C"+(v+1)+".xz);"))}for(d=0;d<l;d++)for(v=0;v<c;v++)f+="result += xR"+d+"C"+v+" * wR"+d+"C"+v+";";this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 result = vec4(0.);\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),Qo=function(){return function(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=t[0],i=t[1],s=t[2],u=t[3],l=e[0],c=n[0],h=n[1];this.outputShape=[l,c,h,u];var p="bilinear"===r?1:0,f=[i-1+".0",s-1+".0"],d=f[0],v=f[1],m=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio","y1*"+d+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+d],g=m[0],y=m[1],x=m[2],w=h>1?[""+(s-1)/(h-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],b=w[0],C=w[1],E=w[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+b+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+C+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+d+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+E+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+p+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "}}(),Jo=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=t;var r=t.length,o=t[t.length-1],a=n?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(n?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+bo(r)+" coords = getOutputCoords();\n        int end = "+Zo(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+Zo(r,"coords")+" = idx;\n          val += getX("+function(t,e){if(1===t)return""+e;if(2===t)return e+".x, "+e+".y";if(3===t)return e+".x, "+e+".y, "+e+".z";if(4===t)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}}();function Zo(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}var ta=function(){function t(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),ea=function(){return function(t){this.variableNames=["A"];var e=uo();this.outputShape=t,this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isnan(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+e.output+" = encode_float(x);\n      }\n    "}}(),na="return real * expR - imag * expI;",ra="return real * expI + imag * expR;",oa=function(){return function(t,e,n){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+t+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),aa=function(){function t(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.valueLoc&&(e.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(e.valueLoc,t)}},t}(),ia=function(){return function(t){this.variableNames=["A"];var e=uo(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+e.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),sa=function(){return function(t,e,n){this.variableNames=["A","indices"];var r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;var o=bo(this.rank),a=function(t,e){var n=t.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<t.length;a++)a===e?o.push("int(getIndices("+r[a]+"))"):o.push(""+r[a]);return o.join()}(t,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var ua,la,ca=function(){return function(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;var r=bo(e.length),o=bo(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}();function ha(t,e){return[e,t]}function pa(t,e){return t*e}function fa(t,e,n){var r=function(t,e){if(t%e!=0)throw new Error("unpackedSize ("+t+") must be a multiple of "+e);return t/e}(t.length,n);if(e.length<r)throw new Error("matrix length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;a+=n)e[o++]=t[a]}function da(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function va(t,e){var n=da(t,e);return n[0]*n[1]*4}function ma(t,e,n,r,o){var a=n*r;if(o.length<a)throw new Error("matrix length ("+o.length+") must be >= "+a);for(var i=r%2==1,s=n%2==1,u=Math.floor(r/2),l=Math.floor(n/2),c=Math.ceil(r/2),h=c*Math.ceil(n/2),f=p(n)*p(r),d=0;d<e;d++){for(var v=d*n*r,m=d*f,g=i?4:0,y=r+(i?1:0),x=m,w=v,b=v+r,C=0;C<l;++C){for(var E=0;E<u;++E)o[w++]=t[x++],o[w++]=t[x++],o[b++]=t[x++],o[b++]=t[x++];x+=g,w+=y,b+=y}if(i){x=m+4*(c-1);var R=v+r-1;for(g=4*c,y=2*r,C=0;C<l;++C)o[R]=t[x],o[R+r]=t[x+2],x+=g,R+=y}if(s){for(x=m+4*(h-c),R=v+(n-1)*r,E=0;E<u;++E)o[R++]=t[x++],o[R++]=t[x++],x+=2;i&&(o[v+n*r-1]=t[x])}}return o}function ga(t,e){var n=uo();return Vt(t,e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function ya(t,e){return Yt(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function xa(t,e){return Qt(t,e,new Uint16Array([0,1,2,2,1,3]))}function wa(t,e){var n,r,o,i,s,u,l,c,h=t;return 2===a.getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,o=h.RGBA16F,i=h.RGBA32F,s=h.RED,u=4,l=1,c=h.HALF_FLOAT):(n=t.RGBA,r=t.RGBA,o=t.RGBA,i=h.RGBA,s=t.RGBA,u=4,l=4,c=null!=e?e.HALF_FLOAT_OES:null),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:t.RGBA,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:c}}function ba(t,e,n,r,o,a,i){te(n,r);var s=Zt(t,e),u=t.TEXTURE_2D;return Bt(t,e,function(){return t.bindTexture(u,s)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texImage2D(u,0,o,n,r,0,a,i,null)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)}),s}function Ca(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatFloat,o.textureFormatFloat,t.FLOAT)}function Ea(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatHalfFloat,o.textureFormatFloat,o.textureTypeHalfFloat)}function Ra(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}function Sa(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedFloat,t.RGBA,t.FLOAT)}function Na(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedHalfFloat,t.RGBA,o.textureTypeHalfFloat)}function ka(t,e,n,r){return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),ne(t,e,n,"clipSpacePos",r,3,20,0)&&ne(t,e,n,"uv",r,2,20,12)}function Ia(t,e,n,r){Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Aa(t,e,n,r,o,a,i){te(r,o),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texSubImage2D(t.TEXTURE_2D,0,0,0,r,o,i,t.FLOAT,a)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Ta(t,e,n,r,o,a,i,s){var u,l=ha(r,o),c=l[0],h=l[1],p=r*o;1===s.defaultNumChannels&&p===a.length?u=a:function(t,e,n){var r=pa(t.length,n);if(e.length<r)throw new Error("unpackedArray length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;++a)e[o]=t[a],o+=n}(a,u=new Float32Array(p*i),i),Aa(t,e,n,c,h,u,s.textureFormatFloat)}function Da(t,e,n,r,o,a,i,s,u,l){var c=da(i,s),h=c[0],f=c[1],d=new Float32Array(va(i,s));!function(t,e,n,r,o){for(var a=r%2==1,i=n%2==1,s=Math.floor(r/2),u=Math.floor(n/2),l=Math.ceil(r/2),c=l*Math.ceil(n/2),h=p(n)*p(r),f=0;f<e;f++){for(var d=f*n*r,v=f*h,m=a?4:0,g=r,y=v,x=0;x<u;++x){for(var w=2*x*r,b=0;b<s;++b){var C=d+w+2*b;o[y]=t[C],o[y+1]=t[C+1],o[y+2]=t[C+g],o[y+3]=t[C+g+1],y+=4}y+=m}if(a){C=d+r-1,y=v+4*(l-1);var E=2*r;for(m=4*l,x=0;x<u;++x)o[y]=t[C],o[y+2]=t[C+r],C+=E,y+=m}if(i){for(C=d+(n-1)*r,y=v+4*(c-l),b=0;b<s;++b)o[y++]=t[C++],o[y++]=t[C++],y+=2;a&&i&&(o[v+h-4]=t[C])}}}(u,r,o,a,d),Aa(t,e,n,h,f,d,t.RGBA)}function Oa(t,e,n,r,o){var a=t.createBuffer();Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,a)});var i=4*pa(n*r,o.downloadUnpackNumChannels);return Bt(t,e,function(){return t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)}),Bt(t,e,function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)}),Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,null)}),a}function _a(t,e,n,r,o){var a=t,i=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));a.bindBuffer(a.PIXEL_PACK_BUFFER,e),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,i),a.bindBuffer(a.PIXEL_PACK_BUFFER,null);var s=new Float32Array(n*r);return fa(i,s,o.downloadUnpackNumChannels),s}function Ma(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.FLOAT,u)});var l=new Float32Array(n*r);return fa(u,l,o.downloadUnpackNumChannels),l}function Fa(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Uint8Array(pa(n*r,4));return Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.UNSIGNED_BYTE,u)}),new Float32Array(u.buffer)}function Ba(t,e,n,r,o,a,i,s){var u=t,l=new Float32Array(va(a,i));u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null);var c=new Float32Array(y([n,r,o]));return ma(l,n,r,o,c),c}function Pa(t,e,n,r,o,a,i,s){var u=da(a,i),l=u[0],c=u[1],h=new Float32Array(va(a,i));Bt(t,e,function(){return t.readPixels(0,0,l,c,t.RGBA,t.FLOAT,h)});var p=new Float32Array(y([n,r,o]));return ma(h,n,r,o,p)}!function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(ua||(ua={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(la||(la={}));var La=Object.freeze({createVertexShader:ga,createVertexBuffer:ya,createIndexBuffer:xa,getTextureConfig:wa,createFloat32MatrixTexture:Ca,createFloat16MatrixTexture:Ea,createUnsignedBytesMatrixTexture:Ra,createPackedMatrixTexture:Sa,createFloat16PackedMatrixTexture:Na,bindVertexProgramAttributeStreams:ka,uploadPixelDataToTexture:Ia,uploadMatrixToTexture:Ta,uploadMatrixToPackedTexture:Da,createBufferFromOutputTexture:Oa,downloadFloat32MatrixFromBuffer:_a,downloadFloat32MatrixFromOutputTexture:Ma,downloadByteEncodedFloatMatrixFromOutputTexture:Fa,downloadPackedMatrixFromBuffer:Ba,downloadMatrixFromPackedOutputTexture:Pa}),Wa=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=a.getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){_t[t]=e}(e,t)):this.gl=Ft(e),1===a.getNumber("WEBGL_VERSION")?(this.textureFloatExtension=zt(this.gl,this.debug,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||(this.textureHalfFloatExtension=zt(this.gl,this.debug,"OES_texture_half_float"),this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float"))):this.colorBufferFloatExtension=zt(this.gl,this.debug,"EXT_color_buffer_float"),this.vertexBuffer=ya(this.gl,this.debug),this.indexBuffer=xa(this.gl,this.debug),this.framebuffer=ee(this.gl,this.debug),this.textureConfig=wa(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return a.getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;Bt(e,this.debug,function(){return e.finish()}),Bt(e,this.debug,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),Bt(e,this.debug,function(){return e.deleteFramebuffer(t.framebuffer)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.deleteBuffer(t.indexBuffer)}),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),Ca(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Ea(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Ra(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),Ia(this.gl,this.debug,t,e)},t.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Na(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Sa(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(ue(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Bt(this.gl,this.debug,function(){return e.gl.deleteTexture(t)})},t.prototype.uploadMatrixToTexture=function(t,e,n,r){this.throwIfDisposed();var o=Jt();return Ta(this.gl,this.debug,t,e,n,r,o,this.textureConfig)},t.prototype.uploadMatrixToPackedTexture=function(t,e,n,r,o,a,i){return this.throwIfDisposed(),Da(this.gl,this.debug,t,e,n,r,o,a,i,this.textureConfig)},t.prototype.downloadFloat32MatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Ma(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Fa(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadPackedMatrixFromBuffer=function(t,e,n,r,o,a){return Ba(this.gl,t,e,n,r,o,a,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(t,e,n){return _a(this.gl,t,e,n,this.textureConfig)},t.prototype.createBufferFromTexture=function(t,e,n){this.bindTextureToFrameBuffer(t);var r=Oa(this.gl,this.debug,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(t){var e,n,r=this;if(a.getBool("WEBGL_FENCE_API_ENABLED")){var o=t,i=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=function(){var t=o.clientWaitSync(i,0,0);return t===o.ALREADY_SIGNALED||t===o.CONDITION_SATISFIED},e=i}else a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(e,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):n=function(){return!0};return{query:e,isFencePassed:n}},t.prototype.downloadMatrixFromPackedTexture=function(t,e,n,r,o,a){var i=this;return this.downloadMatrixDriver(t,function(){return Pa(i.gl,i.debug,e,n,r,o,a,i.textureConfig)})},t.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,n=Gt(e,this.debug,t),r=ga(e,this.debug),o=jt(e,this.debug);return Bt(e,this.debug,function(){return e.attachShader(o,r)}),Bt(e,this.debug,function(){return e.attachShader(o,n)}),Kt(e,this.debug,o),this.debug&&Xt(e,this.debug,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=ka(e,this.debug,this.program,this.vertexBuffer)),o},t.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Bt(this.gl,this.debug,function(){return e.gl.deleteProgram(t)})},t.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Xt(this.gl,this.debug,this.program),Bt(this.gl,this.debug,function(){return e.gl.useProgram(t)})},t.prototype.getUniformLocation=function(t,e,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?oe(this.gl,this.debug,t,e):ae(this.gl,t,e)},t.prototype.getAttributeLocation=function(t,e){var n=this;return this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return n.gl.getAttribLocation(t,e)})},t.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},t.prototype.setInputMatrixTexture=function(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),ie(this.gl,this.debug,this.program,t,e,n)},t.prototype.setOutputMatrixTexture=function(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)},t.prototype.setOutputPackedMatrixTexture=function(t,e,n){this.throwIfDisposed();var r=da(e,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(t,o,a)},t.prototype.setOutputMatrixWriteRegion=function(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&Xt(this.gl,this.debug,this.program),le(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),Bt(t,this.debug,function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return t.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=zt(this.gl,this.debug,2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},t.prototype.endQuery=function(){if(2!==a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){switch(n.label){case 0:return[4,R(function(){return e.disposed||e.isQueryAvailable(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return n.sent(),[2,this.getQueryTime(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},t.prototype.getQueryTime=function(t,e){if(0===e)return null;if(2===e){var n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(t,e){if(0===e)return!0;if(2===e){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},t.prototype.pollFence=function(t){var e=this;return new Promise(function(n){e.addItemToPoll(function(){return t.isFencePassed()},function(){return n()})})},t.prototype.pollItems=function(){for(var t=function(t){for(var e=0;e<t.length;++e){var n=t[e]();if(!n)break}return e-1}(this.itemsToPoll.map(function(t){return t.isDoneFn})),e=0;e<=t;++e){(0,this.itemsToPoll[e].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(t+1)},t.prototype.addItemToPoll=function(t,e){var n=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||R(function(){return n.pollItems(),0===n.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),se(this.gl,this.debug,t,this.framebuffer),this.debug&&le(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(se(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&le(this.gl)):ue(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var n=e();return this.unbindTextureToFrameBuffer(),n},t.prototype.setOutputMatrixTextureDriver=function(t,e,n){this.throwIfDisposed();var r=this.gl;se(r,this.debug,t,this.framebuffer),this.debug&&le(r),this.outputTexture=t,Bt(r,this.debug,function(){return r.viewport(0,0,e,n)}),Bt(r,this.debug,function(){return r.scissor(0,0,e,n)})},t.prototype.setOutputMatrixWriteRegionDriver=function(t,e,n,r){var o=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return o.gl.scissor(t,e,n,r)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}();function Ua(t,e){if(t.length!==e.length)throw Error("Binary was compiled with "+t.length+" inputs, but was executed with "+e.length+" inputs");t.forEach(function(t,n){var r=t.logicalShape,o=e[n],a=o.shape;if(!x(r,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+a+" must match");if(!t.isUniform||!o.isUniform){var i=t.texShape,s=o.isUniform?null:o.texData.texShape;if(!x(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}})}var za=function(){return function(t,e,n){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,l=n.dilationWidth,c=n.dilationHeight,h=s.left,p=s.top,f=o*r,d=uo();this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= "+t[1]+" || pos >= "+t[0]+") continue;\n\n            int offsetY = int(blockIndex / ("+u+")) * "+i+" - "+p+";\n            int d0 = offsetY + "+c+" * (pos / "+f+");\n\n            if(d0 >= "+e[0]+" || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+h+".);\n            int d1 = offsetX + "+l+" * (int(mod(float(pos), "+f+".) / "+o+".));\n\n            if(d1 >= "+e[1]+" || d1 < 0) continue;\n\n            vec2 innerDims = vec2(d1, int(mod(float(pos), "+o+".)));\n            result[row * 2 + col] = getChannel(getA(d0, int(innerDims.x),\n                                              int(innerDims.y)), innerDims);\n          }\n        }\n\n        "+d.output+" = result;\n      }\n    "}}(),Va=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "}}(),Ga=function(){return function(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),qa=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.usesPackedTextures=!0;var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+i+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+i+"; j <= "+i+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+s+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+a+";\n        setOutput(result);\n      }\n    "}}(),Ha=function(){return function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,s=a-1-t.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$a=function(){return function(t,e,n,r,o,a){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===a&&(a=null),this.variableNames=["matrixA","matrixB"],this.usesPackedTextures=!0,this.outputShape=e;var i=n?t[1]:t[2],s=Math.ceil(i/2),u=n?"i * 2, rc.y":"rc.y, i * 2",l=r?"rc.z, i * 2":"i * 2, rc.z",c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],p="",f="";a&&(p="vec4 activation(vec4 x) {\n        "+a+"\n      }",f="result = activation(result);");var d=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),this.userCode="\n      "+p+"\n\n      const float sharedDimension = "+s+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+s+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+u+");\n          vec4 b = getMatrixB(rc.x, "+l+");\n\n          result += ("+c[0]+" * "+h[0]+") + ("+c[1]+" * "+h[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+d+"\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),ja=function(){function t(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.seedLoc&&(e.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(e.seedLoc,t)}},t}(),Ka=function(){return function(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "}}(),Xa=function(){return function(t){this.variableNames=["A"],this.isPackShader=!0,this.outputShape=t;var e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=oo("rc",e),r=bo(e),o=function(t,e,n){if(1===t)return"rc > "+e[0];for(var r="",o=t-2;o<t;o++)r+=n[o]+" >= "+e[o],o<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+n+";\n  "}(e,t[t.length-1],t[t.length-2],n),i=function(t,e){var n=t.length,r=function(t,e){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<t;i++)a=e[e.length-1-i]+","+a;n.push(a)}return n}(n,e);return 1===n?"getA(rc),\n            rc + 1 >= "+t[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(t,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+a+"\n\n            setOutput(vec4("+i+"));\n          }\n        }\n      "}}}();var Ya=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "}}(),Qa=function(){return function(t,e,n){this.variableNames=["x"],this.usesPackedTextures=!0,this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});for(var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=oo("rc",r),u=oo("source",r),l=s[r-1]+" < "+this.outputShape[r-1],c=1===r?"source":"vec2("+u.slice(-2).join()+")",h=[o+" rc = outputLoc;",s[r-1]+" += 1;\n       if("+l+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+s[r-2]+" += 1;\n       if("+s[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+s[r-1]+" += 1;\n         if("+l+") {"],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="",d=0,v=1===r?2:4;d<v;d++)f+="\n        "+h[d]+"\n        if ("+p+") {\n          result["+d+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+d+"] = getChannel(getX("+u.join()+"), "+c+");\n        }\n      ";f+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+a+");\n      const "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+f+"\n        setOutput(result);\n      }\n    "}}(),Ja=function(){return function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;var p="avg"===e,f="0.0";if(p||(f="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+c+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+l+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var d=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(d="avgValue / count");var v=4*Math.floor(r/4),m=r%4,g="\n      if ("+p+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+c+", "+h+");\n      const float initializationValue = "+f+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+f+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+v+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+v+";\n          if ("+(1===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+d+");\n      }\n    "}}}(),Za=function(){return function(t,e){this.variableNames=["x"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i="0.0",s="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",s="min"):"max"===e&&(i="-1.0 / 1e-20",s="max");var u=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");var l=4*Math.floor(n/4),c=n%4,h="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",p="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");var f="";o%n>0&&(f="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+f+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+l+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+h+"\n        }\n\n        int inIdx = inOffset + "+l+";\n        if ("+(1===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(2===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(3===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+h+"\n        }\n        setOutput("+u+");\n      }\n    "}}(),ti=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+lo(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+function(t){return"\n    int getFlatIndex(ivec3 coords) {\n      return round("+function(t,e){if(t.length!==e.length)throw new Error("Vectors to be dotted must be of the same length -got "+t.length+" and "+e.length);for(var n=[],r=Math.floor(t.length/4),o=t.length%4,a=0;a<r;a++){var i=t.slice(4*a,4*a+4),s=e.slice(4*a,4*a+4);n.push(co(i)+", "+co(s))}return 0!==o&&(i=t.slice(4*r),s=e.slice(4*r),1===i.length&&(i=i.map(function(t){return"float("+t+")"}),s=s.map(function(t){return"float("+t+")"})),n.push(co(i)+", "+co(s))),n.map(function(t,e){return"dot("+t+")"}).join("+")}(["coords.x","coords.y","coords.z"],V(t).map(function(t){return t.toString()}).concat(["1."]))+");\n    }\n  "}(t)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+t[1]+";\n        int cols = "+t[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "}}();var ei=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ni=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),ri=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+",\n          "+u[1]/l[1]+");\n      const vec3 inputShapeRC = vec3("+a+".0, "+i+".0,\n                                     "+i+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n        \n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(s-1)+"; \n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "}}(),oi=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+l[0]+") *\n                (float(dyR) / float("+c[0]+"));\n\n            float sourceFracCol =\n                float("+l[1]+") *\n                  (float(dyC) / float("+c[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ai=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+c+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),ii=function(){return function(t,e){this.variableNames=["x"];var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=t,1!==n){var r=t.map(function(n,r){return function(n){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)}).join(","),o=bo(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      "}}(),si=function(){return function(t,e){this.variableNames=["x"],this.usesPackedTextures=!0;var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t;var r=oo("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],a=r[n-2]+" + 1 < "+this.outputShape[n-2],i=bo(n);function s(n){var r=t.map(function(r,o){return function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)});return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+t[0]+" - rc - 1),\n            "+t[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+t[0]+" - (rc  + 1) - 1),\n                "+t[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+i+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(t){return s(t)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",s(t)}(r.slice())+";\n          }\n          if("+a+") {\n            result.b = "+function(t){return t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "}}(),ui=function(){return function(t,e,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=bo(o.length),u=bo(a.length),l="";1===n?l="i":2===n&&(l="i, j");var c="getIndices("+l+")",h="";1===r?h="i":2===r&&(h="i, coords[1]");var p="getUpdates("+h+")",f=e>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+t+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+c+");\n              flattenedIndex += index * "+f+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+p+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}}(),li=function(){return function(t,e){this.variableNames=["x","segmentIds"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ",c="";o%n>0&&(c="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+c+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+h+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+l+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+l+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+l+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+l+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),ci=function(){return function(t,e,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<e.length;u++)s.push(""+a[u]),u<t&&i.push(""+a[u]);r=i.join(),o=s.join()}var l=bo(n);this.userCode="\n      void main() {\n        "+l+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "}}(),hi=function(){function t(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,n=bo(this.rank),r="uniform int start["+this.rank+"];",o=function(t){if(1===t)return"sourceLoc";if(t<=6)return pi.slice(0,t).map(function(t){return"sourceLoc."+t}).join(",");throw Error("Slicing for rank "+t+" is not yet supported")}(this.rank);e="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+t.map(function(t,e){return"sourceLoc."+pi[e]+" = start["+e+"] + coords."+pi[e]+";"}).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+e+"\n        setOutput(getSource("+o+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),pi=["x","y","z","w","u","v"];var fi=function(){function t(t){this.variableNames=["source"],this.usesPackedTextures=!0,this.outputShape=t,this.rank=t.length;var e=bo(this.rank),n=oo("coords",this.rank),r=oo("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+o+")",i="\n      result.x = "+a+";\n      if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",s=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+t[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",u=this.rank<=4?"sourceLoc = coords +\n            "+e+"("+t.map(function(t,e){return"start["+e+"]"}).join()+");":t.map(function(t,e){return r[e]+" = "+n[e]+" + start["+e+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+e+" coords = getOutputCoords();\n        "+e+" sourceLoc;\n        "+u+" \n        vec4 result = vec4(0.);\n        "+i+"\n        "+s+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),di=function(){return function(t,e,n,r){this.variableNames=["x"];var o=n.filter(function(t,e){return-1===r.indexOf(e)});this.outputShape=o;var a=n.length,i=bo(n.length),s=bo(o.length),u="";if(1===a)u="coords * strides + begin";else{var l=0;u=n.map(function(t,e){return-1===r.indexOf(e)?(l++,1===o.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(l-1)+"] * strides["+e+"] + begin["+e+"]"):"begin["+e+"]"}).join(",")}this.userCode="\n      "+i+" begin = "+i+"("+t+");\n      "+i+" strides = "+i+"("+e+");\n\n      void main() {\n        "+s+" coords = getOutputCoords();\n        setOutput(getX("+u+"));\n      }\n    "}}(),vi=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(t,e,n){var r,o=mi(e,n),a=gi(t,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===la.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===la.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===la.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(r),r},t.prototype.releaseTexture=function(t,e,n,r){if(null!=this.freeTextures){var o=gi(e,mi(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(t),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var t=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function mi(t,e){if(t===ua.UPLOAD)return e?la.PACKED_2X2_FLOAT32:la.UNPACKED_FLOAT32;if(t===ua.RENDER||null==t)return e?a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.PACKED_2X2_FLOAT32:la.PACKED_2X2_FLOAT16:a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.UNPACKED_FLOAT32:la.UNPACKED_FLOAT16;if(t===ua.DOWNLOAD||t===ua.PIXELS)return la.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function gi(t,e,n){return t[0]+"_"+t[1]+"_"+e+"_"+n}var yi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+t[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<t.length;o++)r.push("imod("+n[o]+", "+t[o]+")");return r.join()}(t);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var xi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e),o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}(e);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "}}();var wi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0;for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=bo(this.rank),a=ro("rc",this.rank),i=new Array(this.rank);for(r=0;r<e.length;r++)i[e[r]]=a[r];var s="vec2("+i.slice(-2).join()+")",u="++"+a[this.rank-1]+" < "+n[this.rank-1],l="getChannel(getA("+i.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+l+";\n      if("+u+") {\n        result[1] = "+l+";\n      }\n      --"+a[this.rank-1]+";\n      if(++"+a[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+l+";\n        if("+u+") {\n          result[3] = "+l+";\n        }\n      }  \n      setOutput(result);\n    }\n    "}}(),bi=1.7580993408473768,Ci=1.0507009873554805,Ei=function(){return function(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Ri="if (isnan(x)) return x;",Si="return x;",Ni=Ri+"\n  return (x < 0.0) ? 0.0 : x;\n",ki="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+bi+";\n  float scale = "+Ci+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var Ii="return exp(x);",Ai=Ri+"\n  return sin(x);\n",Ti=Ri+"\n  return cos(x);\n",Di=Ri+"\n  return atan(x);\n",Oi=Ri+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",_i=Ri+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",Mi="return x;",Fi="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Bi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Pi=function(){return function(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var e=t.length,n=oo("rc",e),r=bo(e),o=function(t,e){if(1===t)return"rc";for(var n="",r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),i=e<=1?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "}}(),Li={};var Wi=600;var Ui=function(){function t(t){if(this.gpgpu=t,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.disposed=!1,!a.getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){var e=Ft(a.getNumber("WEBGL_VERSION"));this.binaryCache=(n=a.getNumber("WEBGL_VERSION"))in Li?Li[n]:(Li[n]={},Li[n]),this.gpgpu=new Wa(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var n;this.textureManager=new vi(this.gpgpu),this.numMBBeforeWarning=null==a.global.screen?1024:a.global.screen.height*a.global.screen.width*window.devicePixelRatio*Wi/1024/1024,this.texData=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.texData.has(t))throw new Error("Data buffer is already registered");this.texData.set(t,{shape:e,dtype:n})},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n=[t.height,t.width],r=[t.height,t.width,e];if(a.getBool("IS_BROWSER")){if(!(t instanceof HTMLVideoElement||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(t instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if("complete"!==document.readyState)throw new Error("The DOM is not ready yet. Please call tf.browser.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object");this.fromPixels2DContext=document.createElement("canvas").getContext("2d")}this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),t=this.fromPixels2DContext.canvas}}var o=this.makeTensorHandle(n,"int32");this.texData.get(o.dataId).usage=ua.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId),t);var i=new ia(r),s=this.compileAndRun(i,[o]);return this.disposeData(o.dataId),s},t.prototype.makeTensorHandle=function(t,e){var n={};return this.register(n,t,e),{dataId:n,shape:t,dtype:e}},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendWebGL.write(): values can not be null");if(a.getBool("DEBUG"))for(var n=0;n<e.length;n++){var r=e[n];if(!Wt(r))throw Error("The value "+r+" cannot be represented on this device.")}var o=this.texData.get(t);if("complex64"===o.dtype)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.releaseGPUData(t),o.usage=ua.UPLOAD,o.values=e},t.prototype.readSync=function(t){var e=this.texData.get(t),n=e.values,r=e.dtype,o=e.complexTensors,a=e.slice,i=e.shape;if(null!=a){var s=new Ei(i,"return x;"),u=this.compileAndRun(s,[{dataId:t,shape:i,dtype:r}]),l=this.readSync(u.dataId);return u.dispose(),l}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;var c,h,p=null!=this.activeTimers;(p&&(c=performance.now()),"complex64"===r)?h=er(o.real.dataSync(),o.imag.dataSync()):h=this.getValuesFromTexture(t);return p&&(this.downloadWaitMs+=performance.now()-c),this.convertAndCacheOnCPU(t,h)},t.prototype.read=function(t){return r(this,void 0,void 0,function(){var e,n,r,i,s,u,l,c,h,p,f,d,v,m,g,x,w,b,C,E,R,S,N,k,I,A,T,D;return o(this,function(o){switch(o.label){case 0:if(this.pendingRead.has(t))return r=this.pendingRead.get(t),[2,new Promise(function(t){return r.push(t)})];if(i=this.texData.get(t),s=i.texture,u=i.values,l=i.texShape,c=i.isPacked,h=i.shape,p=i.slice,f=i.dtype,d=i.complexTensors,null!=p)return v=new Ei(h,"return x;"),m=this.compileAndRun(v,[{dataId:t,shape:h,dtype:f}]),g=this.read(m.dataId),m.dispose(),[2,g];if(null!=u)return[2,this.convertAndCacheOnCPU(t)];if(this.pendingRead.set(t,[]),!a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===a.getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return x=null,"complex64"===f?[3,2]:(w=l[1],b=l[0],c&&(e=da(l[0],l[1]),w=e[0],b=e[1]),a.get("WEBGL_BUFFER_SUPPORTED")&&(x=this.gpgpu.createBufferFromTexture(s,b,w)),[4,this.gpgpu.createAndWaitForFence()]);case 1:o.sent(),o.label=2;case 2:return"complex64"!==f?[3,4]:[4,Promise.all([d.real.data(),d.imag.data()])];case 3:return E=o.sent(),R=E[0],S=E[1],C=er(R,S),[3,5];case 4:null==x?C=this.getValuesFromTexture(t):(N=y(h),c?(k=fe(h),I=1,A=1,h.length&&(n=de(h),I=n[0],A=n[1]),C=this.gpgpu.downloadPackedMatrixFromBuffer(x,k,I,A,l[0],l[1]).subarray(0,N)):C=this.gpgpu.downloadFloat32MatrixFromBuffer(x,l[0],l[1]).subarray(0,N)),o.label=5;case 5:return T=this.convertAndCacheOnCPU(t,C),D=this.pendingRead.get(t),this.pendingRead.delete(t),D.forEach(function(t){return t(T)}),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)),[2,T]}})})},t.prototype.getValuesFromTexture=function(t){var e,n=this,r=this.texData.get(t),o=r.shape,i=r.dtype,s=r.texture,u=r.texShape,l=y(o);if(a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(t).isPacked){var c=fe(o),h=1,p=1;return o.length&&(h=(e=de(o))[0],p=e[1]),this.gpgpu.downloadMatrixFromPackedTexture(s,c,h,p,u[0],u[1]).subarray(0,l)}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(s,u[0],u[1]).subarray(0,l)}var f=this.makeTensorHandle(o,"float32");f.size=y(o),this.texData.get(f.dataId).usage=ua.DOWNLOAD;var d=Fe(function(){var e=new ea(o);return n.compileAndRun(e,[{shape:o,dtype:i,dataId:t}],f,null)}),v=this.texData.get(d.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture,v.texShape[0],v.texShape[1]).subarray(0,l);return this.disposeData(f.dataId),m},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return e=this.activeTimers,n=[],r=!1,null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t(),a=g(this.activeTimers.map(function(t){return t.query})).filter(function(t){return null!=t}),i=g(this.activeTimers.map(function(t){return t.name})).filter(function(t){return null!=t}),this.activeTimers=e,r&&(this.programTimersStack=null),[4,Promise.all(a)];case 1:return s=o.sent(),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:f(s),getExtraProfileInfo:function(){return s.map(function(t,e){return{name:i[e],ms:t}}).map(function(t){return t.name+": "+t.ms}).join(", ")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}})})},t.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},t.prototype.startTimer=function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},t.prototype.endTimer=function(t){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(this.gpgpu.endQuery(),t):(t.endMs=performance.now(),t)},t.prototype.getQueryTime=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?[2,this.gpgpu.waitForQueryAndGetTime(t)]:[2,(e=t).endMs-e.startMs]})})},t.prototype.disposeData=function(t){if(!this.pendingDisposal.has(t))if(this.pendingRead.has(t))this.pendingDisposal.add(t);else if(this.texData.has(t)){this.releaseGPUData(t);var e=this.texData.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}},t.prototype.releaseGPUData=function(t){var e=this.texData.get(t),n=e.texture,r=e.dtype,o=e.texShape,a=e.usage,i=e.isPacked,s=e.slice,u=s&&s.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,a,i)));var c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null},t.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},t.prototype.getCPUBackend=function(){return a.getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Dt.findBackend("cpu")),this.cpuBackend):null},t.prototype.shouldExecuteOnCPU=function(t,e){var n=this;return void 0===e&&(e=128),null!=this.getCPUBackend()&&t.every(function(t){return null==n.texData.get(t.dataId).texture&&t.size<e})},t.prototype.getGPGPUContext=function(){return this.gpgpu},t.prototype.getCanvas=function(){return this.canvas},t.prototype.complex=function(t,e){var n=this.makeOutputArray(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},t.prototype.slice=function(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);var r=this.texData.get(t.dataId).isPacked,o=mn(t.shape,e,n);if(r||!o){var i=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fi(n):new hi(n),s=i.getCustomSetupFunc(e);return this.compileAndRun(i,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)},t.prototype.shallowSlice=function(t,e,n){var r=this.texData.get(t.dataId),o=ft.make(n,{},t.dtype,this),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;var i=gn(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),o},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r,o,a,i,s,u);var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);var d=new di(c,r,h,p);return this.compileAndRun(d,[t])},t.prototype.reverse=function(t,e){var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new si(t.shape,e):new ii(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.concat=function(t,e){if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>a.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),o=this.concat(t.slice(n),e);return this.concat([r,o],e)}if(a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){var i=new Uo(t.map(function(t){return t.shape}),e);return this.compileAndRun(i,t)}var s=sn(t.map(function(t){return t.shape}),e),u=t.map(function(t){return t.as2D(-1,y(t.shape.slice(e)))}),l=new Wo(u.map(function(t){return t.shape}));return this.compileAndRun(l,u).reshape(s)},t.prototype.neg=function(t){var e=new Ei(t.shape,"return -x;");return this.compileAndRun(e,[t])},t.prototype.batchMatMul=function(t,e,n,r){var o=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],s=t.shape[0];if((1===o||1===a)&&i>1e3){n&&(t=t.transpose([0,2,1])),r&&(e=e.transpose([0,2,1]));var u=1===a?t:t.as3D(s,i,1),l=1===a?2:1,c=1===a?e.as3D(s,1,i):e;return this.multiply(u,c).sum(l,!0)}var h=Ct(t.dtype,e.dtype),p=new $a(t.shape,[s,o,a],n,r),f=this.makePackedTensor(p.outputShape,h);return this.compileAndRun(p,[t,e],f)},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=n?t.shape[2]:t.shape[1],s=r?e.shape[1]:e.shape[2],u=t.shape[0],l=Ct(t.dtype,e.dtype),c=new $a(t.shape,[u,i,s],n,r,!!o,a?function(t,e){if(void 0===e&&(e=!1),"linear"===t)return e?Mi:Si;if("relu"===t)return e?Fi:Ni;throw new Error("Activation "+t+" has not been implemented for the WebGL backend.")}(a,!0):null),h=this.makePackedTensor(c.outputShape,l),p=[t,e];return o&&p.push(o),this.compileAndRun(c,p,h)},t.prototype.multiply=function(t,e){if("complex64"===t.dtype){var n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),o=new To(Io,t.shape,e.shape),i=new To(Ao,t.shape,e.shape),s=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag),this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag)],u=this.compileAndRun(o,s),l=this.compileAndRun(i,s),c=this.complex(u,l);return u.dispose(),l.dispose(),c}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,_o,t.dtype);var h=new Mo(_o,t.shape,e.shape),p=this.makeOutputArray(h.outputShape,t.dtype);return this.compileAndRun(h,[t,e],p)},t.prototype.batchNormalization=function(t,e,n,r,o,i){var s=[t,e,n],u=null;null!=i&&(u=i.shape,s.push(i));var l=null;if(null!=o&&(l=o.shape,s.push(o)),a.getBool("WEBGL_PACK_NORMALIZATION")){var c=new ko(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(c,s)}var h=new No(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(h,s)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){var i=a.getBool("WEBGL_PACK_NORMALIZATION")?new qa(t.shape,e,n,r,o):new Va(t.shape,e,n,r,o);return this.compileAndRun(i,[t])},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){var s=new Ga(e.shape,r,o,a,i);return this.compileAndRun(s,[e,n,t])},t.prototype.tile=function(t,e){var n=new yi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.pad=function(t,e,n){var r=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qa(t.shape,e,n):new Ya(t.shape,e,n);return this.compileAndRun(r,[t])},t.prototype.transpose=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.transpose(t,e);var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wi(t.shape,e):new xi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.gather=function(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);var r=new sa(t.shape,e.size,n);return this.compileAndRun(r,[t,e])},t.prototype.batchToSpaceND=function(t,e,n){d(t.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){d(t.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.reduce=function(t,e,n){var r=t.shape[0],o=t.shape[1],a=cn(o),i=new Za({windowSize:a,inSize:o,batchSize:r},e),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],n);return this.compileAndRun(i,[t],c),1===c.shape[1]?c:this.reduce(c,e,n)},t.prototype.argReduce=function(t,e,n){void 0===n&&(n=null);var r=t.shape[0],o=t.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=cn(o),i=new no({windowSize:a,inSize:o,batchSize:r},e,null==n),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],"int32"),h=[t];return null!=n&&h.push(n),this.compileAndRun(i,h,c),1===c.shape[1]?c:this.argReduce(t,e,c)},t.prototype.argReducePacked=function(t,e,n){void 0===n&&(n=null);var r=null!=n?n.shape:t.shape,o=cn(r[r.length-1]),a=new Ro(r,o,e,null==n),i=this.makePackedTensor(a.outputShape,"int32"),s=null==n?[t]:[t,n];return this.compileAndRun(a,s,i),i.rank===t.rank?this.argReducePacked(t,e,i):i},t.prototype.sum=function(t,e){nn("sum",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"sum",i).reshape(r)},t.prototype.prod=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"prod",i).reshape(r)},t.prototype.unsortedSegmentSum=function(t,e,n){var r=0,o=rn([r],t.rank),a=t;null!=o&&(a=t.transpose(o),r=an(1,t.rank)[0]);var i=function(t,e,n){for(var r=[],o=t.length,a=0;a<o;a++)a!==e?r.push(t[a]):r.push(n);return r}(a.shape,r,n),s=y([a.shape[r]]),u=a.as2D(-1,s),l=Et(t.dtype),c=this.segOpCompute(u,"unsortedSegmentSum",e,l,n).reshape(i);return null!=o&&(c=c.transpose(on(o))),c},t.prototype.segOpCompute=function(t,e,n,r,o){var a=t.shape[0],i=t.shape[1],s=function(t,e){var n,r=!1;for(t<=ln?(n=t,r=!0):n=z(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=z(t,n+1);return n}(i,o),u=new li({windowSize:s,inSize:i,batchSize:a,numSegments:o},e),l=u.outputShape,c=l[0],h=l[1],p=this.makeOutputArray([c,h],r);return this.compileAndRun(u,[t,n],p),p.shape[1]===o?p:(n=jn(0,o).tile([i/s]),this.segOpCompute(p,e,n,r,o))},t.prototype.argMinMaxReduce=function(t,e,n){var r=[e];if(nn("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!a.getBool("WEBGL_PACK_REDUCE")||t.rank<=2){var o=tn(t.shape,r),i=o[0],s=y(o[1]),u=t.as2D(-1,s);return this.argReduce(u,n).reshape(i)}return this.argReducePacked(t,n)},t.prototype.argMin=function(t,e){return this.argMinMaxReduce(t,e,"min")},t.prototype.argMax=function(t,e){return this.argMinMaxReduce(t,e,"max")},t.prototype.cumsum=function(t,e,n,r){if(e!==t.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(t.rank-1)+" but got axis="+e);var o=new Jo(t.shape,n,r);return this.compileAndRun(o,[t])},t.prototype.equal=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");var n=new Mo("return float(a == b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.notEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");var n=new Mo("return float(a != b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.less=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");var n=new Mo("return float(a < b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.lessEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");var n=new Mo("return float(a <= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greater=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");var n=new Mo("return float(a > b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greaterEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var n=new Mo("return float(a >= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalNot=function(t){var e=new Ei(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])},t.prototype.logicalAnd=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var n=new Mo("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalOr=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var n=new Mo("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.select=function(t,e,n){var r=new ci(t.rank,e.shape,e.rank),o=this.makeOutputArray(r.outputShape,Ct(e.dtype,n.dtype));return this.compileAndRun(r,[t,e,n],o)},t.prototype.where=function(t){je("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){nn("min",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)},t.prototype.minimum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.mod=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.max=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.max(t,e);nn("max",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(r)},t.prototype.maximum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.all=function(t,e){nn("all",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)},t.prototype.any=function(t,e){nn("any",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)},t.prototype.squaredDifference=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("return (a - b) * (a - b);",t.shape,e.shape):new Mo("return (a - b) * (a - b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.realDivide=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS")){return this.packedBinaryOp(t,e,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(b.x == 0.0) {\n    result.x = NAN;\n  } else if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(b.y == 0.0) {\n    result.y = NAN;\n  } else if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(b.z == 0.0) {\n    result.z = NAN;\n  } else if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(b.w == 0.0) {\n    result.w = NAN;\n  } else if(a.w == b.w) {\n    result.w = 1.;\n  }\n  \n  return result;\n","float32",!0)}var n=new Mo("\nif (b == 0.0) {\n  return NAN;\n} \nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t,e],r)},t.prototype.floorDiv=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var n=new Mo("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"int32");return this.compileAndRun(n,[t,e],r)},t.prototype.add=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Do);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Do,n);var r=new Mo(Do,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.packedBinaryOp=function(t,e,n,r,o){void 0===o&&(o=!1);var a=new Fo(n,t.shape,e.shape,o),i=this.makePackedTensor(a.outputShape,r);return this.compileAndRun(a,[t,e],i)},t.prototype.complexSeparableBinaryOp=function(t,e,n){var r=this,o=this.texData.get(t.dataId),a=this.texData.get(e.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map(function(o){var a=o[0],i=o[1],s=r.makeComplexComponentTensorHandle(t,a),u=r.makeComplexComponentTensorHandle(e,i),l=new Mo(n,t.shape,e.shape),c=r.makeOutputArray(l.outputShape,Ct(a.dtype,i.dtype));return r.compileAndRun(l,[s,u],c)}),s=i[0],u=i[1],l=this.complex(s,u);return s.dispose(),u.dispose(),l},t.prototype.makeComplexComponentTensorHandle=function(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}},t.prototype.addN=function(t){if(1===t.length)return t[0];if(t.length>a.get("WEBGL_MAX_TEXTURES_IN_SHADER")){var e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}var o=t.map(function(t){return t.dtype}).reduce(function(t,e){return Ct(t,e)}),i=t.map(function(t){return t.shape}),s=a.getBool("WEBGL_PACK"),u=s?new eo(t[0].shape,i):new to(t[0].shape,i),l=s?this.makePackedTensor(u.outputShape,o):this.makeOutputArray(u.outputShape,o);return this.compileAndRun(u,t,l)},t.prototype.subtract=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Oo);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Oo,t.dtype);var r=new Mo(Oo,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.pow=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS"),r=n?new Fo("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),o=Ct(t.dtype,e.dtype),i=n?this.makePackedTensor(r.outputShape,o):this.makeOutputArray(r.outputShape,o);return this.compileAndRun(r,[t,e],i)},t.prototype.ceil=function(t){var e=new Ei(t.shape,"return ceil(x);");return this.compileAndRun(e,[t])},t.prototype.floor=function(t){var e=new Ei(t.shape,"return floor(x);");return this.compileAndRun(e,[t])},t.prototype.sign=function(t){var e=new Ei(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])},t.prototype.isNaN=function(t){var e=new Ei(t.shape,"return float(isnan(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isInf=function(t){var e=new Ei(t.shape,"return float(isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isFinite=function(t){var e=new Ei(t.shape,"return float(!isnan(x) && !isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.round=function(t){var e=new Ei(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])},t.prototype.exp=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Ii):new Ei(t.shape,Ii),this.compileAndRun(e,[t])},t.prototype.expm1=function(t){var e=new Ei(t.shape,"return exp(x) - 1.0;");return this.compileAndRun(e,[t])},t.prototype.log=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n"):new Ei(t.shape,"if (x < 0.0) return NAN;\n  return log(x);"),this.compileAndRun(e,[t])},t.prototype.log1p=function(t){var e=new Ei(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])},t.prototype.sqrt=function(t){var e=new Ei(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])},t.prototype.rsqrt=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);var e=new Ei(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])},t.prototype.square=function(t){var e=new Ei(t.shape,"return x * x;");return this.compileAndRun(e,[t])},t.prototype.reciprocal=function(t){var e=new Ei(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])},t.prototype.relu=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Fi):new Ei(t.shape,Ni),this.compileAndRun(e,[t])},t.prototype.prelu=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",t.shape,e.shape):new Mo("return (a < 0.) ? b * a : a;",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.elu=function(t){var e=new Ei(t.shape,"return (x >= 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(e,[t])},t.prototype.eluDer=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Mo("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.selu=function(t){var e=new Ei(t.shape,ki);return this.compileAndRun(e,[t])},t.prototype.int=function(t){var e=new Ei(t.shape,"return float(int(x));"),n=this.makeOutputArray(e.outputShape,"int32");return this.compileAndRun(e,[t],n)},t.prototype.clip=function(t,e,n){var r,o=(r=a.getBool("WEBGL_PACK_CLIP")?new Po(t.shape):new Bo(t.shape)).getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,o)},t.prototype.abs=function(t){var e=new Ei(t.shape,"return abs(x);");return this.compileAndRun(e,[t])},t.prototype.complexAbs=function(t){var e=this.texData.get(t.dataId),n=new Lo(t.shape),r=[this.makeComplexComponentTensorHandle(t,e.complexTensors.real),this.makeComplexComponentTensorHandle(t,e.complexTensors.imag)];return this.compileAndRun(n,r)},t.prototype.sigmoid=function(t){var e=new Ei(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])},t.prototype.softplus=function(t){var e=new Ei(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])},t.prototype.sin=function(t){var e=new Ei(t.shape,Ai);return this.compileAndRun(e,[t])},t.prototype.cos=function(t){var e=new Ei(t.shape,Ti);return this.compileAndRun(e,[t])},t.prototype.tan=function(t){var e=new Ei(t.shape,"return tan(x);");return this.compileAndRun(e,[t])},t.prototype.asin=function(t){var e=new Ei(t.shape,"return asin(x);");return this.compileAndRun(e,[t])},t.prototype.acos=function(t){var e=new Ei(t.shape,"return acos(x);");return this.compileAndRun(e,[t])},t.prototype.atan=function(t){var e=new Ei(t.shape,Di);return this.compileAndRun(e,[t])},t.prototype.atan2=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.sinh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.cosh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.tanh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])},t.prototype.asinh=function(t){var e=new Ei(t.shape,"return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])},t.prototype.acosh=function(t){var e=new Ei(t.shape,Oi);return this.compileAndRun(e,[t])},t.prototype.atanh=function(t){var e=new Ei(t.shape,_i);return this.compileAndRun(e,[t])},t.prototype.erf=function(t){var e=new Ei(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n');return this.compileAndRun(e,[t])},t.prototype.step=function(t,e){var n=new Ei(t.shape,function(t){return void 0===t&&(t=0),Ri+"\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}(e));return this.compileAndRun(n,[t])},t.prototype.conv2dByMatMul=function(t,e,n){var r=t.shape,o=this.texData.get(t.dataId),i=n.inChannels,s=r[0]*r[1]*r[2],u=n.outChannels,l=(1===s||1===u)&&i>1e3,c=r[2]%2!=0&&!!o.isPacked;if(l||!a.getBool("WEBGL_LAZILY_UNPACK")||!a.getBool("WEBGL_PACK_BINARY_OPERATIONS")||!c){var h=this.reshape(t,[1,r[0]*r[1]*r[2],n.inChannels]),p=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.batchMatMul(h,p,!1,!1),n.outShape)}var f=ft.make([1,r[0]*r[1]*(r[2]+1),n.inChannels],{dataId:t.dataId},t.dtype,this),v=o.shape;o.shape=o.shape.slice(),o.shape[o.shape.length-2]++,d(ge(o.shape,f.shape),function(){return"packed reshape "+o.shape+" to "+f.shape+" isn't free"});var m=this.reshape(e,[1,n.inChannels,n.outChannels]),g=this.batchMatMul(f,m,!1,!1),y=this.texData.get(g.dataId);return d(y.isPacked,function(){return"batchMatMul result is expected to be packed"}),o.shape=v,y.shape=n.outShape,ft.make(n.outShape,{dataId:g.dataId},g.dtype,this)},t.prototype.conv2dWithIm2Row=function(t,e,n){var r=n.filterWidth,o=n.filterHeight,a=n.inChannels,i=n.outWidth,s=n.outHeight,u=r*o*a,l=s*i,c=[u,l],h=t.squeeze([0]),p=e.reshape([1,u,-1]),f=new za(c,h.shape,n),d=this.compileAndRun(f,[h]).reshape([1,c[0],c[1]]),v=new $a(d.shape,[1,l,n.outChannels],!0,!1);return this.compileAndRun(v,[d,p]).reshape([1,s,i,n.outChannels])},t.prototype.conv2d=function(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(a.getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);var r=new jo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerInput=function(t,e,n){var r=new Vo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerFilter=function(t,e,n){var r=new zo(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2D=function(t,e,n){var r;return a.getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new Yo(n),this.compileAndRun(r,[t,e],this.makePackedTensor(n.outShape,t.dtype))):(r=new Xo(n),this.compileAndRun(r,[t,e]))},t.prototype.depthwiseConv2DDerInput=function(t,e,n){var r=new $o(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){var r=new Ho(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3d=function(t,e,n){var r=new Ko(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerInput=function(t,e,n){var r=new qo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerFilter=function(t,e,n){var r=new Go(n);return this.compileAndRun(r,[t,e])},t.prototype.maxPool=function(t,e){var n=new Ja(e,"max",!1),r=this.makeOutputArray(n.outputShape,t.dtype);return this.compileAndRun(n,[t],r)},t.prototype.avgPool=function(t,e){var n=new Ja(e,"avg",!1),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t],r)},t.prototype.maxPoolBackprop=function(t,e,n,r){var o=new Ja(r,"max",!0),a=this.compileAndRun(o,[e]),i=new Ha(r),s=this.makeOutputArray(i.outputShape,e.dtype),u=this.compileAndRun(i,[t,a],s);return a.dispose(),u},t.prototype.avgPoolBackprop=function(t,e,n){var r=new So(n),o=this.makeOutputArray(r.outputShape,e.dtype);return this.compileAndRun(r,[t],o)},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reshape=function(t,e){var n=this.texData.get(t.dataId);return!n.isPacked||ge(t.shape,e)||null!==n.texture&&ge(n.shape,e)?Zn(t,e):this.packedReshape(t,e)},t.prototype.resizeBilinear=function(t,e,n,r){var o=a.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ri(t.shape,e,n,r):new ni(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeBilinearBackprop=function(t,e,n){var r=new ei(t,e,n);return this.compileAndRun(r,[t])},t.prototype.resizeNearestNeighbor=function(t,e,n,r){var o=new ai(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){var r=new oi(t,e,n);return this.compileAndRun(r,[t])},t.prototype.multinomial=function(t,e,n,r){var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=new ja(a,i,n),u=this.makeOutputArray(s.outputShape,"int32"),l=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],u,l)},t.prototype.oneHot=function(t,e,n,r){var o=new Ka(t.size,e,n,r);return this.compileAndRun(o,[t])},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.cropAndResize=function(t,e,n,r,o,a){var i=new Qo(t.shape,e.shape,r,o,a);return this.compileAndRun(i,[t,e,n])},t.prototype.depthToSpace=function(t,e,n){d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});var r=t.shape[0],o="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],s=o*e,u=a*e,l=i/(e*e),c=new ta("NHWC"===n?[r,s,u,l]:[r,l,s,u],e,n);return this.compileAndRun(c,[t])},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=[u/i,i],c=t.reshape([a,o]),h=e.reshape([a,i]);if(0===u)return Zn(Fn([]),n);var p=Bn(0),f=new ui(a,o,c.rank,h.rank,s,l);return this.compileAndRun(f,[h,c,p]).reshape(n)},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,l=new ui(i,a,t.rank,e.rank,s,[u,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)},t.prototype.fft=function(t){return this.fftImpl(t,!1)},t.prototype.ifft=function(t){return this.fftImpl(t,!0)},t.prototype.fftImpl=function(t,e){var n=this.texData.get(t.dataId),r=new oa(na,t.shape,e),o=new oa(ra,t.shape,e),a=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(t.shape[0],t.shape[1]);return i.dispose(),s.dispose(),u},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3],l=e.reshape([i,r]),c=t.reshape([t.size/s,s]),h=new ca(r,u,[i,s]);return this.compileAndRun(h,[c,l]).reshape(a)},t.prototype.fill=function(t,e,n){if("string"===(n=n||W(e))){var r=A(n,y(t));return r.fill(e),ft.make(t,{values:r},n)}var o=new aa(t,e),a=o.getCustomSetupFunc(e),i=this.makeOutputArray(t,n);return this.compileAndRun(o,[],i,a)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.makeOutputArray=function(t,e){return ft.make(t,{},e,this)},t.prototype.makePackedTensor=function(t,e){var n=ft.make(t,{},e,this);return this.texData.get(n.dataId).isPacked=!0,n},t.prototype.unpackTensor=function(t){var e=new Pi(t.shape);return this.compileAndRun(e,[t],ft.make(e.outputShape,{},t.dtype,this))},t.prototype.packTensor=function(t){var e=new Xa(t.shape);return this.compileAndRun(e,[t],this.makePackedTensor(t.shape,t.dtype))},t.prototype.packedReshape=function(t,e){var n=t.reshape([fe(t.shape)].concat(de(t.shape))),r=[fe(e)].concat(de(e)),o=new ti(r,n.shape);return this.compileAndRun(o,[n]).reshape(e)},t.prototype.compileAndRun=function(t,e,n,r){var o=this;if(null==n&&(n=t.usesPackedTextures?this.makePackedTensor(t.outputShape,e[0].dtype):this.makeOutputArray(t.outputShape,e[0].dtype)),0===n.size)return this.texData.get(n.dataId).values=I(n.dtype,0),n;var i=e.map(function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n=o.texData.get(e.dataId);if(null==n.texture){if(!t.usesPackedTextures&&y(e.shape)<=a.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.usesPackedTextures&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.usesPackedTextures)e=n.isPacked?o.unpackTensor(e):o.packTensor(e),n=o.texData.get(e.dataId);else if(n.isPacked&&!ge(n.shape,e.shape)){var r=e,i=e.shape;e.shape=n.shape,e=o.packedReshape(e,i),n=o.texData.get(e.dataId),r.shape=i}return o.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(n.dataId);var s,u={shape:n.shape,texData:this.texData.get(n.dataId),isUniform:!1},l=function(t,e,n){var r="";e.concat(n).forEach(function(t){var e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=t.shape+"_"+n+"_"+e});var o=t.userCode,a=t.constructor.name;return a+="_"+r+"_"+o}(t,i,u),c=this.getAndSaveBinary(l,function(){return function(t,e,n,r){var o=e.userCode,i=n.map(function(t,n){var r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),s=i.map(function(t){return t.shapeInfo}),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=ho(i,u,o,e.usesPackedTextures),c=t.createProgram(l),h=null,p=t.getUniformLocation(c,"NAN",!1);1===a.getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(c,"INFINITY",!1));for(var f={},d=0;d<e.variableNames.length;d++){var v=e.variableNames[d];f[v]=t.getUniformLocation(c,v,!1),f["offset"+v]=t.getUniformLocation(c,"offset"+v,!1)}return{program:e,source:l,webGLProgram:c,uniformLocations:f,inShapeInfos:s,outShapeInfo:u,infLoc:h,nanLoc:p}}(o.gpgpu,t,i,u)}),h=null!=this.activeTimers;return h&&(s=this.startTimer()),function(t,e,n,r,o){Ua(e.inShapeInfos,n),Ua([e.outShapeInfo],[r]);var i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i,s[0],s[1]):t.setOutputMatrixTexture(i,s[0],s[1]),t.setProgram(e.webGLProgram),1===a.getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(function(n,r){var o=e.program.variableNames[r],a=e.uniformLocations[o],i=e.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(y(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{var s=n.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),t.gl.uniform1fv(a,s)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=o&&o(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,c,i,u,r),h&&(s=this.endTimer(s),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(s)})),a.getBool("WEBGL_LAZILY_UNPACK")||!this.texData.get(n.dataId).isPacked||t.isPackShader?n:this.unpackTensor(n)},t.prototype.getAndSaveBinary=function(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.dispose=function(){this.disposed||(this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},t.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Fe(function(){var e=a.getBool("DEBUG");a.set("DEBUG",!1);var n=t.abs(Bn(1e-8)).dataSync()[0];return a.set("DEBUG",e),n>0?32:16})),this.floatPrecisionValue},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.uploadToGPU=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.values,i=n.texture,s=n.usage,u=n.isPacked;if(null==i){var l,c=null!=this.activeTimers;c&&(l=performance.now());var h=ve(r,u);n.texShape=h;var p=this.acquireTexture(h,s,o,u);if(n.texture=p,null!=a){if(u){var f=fe(r),d=1,v=1;r.length&&(d=(e=de(r))[0],v=e[1]),this.gpgpu.uploadMatrixToPackedTexture(p,f,d,v,h[0],h[1],zi(a))}else this.gpgpu.uploadMatrixToTexture(p,h[0],h[1],zi(a));n.values=null,c&&(this.uploadWaitMs+=performance.now()-l)}}},t.prototype.convertAndCacheOnCPU=function(t,e){var n=this.texData.get(t),r=n.dtype;return this.releaseGPUData(t),n.usage=ua.UPLOAD,null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){for(var n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length),r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values},t.prototype.acquireTexture=function(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)},t.prototype.computeBytes=function(t,e){return t[0]*t[1]*M(e)},t}();function zi(t){return t instanceof Float32Array?t:new Float32Array(t)}Ot()&&Dt.registerBackend("webgl",function(){return new Ui},2);var Vi=An({abs_:function(t){var e=wn(t,"x","abs");return"complex64"===e.dtype?Dt.runKernel(function(t){return t.complexAbs(e)},{$x:e}):Dt.runKernel(function(t,n){var r=t.abs(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().step(-1))}}})}}),Gi=An({acos_:function(t){var e=wn(t,"x","acos");return Dt.runKernel(function(t,n){var r=t.acos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt()).neg()}}})}}),qi=An({acosh_:function(t){var e=wn(t,"x","acosh");return Dt.runKernel(function(t,n){var r=t.acosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(n.toFloat().square().sub(1).sqrt())}}})}}),Hi=An({asin_:function(t){var e=wn(t,"x","asin");return Dt.runKernel(function(t,n){var r=t.asin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt())}}})}}),$i=An({asinh_:function(t){var e=wn(t,"x","asinh");return Dt.runKernel(function(t,n){var r=t.asinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).add(n.toFloat().square()).sqrt())}}})}}),ji=An({atan_:function(t){var e=wn(t,"x","atan");return Dt.runKernel(function(t,n){var r=t.atan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().square().add(1))}}})}}),Ki=An({atanh_:function(t){var e=wn(t,"x","atanh");return Dt.runKernel(function(t,n){var r=t.atanh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(Bn(1).sub(n.toFloat().square()))}}})}}),Xi=An({ceil_:function(t){var e=wn(t,"x","ceil");return Dt.runKernel(function(t){return t.ceil(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),Yi=An({clipByValue_:function(t,e,n){var r=wn(t,"x","clipByValue");return d(e<=n,function(){return"Error in clip: min ("+e+") must be less than or equal to max ("+n+")."}),Dt.runKernel(function(t,o){var a=t.clip(r,e,n);return o([r]),a},{$x:r},function(t,r){var o=r[0];return{$x:function(){return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)),Xn(t))}}})}}),Qi=An({cos_:function(t){var e=wn(t,"x","cos");return Dt.runKernel(function(t,n){var r=t.cos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sin().neg().mul(t)}}})}}),Ji=An({cosh_:function(t){var e=wn(t,"x","cosh");return Dt.runKernel(function(t,n){var r=t.cosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}})}}),Zi=An({erf_:function(t){var e=wn(t,"x","erf");return d("int32"===e.dtype||"float32"===e.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===e.dtype&&(e=e.toFloat()),Dt.runKernel(function(t,n){var r=t.erf(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}}),ts=An({exp_:function(t){var e=wn(t,"x","exp");return Dt.runKernel(function(t,n){var r=t.exp(e);return n([r]),r},{$x:e},function(t,e){return{$x:function(){return t.mulStrict(e[0])}}})}}),es=An({expm1_:function(t){var e=wn(t,"x","expm1");return Dt.runKernel(function(t,n){var r=t.expm1(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.exp())}}})}}),ns=An({floor_:function(t){var e=wn(t,"x","floor");return Dt.runKernel(function(t){return t.floor(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),rs=An({log_:function(t){var e=wn(t,"x","log");return Dt.runKernel(function(t,n){var r=t.log(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat())}}})}}),os=An({log1p_:function(t){var e=wn(t,"x","log1p");return Dt.runKernel(function(t,n){var r=t.log1p(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.add(1))}}})}}),as=An({logSigmoid_:function(t){var e=wn(t,"x","logSigmoid");return Dt.runKernel(function(t,n){var r=t.softplus(e.neg()).neg();return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.neg().sigmoid())}}})}}),is=An({neg_:function(t){var e=wn(t,"x","neg");return Dt.runKernel(function(t){return t.neg(e)},{$x:e},function(t){return{$x:function(){return t.neg()}}})}}),ss=An({reciprocal_:function(t){var e=wn(t,"x","reciprocal");return Dt.runKernel(function(t,n){var r=t.reciprocal(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.square().neg())}}})}}),us=An({round_:function(t){var e=wn(t,"x","round");return Dt.runKernel(function(t){return t.round(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ls=An({rsqrt_:function(t){var e=wn(t,"x","rsqrt");return Dt.runKernel(function(t,n){var r=t.rsqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.pow(1.5).mul(2)).neg()}}})}}),cs=An({sigmoid_:function(t){var e=wn(t,"x","sigmoid");return Dt.runKernel(function(t,n){var r=t.sigmoid(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.mul(Bn(1).sub(n)))}}})}}),hs=An({sign_:function(t){var e=wn(t,"x","sign");return Dt.runKernel(function(t){return t.sign(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ps=An({isNaN_:function(t){var e=wn(t,"x","isNaN");return Dt.runKernel(function(t){return t.isNaN(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),fs=An({isInf_:function(t){var e=wn(t,"x","isInf");return Dt.runKernel(function(t){return t.isInf(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ds=An({isFinite_:function(t){var e=wn(t,"x","isFinite");return Dt.runKernel(function(t){return t.isFinite(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),vs=An({sin_:function(t){var e=wn(t,"x","sin");return Dt.runKernel(function(t,n){var r=t.sin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cos().mul(t)}}})}}),ms=An({sinh_:function(t){var e=wn(t,"x","sinh");return Dt.runKernel(function(t,n){var r=t.sinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}})}}),gs=An({softplus_:function(t){var e=wn(t,"x","softplus");return Dt.runKernel(function(t,n){var r=t.softplus(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.sigmoid())}}})}}),ys=An({sqrt_:function(t){var e=wn(t,"x","sqrt");return Dt.runKernel(function(t,n){var r=t.sqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().sqrt().mul(2))}}})}}),xs=An({square_:function(t){var e=wn(t,"x","square");return Dt.runKernel(function(t,n){return n([e]),t.square(e)},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().mul(2))}}})}}),ws=An({step_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","step");return Dt.runKernel(function(t){return t.step(n,e)},{$x:n},function(t){return{$x:function(){return Xn(t)}}})}}),bs=An({tan_:function(t){var e=wn(t,"x","tan");return Dt.runKernel(function(t,n){var r=t.tan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.cos().square())}}})}}),Cs=An({tanh_:function(t){var e=wn(t,"x","tanh");return Dt.runKernel(function(t,n){var r=t.tanh(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Bn(1).sub(n.square()).mulStrict(t)}}})}});function Es(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(2===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(2===l.rank||1===l.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."}),d(2===c.rank||1===c.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(2===i.rank||1===i.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(2===s.rank||1===s.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Rs(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(3===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(3===l.rank||1===l.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."}),d(3===c.rank||1===c.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(3===i.rank||1===i.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(3===s.rank||1===s.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ss(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(4===u.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank||1===l.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."}),d(4===c.rank||1===c.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(4===i.rank||1===i.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(4===s.rank||1===s.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ns(t,e,n,r,o,a){null==a&&(a=.001);var i,s,u,l=wn(t,"x","batchNorm"),c=wn(e,"mean","batchNorm"),h=wn(n,"variance","batchNorm");null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(c.rank===h.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),d(null==s||c.rank===s.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),d(null==i||c.rank===i.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),u=0===l.rank||1===l.rank?l.as4D(1,1,1,l.size):2===l.rank?l.as4D(1,1,l.shape[0],l.shape[1]):3===l.rank?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;return Dt.runKernel(function(t,e){var n=t.batchNormalization(u,ks(c),ks(h),a,ks(i),ks(s));return e([l,c,h,i]),n},{$x:l,$mean:c,$variance:h,$scale:i,$offset:s},function(t,e){var n=e[0],r=e[1],o=e[2],i=e[3],s=null==i?Bn(1):i,l=io(r.shape,u.shape),c=[];if(1===r.rank){for(var h=0;h<u.shape.length-1;++h)c.push(u.shape[h]);c.push(1)}var p=n.sub(r),f=t.mul(s),d=ls(o.add(Bn(a))),v=d.mul(d).mul(d).mul(Bn(-.5));return{$x:function(){return 1===r.rank?t.mul(Xr(d.as4D(1,1,1,r.shape[0]),c)).mul(s).reshape(n.shape):t.mul(d).mul(s).reshape(n.shape)},$mean:function(){var t=d.mul(Bn(-1)).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$variance:function(){var t=v.mul(p).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$scale:function(){var e=p.mul(d),n=t.mul(e);return 1===r.rank&&(n=n.sum(l)),n.reshape(r.shape)},$offset:function(){var e=t;return 1===r.rank&&(e=e.sum(l)),e.reshape(r.shape)}}}).reshape(l.shape)}function ks(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function Is(){De("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var As=An({batchNormalization2d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Es(t,e,n,a,o,r)}}),Ts=An({batchNormalization3d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Rs(t,e,n,a,o,r)}}),Ds=An({batchNormalization4d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ss(t,e,n,a,o,r)}}),Os=An({batchNormalization_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ns(t,e,n,a,o,r)}}),_s=An({batchNorm_:Ns}),Ms=An({batchNorm2d_:Es}),Fs=An({batchNorm3d_:Rs}),Bs=An({batchNorm4d_:Ss});function Ps(t,e,n,r,o,a,i){void 0===i&&(i="channelsLast");var s,u=Us(e),l=u[0],c=u[1];if("channelsLast"===i)s=[l,c,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[l,c,t[1],t[1]]}return Ls(t,s,n,r,o,a,!1,i)}function Ls(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],l=u[0],c=u[1],h=u[2],p=u[3];if("channelsLast"===s)l=t[0],c=t[1],h=t[2],p=t[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);l=t[0],p=t[1],c=t[2],h=t[3]}var f,v=e[0],m=e[1],g=e[3],y=Us(n),x=y[0],b=y[1],C=Us(r),E=C[0],R=C[1],S=Vs(v,E),N=Vs(m,R),k=function(t,e,n,r,o,a,i,s){var u,l,c;if("number"==typeof t){var h=0===t?"VALID":"NUMBER";u={top:t,bottom:t,left:t,right:t,type:h};var p=function(t,e,n,r,o,a){null==o&&(o=function(t,e,n,r){void 0===r&&(r=1);var o=Vs(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}(t,e,r));var i=t[0],s=t[1],u=Gs((i-e+2*o)/r+1,a);d(w(u),function(){return"The output # of rows ("+u+") must be an integer. Change the stride and/or zero pad parameters"});var l=Gs((s-e+2*o)/r+1,a);return d(w(l),function(){return"The output # of columns ("+l+") must be an integer. Change the stride and/or zero pad parameters"}),[u,l,n]}([e,n,1],a,1,r,t,s);l=p[0],c=p[1]}else if("same"===t){l=Math.ceil(e/r),c=Math.ceil(n/o);var f=Math.max(0,(l-1)*r+a-e),v=Math.max(0,(c-1)*o+i-n),m=Math.floor(f/2),g=f-m,y=Math.floor(v/2),x=v-y;u={top:m,bottom:g,left:y,right:x,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-a+1)/r),c=Math.ceil((n-i+1)/o)}return{padInfo:u,outHeight:l,outWidth:c}}(o,c,h,x,b,S,N,a),I=k.padInfo,A=k.outHeight,T=k.outWidth,D=i?g*p:g;return"channelsFirst"===s?f=[l,D,A,T]:"channelsLast"===s&&(f=[l,A,T,D]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:h,inChannels:p,outHeight:A,outWidth:T,outChannels:D,padInfo:I,strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationHeight:E,dilationWidth:R,inShape:t,outShape:f,filterShape:e}}function Ws(t,e,n,r,o,a,i){void 0===a&&(a=!1),void 0===i&&(i="channelsLast");var s=[-1,-1,-1,-1,-1],u=s[0],l=s[1],c=s[2],h=s[3],p=s[4];if("channelsLast"===i)u=t[0],l=t[1],c=t[2],h=t[3],p=t[4];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);u=t[0],p=t[1],l=t[2],c=t[3],h=t[4]}var f,d=e[0],v=e[1],m=e[2],g=e[4],y=zs(n),x=y[0],w=y[1],b=y[2],C=zs(r),E=C[0],R=C[1],S=C[2],N=function(t,e,n,r,o,a,i,s,u,l){var c,h,p,f;if("same"===t){h=Math.ceil(e/o),p=Math.ceil(n/a),f=Math.ceil(r/i);var d=(h-1)*o+s-e,v=(p-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(d/2),y=d-g,x=Math.floor(v/2),w=v-x,b=Math.floor(m/2),C=m-b;c={top:x,bottom:w,left:b,right:C,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((e-s+1)/o),p=Math.ceil((n-u+1)/a),f=Math.ceil((r-l+1)/i)}return{padInfo:c,outDepth:h,outHeight:p,outWidth:f}}(o,l,c,h,x,w,b,Vs(d,E),Vs(v,R),Vs(m,S)),k=N.padInfo,I=N.outDepth,A=N.outHeight,T=N.outWidth,D=a?g*p:g;return"channelsFirst"===i?f=[u,D,I,A,T]:"channelsLast"===i&&(f=[u,I,A,T,D]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:I,outHeight:A,outWidth:T,outChannels:D,padInfo:k,strideDepth:x,strideHeight:w,strideWidth:b,filterDepth:d,filterHeight:v,filterWidth:m,dilationDepth:E,dilationHeight:R,dilationWidth:S,inShape:t,outShape:f,filterShape:e}}function Us(t){return"number"==typeof t?[t,t]:t}function zs(t){return"number"==typeof t?[t,t,t]:t}function Vs(t,e){return e<=1?t:t+(t-1)*(e-1)}function Gs(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function qs(t){var e=Us(t),n=e[0],r=e[1];return 1===n&&1===r}function Hs(t,e){return qs(t)||qs(e)}function $s(t,e,n,r,o,a){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var i=t,s=e,u=!1;3===e.rank&&(u=!0,s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),i=[1,t[0],t[1],t[2]]);var l=i[3],c=s.shape[3];d(4===i.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+i.length+"."}),d(4===s.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+s.rank}),d(4===n.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank}),d(l===n.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+n.shape[2]+"."}),d(c===n.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+c+") must match output depth for filter "+n.shape[3]+"."}),null!=a&&d(w(o),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var h=Ls(i,n.shape,r,1,o,a),p=Dt.runKernel(function(t,e){var r=t.conv2dDerInput(s,n,h);return e([n,s]),r},{dy4D:s,filter:n},function(t,e){var n=e[0],i=e[1];return{dy4D:function(){return Ys(t,n,r,o,"NHWC",1,a)},filter:function(){return Js(t,i,n.shape,r,o,a)}}});return u?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function js(t,e,n,r,o,a){var i=t;3===t.rank&&(i=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var s=e;3===s.rank&&(s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),d(4===i.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."}),d(4===s.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+s.shape+"."}),d(4===n.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."}),d(i.shape[3]===n[2],function(){return"Error in conv2dDerFilter: depth of input "+i.shape[3]+") must match input depth in filter ("+n[2]+"."}),d(s.shape[3]===n[3],function(){return"Error in conv2dDerFilter: depth of dy ("+s.shape[3]+") must match output depth for filter ("+n[3]+")."}),null!=a&&d(w(o),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var u=Ls(i.shape,n,r,1,o,a);return Dt.runKernel(function(t){return t.conv2dDerFilter(i,s,u)},{x4D:i,dy4D:s})}function Ks(t){var e=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}var Xs=An({conv1d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=wn(t,"x","conv1d"),u=wn(e,"filter","conv1d"),l=s,c=!1;2===s.rank&&(c=!0,l=s.as3D(1,s.shape[0],s.shape[1])),d(3===l.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+l.rank+"."}),d(3===u.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[2]===u.shape[1],function(){return"Error in conv1d: depth of input ("+l.shape[2]+") must match input depth for filter "+u.shape[1]+"."}),d(Hs(n,a),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+a+"'"}),d("NWC"===o,function(){return"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported."});var h=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),p=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),f=Ys(p,h,[1,n],r,"NHWC",[1,a],i);return c?f.as2D(f.shape[2],f.shape[3]):f.as3D(f.shape[0],f.shape[2],f.shape[3])}}),Ys=An({conv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","conv2d"),u=wn(e,"filter","conv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in conv2d: depth of input ("+l.shape[3]+") must match input depth for filter "+u.shape[2]+"."}),d(Hs(n,a),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NHWC"===o,function(){return"Error in conv2d: got dataFormat of "+o+" but only NHWC is currently supported."});var h=Ls(l.shape,u.shape,n,a,r,i),p=Dt.runKernel(function(t,e){var n=t.conv2d(l,u,h);return e([u,l]),n},{x:l,$filter:u},function(t,e){var o=e,i=o[0],s=o[1];return d(qs(a),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"}),{x:function(){return $s(s.shape,t,i,n,r)},$filter:function(){return js(s,t,i.shape,n,r)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),Qs=An({conv3d_:function(t,e,n,r,o,a){void 0===o&&(o="NDHWC"),void 0===a&&(a=[1,1,1]);var i=wn(t,"x","conv3d"),s=wn(e,"filter","conv3d"),u=i,l=!1;4===i.rank&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),d(5===u.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."}),d(5===s.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+s.rank+"."}),d(u.shape[4]===s.shape[3],function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+s.shape[3]+"."}),d(function(t,e){return Ks(t)||Ks(e)}(n,a),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NDHWC"===o,function(){return"Error in conv3d: got dataFormat of "+o+" but only NDHWC is currently supported."});var c=Ws(u.shape,s.shape,n,a,r),h=Dt.runKernel(function(t,e){var n=t.conv3d(u,s,c);return e([u,s]),n},{x:u,$filter:s},function(t,e){d(Ks(a),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"});var o=e[0],i=e[1];return{x:function(){return function(t,e,n,r,o){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var a=t,i=e,s=!1;4===e.rank&&(s=!0,i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]),a=[1,t[0],t[1],t[2],t[3]]);var u=a[4],l=i.shape[4];d(5===a.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+a.length+"."}),d(5===i.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+i.rank}),d(5===n.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank}),d(u===n.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+n.shape[3]+"."}),d(l===n.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+l+") must match output depth for filter "+n.shape[4]+"."});var c=Ws(a,n.shape,r,1,o),h=Dt.runKernel(function(t){return t.conv3dDerInput(i,n,c)},{dy5D:i});return s?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}(o.shape,t,i,n,r)},$filter:function(){return function(t,e,n,r,o){var a=t;4===t.rank&&(a=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]));var i=e;4===i.rank&&(i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3])),d(5===a.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+a.shape+"."}),d(5===i.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+i.shape+"."}),d(5===n.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."}),d(a.shape[4]===n[3],function(){return"Error in conv3dDerFilter: depth of input "+a.shape[4]+") must match input depth in filter ("+n[3]+"."}),d(i.shape[4]===n[4],function(){return"Error in conv3dDerFilter: depth of dy ("+i.shape[4]+") must match output depth for filter ("+n[4]+")."});var s=Ws(a.shape,n,r,1,o);return Dt.runKernel(function(t){return t.conv3dDerFilter(a,i,s)},{x5D:a,dy5D:i})}(o,t,i.shape,n,r)}}});return l?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),Js=An({conv2dDerFilter_:js}),Zs=An({depthwiseConv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","depthwiseConv2d"),u=wn(e,"filter","depthwiseConv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+l.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."}),null==a&&(a=[1,1]),d(Hs(n,a),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),null!=i&&d(w(r),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."});var h=Ls(l.shape,u.shape,n,a,r,i,!0),p=Dt.runKernel(function(t,e){var n=t.depthwiseConv2D(l,u,h);return e([l,u]),n},{x:l,$filter:u},function(t,e){d(qs(a),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"});var n=e[0],r=e[1];return{x:function(){return function(t,e,n,r){var o=e,a=!1;3===e.rank&&(a=!0,o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var i=Dt.runKernel(function(t){return t.depthwiseConv2DDerInput(o,n,r)},{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}(n.shape,t,r,h)},$filter:function(){return function(t,e,n,r){var o=t;3===t.rank&&(o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var a=e;return 3===a.rank&&(a=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),Dt.runKernel(function(t){return t.depthwiseConv2DDerFilter(o,a,r)},{x4D:o,dy4D:a})}(n,t,r.shape,h)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),tu=An({separableConv2d_:function(t,e,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=wn(t,"x","separableConv2d"),u=wn(e,"depthwiseFilter","separableConv2d"),l=wn(n,"pointwiseFilter","separableConv2d"),c=s,h=!1;if(3===s.rank&&(h=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");d(4===c.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+c.rank+"."}),d(4===u.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."}),d(1===l.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+l.shape[0]+"."}),d(1===l.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+l.shape[1]+"."});var p=u.shape[2],f=u.shape[3];d(l.shape[2]===p*f,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+p*f+", but got "+l.shape[2]+"."});var v=Zs(c,u,r,o,i,a),m=Ys(v,l,1,"valid",i);return h?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}}),eu=An({conv2dTranspose_:function(t,e,n,r,o,a){return $s(n,wn(t,"x","conv2dTranspose"),wn(e,"filter","conv2dTranspose"),r,o,a)}});var nu=An({matMul_:function(t,e,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=wn(t,"a","matMul"),i=wn(e,"b","matMul");o=Rt(a,i),a=o[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?a.shape[a.rank-1]:a.shape[a.rank-2],c=r?i.shape[i.rank-2]:i.shape[i.rank-1],h=a.shape.slice(0,-2),p=i.shape.slice(0,-2),f=y(h),v=y(p);d(a.rank>=2&&i.rank>=2&&a.rank===i.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+a.rank+" and "+i.rank+"."}),d(x(h,p),function(){return"Error in matMul: outer dimensions ("+h+") and ("+p+") of Tensors with shapes "+a.shape+" and "+i.shape+" must match."}),d(s===u,function(){return"Error in matMul: inner shapes ("+s+") and ("+u+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var m=a.shape.slice(0,-2).concat([l,c]),g=n?a.as3D(f,s,l):a.as3D(f,l,s),w=r?i.as3D(v,c,u):i.as3D(v,u,c);return Dt.runKernel(function(t,e){var o=t.batchMatMul(g,w,n,r);return e([g,w]),o},{$a:g,$b:w},function(t,e){var o=e,a=o[0],i=o[1];return n||r?!n&&r?{$a:function(){return t.matMul(i,!1,!1)},$b:function(){return t.matMul(a,!0,!1)}}:n&&!r?{$a:function(){return i.matMul(t,!1,!0)},$b:function(){return a.matMul(t,!1,!1)}}:{$a:function(){return i.matMul(t,!0,!0)},$b:function(){return t.matMul(a,!0,!0)}}:{$a:function(){return t.matMul(i,!1,!0)},$b:function(){return a.matMul(t,!0,!1)}}}).reshape(m)}}),ru=An({dot_:function(t,e){var n=wn(t,"t1","dot"),r=wn(e,"t2","dot");d(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+"."});var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return d(o===a,function(){return"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."}),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}}),ou=An({outerProduct_:function(t,e){var n=wn(t,"v1","outerProduct"),r=wn(e,"v2","outerProduct");return d(1===n.rank&&1===r.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+"."}),n.as2D(-1,1).matMul(r.as2D(1,-1))}});var au=An({reverse_:function(t,e){var n=wn(t,"x","reverse");if(0===n.rank)return n.clone();var r=N(e,n.shape);return Dt.runKernel(function(t){return t.reverse(n,r)},{$x:n},function(t){return{$x:function(){return t.reverse(r)}}}).reshapeAs(n)}}),iu=An({reverse1d_:function(t){var e=wn(t,"x","reverse");return d(1===e.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+e.rank+"."}),au(e,0)}}),su=An({reverse2d_:function(t,e){var n=wn(t,"x","reverse");return d(2===n.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."}),au(n,e)}}),uu=An({reverse3d_:function(t,e){var n=wn(t,"x","reverse");return d(3===n.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."}),au(n,e)}}),lu=An({reverse4d_:function(t,e){var n=wn(t,"x","reverse");return d(4===n.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."}),au(n,e)}});function cu(t,e,n,r,o,a){var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),d(4===s.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."}),d(Hs(n,r),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"}),null!=a&&d(w(o),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t,e){var n=t.maxPool(s,l);return e([s,n]),n},{x:s},function(t,a){var i=a[0],s=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=wn(t,"dy","maxPoolBackprop"),l=wn(e,"input","maxPoolBackprop"),c=wn(n,"output","maxPoolBackprop");d(l.rank===u.rank,function(){return"Rank of input ("+l.rank+") does not match rank of dy ("+u.rank+")"}),null==a&&(a=[1,1]),d(Hs(o,a),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"}),d(4===u.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."}),null!=s&&d(w(i),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."});var h=Ps(l.shape,r,o,a,i,s);return Dt.runKernel(function(t){return t.maxPoolBackprop(u,l,c,h)},{$dy:u,$input:l})}(t,i,s,e,n,r,o)}}});return u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function hu(t,e,n,r,o,a){var i=wn(t,"x","avgPool","float32");null==r&&(r=[1,1]),d(Hs(n,r),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"});var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===s.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."}),null!=a&&d(w(o),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t){return t.avgPool(s,l)},{x:s},function(t){return{x:function(){return function(t,e,n,r,o,a){var i=wn(t,"dy","avgPoolBackprop"),s=wn(e,"input","avgPoolBackprop");d(s.rank===i.rank,function(){return"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"}),null==o&&(o=[1,1]),d(Hs(r,o),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"});var u=s,l=i,c=!1;3===s.rank&&(c=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===l.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+"."});var h=Ps(u.shape,n,r,o,a),p=Dt.runKernel(function(t){return t.avgPoolBackprop(l,u,h)},{dy4D:l,input4D:u});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}(t,s,e,n,r,o)}}});return c=c.cast(i.dtype),u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}var pu=An({maxPool_:function(t,e,n,r,o){return cu(t,e,n,1,r,o)}}),fu=An({avgPool_:function(t,e,n,r,o){return hu(t,e,n,1,r,o)}}),du=An({pool_:function(t,e,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r="valid");var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(Hs(a,o),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'"});var l,c=Ps(s.shape,e,a,o,r),h=[c.dilationHeight,c.dilationWidth];l="same"===r?function(t,e){var n=t.map(function(t,n){return t+(t-1)*(e[n]-1)}).map(function(t){return t-1}),r=n.map(function(t){return Math.floor(t/2)}),o=n.map(function(t,e){return t-r[e]});return n.map(function(t,e){return[r[e],o[e]]})}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];var p=1===h[0]&&1===h[1],f=function(t,e,n){var r=n.map(function(t){return t[0]}),o=n.map(function(t){return t[1]}),a=t.concat(r,o),i=e.map(function(t,e){return(t-a[e]%t)%t}),s=o.map(function(t,e){return t+i[e]}),u=e.map(function(t,e){return[r[e],s[e]]}),l=e.map(function(t,e){return[0,i[e]]});return[u,l]}([c.inHeight,c.inWidth],h,l),v=f[0],m=f[1],g=p?r:"valid",y=p?s:$r(s,h,v),x=("avg"===n?function(){return hu(y,e,a,1,g)}:function(){return cu(y,e,a,1,g)})(),w=p?x:Ir(x,h,m);return u?w.as3D(w.shape[1],w.shape[2],w.shape[3]):w}});var vu=An({slice_:function(t,e,n){var r,o,a=wn(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");r="number"==typeof e?[e].concat(new Array(a.rank-1).fill(0)):e.length<a.rank?e.concat(new Array(a.rank-e.length).fill(0)):e.slice(),o=(o=null==n?new Array(a.rank).fill(-1):"number"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map(function(t,e){return t>=0?t:(d(-1===t,function(){return"Bad value in size"}),a.shape[e]-r[e])}),function(t,e,n){d(t.rank===e.length,function(){return"Error in slice"+t.rank+"D: Length of begin "+e+" must match the rank of the array ("+t.rank+")."}),d(t.rank===n.length,function(){return"Error in slice"+t.rank+"D: Length of size "+n+" must match the rank of the array ("+t.rank+")."});for(var r=function(r){d(e[r]+n[r]<=t.shape[r],function(){return"Error in slice"+t.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+n[r])+") would overflow input.shape["+r+"] ("+t.shape[r]+")"})},o=0;o<t.rank;++o)r(o)}(a,r,o);var i=a.shape;return Dt.runKernel(function(t){return t.slice(a,r,o)},{$x:a},function(t){for(var e=[],n=0;n<t.rank;n++)e.push([r[n],i[n]-r[n]-o[n]]);return{$x:function(){return t.pad(e)}}})}}),mu=An({slice1d_:function(t,e,n){var r=wn(t,"x","slice1d");return d(1===r.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,[e],[n])}}),gu=An({slice2d_:function(t,e,n){var r=wn(t,"x","slice2d");return d(2===r.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),yu=An({slice3d_:function(t,e,n){var r=wn(t,"x","slice3d");return d(3===r.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),xu=An({slice4d_:function(t,e,n){var r=wn(t,"x","slice4d");return d(4===r.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}});function wu(t,e,n,r,o){return e.rank<n.rank&&(e=e.reshape(en(e.shape,r))),t.rank<n.rank&&(t=t.reshape(en(t.shape,r))),{$x:function(){var r=t.mul(n.equal(e).cast(t.dtype));return null==o?r:r.transpose(o)}}}var bu=An({all_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","all","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.all(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Cu=An({any_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","any","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.any(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Eu=An({argMax_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMax");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMax(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Ru=An({argMin_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMin");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMin(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Su=An({logSumExp_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","logSumExp"),o=N(e,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Nu=An({max_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","max"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.max(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),ku=An({mean_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","mean"),o=N(e,r.shape),a=y(tn(r.shape,o)[1]);return kn(function(t){var r=Bn(a);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32")).div(a)}}})(r)}}),Iu=An({min_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","min"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.min(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),Au=An({moments_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=N(e,(t=wn(t,"x","moments")).shape),o=t.mean(r,n),a=o.shape;n||(a=en(o.shape,r));var i=t.toFloat().sub(o.reshape(a)).square();return{mean:o,variance:i.mean(r,n)}}}),Tu=An({sum_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape);return kn(function(t){var e=rn(o,t.rank),r=o,a=t;null!=e&&(a=t.transpose(e),r=an(r.length,t.rank));var i=Dt.runKernel(function(t){return t.sum(a,r)},{permutedX:a});if(n){var s=en(i.shape,o);i=i.reshape(s)}return{value:i,gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32"))}}})(r)}}),Du=An({prod_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape),a=rn(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=an(i.length,r.rank));var u=Dt.runKernel(function(t){return t.prod(s,i)},{permutedX:s});if(n){var l=en(u.shape,o);u=u.reshape(l)}return u}});var Ou=An({equal_:function(t,e){var n,r=wn(t,"a","equal"),o=wn(e,"b","equal");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.equal(r,o)},{$a:r,$b:o})}}),_u=An({equalStrict_:function(t,e){var n=wn(t,"a","equalStrict"),r=wn(e,"b","equalStrict");return v(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),Mu=An({greater_:function(t,e){var n,r=wn(t,"a","greater"),o=wn(e,"b","greater");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.greater(r,o)},{$a:r,$b:o})}}),Fu=An({greaterEqual_:function(t,e){var n,r=wn(t,"a","greaterEqual"),o=wn(e,"b","greaterEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.greaterEqual(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return Xn(n)},$b:function(){return Xn(r)}}})}}),Bu=An({greaterEqualStrict_:function(t,e){var n=wn(t,"a","greaterEqualStrict"),r=wn(e,"b","greaterEqualStrict");return v(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),Pu=An({greaterStrict_:function(t,e){var n=wn(t,"a","greaterStrict"),r=wn(e,"b","greaterStrict");return v(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Lu=An({less_:function(t,e){var n,r=wn(t,"a","less"),o=wn(e,"b","less");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.less(r,o)},{$a:r,$b:o})}}),Wu=An({lessEqual_:function(t,e){var n,r=wn(t,"a","lessEqual"),o=wn(e,"b","lessEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.lessEqual(r,o)},{$a:r,$b:o})}}),Uu=An({lessEqualStrict_:function(t,e){var n=wn(t,"a","lessEqualStrict"),r=wn(e,"b","lessEqualStrict");return v(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),zu=An({lessStrict_:function(t,e){var n=wn(t,"a","lessStrict"),r=wn(e,"b","lessStrict");return v(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Vu=An({notEqual_:function(t,e){var n,r=wn(t,"a","notEqual"),o=wn(e,"b","notEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.notEqual(r,o)},{$a:r,$b:o})}}),Gu=An({notEqualStrict_:function(t,e){var n=wn(t,"a","notEqualStrict"),r=wn(e,"b","notEqualStrict");return v(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}});var qu=An({add_:function(t,e){var n,r=wn(t,"a","add"),o=wn(e,"b","add");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.add(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(o.shape)}}})}}),Hu=An({addN_:function(t){d(Array.isArray(t),function(){return"The argument passed to tf.addN() must be a list of tensors"}),d(t.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+t.length});var e=t.map(function(t,e){return wn(t,"tensors"+e,"addN")}),n=e[0];e.forEach(function(t){if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(function(t){if(!x(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var r=e;return Dt.runKernel(function(t){return t.addN(e)},r,function(t){var n={};return e.forEach(function(e,r){n[r]=function(){return t.clone()}}),n})}}),$u=An({addStrict_:function(t,e){var n=wn(t,"a","addStrict"),r=wn(e,"b","addStrict");return v(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),ju=An({atan2_:function(t,e){var n,r=wn(t,"a","atan2"),o=wn(e,"b","atan2");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.atan2(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=qu(n.square(),r.square()),o=t.mul(r.div(e)),i=io(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},$b:function(){var e=qu(n.square(),r.square()),o=is(t.mul(n.div(e))),i=io(r.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(r.shape)}}})}}),Ku=An({div_:function(t,e){var n,r=wn(t,"a","div"),o=wn(e,"b","div");if(n=Rt(r,o),r=n[0],o=n[1],"int32"===r.dtype&&"int32"===o.dtype)return Yu(r,o);var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.realDivide(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Xu=An({divStrict_:function(t,e){var n=wn(t,"a","div"),r=wn(e,"b","div");return v(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),Yu=An({floorDiv_:function(t,e){var n,r=wn(t,"a","floorDiv"),o=wn(e,"b","floorDiv");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.floorDiv(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Qu=An({maximum_:function(t,e){var n,r=wn(t,"a","maximum"),o=wn(e,"b","maximum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.maximum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.greaterEqual(r).toFloat())},$b:function(){return t.mul(n.less(r).toFloat())}}})}}),Ju=An({maximumStrict_:function(t,e){var n=wn(t,"a","maximumStrict"),r=wn(e,"b","maximumStrict");return v(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),Zu=An({minimum_:function(t,e){var n,r=wn(t,"a","minimum"),o=wn(e,"b","minimum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.minimum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.lessEqual(r).toFloat())},$b:function(){return t.mul(n.greater(r).toFloat())}}})}}),tl=An({minimumStrict_:function(t,e){var n=wn(t,"a","minimumStrict"),r=wn(e,"b","minimumStrict");return v(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),el=An({mod_:function(t,e){var n,r=wn(t,"a","mod"),o=wn(e,"b","mod");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.mod(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=io(n.shape,a);return e.length>0?t.sum(e).reshape(n.shape):t},$b:function(){var e=t.mul(n.div(r).floor().neg()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),nl=An({modStrict_:function(t,e){var n=wn(t,"a","modStrict"),r=wn(e,"b","modStrict");return v(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),rl=An({mul_:function(t,e){var n,r=wn(t,"a","mul"),o=wn(e,"b","mul");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.multiply(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.mul(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),ol=An({mulStrict_:function(t,e){var n=wn(t,"a","mul"),r=wn(e,"b","mul");return v(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),al=An({pow_:function(t,e){var n=wn(t,"base","pow"),r=wn(e,"exp","pow"),o=so(n.shape,r.shape);return t=n.cast(Ct(n.dtype,r.dtype)),e=r.cast(Ct(n.dtype,r.dtype)),Dt.runKernel(function(t,e){var o=t.pow(n,r);return e([n,r,o]),o},{$base:n,$exp:r},function(t,e){var n=e[0],r=e[1],a=e[2];return{$base:function(){var e=r.toFloat(),a=t.mul(e.mul(n.pow(e.sub(Bn(1))))),i=io(n.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(n.shape)},$exp:function(){var e=n.greater(0),i=n.log().where(e,Xn(n)),s=t.mul(a.mul(i)),u=io(r.shape,o);return u.length>0&&(s=s.sum(u)),s.reshape(r.shape)}}})}}),il=An({powStrict_:function(t,e){return v(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),sl=An({squaredDifference_:function(t,e){var n,r=wn(t,"a","squaredDifference"),o=wn(e,"b","squaredDifference");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.squaredDifference(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1],o=Bn(2);return{$a:function(){return t.mul(n.sub(r).mul(o))},$b:function(){return t.mul(r.sub(n).mul(o))}}})}}),ul=An({squaredDifferenceStrict_:function(t,e){var n=wn(t,"a","squaredDifferenceStrict"),r=wn(e,"b","squaredDifferenceStrict");return v(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),ll=An({sub_:function(t,e){var n,r=wn(t,"a","sub"),o=wn(e,"b","sub");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.subtract(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.neg().reshape(o.shape)}}})}}),cl=An({subStrict_:function(t,e){var n=wn(t,"a","subStrict"),r=wn(e,"b","subStrict");return v(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}});var hl=An({logicalAnd_:function(t,e){var n=wn(t,"a","logicalAnd","bool"),r=wn(e,"b","logicalAnd","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalAnd(n,r)},{$a:n,$b:r})}}),pl=An({logicalNot_:function(t){var e=wn(t,"x","logicalNot","bool");return Dt.runKernel(function(t){return t.logicalNot(e)},{$x:e})}}),fl=An({logicalOr_:function(t,e){var n=wn(t,"a","logicalOr","bool"),r=wn(e,"b","logicalOr","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalOr(n,r)},{$a:n,$b:r})}}),dl=An({logicalXor_:function(t,e){var n=wn(t,"a","logicalXor","bool"),r=wn(e,"b","logicalXor","bool");return so(n.shape,r.shape),fl(t,e).logicalAnd(hl(t,e).logicalNot())}}),vl=An({where_:function(t,e,n){var r=wn(e,"a","where"),o=wn(n,"b","where"),a=wn(t,"condition","where","bool");return v(r.shape,o.shape,"Error in where: "),1===a.rank?d(a.shape[0]===r.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):v(a.shape,o.shape,"Error in where: "),Dt.runKernel(function(t,e){var n=t.select(a,r,o);return e([a]),n},{$condition:a,$a:r,$b:o},function(t,e){var n=e[0];return{$condition:function(){return Xn(n).toFloat()},$a:function(){return t.mul(n.cast(t.dtype))},$b:function(){return t.mul(n.logicalNot().cast(t.dtype))}}})}}),ml=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:return[4,(e=wn(t,"condition","whereAsync","bool")).data()];case 1:return n=o.sent(),r=Zr(e.shape,n),t!==e&&e.dispose(),[2,r]}})})};var gl=An({elu_:function(t){var e=wn(t,"x","elu");return Dt.runKernel(function(t,n){var r=t.elu(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Dt.runKernel(function(e){return e.eluDer(t,n)},{dy:t,y:n})}}})}}),yl=An({leakyRelu_:function(t,e){void 0===e&&(e=.2);var n=wn(t,"x","leakyRelu");return Qu(Bn(e).mul(n),n)}}),xl=An({prelu_:function(t,e){var n=wn(t,"x","prelu"),r=wn(e,"alpha","prelu");return Dt.runKernel(function(t,e){var o=t.prelu(n,r);return e([n,r]),o},{$x:n,$alpha:r},function(t,e){var n=e[0],r=e[1],o=n.greater(0);return{$x:function(){return vl(o,t,t.mul(r))},$alpha:function(){var e=vl(o,Xn(t),t.mul(n)),a=io(r.shape,t.shape);return a.length>0&&(e=e.sum(a)),e.reshape(r.shape)}}})}}),wl=An({relu_:function(t){var e=wn(t,"x","relu");return"bool"===e.dtype?e.toInt():Dt.runKernel(function(t,n){var r=t.relu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mulStrict(n.step().toFloat())}}})}}),bl=An({selu_:function(t){var e=wn(t,"x","selu");return Dt.runKernel(function(t,n){var r=t.selu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){var e=n.greater(Bn(0)),r=Bn(bi),o=Bn(Ci),a=t.mul(o),i=t.mul(r).mul(n.toFloat().exp());return vl(e,a,i)}}})}});var Cl=An({transpose_:function(t,e){var n=wn(t,"x","transpose");return null==e&&(e=n.shape.map(function(t,e){return e}).reverse()),d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."}),e.forEach(function(t){d(t>=0&&t<n.rank,function(){return"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e})}),n.rank<=1?n.clone():Dt.runKernel(function(t){return t.transpose(n,e)},{$x:n},function(t){var n=on(e);return{$x:function(){return t.transpose(n)}}})}});var El=An({localResponseNormalization_:function(t,e,n,r,o){void 0===e&&(e=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=wn(t,"x","localResponseNormalization");d(4===a.rank||3===a.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."}),d(w(e),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+e+"."});var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=Dt.runKernel(function(t,a){var s=t.localResponseNormalization4D(i,e,n,r,o);return a([i,s]),s},{x4D:i},function(t,a){var i=a[0],s=a[1];return{x4D:function(){return Dt.runKernel(function(a){return a.LRNGrad(t,i,s,e,n,r,o)},{})}}});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}});var Rl=An({norm_:function(t,e,n,r){void 0===e&&(e="euclidean"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=function t(e,n,r){if(void 0===r&&(r=null),0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(Bn(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=wn(t,"x","norm"),e,n),a=o.shape;if(r){var i=N(n,t.shape);a=en(o.shape,i)}return o.reshape(a)}});function Sl(t,e){for(var n=[],r=t;r<e;++r)n.push(r);return n}function Nl(t){for(var e=[],n=0;n<t.length;++n)for(var r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var kl=An({gather_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","gather"),o=wn(e,"indices","gather","int32");n=N(n,r.shape)[0];var a=function(t,e,n){for(var r=t.shape[n],o=[],a=1,i=1,s=0;s<n;s++)o.push(t.shape[s]),a*=t.shape[s];for(s=0;s<e.rank;s++)o.push(e.shape[s]);for(s=n+1;s<t.rank;s++)o.push(t.shape[s]),i*=t.shape[s];return{batchSize:a,sliceSize:i,dimSize:r,outputShape:o}}(r,o,n);return Dt.runKernel(function(t,e){var a=t.gather(r,o.flatten(),n);return e([o]),a},{$x:r},function(t,e){var o=e[0];return{$x:function(){var e=r.shape,a=o.size,i=e.slice(0,n),s=i.length,u=e.slice(n,e.length).slice(1),l=u.length,c=Sl(0,s),h=Sl(s+1,s+1+l),p=Nl([i,[a],u]),f=t.reshape(p),d=o.reshape([a]),v=Nl([[s],c,h]),m=f.transpose(v),g=Il(m,d,r.shape[n]),y=on(v);return g=g.transpose(y)}}}).reshape(a.outputShape)}}),Il=An({unsortedSegmentSum_:function(t,e,n){var r=wn(t,"x","unsortedSegmentSum"),o=wn(e,"segmentIds","unsortedSegmentSum","int32");return d(w(n),function(){return"numSegments must be of dtype int"}),Dt.runKernel(function(t,e){var a=t.unsortedSegmentSum(r,o,n);return e([o]),a},{$x:r},function(t,e){var n=e[0];return{$x:function(){return function(t,e){for(var n=Qu(e,Xn(e)),r=kl(t,n),o=Fu(e,Bn(0,"int32")),a=r.rank-o.rank,i=0;i<a;++i)o=_r(o,i+1);o=hl(o,Gn(r.shape,"bool"));var s=Xn(r);return vl(o,r,s)}(t,n)}}})}});var Al=An({basicLSTMCell_:function(t,e,n,r,o,a){var i=wn(t,"forgetBias","basicLSTMCell"),s=wn(e,"lstmKernel","basicLSTMCell"),u=wn(n,"lstmBias","basicLSTMCell"),l=wn(r,"data","basicLSTMCell"),c=wn(o,"c","basicLSTMCell"),h=wn(a,"h","basicLSTMCell"),p=l.concat(h,1).matMul(s).add(u),f=p.shape[0],d=p.shape[1]/4,v=[f,d],m=p.slice([0,0],v),g=p.slice([0,d],v),y=p.slice([0,2*d],v),x=p.slice([0,3*d],v),w=m.sigmoid().mulStrict(g.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid())),b=w.tanh().mulStrict(x.sigmoid());return[w,b]}}),Tl=An({multiRNNCell_:function(t,e,n,r){for(var o=wn(e,"data","multiRNNCell"),a=bn(n,"c","multiRNNCell"),i=bn(r,"h","multiRNNCell"),s=o,u=[],l=0;l<t.length;l++){var c=t[l](s,a[l],i[l]);u.push(c[0]),u.push(c[1]),s=c[1]}var h=[],p=[];for(l=0;l<u.length;l+=2)h.push(u[l]),p.push(u[l+1]);return[h,p]}});var Dl=An({movingAverage_:function(t,e,n,r,o){void 0===o&&(o=!0);var a=wn(t,"v","movingAverage"),i=wn(e,"x","movingAverage"),s=wn(n,"decay","movingAverage");St(a,i),d(x(a.shape,i.shape),function(){return"Shape mismatch in v and x"});var u=Bn(1),l=u.sub(s),c=i.sub(a).mul(l);if(o){d(null!=r,function(){return"When using zeroDebias: true, step is required."});var h=wn(r,"step","movingAverage");c=c.div(u.sub(al(s,h)))}return a.add(c)}});var Ol=An({stridedSlice_:function(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");var l=wn(t,"x","stridedSlice");if(r.every(function(t){return 1===t})){var c=fn(l.shape,e,n,r,o,a,i,s,u),h=c[0],p=c[1],f=c[2],d=p.filter(function(t,e){return-1===f.indexOf(e)});return vu(l,h,p).reshape(d)}return Dt.runKernel(function(t){return t.stridedSlice(l,e,n,r,o,a,i,s,u)},{$x:l})}});var _l=An({topk_:function(t,e,n){void 0===e&&(e=1),void 0===n&&(n=!0);var r=wn(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=r.shape[r.shape.length-1];if(e>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+e);var a=Dt.runKernel(function(t){return t.topk(r,e,n)},{$x:r});return{values:a[0],indices:a[1]}}});var Ml=An({scatterND_:function(t,e,n){var r=wn(t,"indices","scatterND","int32"),o=wn(e,"updates","scatterND");return hn(o,r,n),Dt.runKernel(function(t){return t.scatterND(r,o,n)},{$indices:r,$updates:o})}});var Fl=An({fft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.fft(r)},{input:t}).reshape(t.shape)}}),Bl=An({ifft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.ifft(r)},{input:t}).reshape(t.shape)}}),Pl=An({rfft_:function(t){d("float32"===t.dtype,function(){return"The dtype for rfft() must be real value but got "+t.dtype});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.zerosLike(),o=On(t,r).as2D(n,e),a=Fl(o),i=Math.floor(e/2)+1,s=_n(a),u=Mn(a),l=s.split([i,e-i],s.shape.length-1),c=u.split([i,e-i],u.shape.length-1),h=t.shape.slice();return h[t.shape.length-1]=i,On(l[0],c[0]).reshape(h)}}),Ll=An({irfft_:function(t){var e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){var r=t.as2D(n,e),o=Bl(r);return _n(o)}var a=[n,2*(e-1)],i=_n(t).as2D(n,e),s=Mn(t).as2D(n,e),u=i.slice([0,1],[n,e-2]).reverse(1),l=s.slice([0,1],[n,e-2]).reverse(1).mul(Bn(-1)),c=i.concat(u,1),h=s.concat(l,1);return r=On(c,h).as2D(a[0],a[1]),o=Bl(r),_n(o)}}),Wl=Object.freeze({fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll});var Ul=An({sparseToDense_:function(t,e,n,r){void 0===r&&(r=0);var o=wn(t,"sparseIndices","sparseToDense","int32"),a=wn(e,"sparseValues","sparseToDense"),i=wn(r,"defaultValue","sparseToDense",a.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+t.shape+".");var o=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+a+".");var i=e.size;if(0!==e.rank&&(1!==e.rank||i!==o))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+o+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,a,n,i),Dt.runKernel(function(t){return t.sparseToDense(o,a,n,i)},{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}});var zl=An({gatherND_:function(t,e){var n=wn(e,"indices","gatherND","int32"),r=wn(t,"x","gatherND");return Dt.runKernel(function(t){return t.gatherND(r,n)},{$x:r,$indices:n})}});var Vl=An({dropout_:function(t,e,n,r){if(null!=n&&!x(t.shape,n))throw new Error("Non-default noise shape is not implemented yet: "+JSON.stringify(n));var o=qr(t.shape,0,1,"float32",r).greater(e);return o=o.div(ll(1,e)),t.mul(o)}});function Gl(t,e,n){for(var r=1-t%2,o=new Float32Array(t),a=0;a<t;++a){var i=2*Math.PI*a/(t+r-1);o[a]=e-n*Math.cos(i)}return Pn(o,"float32")}var ql,Hl=An({hannWindow_:function(t){return Gl(t,.5,.5)}}),$l=An({hammingWindow_:function(t){return Gl(t,.54,.46)}});!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ql||(ql={}));var jl=An({absoluteDifference_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","absoluteDifference"),a=wn(e,"predictions","absoluteDifference"),i=null;null!=n&&(i=wn(n,"weights","absoluteDifference")),v(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return Kl(s,i,r)}}),Kl=An({computeWeightedLoss_:function(t,e,n){void 0===n&&(n=ql.SUM_BY_NONZERO_WEIGHTS);var r=wn(t,"losses","computeWeightedLoss"),o=null;null!=e&&(o=wn(e,"weights","computeWeightedLoss"));var a=null==o?r:r.mul(o);if(n===ql.NONE)return a;if(n===ql.SUM)return a.sum();if(n===ql.MEAN){if(null==o)return a.mean();var i=r.size/o.size,s=a.sum().div(o.sum());return i>1?s.div(Bn(i)):s}if(n===ql.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(Bn(r.size));var u=o.mul(Gn(r.shape)).notEqual(Bn(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+n)}}),Xl=An({cosineDistance_:function(t,e,n,r,o){void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","cosineDistance"),i=wn(e,"predictions","cosineDistance"),s=null;null!=r&&(s=wn(r,"weights","cosineDistance")),v(a.shape,i.shape,"Error in cosineDistance: ");var u=Bn(1).sub(a.mul(i).sum(n,!0));return Kl(u,s,o)}}),Yl=An({hingeLoss_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","hingeLoss"),a=wn(e,"predictions","hingeLoss"),i=null;null!=n&&(i=wn(n,"weights","hingeLoss")),v(o.shape,a.shape,"Error in hingeLoss: ");var s=Bn(1);o=Bn(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return Kl(u,i,r)}}),Ql=An({huberLoss_:function(t,e,n,r,o){void 0===r&&(r=1),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","huberLoss"),i=wn(e,"predictions","huberLoss"),s=null;null!=n&&(s=wn(n,"weights","huberLoss")),v(a.shape,i.shape,"Error in huberLoss: ");var u=Bn(r),l=i.sub(a).abs(),c=Zu(l,u),h=l.sub(c),p=Bn(.5).mul(c.square()).add(u.mul(h));return Kl(p,s,o)}}),Jl=An({logLoss_:function(t,e,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","logLoss"),i=wn(e,"predictions","logLoss"),s=null;null!=n&&(s=wn(n,"weights","logLoss")),v(a.shape,i.shape,"Error in logLoss: ");var u=Bn(1),l=Bn(r),c=a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return Kl(c,s,o)}}),Zl=An({meanSquaredError_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","meanSquaredError"),a=wn(e,"predictions","meanSquaredError"),i=null;null!=n&&(i=wn(n,"weights","meanSquaredError")),v(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return Kl(s,i,r)}}),tc=An({sigmoidCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"multiClassLabels","sigmoidCrossEntropy"),i=wn(e,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","sigmoidCrossEntropy")),v(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(.5);a=a.mul(l.sub(u)).add(c.mul(u))}var h=function(t,e){var n=wn(t,"labels","sigmoidCrossEntropyWithLogits"),r=wn(e,"logits","sigmoidCrossEntropyWithLogits");v(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}(a,i);return Kl(h,s,o)}}),ec=An({softmaxCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"onehotLabels","softmaxCrossEntropy"),i=wn(e,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","softmaxCrossEntropy")),v(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(a.shape[1]);a=a.mul(l.sub(u)).add(u.div(c))}var h=function(t,e,n){if(void 0===n&&(n=-1),-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+n);return kn(function(t,e,r){var o=e.logSumExp([n],!0),a=e.toFloat().sub(o);return r([t,a]),{value:a.mul(t).neg().sum([n]),gradFunc:function(t,e){var r=e[0],o=e[1],a=en(t.shape,[n]);return[t.reshape(a).mul(r.toFloat().sub(o.exp())),t.reshape(a).mul(o.exp().sub(r.toFloat()))]}}})(t,e)}(a,i);return Kl(h,s,o)}}),nc=Object.freeze({get Reduction(){return ql},absoluteDifference:jl,computeWeightedLoss:Kl,cosineDistance:Xl,hingeLoss:Yl,huberLoss:Ql,logLoss:Jl,meanSquaredError:Zl,sigmoidCrossEntropy:tc,softmaxCrossEntropy:ec});function rc(t,e){return void 0===e&&(e=!1),Dt.tidy(function(){if(2!==t.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+t.shape.length+"D Tensor.");for(var n=t.shape[0],r=t.shape[1],o=Mr(n),a=t.clone(),i=Ln([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,l=function(t){var e,u=a,l=s,c=o;e=Dt.tidy(function(){var e=a.slice([t,t],[n-t,1]),u=e.norm(),l=a.slice([t,t],[1,1]),c=l.sign().neg(),h=l.sub(c.mul(u)),p=e.div(h);s=1===p.shape[0]?i.clone():i.concat(p.slice([1,0],[p.shape[0]-1,p.shape[1]]),0);var f=c.matMul(h).div(u).neg(),d=a.slice([t,0],[n-t,r]),v=f.mul(s);a=0===t?d.sub(v.matMul(s.transpose().matMul(d))):a.slice([0,0],[t,r]).concat(d.sub(v.matMul(s.transpose().matMul(d))),0);var m=o.slice([0,t],[n,o.shape[1]-t]);return o=0===t?m.sub(m.matMul(s).matMul(v.transpose())):o.slice([0,0],[n,t]).concat(m.sub(m.matMul(s).matMul(v.transpose())),1),[s,a,o]}),s=e[0],a=e[1],o=e[2],Be([u,l,c])},c=0;c<u;++c)l(c);return!e&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]})}var oc=An({gramSchmidt_:function(t){var e;if(Array.isArray(t)){e=!1,d(null!=t&&t.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var n=t[0].shape[0],r=function(e){d(t[e].shape[0]===n,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+t[e].shape[0]+" vs. "+n+")"})},o=1;o<t.length;++o)r(o)}else e=!0,t=dr(t,t.shape[0],0).map(function(t){return jr(t,[0])});d(t.length<=t[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+t.length+") exceeds number of dimensions ("+t[0].shape[0]+")."});var a=[],i=t,s=function(t){a.push(Dt.tidy(function(){var e=i[t];if(t>0)for(var n=0;n<t;++n){var r=Tu(a[n].mulStrict(e)).mul(a[n]);e=e.sub(r)}return e.div(Rl(e,"euclidean"))}))};for(o=0;o<t.length;++o)s(o);return e?Kr(a,0):a}}),ac=An({qr_:function(t,e){if(void 0===e&&(e=!1),t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return rc(t,e);var n=t.shape.slice(0,t.shape.length-2).reduce(function(t,e){return t*e}),r=Qr(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],a=[];return r.forEach(function(t){var n=rc(t,e),r=n[0],i=n[1];o.push(r),a.push(i)}),[Kr(o,0).reshape(t.shape),Kr(a,0).reshape(t.shape)]}}),ic=Object.freeze({gramSchmidt:oc,qr:ac});function sc(t,e,n,r,o){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY);var a=t.shape[0];return n=Math.min(n,a),d(0<=r&&r<=1,function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"}),d(2===t.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+t.rank+"'"}),d(4===t.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]}),d(1===e.rank,function(){return"scores must be a 1D tensor"}),d(e.shape[0]===a,function(){return"scores has incompatible shape with boxes. Expected "+a+", but was "+e.shape[0]}),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o}}var uc=An({resizeBilinear_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeBilinear");d(3===r.rank||4===r.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeBilinear(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeBilinearBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),lc=An({resizeNearestNeighbor_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeNearestNeighbor");d(3===r.rank||4===r.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."}),d("float32"===r.dtype||"int32"===r.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeNearestNeighbor(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeNearestNeighborBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),cc=An({nonMaxSuppression_:function(t,e,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=wn(t,"boxes","nonMaxSuppression"),i=wn(e,"scores","nonMaxSuppression"),s=sc(a,i,n,r,o);return n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold,Dt.runKernel(function(t){return t.nonMaxSuppression(a,i,n,r,o)},{$boxes:a})}}),hc=function(t,e,n,a,i){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),r(this,void 0,void 0,function(){var r,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return r=wn(t,"boxes","nonMaxSuppressionAsync"),s=wn(e,"scores","nonMaxSuppressionAsync"),u=sc(r,s,n,a,i),n=u.maxOutputSize,a=u.iouThreshold,i=u.scoreThreshold,[4,r.data()];case 1:return l=o.sent(),[4,s.data()];case 2:return c=o.sent(),h=ar(l,c,n,a,i),r!==t&&r.dispose(),s!==e&&s.dispose(),[2,h]}})})},pc=An({cropAndResize_:function(t,e,n,r,o,a){var i=wn(t,"image","cropAndResize","float32"),s=wn(e,"boxes","cropAndResize","float32"),u=wn(n,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var l=s.shape[0];return d(4===i.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."}),d(2===s.rank&&4===s.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+l+",4] but had shape "+s.shape+"."}),d(1===u.rank&&u.shape[0]===l,function(){return"Error in cropAndResize: boxInd must be have size ["+l+"] but had shape "+s.shape+"."}),d(2===r.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."}),d(r[0]>=1&&r[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+r}),d("bilinear"===o||"nearest"===o,function(){return"method must be bilinear or nearest, but was "+o}),Dt.runKernel(function(t,e){return t.cropAndResize(i,s,u,r,o,a)},{$image:i,$boxes:s})}}),fc=Object.freeze({resizeBilinear:uc,resizeNearestNeighbor:lc,nonMaxSuppression:cc,nonMaxSuppressionAsync:hc,cropAndResize:pc});var dc=An({matMul_:function(t,e,n,r,o,a){var i;void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===a&&(a="linear");var s=wn(t,"a","fused matMul"),u=wn(e,"b","fused matMul");i=Rt(s,u),s=i[0],u=i[1];var l=n?s.shape[s.rank-2]:s.shape[s.rank-1],c=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?s.shape[s.rank-1]:s.shape[s.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=s.shape.slice(0,-2),v=u.shape.slice(0,-2),m=y(f),g=y(v);d(s.rank>=2&&u.rank>=2&&s.rank===u.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+s.rank+" and "+u.rank+"."}),d(x(f,v),function(){return"Error in fused matMul: outer dimensions ("+f+") and ("+v+") of Tensors with shapes "+s.shape+" and "+u.shape+" must match."}),d(l===c,function(){return"Error in fused matMul: inner shapes ("+l+") and ("+c+") of Tensors with shapes "+s.shape+" and "+u.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var w,b=s.shape.slice(0,-2).concat([h,p]),C=n?s.as3D(m,l,h):s.as3D(m,h,l),E=r?u.as3D(g,p,c):u.as3D(g,c,p);null!=o&&so(b,(w=Rt(w=wn(o,"bias","fused matMul"),s)[0]).shape);var R={$a:C,$b:E};return null!=o&&(R.$bias=w),Dt.runKernel(function(t,e){var o=t.fusedBatchMatMul(C,E,n,r,w,a);return e([C,E,o]),o},R,function(t,e){var i,s=e[0],u=e[1],l=e[2];if(null==a||"linear"===a)i=t;else{if("relu"!==a)throw new Error("Gradient for activation "+a+" has not been implemented yet.");i=t.mul(l.step())}var c={};return null!=o&&(c={$bias:function(){var t=i,e=io(w.shape,i.shape);return e.length>0&&(t=t.sum(e)),t.reshape(w.shape)}}),n||r?!n&&r?Object.assign({$a:function(){return i.matMul(u,!1,!1)},$b:function(){return i.matMul(s,!0,!1)}},c):n&&!r?Object.assign({$a:function(){return u.matMul(i,!1,!0)},$b:function(){return s.matMul(i,!1,!1)}},c):Object.assign({$a:function(){return u.matMul(i,!0,!0)},$b:function(){return i.matMul(s,!0,!0)}},c):Object.assign({$a:function(){return i.matMul(u,!1,!0)},$b:function(){return s.matMul(i,!0,!1)}},c)}).reshape(b)}}),vc=Object.freeze({matMul:dc}),mc=Object.freeze({image:fc,linalg:ic,losses:nc,spectral:Wl,fused:vc,op:An,batchNormalization2d:As,batchNormalization3d:Ts,batchNormalization4d:Ds,batchNormalization:Os,batchNorm:_s,batchNorm2d:Ms,batchNorm3d:Fs,batchNorm4d:Bs,complex:On,real:_n,imag:Mn,concat:lr,concat1d:cr,concat2d:hr,concat3d:pr,concat4d:fr,split:dr,conv1d:Xs,conv2d:Ys,conv3d:Qs,conv2dDerFilter:Js,depthwiseConv2d:Zs,separableConv2d:tu,conv2dTranspose:eu,matMul:nu,dot:ru,outerProduct:ou,reverse:au,reverse1d:iu,reverse2d:su,reverse3d:uu,reverse4d:lu,maxPool:pu,avgPool:fu,pool:du,slice:vu,slice1d:mu,slice2d:gu,slice3d:yu,slice4d:xu,abs:Vi,acos:Gi,acosh:qi,asin:Hi,asinh:$i,atan:ji,atanh:Ki,ceil:Xi,clipByValue:Yi,cos:Qi,cosh:Ji,erf:Zi,exp:ts,expm1:es,floor:ns,log:rs,log1p:os,logSigmoid:as,neg:is,reciprocal:ss,round:us,rsqrt:ls,sigmoid:cs,sign:hs,isNaN:ps,isInf:fs,isFinite:ds,sin:vs,sinh:ms,softplus:gs,sqrt:ys,square:xs,step:ws,tan:bs,tanh:Cs,all:bu,any:Cu,argMax:Eu,argMin:Ru,logSumExp:Su,max:Nu,mean:ku,min:Iu,moments:Au,sum:Tu,prod:Du,equal:Ou,equalStrict:_u,greater:Mu,greaterEqual:Fu,greaterEqualStrict:Bu,greaterStrict:Pu,less:Lu,lessEqual:Wu,lessEqualStrict:Uu,lessStrict:zu,notEqual:Vu,notEqualStrict:Gu,add:qu,addN:Hu,addStrict:$u,atan2:ju,div:Ku,divStrict:Xu,floorDiv:Yu,maximum:Qu,maximumStrict:Ju,minimum:Zu,minimumStrict:tl,mod:el,modStrict:nl,mul:rl,mulStrict:ol,pow:al,powStrict:il,squaredDifference:sl,squaredDifferenceStrict:ul,sub:ll,subStrict:cl,elu:gl,leakyRelu:yl,prelu:xl,relu:wl,selu:bl,logicalAnd:hl,logicalNot:pl,logicalOr:fl,logicalXor:dl,where:vl,whereAsync:ml,buffer:Nr,print:kr,batchToSpaceND:Ir,cast:Ar,clone:Tr,cumsum:Dr,depthToSpace:Or,expandDims:_r,eye:Mr,multinomial:Fr,oneHot:Br,pad:Pr,pad1d:Lr,pad2d:Wr,pad3d:Ur,pad4d:zr,rand:Vr,randomNormal:Gr,randomUniform:qr,reshape:Hr,spaceToBatchND:$r,squeeze:jr,stack:Kr,tile:Xr,truncatedNormal:Yr,unstack:Qr,setdiff1dAsync:Jr,fill:Hn,linspace:$n,ones:Gn,range:jn,scalar:Bn,tensor:Fn,tensor1d:Pn,tensor2d:Ln,tensor3d:Wn,tensor4d:Un,tensor5d:zn,tensor6d:Vn,zeros:qn,onesLike:Kn,zerosLike:Xn,transpose:Cl,softmax:Tn,logSoftmax:Dn,localResponseNormalization:El,norm:Rl,gather:kl,unsortedSegmentSum:Il,basicLSTMCell:Al,multiRNNCell:Tl,movingAverage:Dl,stridedSlice:Ol,topk:_l,scatterND:Ml,fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll,sparseToDense:Ul,gatherND:zl,dropout:Vl,hannWindow:Hl,hammingWindow:$l});var gc=function(){function t(){this.blockSize=48,this.firstUse=!0,a.get("IS_BROWSER")&&(this.fromPixels2DContext=document.createElement("canvas").getContext("2d")),this.data=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.firstUse&&(this.firstUse=!1,a.get("IS_NODE")&&je("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")),this.data.has(t))throw new Error("Data buffer is already registered");this.data.set(t,{dtype:n})},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendCPU.write(): values can not be null");this.data.get(t).values=e},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n,r;if(a.get("IS_NODE")&&null==t.getContext)throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");if(null!=t.getContext)n=t.getContext("2d").getImageData(0,0,t.width,t.height).data;else if(t instanceof ImageData)n=t.data;else{if(!(t instanceof HTMLImageElement||t instanceof HTMLVideoElement))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(null==this.fromPixels2DContext)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),n=this.fromPixels2DContext.getImageData(0,0,t.width,t.height).data}if(4===e)r=new Int32Array(n);else{var o=t.width*t.height;r=new Int32Array(o*e);for(var i=0;i<o;i++)for(var s=0;s<e;++s)r[i*e+s]=n[4*i+s]}return Wn(r,[t.height,t.width,e],"int32")},t.prototype.read=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.readSync(t)]})})},t.prototype.readSync=function(t){var e=this.data.get(t),n=e.dtype,r=e.complexTensors;return"complex64"===n?er(r.real.dataSync(),r.imag.dataSync()):this.data.get(t).values},t.prototype.disposeData=function(t){if(this.data.has(t)){var e=this.data.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=j(),t(),[2,{kernelMs:j()-e}]})})},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.complex=function(t,e){var n=ft.make(t.shape,{},"complex64");return this.data.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},t.prototype.assertNotComplex=function(t,e){Array.isArray(t)||(t=[t]),t.forEach(function(t){null!=t&&d("complex64"!==t.dtype,function(){return e+" does not support complex64 tensors."})})},t.prototype.slice=function(t,e,n){if(this.assertNotComplex(t,"slice"),mn(t.shape,e,n)){var r=gn(e,t.strides),o=y(n);return Fn(t.dataSync().subarray(r,r+o),n,t.dtype)}for(var a=Nr(n,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s).map(function(t,n){return t+e[n]});a.values[s]=i.get.apply(i,u)}return a.toTensor()},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){this.assertNotComplex(t,"stridedSlice");var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);for(var d=Nr(h,t.dtype),v=t.bufferSync(),m=0;m<d.size;m++){for(var g=d.indexToLoc(m),y=new Array(g.length),x=0;x<y.length;x++)y[x]=g[x]*r[x]+c[x];d.set.apply(d,[v.get.apply(v,y)].concat(g))}return d.toTensor().reshape(f)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reverse=function(t,e){this.assertNotComplex(t,"reverse");for(var n=Nr(t.shape,t.dtype),r=t.bufferSync(),o=function(o){var a=n.indexToLoc(o),i=a.slice();e.forEach(function(e){return i[e]=t.shape[e]-1-i[e]}),n.set.apply(n,[r.get.apply(r,i)].concat(a))},a=0;a<n.size;a++)o(a);return n.toTensor()},t.prototype.concat=function(t,e){this.assertNotComplex(t,"concat");var n=t.map(function(t){var n=y(t.shape.slice(e));return t.as2D(-1,n)}),r=sn(n.map(function(t){return t.shape}),1),o=Nr(r,t[0].dtype).values;if(1===n[0].shape[0]){var a=0;n.forEach(function(t){o.set(t.dataSync(),a),a+=t.size})}else{var i=0;n.forEach(function(t){for(var e=t.dataSync(),n=0,a=0;a<t.shape[0];++a)for(var s=a*r[1]+i,u=0;u<t.shape[1];++u)o[s+u]=e[n++];i+=t.shape[1]})}var s=sn(t.map(function(t){return t.shape}),e);return Fn(o,s,t[0].dtype)},t.prototype.neg=function(t){return this.assertNotComplex(t,"neg"),this.multiply(Bn(-1),t)},t.prototype.add=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t+n,imag:e+r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t+e})},t.prototype.addN=function(t){this.assertNotComplex(t,"addN");for(var e=t.map(function(t){return t.dataSync()}),n=Nr(t[0].shape,t[0].dtype),r=n.values,o=0;o<t.length;o++)for(var a=e[o],i=0;i<r.length;i++)r[i]+=a[i];return n.toTensor()},t.prototype.subtract=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t-n,imag:e-r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t-e})},t.prototype.pow=function(t,e){return this.assertNotComplex([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.pow(t,e)})},t.prototype.batchMatMul=function(t,e,n,r){this.assertNotComplex([t,e],"matMul");for(var o=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],s=t.shape[0],u=t.dataSync(),l=e.dataSync(),c=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],h=c[0],p=c[1],f=c[2],d=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],v=d[0],m=d[1],g=d[2],y=a*i,x=Nr([s,a,i],t.dtype),w=x.values,b=this.blockSize,C=0;C<s;C++)for(var E=0;E<a;E+=b)for(var R=0;R<i;R+=b)for(var S=0;S<o;S+=b)for(var N=Math.min(E+b,a),k=Math.min(R+b,i),I=Math.min(S+b,o),A=E;A<N;A++)for(var T=R;T<k;T++){for(var D=0,O=S;O<I;O++)D+=u[C*h+A*p+O*f]*l[O*v+T*m+C*g];w[C*y+(A*i+T)]+=D}return x.toTensor()},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=this.batchMatMul(t,e,n,r);return o&&(i=this.add(i,o)),a&&(i=function(t,e,n){if("linear"===e)return t.linear(n);if("relu"===e)return t.relu(n);throw new Error("Activation "+e+" has not been implemented for the CPU backend.")}(this,a,i)),i},t.prototype.multiply=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t*n-e*r,imag:t*r+e*n}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t*e})},t.prototype.realDivide=function(t,e){this.assertNotComplex([t,e],"realDivide");return this.broadcastedBinaryOp(t,e,"float32",function(t,e){return t/e})},t.prototype.floorDiv=function(t,e){this.assertNotComplex([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",function(t,e){return Math.floor(t/e)})},t.prototype.sum=function(t,e){this.assertNotComplex(t,"sum"),nn("sum",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=0,p=0;p<i;++p)h+=u[c+p];s[l]=h}return a},t.prototype.prod=function(t,e){this.assertNotComplex(t,"sum");for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=1,p=0;p<i;++p)h*=u[c+p];s[l]=h}return a},t.prototype.unsortedSegmentSum=function(t,e,n){this.assertNotComplex(t,"unsortedSegmentSum");for(var r=[],o=t.rank-e.rank,a=0;a<o;++a)e=e.expandDims(a+1);for(a=0;a<n;++a){var i=Bn(a,"int32"),s=Ou(i,e).asType("float32").mul(t).sum(0);r.push(s)}return Kr(r)},t.prototype.argMin=function(t,e){this.assertNotComplex(t,"argMin");var n=[e];nn("argMin",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v<p&&(p=v,f=d)}u[c]=f}return i},t.prototype.argMax=function(t,e){this.assertNotComplex(t,"argMax");var n=[e];nn("argMax",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v>p&&(p=v,f=d)}u[c]=f}return i},t.prototype.cumsum=function(t,e,n,r){if(this.assertNotComplex(t,"cumsum"),e!==t.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(t.rank-1)+" but got axis="+e);for(var o=Ct(t.dtype,"int32"),a=qn(t.shape,o),i=a.dataSync(),s=t.dataSync(),u=t.shape[t.rank-1],l=r?function(t,e){return t+u-e-1}:function(t,e){return t+e},c=0;c<s.length;c+=u)for(var h=0;h<u;h++){var p=l(c,h);if(0===h)i[p]=n?0:s[p];else{var f=l(c,h-1);i[p]=n?s[f]+i[f]:s[p]+i[f]}}return a},t.prototype.equal=function(t,e){return this.assertNotComplex([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t===e?1:0})},t.prototype.notEqual=function(t,e){return this.assertNotComplex([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t!==e?1:0})},t.prototype.less=function(t,e){return this.assertNotComplex([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<e?1:0})},t.prototype.lessEqual=function(t,e){return this.assertNotComplex([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<=e?1:0})},t.prototype.greater=function(t,e){return this.assertNotComplex([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>e?1:0})},t.prototype.greaterEqual=function(t,e){return this.assertNotComplex([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>=e?1:0})},t.prototype.logicalNot=function(t){this.assertNotComplex(t,"logicalNot");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e[r]?0:1;return ft.make(t.shape,{values:n},"bool")},t.prototype.logicalAnd=function(t,e){return this.assertNotComplex([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t&&e})},t.prototype.logicalOr=function(t,e){return this.assertNotComplex([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t||e})},t.prototype.select=function(t,e,n){this.assertNotComplex([t,e,n],"select");for(var r=t.dataSync(),o=e.dataSync(),a=n.dataSync(),i=qn(e.shape,Ct(e.dtype,n.dtype)),s=i.dataSync(),u=0,l=0===t.rank||t.rank>1||1===e.rank?1:e.shape[1],c=0;c<r.length;c++)for(var h=0;h<l;h++)1===r[c]?s[u++]=o[c]:s[u++]=a[c];return i},t.prototype.where=function(t){this.assertNotComplex([t],"where");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return this.assertNotComplex(t,"topk"),ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){this.assertNotComplex(t,"min"),nn("min",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f<h&&(h=f)}s[l]=h}return a},t.prototype.minimum=function(t,e){return this.assertNotComplex([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.min(t,e)})},t.prototype.mod=function(t,e){return this.assertNotComplex([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})},t.prototype.max=function(t,e){this.assertNotComplex(t,"max"),nn("max",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f>h&&(h=f)}s[l]=h}return a},t.prototype.maximum=function(t,e){return this.assertNotComplex([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.max(t,e)})},t.prototype.all=function(t,e){this.assertNotComplex(t,"all"),nn("all",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h&&f}s[l]=h}return a},t.prototype.any=function(t,e){this.assertNotComplex(t,"any"),nn("any",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h||f}s[l]=h}return a},t.prototype.squaredDifference=function(t,e){return this.assertNotComplex([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t-e;return n*n})},t.prototype.ceil=function(t){this.assertNotComplex(t,"ceil");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return ft.make(t.shape,{values:n})},t.prototype.floor=function(t){this.assertNotComplex(t,"floor");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return ft.make(t.shape,{values:n})},t.prototype.sign=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)e[r]<0?n[r]=-1:e[r]>0?n[r]=1:n[r]=0;return ft.make(t.shape,{values:n})},t.prototype.isNaN=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isInf=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isFinite=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.round=function(t){this.assertNotComplex(t,"round");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=Math.floor(e[r]);e[r]-o<.5?n[r]=Math.floor(e[r]):e[r]-o>.5?n[r]=Math.ceil(e[r]):n[r]=o%2==0?o:o+1}return ft.make(t.shape,{values:n})},t.prototype.exp=function(t){this.assertNotComplex(t,"exp");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return ft.make(t.shape,{values:n})},t.prototype.expm1=function(t){this.assertNotComplex(t,"expm1");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return ft.make(t.shape,{values:n})},t.prototype.log=function(t){this.assertNotComplex(t,"log");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log(o)}return ft.make(t.shape,{values:n})},t.prototype.log1p=function(t){this.assertNotComplex(t,"log1p");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log1p(o)}return ft.make(t.shape,{values:n})},t.prototype.sqrt=function(t){this.assertNotComplex(t,"sqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.rsqrt=function(t){this.assertNotComplex(t,"rsqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=1/Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.square=function(t){this.assertNotComplex(t,"square");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=o*o}return ft.make(t.shape,{values:n})},t.prototype.reciprocal=function(t){this.assertNotComplex(t,"reciprocal");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=1/e[r];return ft.make(t.shape,{values:n})},t.prototype.linear=function(t){return t},t.prototype.relu=function(t){this.assertNotComplex(t,"relu");for(var e=qn(t.shape,t.dtype),n=e.dataSync(),r=t.dataSync(),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return e},t.prototype.prelu=function(t,e){return this.assertNotComplex([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return t<0?e*t:t})},t.prototype.elu=function(t){this.assertNotComplex(t,"elu");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r];e[r]=o>=0?o:Math.exp(o)-1}return ft.make(t.shape,{values:e})},t.prototype.eluDer=function(t,e){this.assertNotComplex([t,e],"eluDer");for(var n=new Float32Array(e.size),r=e.dataSync(),o=t.dataSync(),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1)}return ft.make(e.shape,{values:n})},t.prototype.selu=function(t){this.assertNotComplex(t,"selu");for(var e=bi,n=Ci,r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:e*(Math.exp(i)-1)}return ft.make(t.shape,{values:r})},t.prototype.clip=function(t,e,n){this.assertNotComplex(t,"clip");for(var r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<e?e:i}return ft.make(t.shape,{values:r})},t.prototype.abs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return ft.make(t.shape,{values:e})},t.prototype.complexAbs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<t.size;++r){var o=n[2*r],a=n[2*r+1];e[r]=Math.hypot(o,a)}return ft.make(t.shape,{values:e})},t.prototype.int=function(t){this.assertNotComplex(t,"int");for(var e=new Int32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=n[r];return ft.make(t.shape,{values:e},"int32")},t.prototype.sigmoid=function(t){this.assertNotComplex(t,"sigmoid");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return ft.make(t.shape,{values:e})},t.prototype.softplus=function(t){this.assertNotComplex(t,"softplus");for(var e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o]>-e,i=r[o]<e,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u}return ft.make(t.shape,{values:n})},t.prototype.sin=function(t){this.assertNotComplex(t,"sin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cos=function(t){this.assertNotComplex(t,"cos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tan=function(t){this.assertNotComplex(t,"tan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asin=function(t){this.assertNotComplex(t,"asin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acos=function(t){this.assertNotComplex(t,"acos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan=function(t){this.assertNotComplex(t,"atan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan2=function(t,e){return this.assertNotComplex([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.atan2(t,e)})},t.prototype.sinh=function(t){this.assertNotComplex(t,"sinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cosh=function(t){this.assertNotComplex(t,"cosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tanh=function(t){this.assertNotComplex(t,"tanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=b(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asinh=function(t){this.assertNotComplex(t,"asinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acosh=function(t){this.assertNotComplex(t,"acosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atanh=function(t){this.assertNotComplex(t,"atanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.erf=function(t){this.assertNotComplex(t,"erf");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r],a=1/(1+.3275911*o);e[r]=1-((((1.061405429*a-1.453152027)*a+1.421413741)*a-.284496736)*a+.254829592)*a*Math.exp(-o*o)}return ft.make(t.shape,{values:e})},t.prototype.step=function(t,e){void 0===e&&(e=0),this.assertNotComplex(t,"step");for(var n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:e}return ft.make(t.shape,{values:n})},t.prototype.conv2d=function(t,e,n){this.assertNotComplex([t,e],"conv2d");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=Nr(n.outShape,t.dtype),c=t.dataSync(),h=e.dataSync(),p=l.values,f=0;f<n.batchSize;++f)for(var d=f*t.strides[0],v=f*l.strides[0],m=0;m<n.outHeight;++m)for(var g=v+m*l.strides[1],y=m*n.strideHeight-s,x=0;x<r;x++){var w=y+x*a;if(!(w<0||w>=n.inHeight))for(var b=x*e.strides[0],C=d+w*t.strides[1],E=0;E<n.outWidth;++E)for(var R=g+E*n.outChannels,S=E*n.strideWidth-u,N=0;N<o;N++){var k=S+N*i;if(!(k<0||k>=n.inWidth))for(var I=b+N*e.strides[1],A=C+k*n.inChannels,T=I,D=0;D<n.inChannels;++D){for(var O=c[A+D],_=0;_<n.outChannels;++_)p[R+_]+=O*h[T+_];T+=n.outChannels}}}return l.toTensor()},t.prototype.conv3d=function(t,e,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,p=Nr(n.outShape,t.dtype),f=t.dataSync(),d=e.dataSync(),v=p.values,m=0;m<n.batchSize;++m)for(var g=m*t.strides[0],y=m*p.strides[0],x=0;x<n.outDepth;++x)for(var w=y+x*p.strides[1],b=x*n.strideDepth-l,C=0;C<r;C++){var E=b+C*i;if(!(E<0||E>=n.inDepth))for(var R=C*e.strides[0],S=g+E*t.strides[1],N=0;N<n.outHeight;++N)for(var k=w+N*p.strides[2],I=N*n.strideHeight-h,A=0;A<o;A++){var T=I+A*s;if(!(T<0||T>=n.inHeight))for(var D=R+A*e.strides[1],O=S+T*t.strides[2],_=0;_<n.outWidth;++_)for(var M=k+_*n.outChannels,F=_*n.strideWidth-c,B=0;B<a;B++){var P=F+B*u;if(!(P<0||P>=n.inWidth))for(var L=D+B*e.strides[2],W=O+P*n.inChannels,U=L,z=0;z<n.inChannels;++z){for(var V=f[W+z],G=0;G<n.outChannels;++G)v[M+G]+=V*d[U+G];U+=n.outChannels}}}}return p.toTensor()},t.prototype.conv2dDerInput=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=0;O<x;++O)for(var _=0;_<C;++_)for(var M=0;M<E;++M)for(var F=M-T,B=Math.max(0,Math.ceil(F/I)),P=Math.min(N,(w+F)/I),L=0;L<R;++L){for(var W=L-D,U=Math.max(0,Math.ceil(W/A)),z=Math.min(k,(b+W)/A),V=0,G=B;G<P;++G)for(var q=G*I-F,H=U;H<z;++H)for(var $=h*O+p*G+f*H,j=m*(w-1-q)+g*(b-1-(H*A-W))+y*_,K=0;K<S;++K){V+=l[$+K]*d[j+K]}o[i*O+s*M+u*L+_]=V}return r.toTensor()},t.prototype.conv3dDerInput=function(t,e,n){for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=a[3],c=t.dataSync(),h=t.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=n.batchSize,E=n.filterDepth,R=n.filterHeight,S=n.filterWidth,N=n.inChannels,k=n.inDepth,I=n.inHeight,A=n.inWidth,T=n.outChannels,D=n.outDepth,O=n.outHeight,_=n.outWidth,M=n.strideDepth,F=n.strideHeight,B=n.strideWidth,P=E-1-n.padInfo.front,L=R-1-n.padInfo.top,W=S-1-n.padInfo.left,U=0;U<C;++U)for(var z=0;z<N;++z)for(var V=0;V<k;++V)for(var G=V-P,q=Math.max(0,Math.ceil(G/M)),H=Math.min(D,(E+G)/M),$=0;$<I;++$)for(var j=$-L,K=Math.max(0,Math.ceil(j/F)),X=Math.min(O,(R+j)/F),Y=0;Y<A;++Y){for(var Q=Y-W,J=Math.max(0,Math.ceil(Q/B)),Z=Math.min(_,(S+Q)/B),tt=0,et=q;et<H;++et)for(var nt=et*M-G,rt=K;rt<X;++rt)for(var ot=rt*F-j,at=J;at<Z;++at)for(var it=p*U+f*et+d*rt+v*at,st=y*(E-1-nt)+x*(R-1-ot)+w*(S-1-(at*B-Q))+b*z,ut=0;ut<T;++ut){tt+=c[it+ut]*m[st+ut]}o[i*U+s*V+u*$+l*Y+z]=tt}return r.toTensor()},t.prototype.conv2dDerFilter=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=t.bufferSync(),h=e.bufferSync(),p=0;p<a;++p)for(var f=Math.max(0,Math.ceil((l-p)/r)),d=Math.min(n.outHeight,(n.inHeight+l-p)/r),v=0;v<i;++v)for(var m=Math.max(0,Math.ceil((u-v)/o)),g=Math.min(n.outWidth,(n.inWidth+u-v)/o),y=0;y<n.inChannels;++y)for(var x=0;x<n.outChannels;++x){for(var w=0,b=0;b<n.batchSize;++b)for(var C=f;C<d;++C)for(var E=p+C*r-l,R=m;R<g;++R){var S=v+R*o-u;w+=c.get(b,E,S,y)*h.get(b,C,R,x)}s.set(w,p,v,y,x)}return s.toTensor()},t.prototype.conv3dDerFilter=function(t,e,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,l=Nr(n.filterShape,"float32"),c=l.values,h=l.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=t.dataSync(),E=t.strides,R=E[0],S=E[1],N=E[2],k=E[3],I=n.padInfo.front,A=n.padInfo.left,T=n.padInfo.top,D=0;D<i;++D)for(var O=Math.max(0,Math.ceil((I-D)/r)),_=Math.min(n.outDepth,(n.inDepth+I-D)/r),M=D*p,F=0;F<s;++F)for(var B=Math.max(0,Math.ceil((T-F)/o)),P=Math.min(n.outHeight,(n.inHeight+T-F)/o),L=F*f+M,W=0;W<u;++W)for(var U=Math.max(0,Math.ceil((A-W)/a)),z=Math.min(n.outWidth,(n.inWidth+A-W)/a),V=W*d+L,G=0;G<n.inChannels;++G)for(var q=G*v+V,H=0;H<n.outChannels;++H){for(var $=0,j=0;j<n.batchSize;++j)for(var K=j*R,X=j*y,Y=O;Y<_;++Y)for(var Q=(D+Y*r-I)*S+K,J=Y*x+X,Z=B;Z<P;++Z)for(var tt=(F+Z*o-T)*N+Q,et=Z*w+J,nt=U;nt<z;++nt){var rt=nt*b+et;$+=C[(W+nt*a-A)*k+tt+G]*m[rt+H]}c[q+H]=$}return l.toTensor()},t.prototype.depthwiseConv2D=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2D");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=n.outChannels/n.inChannels,c=Nr(n.outShape,t.dtype),h=t.dataSync(),p=e.dataSync(),f=c.values,d=0;d<n.batchSize;++d)for(var v=d*t.strides[0],m=d*c.strides[0],g=0;g<n.outHeight;++g)for(var y=m+g*c.strides[1],x=g*n.strideHeight-s,w=0;w<r;++w){var b=x+w*a;if(!(b<0||b>=n.inHeight))for(var C=w*e.strides[0],E=v+b*t.strides[1],R=0;R<n.outWidth;++R)for(var S=y+R*c.strides[2],N=R*n.strideWidth-u,k=0;k<o;++k){var I=N+k*i;if(!(I<0||I>=n.inWidth))for(var A=C+k*e.strides[1],T=E+I*n.inChannels,D=S,O=A,_=0;_<n.inChannels;++_){for(var M=h[T+_],F=0;F<l;++F)f[D+F]+=M*p[O+F];D+=l,O+=l}}}return c.toTensor()},t.prototype.depthwiseConv2DDerInput=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=S/C,_=0;_<x;++_)for(var M=0;M<C;++M)for(var F=0;F<E;++F)for(var B=F-T,P=Math.max(0,Math.ceil(B/I)),L=Math.min(N,(w+B)/I),W=0;W<R;++W){for(var U=W-D,z=Math.max(0,Math.ceil(U/A)),V=Math.min(k,(b+U)/A),G=0,q=P;q<L;++q)for(var H=q*I-B,$=z;$<V;++$)for(var j=h*_+p*q+f*$,K=m*(w-1-H)+g*(b-1-($*A-U))+y*M,X=0;X<O;++X){G+=l[j+(M*O+X)]*d[K+X]}o[i*_+s*F+u*W+M]=G}return r.toTensor()},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,h=t.bufferSync(),p=e.bufferSync(),f=0;f<a;++f)for(var d=Math.max(0,Math.ceil((l-f)/r)),v=Math.min(n.outHeight,(n.inHeight+l-f)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((u-m)/o)),y=Math.min(n.outWidth,(n.inWidth+u-m)/o),x=0;x<n.outChannels;++x){for(var w=Math.trunc(x/c),b=x%c,C=0,E=0;E<n.batchSize;++E)for(var R=d;R<v;++R)for(var S=f+R*r-l,N=g;N<y;++N){var k=m+N*o-u;C+=h.get(E,S,k,w)*p.get(E,R,N,x)}s.set(C,f,m,w,b)}return s.toTensor()},t.prototype.tile=function(t,e){this.assertNotComplex(t,"tile");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];var o=Nr(n,t.dtype),a=t.bufferSync();for(r=0;r<o.values.length;++r){for(var i=o.indexToLoc(r),s=new Array(t.rank),u=0;u<s.length;u++)s[u]=i[u]%t.shape[u];var l=a.locToIndex(s);o.values[r]=a.values[l]}return o.toTensor()},t.prototype.pad=function(t,e,n){this.assertNotComplex(t,"pad");var r=e.map(function(e,n){return e[0]+t.shape[n]+e[1]}),o=e.map(function(t){return t[0]}),a=t.bufferSync(),i=Nr(r,t.dtype);0!==n&&i.values.fill(n);for(var s=0;s<t.size;s++){var u=a.indexToLoc(s),l=u.map(function(t,e){return t+o[e]});i.set.apply(i,[a.get.apply(a,u)].concat(l))}return i.toTensor()},t.prototype.transpose=function(t,e){this.assertNotComplex(t,"transpose");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[e[r]];var o=t.dataSync(),a=Nr(n,t.dtype),i=t.bufferSync();for(r=0;r<t.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),l=0;l<u.length;l++)u[l]=s[e[l]];var c=a.locToIndex(u);a.values[c]=o[r]}return a.toTensor()},t.prototype.gather=function(t,e,n){this.assertNotComplex([t,e],"gather");var r=t.shape.slice(),o=e.dataSync();r[n]=o.length;for(var a=Nr(r,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s),l=u.slice();l[n]=o[u[n]];var c=i.locToIndex(l);a.values[s]=i.values[c]}return a.toTensor()},t.prototype.batchToSpaceND=function(t,e,n){this.assertNotComplex([t],"batchToSpaceND");var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){this.assertNotComplex([t],"spaceToBatchND");var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.pool=function(t,e,n){this.assertNotComplex(t,"pool");for(var r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,p=t.dataSync(),f=Nr(e.outShape,t.dtype),d=f.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],y=0;y<e.batchSize;++y)for(var x=y*v,w=y*t.strides[0],b=0;b<e.inChannels;++b)for(var C=0;C<e.outHeight;++C)for(var E=C*r-l,R=Math.max(0,E),S=Math.min(e.inHeight,s+E),N=x+C*m,k=0;k<e.outWidth;++k){for(var I=k*o-c,A=Math.max(0,I),T=Math.min(e.inWidth,u+I),D=h,O=0,_=0,M=R;M<S;M+=a){for(var F=w+M*t.strides[1],B=A;B<T;B+=i){var P=p[F+B*t.strides[2]+b];"max"===n&&P>D?D=P:"avg"===n&&(O+=P,_++)}if(isNaN(D))break}d[N+k*g+b]="avg"===n?O/_:D}return f.toTensor()},t.prototype.maxPool=function(t,e){return this.pool(t,e,"max")},t.prototype.maxPoolPositions=function(t,e){for(var n=Nr(e.outShape,"int32"),r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h=t.bufferSync(),p=0;p<e.batchSize;++p)for(var f=0;f<e.inChannels;++f)for(var d=0;d<e.outHeight;++d){for(var v=d*r-l,m=v;m<0;)m+=a;for(var g=Math.min(e.inHeight,s+v),y=0;y<e.outWidth;++y){for(var x=y*o-c,w=x;w<0;)w+=i;for(var b=Math.min(e.inWidth,u+x),C=Number.NEGATIVE_INFINITY,E=-1,R=m;R<g;R+=a)for(var S=R-v,N=w;N<b;N+=i){var k=N-x,I=h.get(p,R,N,f);I>C&&(C=I,E=S*u+k)}n.set(E,p,d,y,f)}}return n.toTensor()},t.prototype.maxPoolBackprop=function(t,e,n,r){this.assertNotComplex([e,n],"maxPoolBackprop");for(var o=this.maxPoolPositions(e,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,h=c-1-r.padInfo.left,p=l-1-r.padInfo.top,f=Nr(e.shape,"float32"),d=o.bufferSync(),v=t.bufferSync(),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var y=0;y<r.inHeight;++y)for(var x=0;x<r.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/a;if(!(R<0||R>=r.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/i;if(!(N<0||N>=r.outWidth||Math.floor(N)!==N)){var k=l*c-1-d.get(m,R,N,g)===E*c+S?1:0;if(0!==k)C+=v.get(m,R,N,g)*k}}}f.set(C,m,y,x,g)}return f.toTensor()},t.prototype.avgPoolBackprop=function(t,e,n){this.assertNotComplex([t,e],"avgPoolBackprop");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,p=l-1-n.padInfo.top,f=Nr(e.shape,"float32"),d=1/(a*i),v=t.bufferSync(),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var y=0;y<n.inHeight;++y)for(var x=0;x<n.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/r;if(!(R<0||R>=n.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/o;if(!(N<0||N>=n.outWidth||Math.floor(N)!==N))C+=v.get(m,R,N,g)}}f.set(C*d,m,y,x,g)}return f.toTensor()},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.reshape=function(t,e){return Zn(t,e)},t.prototype.avgPool=function(t,e){return this.assertNotComplex(t,"avgPool"),this.pool(t,e,"avg").toFloat()},t.prototype.resizeBilinear=function(t,e,n,r){this.assertNotComplex(t,"resizeBilinear");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(y([a,e,n,u])),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=0,d=h[0]/p[0],v=h[1]/p[1],m=0;m<a;m++)for(var g=0;g<e;g++)for(var x=d*g,w=Math.floor(x),b=x-w,C=Math.min(i-1,Math.ceil(x)),E=m*t.strides[0]+w*t.strides[1],R=m*t.strides[0]+C*t.strides[1],S=0;S<n;S++)for(var N=v*S,k=Math.floor(N),I=N-k,A=Math.min(s-1,Math.ceil(N)),T=E+k*t.strides[2],D=R+k*t.strides[2],O=E+ +A*t.strides[2],_=R+A*t.strides[2],M=0;M<u;M++){var F=l[T+M],B=l[D+M],P=F+(l[O+M]-F)*I,L=P+(B+(l[_+M]-B)*I-P)*b;c[f++]=L}return Fn(c,[a,e,n,u])},t.prototype.resizeBilinearBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeBilinearBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=[n&&l>1?a-1:a,n&&c>1?i-1:i],f=[n&&l>1?l-1:l,n&&c>1?c-1:c],d=p[0]/f[0],v=p[1]/f[1],m=t.dataSync(),g=0,y=0;y<o;y++)for(var x=y*e.strides[0],w=0;w<l;w++)for(var b=w*d,C=Math.floor(b),E=Math.min(Math.ceil(b),a-1),R=x+C*e.strides[1],S=x+E*e.strides[1],N=b-C,k=1-N,I=0;I<c;I++)for(var A=I*v,T=Math.floor(A),D=Math.min(Math.ceil(A),i-1),O=A-T,_=1-O,M=R+T*e.strides[2],F=R+D*e.strides[2],B=S+T*e.strides[2],P=S+D*e.strides[2],L=k*_,W=k*O,U=N*_,z=N*O,V=0;V<s;V++){var G=m[g++];h[M+V]+=G*L,h[F+V]+=G*W,h[B+V]+=G*U,h[P+V]+=G*z}return Un(h,[o,i,a,s],e.dtype)},t.prototype.resizeNearestNeighbor=function(t,e,n,r){this.assertNotComplex(t,"resizeNearestNeighbor");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(a*e*n*u),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=h[0]/p[0],d=h[1]/p[1],v=0,m=0;m<a;m++)for(var g=m*t.strides[0],y=0;y<e;y++)for(var x=f*y,w=g+Math.min(i-1,r?Math.round(x):Math.floor(x))*t.strides[1],b=0;b<n;b++)for(var C=d*b,E=w+Math.min(s-1,r?Math.round(C):Math.floor(C))*t.strides[2],R=0;R<u;R++){var S=l[E+R];c[v++]=S}return Fn(c,[a,e,n,u],t.dtype)},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeNearestNeighborBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=t.dataSync(),f=[n&&l>1?a-1:a,n&&c>1?i-1:i],d=[n&&l>1?l-1:l,n&&c>1?c-1:c],v=f[0]/d[0],m=f[1]/d[1],g=1/v,y=1/m,x=2*Math.ceil(g)+2,w=2*Math.ceil(y)+2,b=0;b<o;b++)for(var C=b*e.strides[0],E=0;E<a;E++)for(var R=C+E*e.strides[1],S=Math.floor(E*g),N=Math.floor(S-x/2),k=0;k<i;k++)for(var I=R+k*e.strides[2],A=Math.floor(k*y),T=Math.floor(A-w/2),D=0;D<s;D++){for(var O=0,_=0;_<x;_++){var M=_+N;if(!(M<0||M>=l)){var F=C+M*t.strides[1],B=M*v;if(E===Math.min(a-1,n?Math.round(B):Math.floor(B)))for(var P=0;P<w;P++){var L=P+T;if(!(L<0||L>=c)){var W=F+L*t.strides[2],U=L*m;k===Math.min(i-1,n?Math.round(U):Math.floor(U))&&(O+=p[W+D])}}}}h[I+D]=O}return Un(h,e.shape,e.dtype)},t.prototype.batchNormalization=function(t,e,n,r,o,a){this.assertNotComplex([t,e,n,o,a],"batchNorm");for(var i=t.dataSync(),s=e.dataSync(),u=n.dataSync(),l=o?o.dataSync():new Float32Array([1]),c=a?a.dataSync():new Float32Array([0]),h=new Float32Array(i.length),p=c.length,f=l.length,d=u.length,v=s.length,m=0,g=0,y=0,x=0,w=0;w<i.length;++w)h[w]=c[m++]+(i[w]-s[g++])*l[y++]/Math.sqrt(u[x++]+r),m>=p&&(m=0),g>=v&&(g=0),y>=f&&(y=0),x>=d&&(x=0);return Un(h,t.shape)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){this.assertNotComplex(t,"localResponseNormalization4D");var a=t.shape[3],i=a-1,s=t.dataSync(),u=t.size,l=new Float32Array(u);function c(t){for(var n=t%a,r=t-n+Math.max(0,n-e),o=t-n+Math.min(n+e,i),u=0;r<=o;r++){var l=s[r];u+=l*l}return u}for(var h=0;h<u;h++){var p=c(h),f=s[h]*Math.pow(n+r*p,-o);l[h]=f}return Un(l,t.shape)},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){this.assertNotComplex(t,"LRNGrad");for(var s=t.shape[3],u=t.dataSync(),l=e.dataSync(),c=n.dataSync(),h=new Float32Array(t.size),p=t.size,f=0;f<p;f++){for(var d=f%s,v=f-d+Math.max(0,d-r),m=f-d+Math.min(s,d+r+1),g=0,y=v;y<m;y++)g+=Math.pow(l[y],2);g=a*g+o;for(y=v;y<m;y++){var x=-2*a*i*l[y]*c[f]/g;f===y&&(x+=Math.pow(g,-i)),x*=u[f],h[y]+=x}}return Un(h,t.shape)},t.prototype.multinomial=function(t,e,n,r){this.assertNotComplex(t,"multinomial");for(var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=qn([a,n],"int32"),u=s.dataSync(),l=o.dataSync(),c=0;c<a;++c){var h=c*i,p=new Float32Array(i-1);p[0]=l[h];for(var f=1;f<p.length;++f)p[f]=p[f-1]+l[h+f];for(var d=Er(r.toString()),v=c*n,m=0;m<n;++m){var g=d();u[v+m]=p.length;for(var y=0;y<p.length;y++)if(g<p[y]){u[v+m]=y;break}}}return s},t.prototype.oneHot=function(t,e,n,r){this.assertNotComplex(t,"oneHot");var o=new Float32Array(t.size*e);o.fill(r);for(var a=t.dataSync(),i=0;i<t.size;++i)a[i]>=0&&a[i]<e&&(o[i*e+a[i]]=n);return Ln(o,[t.size,e],"int32")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return this.assertNotComplex(t,"nonMaxSuppression"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.fft=function(t){return this.fftBatch(t,!1)},t.prototype.ifft=function(t){return this.fftBatch(t,!0)},t.prototype.fftBatch=function(t,e){for(var n=t.shape[0],r=t.shape[1],o=Nr(t.shape,"float32"),a=Nr(t.shape,"float32"),i=_n(t).as2D(n,r),s=Mn(t).as2D(n,r),u=0;u<n;u++)for(var l=i.slice([u,0],[1,r]),c=s.slice([u,0],[1,r]),h=On(l,c),p=this.fftImpl(h,e).dataSync(),f=0;f<r;f++){var d=nr(p,f);o.values[u*r+f]=d.real,a.values[u*r+f]=d.imag}return On(o.toTensor(),a.toTensor()).as2D(n,r)},t.prototype.fftImpl=function(t,e){var n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(o=On(_n(o).div(Bn(r)),Mn(o).div(Bn(r)))),o}var a=t.dataSync(),i=function(t){for(var e=new Float32Array(t.length/2),n=new Float32Array(t.length/2),r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}(this.fourierTransformByMatmul(a,r,e));return On(i.real,i.imag).as2D(t.shape[0],t.shape[1])},t.prototype.isExponentOf2=function(t){return 0==(t&t-1)},t.prototype.fftRadix2=function(t,e,n){if(1===e)return t;var r=t.dataSync(),o=e/2,a=function(t){for(var e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),i=On(a.real,a.imag).as1D(),s=function(t){for(var e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),u=On(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var l=function(t,e){for(var n=new Float32Array(t/2),r=new Float32Array(t/2),o=0;o<Math.ceil(t/2);o++){var a=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}(e,n),c=On(l.real,l.imag).mul(u),h=i.add(c),p=i.sub(c),f=_n(h).concat(_n(p)),d=Mn(h).concat(Mn(p));return On(f,d).as1D()},t.prototype.fourierTransformByMatmul=function(t,e,n){for(var r=new Float32Array(2*e),o=0;o<e;o++){for(var a=0,i=0,s=0;s<e;s++){var u=or(o*s,e,n),l=nr(t,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(a/=e,i/=e),rr(r,a,i,o)}return r},t.prototype.depthToSpace=function(t,e,n){d("NHWC"===n,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n}),d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});for(var r=t.shape[0],o=t.shape[1],a=t.shape[2],i=t.shape[3],s=o*e,u=a*e,l=i/(e*e),c=t.dataSync(),h=new Float32Array(r*s*u*l),p=0,f=0;f<r;++f)for(var v=0;v<s;++v)for(var m=Math.floor(v/e),g=v%e,y=0;y<u;++y)for(var x=Math.floor(y/e),w=(g*e+y%e)*l,b=0;b<l;++b){var C=b+w+i*(x+a*(m+o*f));h[p++]=c[C]}return Un(h,[r,s,u,l])},t.prototype.broadcastedBinaryOp=function(t,e,n,r){var o=so(t.shape,e.shape),a=Nr(o,n),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,o),l=ao(e.shape,o),c=a.values;if(u.length+l.length===0)for(var h=0;h<c.length;++h)c[h]=r(i[h%i.length],s[h%s.length]);else{var p=t.bufferSync(),f=e.bufferSync(),d=function(n){var o=a.indexToLoc(n),h=o.slice(-t.rank);u.forEach(function(t){return h[t]=0});var d=p.locToIndex(h),v=o.slice(-e.rank);l.forEach(function(t){return v[t]=0});var m=f.locToIndex(v);c[n]=r(i[d],s[m])};for(h=0;h<c.length;++h)d(h)}return a.toTensor()},t.prototype.broadcastedBinaryComplexOp=function(t,e,n){var r=so(t.shape,e.shape),o=Nr(r,"float32"),a=Nr(r,"float32"),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,r),l=ao(e.shape,r),c=o.values,h=a.values;if(u.length+l.length===0)for(var p=0;p<c.length;p++){var f=p%i.length,d=p%s.length,v=n(i[2*f],i[2*f+1],s[2*d],s[2*d+1]);c[p]=v.real,h[p]=v.imag}else{var m=this.data.get(t.dataId).complexTensors.real.bufferSync(),g=this.data.get(e.dataId).complexTensors.real.bufferSync(),y=function(r){var a=o.indexToLoc(r),p=a.slice(-t.rank);u.forEach(function(t){return p[t]=0});var f=m.locToIndex(p),d=a.slice(-e.rank);l.forEach(function(t){return d[t]=0});var v=g.locToIndex(d),y=n(i[2*f],i[2*f+1],s[2*v],s[2*v+1]);c[r]=y.real,h[r]=y.imag};for(p=0;p<c.length;p++)y(p)}return this.complex(o.toTensor(),a.toTensor())},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return 1e-7},t.prototype.cropAndResize=function(t,e,n,r,o,a){for(var i=t.shape,s=i[0],u=i[1],l=i[2],c=i[3],h=e.shape[0],p=r[0],f=r[1],d=Nr([h,p,f,c],t.dtype),v=e.dataSync(),m=n.dataSync(),g=t.dataSync(),y=t.strides,x=d.strides,w=0;w<h;w++){var b=4*w,C=v[b],E=v[b+1],R=v[b+2],S=v[b+3],N=m[w];if(!(N>=s))for(var k=p>1?(R-C)*(u-1)/(p-1):0,I=f>1?(S-E)*(l-1)/(f-1):0,A=0;A<p;A++){var T=p>1?C*(u-1)+A*k:.5*(C+R)*(u-1);if(T<0||T>u-1)for(var D=0;D<f;D++)for(var O=0;O<c;O++){var _=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else if("bilinear"===o){var M=Math.floor(T),F=Math.ceil(T),B=T-M;for(D=0;D<f;D++){if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var P=Math.floor(H),L=Math.ceil(H),W=H-P;for(O=0;O<c;O++){var U=g[_=O+P*y[2]+M*y[1]+N*y[0]],z=g[_=O+L*y[2]+M*y[1]+N*y[0]],V=g[_=O+P*y[2]+F*y[1]+N*y[0]],G=U+(z-U)*W,q=V+(g[_=O+L*y[2]+F*y[1]+N*y[0]]-V)*W;_=O+D*x[2]+A*x[1]+w*x[0],d.values[_]=G+(q-G)*B}}}}else for(D=0;D<f;++D){var H;if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var $=Math.round(H),j=Math.round(T);for(O=0;O<c;O++){var K=O+$*y[2]+j*y[1]+N*y[0],X=O+D*x[2]+A*x[1]+w*x[0];d.values[X]=g[K]}}}}}return d.toTensor()},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,l=o.outputSize;return this.scatter(t,e,n,l,s,i,a,u,r,!1)},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return Fn([],a,t.dtype);for(var l=new lt([i,s],t.dtype),c=e.dataSync(),h=t.dataSync(),p=0;p<i;p++){for(var f=[],d=0,v=0;v<r;v++){var m=c[p*r+v];d+=m*u[v],f.push(m)}if(d<0||d>=t.size/s)throw new Error("Invalid indices: "+f+" does not index into "+t.shape);for(var g=0;g<s;g++)l.values[p*s+g]=h[d*s+g]}return l.toTensor().reshape(a)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=Bn(0);return this.scatter(t,e,n,u,i,a,o,s,l,!0)},t.prototype.fill=function(t,e,n){var r=A(n=n||W(e),y(t));return r.fill(e),ft.make(t,{values:r},n)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){var e=A(t.dtype,y(t.shape));return ft.make(t.shape,{values:e},t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.scatter=function(t,e,n,r,o,a,i,s,u,l){var c=[r/o,o],h=t.dataSync(),p=e.dataSync();if(0===r)return Fn([],n,e.dtype);var f=new lt(c,e.dtype);f.values.fill(u.dataSync()[0]);for(var d=0;d<a;d++){for(var v=[],m=0,g=0;g<i;g++){var y=h[d*i+g];v.push(y),m+=y*s[g]}if(m<0||m>=r/o)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var x=0;x<o;x++)l?f.values[m*o+x]+=p[d*o+x]:f.values[m*o+x]=0===e.rank?p[0]:p[d*o+x]}return f.toTensor().reshape(n)},t}();Dt.registerBackend("cpu",function(){return new gc},1);var yc={float32:4,int32:4,uint16:2,uint8:1,bool:1};function xc(t,e){for(var n={},r=0,o=function(e){var o=e.name,a=e.dtype,i=e.shape,s=y(i),u=void 0;if("quantization"in e){var l=e.quantization;if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+l.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var c=yc[l.dtype],h=t.slice(r,r+s*c),p="uint8"===l.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===a)u=Float32Array.from(p,function(t){return t*l.scale+l.min});else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(p,function(t){return Math.round(t*l.scale+l.min)})}r+=s*c}else{var f=yc[a];h=t.slice(r,r+s*f);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(h)}r+=s*f}var d=void 0;if("float32"===a)d=Fn(u,i,"float32");else if("int32"===a)d=Fn(u,i,"int32");else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);d=Fn(u,i,"bool")}n[o]=d},a=0,i=e;a<i.length;a++){o(i[a])}return n}function wc(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));var e=0,n=[];t.forEach(function(t){if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});var r=new Uint8Array(e),o=0;return n.forEach(function(t){r.set(new Uint8Array(t.buffer),o),o+=t.byteLength}),r.buffer}var bc="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Cc(t){return bc?Buffer.byteLength(t):new Blob([t]).size}function Ec(t){var e=0;t.forEach(function(t){e+=t.byteLength});var n=new Uint8Array(e),r=0;return t.forEach(function(t){n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function Rc(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);var e=t.split("/");return e[e.length-1]}function Sc(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Cc(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Cc(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}var Nc=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(e){t.getInstance().saveRouters.push(e)},t.registerLoadRouter=function(e){t.getInstance().loadRouters.push(e)},t.getSaveHandlers=function(e){return t.getHandlers(e,"save")},t.getLoadHandlers=function(e,n){return t.getHandlers(e,"load",n)},t.getHandlers=function(e,n,r){var o=[];return("load"===n?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(function(t){var n=t(e,r);null!==n&&o.push(n)}),o},t}(),kc="://",Ic=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(e,n){d(null!=e,function(){return"scheme must not be undefined or null."}),e.endsWith(kc)&&(e=e.slice(0,e.indexOf(kc))),d(e.length>0,function(){return"scheme must not be an empty string."});var r=t.getInstance();d(null==r.managers[e],function(){return"A model store manager is already registered for scheme '"+e+"'."}),r.managers[e]=n},t.getManager=function(t){var e=this.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function Ac(t){if(-1===t.indexOf(kc))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+Ic.getSchemes().join(","));return{scheme:t.split(kc)[0],path:t.split(kc)[1]}}function Tc(t,e,n){return void 0===n&&(n=!1),r(this,void 0,void 0,function(){var r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return d(t!==e,function(){return"Old path and new path are the same: '"+t+"'"}),d((r=Nc.getLoadHandlers(t)).length>0,function(){return"Copying failed because no load handler is found for source URL "+t+"."}),d(r.length<2,function(){return"Copying failed because more than one ("+r.length+") load handlers for source URL "+t+"."}),a=r[0],d((i=Nc.getSaveHandlers(e)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+e+"."}),d(i.length<2,function(){return"Copying failed because more than one ("+r.length+") save handlers for destination URL "+e+"."}),s=i[0],u=Ac(t).scheme,l=Ac(t).path,c=u===Ac(t).scheme,[4,a.load()];case 1:return h=o.sent(),n&&c?[4,Ic.getManager(u).removeModel(l)]:[3,3];case 2:o.sent(),o.label=3;case 3:return[4,s.save(h)];case 4:return p=o.sent(),!n||c?[3,6]:[4,Ic.getManager(u).removeModel(l)];case 5:o.sent(),o.label=6;case 6:return[2,p.modelArtifactsInfo]}})})}var Dc="models_store",Oc="model_info_store";function _c(){if(!a.getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var t=window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Mc(t){var e=t.result;e.createObjectStore(Dc,{keyPath:"modelPath"}),e.createObjectStore(Oc,{keyPath:"modelPath"})}var Fc=function(){function t(t){if(this.indexedDB=_c(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(t,e){var n=this;return new Promise(function(t,r){var o=n.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var a=o.result;if(null==e){var i=a.transaction(Dc,"readonly"),s=i.objectStore(Dc).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error("Cannot find model with path '"+n.modelPath+"' in IndexedDB."));t(s.result.modelArtifacts)},s.onerror=function(t){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()}}else{var u,l=Sc(e),c=a.transaction(Oc,"readwrite"),h=c.objectStore(Oc),p=h.put({modelPath:n.modelPath,modelArtifactsInfo:l});p.onsuccess=function(){var o=(u=a.transaction(Dc,"readwrite")).objectStore(Dc).put({modelPath:n.modelPath,modelArtifacts:e,modelArtifactsInfo:l});o.onsuccess=function(){return t({modelArtifactsInfo:l})},o.onerror=function(t){var e=(h=c.objectStore(Oc)).delete(n.modelPath);e.onsuccess=function(){return a.close(),r(o.error)},e.onerror=function(t){return a.close(),r(o.error)}}},p.onerror=function(t){return a.close(),r(p.error)},c.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(t){return r(o.error)}})},t.URL_SCHEME="indexeddb://",t}(),Bc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fc.URL_SCHEME)?(e=t.slice(Fc.URL_SCHEME.length),new Fc(e)):null;var e};Nc.registerSaveRouter(Bc),Nc.registerLoadRouter(Bc);var Pc=function(){function t(){this.indexedDB=_c()}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t=this;return o(this,function(e){return[2,new Promise(function(e,n){var r=t.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=function(){return Mc(r)},r.onsuccess=function(){var t=r.result,o=t.transaction(Oc,"readonly"),a=o.objectStore(Oc).getAll();a.onsuccess=function(){for(var t={},n=0,r=a.result;n<r.length;n++){var o=r[n];t[o.modelPath]=o.modelArtifactsInfo}e(t)},a.onerror=function(e){return t.close(),n(a.error)},o.oncomplete=function(){return t.close()}},r.onerror=function(t){return n(r.error)}})]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){var r;return t=(r=t).startsWith(Fc.URL_SCHEME)?r.slice(Fc.URL_SCHEME.length):r,[2,new Promise(function(n,r){var o=e.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var e,a=o.result,i=a.transaction(Oc,"readwrite"),s=i.objectStore(Oc),u=s.get(t);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var o=s.delete(t),i=function(){var o=(e=a.transaction(Dc,"readwrite")).objectStore(Dc).delete(t);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(t){return r(u.error)}};o.onsuccess=i,o.onerror=function(t){return i(),a.close(),r(u.error)}},u.onerror=function(t){return a.close(),r(u.error)},i.oncomplete=function(){null==e?a.close():e.oncomplete=function(){return a.close()}}},o.onerror=function(t){return r(o.error)}})]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(Fc.URL_SCHEME,new Pc)}catch(t){}var Lc="/",Wc="tensorflowjs_models",Uc="info",zc="model_topology",Vc="weight_specs",Gc="weight_data",qc="model_metadata";function Hc(t){return{info:[Wc,t,Uc].join(Lc),topology:[Wc,t,zc].join(Lc),weightSpecs:[Wc,t,Vc].join(Lc),weightData:[Wc,t,Gc].join(Lc),modelMetadata:[Wc,t,qc].join(Lc)}}function $c(t){var e=t.split(Lc);if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join(Lc)}var jc=function(){function t(t){if(!a.getBool("IS_BROWSER")||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Hc(this.modelPath)}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Sc(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(a=t.weightData,bc?Buffer.from(a).toString("base64"):btoa(String.fromCharCode.apply(null,new Uint8Array(a))))),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy})),[2,{modelArtifactsInfo:r}]}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+r.modelTopologyBytes+", weightSpecsBytes="+r.weightSpecsBytes+", weightDataBytes="+r.weightDataBytes+".")}var a;return[2]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){if(null==(t=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=n,null==(r=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=r,null!=(a=this.LS.getItem(this.keys.modelMetadata))&&(i=JSON.parse(a),e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy),null==(s=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=function(t){if(bc){var e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var n=atob(t),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}(s),[2,e]})})},t.URL_SCHEME="localstorage://",t}(),Kc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(jc.URL_SCHEME)?(e=t.slice(jc.URL_SCHEME.length),new jc(e)):null;var e};Nc.registerSaveRouter(Kc),Nc.registerLoadRouter(Kc);var Xc=function(){function t(){d(a.getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),d(void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i;return o(this,function(o){for(t={},e=Wc+Lc,n=Lc+Uc,r=0;r<this.LS.length;++r)(a=this.LS.key(r)).startsWith(e)&&a.endsWith(n)&&(i=$c(a),t[i]=JSON.parse(this.LS.getItem(a)));return[2,t]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){var o;if(t=(o=t).startsWith(jc.URL_SCHEME)?o.slice(jc.URL_SCHEME.length):o,e=Hc(t),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+t+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(jc.URL_SCHEME,new Xc)}catch(t){}var Yc="model",Qc=".json",Jc=".weights.bin";function Zc(t){return new Promise(function(t){return setTimeout(t)}).then(t)}var th=function(){function t(e){if(!a.getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),null!=e&&0!==e.length||(e=Yc),this.modelTopologyFileName=e+Qc,this.weightDataFileName=e+Jc}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),(i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,i.href=a,[4,Zc(function(){return i.dispatchEvent(new MouseEvent("click"))})];case 2:return o.sent(),null==t.weightData?[3,4]:((s=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,s.href=e,[4,Zc(function(){return s.dispatchEvent(new MouseEvent("click"))})]);case 3:o.sent(),o.label=4;case 4:return[2,{modelArtifactsInfo:Sc(t)}]}})})},t.URL_SCHEME="downloads://",t}(),eh=function(){function t(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n=this;return o(this,function(r){return t=this.files[0],e=this.files.slice(1),[2,new Promise(function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===e.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var l;try{l=n.checkManifestAndWeightFiles(u,e)}catch(t){return void o(t)}var c=[],h=[],p=[];u.forEach(function(t){t.paths.forEach(function(t){h.push(t),p.push(null)}),c.push.apply(c,t.weights)}),u.forEach(function(t){t.paths.forEach(function(t){var e=new FileReader;e.onload=function(e){var n=e.target.result,o=h.indexOf(t);p[o]=n,-1===p.indexOf(null)&&r({modelTopology:s,weightSpecs:c,weightData:Ec(p)})},e.onerror=function(e){return o("Failed to weights data from file of path '"+t+"'.")},e.readAsArrayBuffer(l[t])})})}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},a.onerror=function(e){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(t)})]})})},t.prototype.checkManifestAndWeightFiles=function(t,e){for(var n=[],r=e.map(function(t){return Rc(t.name)}),o={},a=0,i=t;a<i.length;a++){i[a].paths.forEach(function(t){var a=Rc(t);if(-1!==n.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(n.push(a),-1===r.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[t]=e[r.indexOf(a)]})}if(n.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+e.length+").");return o},t}();function nh(t,e,n,r){!function(t){d(null!=t&&Array.isArray(t)&&t.length>0,function(){return"promises must be a none empty array"})}(t),function(t,e){d(t>=0&&t<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+t}),d(e>=0&&e<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+e}),d(e>=t,function(){return"startFraction must be no more than endFraction, but got startFraction "+t+" and endFraction "+e})}(n=null==n?0:n,r=null==r?1:r);var o=0;return Promise.all(t.map(function(a){return a.then(function(a){var i=n+ ++o/t.length*(r-n);return e(i),a}),a}))}function rh(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return null==e&&(e={}),n=null==e.fetchFunc?J:e.fetchFunc,r=t.map(function(t){return n(t,e.requestInit)}),a=0,i=.5,null!=e.onProgress?[3,2]:[4,Promise.all(r)];case 1:return s=o.sent(),[3,4];case 2:return[4,nh(r,e.onProgress,a,i)];case 3:s=o.sent(),o.label=4;case 4:return u=s.map(function(t){return t.arrayBuffer()}),l=.5,c=1,null!=e.onProgress?[3,6]:[4,Promise.all(u)];case 5:return h=o.sent(),[3,8];case 6:return[4,nh(u,e.onProgress,l,c)];case 7:h=o.sent(),o.label=8;case 8:return[2,h]}})})}function oh(t){var e=this;return function(n,a,i){return void 0===a&&(a=""),r(e,void 0,void 0,function(){var e,r,s,u,l,c,h,p,f,d;return o(this,function(o){switch(o.label){case 0:if(e=n.map(function(){return!1}),r={},s=null!=i?i.map(function(){return!1}):[],u=[],n.forEach(function(t,n){var o=0;t.weights.forEach(function(t){var a="quantization"in t?t.quantization.dtype:t.dtype,l=yc[a]*y(t.shape),c=function(){e[n]=!0,null==r[n]&&(r[n]=[]),r[n].push({manifestEntry:t,groupOffset:o,sizeBytes:l})};null!=i?i.forEach(function(e,n){e===t.name&&(c(),s[n]=!0)}):c(),u.push(t.name),o+=l})}),!s.every(function(t){return t}))throw l=i.filter(function(t,e){return!s[e]}),new Error("Could not find weights in manifest with names: "+l.join(", ")+". \nManifest JSON has weights with names: "+u.join(", ")+".");return c=e.reduce(function(t,e,n){return e&&t.push(n),t},[]),h=[],c.forEach(function(t){n[t].paths.forEach(function(t){var e=a+(a.endsWith("/")?"":"/")+t;h.push(e)})}),[4,t(h)];case 1:return p=o.sent(),f={},d=0,c.forEach(function(t){for(var e=n[t].paths.length,o=0,a=0;a<e;a++)o+=p[d+a].byteLength;for(var i=new ArrayBuffer(o),s=new Uint8Array(i),u=0,l=0;l<e;l++){var c=new Uint8Array(p[d+l]);s.set(c,u),u+=c.byteLength}r[t].forEach(function(t){var e=xc(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(var n in e)f[n]=e[n]}),d+=e}),[2,f]}})})}}Nc.registerSaveRouter(function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(th.URL_SCHEME)?(e=t.slice(th.URL_SCHEME.length),void 0===e&&(e="model"),new th(e)):null;var e});var ah=function(){function t(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(d("function"==typeof e.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=e.fetchFunc):this.fetch=J,d(null!=t&&t.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(t)&&d(2===t.length,function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."}),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((a=o.sent()).ok)return[2,{modelArtifactsInfo:Sc(t),responses:[a]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=o.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");o.label=2;case 2:return o.trys.push([2,4,,5]),[4,t.json()];case 3:return e=o.sent(),[3,5];case 4:throw o.sent(),n="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?n+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":n+=" Please make sure the server is serving valid JSON for this request.",new Error(n);case 5:if(r=e.modelTopology,a=e.weightsManifest,null==r&&null==a)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==a?[3,7]:[4,this.loadWeights(a)];case 6:u=o.sent(),i=u[0],s=u[1],o.label=7;case 7:return[2,{modelTopology:r,weightSpecs:i,weightData:s}]}})})},t.prototype.loadWeights=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,n=function(t){var e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),r=n[0],a=n[1],i=this.weightPathPrefix||r,s=[],u=0,l=t;u<l.length;u++)c=l[u],s.push.apply(s,c.weights);return h=[],t.forEach(function(t){t.paths.forEach(function(t){h.push(i+t+a)})}),[4,rh(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return p=o.sent(),[2,[s,Ec(p)]]}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function ih(t){return null!=t.match(ah.URL_SCHEME_REGEX)}var sh=function(t,e){return(Array.isArray(t)?t.every(function(t){return ih(t)}):ih(t))?uh(t,{onProgress:e}):null};function uh(t,e){return new ah(t,e)}Nc.registerSaveRouter(sh),Nc.registerLoadRouter(sh);var lh=function(){function t(t,e,n){this.modelTopology=t,this.weightSpecs=e,this.weightData=n}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){return t={},null!=this.modelTopology&&(t=n({modelTopology:this.modelTopology},t)),null!=this.weightSpecs&&this.weightSpecs.length>0&&(t=n({weightSpecs:this.weightSpecs},t)),null!=this.weightData&&this.weightData.byteLength>0&&(t=n({weightData:this.weightData},t)),[2,t]})})},t}(),ch=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.saveHandler(t)]})})},t}();var hh=Object.freeze({browserFiles:function(t){return new eh(t)},browserHTTPRequest:function(t,e){return uh(t,e)},concatenateArrayBuffers:Ec,decodeWeights:xc,encodeWeights:function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:for(r in e=[],n=[],t){if("float32"!==(a=t[r]).dtype&&"int32"!==a.dtype&&"bool"!==a.dtype)throw new Error("Unsupported dtype in weight '"+r+"': "+a.dtype);e.push({name:r,shape:a.shape,dtype:a.dtype}),n.push(a.data())}return[4,Promise.all(n)];case 1:return[2,{data:wc(o.sent()),specs:e}]}})})},fromMemory:function(t,e,n){return new lh(t,e,n)},getLoadHandlers:function(t,e){return Nc.getLoadHandlers(t)},getModelArtifactsInfoForJSON:Sc,getSaveHandlers:function(t){return Nc.getSaveHandlers(t)},http:uh,isHTTPScheme:ih,loadWeights:function(t,e,n,a){return void 0===e&&(e=""),r(this,void 0,void 0,function(){return o(this,function(r){return[2,oh(function(t){return rh(t,{requestInit:a})})(t,e,n)]})})},registerLoadRouter:function(t){return Nc.registerLoadRouter(t)},registerSaveRouter:function(t){return Nc.registerSaveRouter(t)},weightsLoaderFactory:oh,withSaveHandler:function(t){return new ch(t)},copyModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!1)]})})},listModels:function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:t=Ic.getSchemes(),e={},n=0,r=t,o.label=1;case 1:return n<r.length?(a=r[n],[4,Ic.getManager(a).listModels()]):[3,4];case 2:for(s in i=o.sent())e[a+kc+s]=i[s];o.label=3;case 3:return n++,[3,1];case 4:return[2,e]}})})},moveModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!0)]})})},removeModel:function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=Ac(t),[2,Ic.getManager(e.scheme).removeModel(e.path)]})})}});var ph=An({confusionMatrix_:function(t,e,n){var r=wn(t,"labels","confusionMatrix"),o=wn(e,"predictions","confusionMatrix");d(null==n||n>0&&Number.isInteger(n),function(){return"If provided, numClasses must be a positive integer, but got "+n}),d(1===r.rank,function(){return"Expected the rank of labels to be 1, but got "+r.rank}),d(1===o.rank,function(){return"Expected the rank of predictions to be 1, but got "+o.rank}),d(r.shape[0]===o.shape[0],function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."}),d(n>0&&Number.isInteger(n),function(){return"numClasses is required to be a positive integer, but got "+n});var a=Br(r.asType("int32"),n),i=Br(o.asType("int32"),n);return a.transpose().matMul(i).asType("int32")}}),fh=Object.freeze({confusionMatrix:ph});var dh=An({fromPixels_:function(t,e){if(void 0===e&&(e=3),e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return Dt.fromPixels(t,e)}}),vh=Object.freeze({toPixels:function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p,f,d,v,m,g,y,x,w,b,C,E,R,S;return o(this,function(o){switch(o.label){case 0:if(n=wn(t,"img","toPixels"),t instanceof ft||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+n.rank+".");if(r=n.shape.slice(0,2),a=r[0],i=r[1],(s=2===n.rank?1:n.shape[2])>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);return[4,n.data()];case 1:return u=o.sent(),l=n.min(),c=n.max(),[4,Promise.all([l.data(),c.data()])];case 2:if(h=o.sent(),p=h[0],f=h[1],d=p[0],v=f[0],l.dispose(),c.dispose(),"float32"===n.dtype){if(d<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+d+" - "+v+"].")}else{if("int32"!==n.dtype)throw new Error("Unsupported type for toPixels: "+n.dtype+". Please use float32 or int32 tensors.");if(d<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+d+" - "+v+"].")}for(m="float32"===n.dtype?255:1,g=new Uint8ClampedArray(i*a*4),y=0;y<a*i;++y)x=void 0,w=void 0,b=void 0,C=void 0,1===s?(x=u[y]*m,w=u[y]*m,b=u[y]*m,C=255):3===s?(x=u[3*y]*m,w=u[3*y+1]*m,b=u[3*y+2]*m,C=255):4===s&&(x=u[4*y]*m,w=u[4*y+1]*m,b=u[4*y+2]*m,C=u[4*y+3]*m),g[0+(E=4*y)]=Math.round(x),g[E+1]=Math.round(w),g[E+2]=Math.round(b),g[E+3]=Math.round(C);return null!=e&&(e.width=i,e.height=a,R=e.getContext("2d"),S=new ImageData(g,i,a),R.putImageData(S,0,0)),n!==t&&n.dispose(),[2,g]}})})},fromPixels:dh}),mh=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(t,e){return new t(e)},t}(),gh=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(e){t.getMap().classNameMap[e.className]=[e,e.fromConfig]},t}();function yh(t){d(null!=t.className,function(){return"Class being registered does not have the static className property defined."}),d("string"==typeof t.className,function(){return"className is required to be a string, but got type "+typeof t.className}),d(t.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),gh.register(t)}var xh=Object.freeze({Serializable:mh,SerializationMap:gh,registerClass:yh}),wh=.001,bh=.1;function Ch(){return 32===Dt.backend.floatPrecision()?wh:bh}function Eh(t,e,n){var r=!0;if((_(t)||_(e))&&(r=!1),_(t)&&_(e)&&(r=!0),r){var o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error("Arrays are of different type. Actual: "+o+". Expected: "+a)}if(Array.isArray(t)&&Array.isArray(e)){var i=yn(t),s=yn(e);if(!x(i,s))throw new Error("Arrays have different shapes. Actual: ["+i+"]. Expected: ["+s+"]")}var u=_(t)?t:g(t),l=_(e)?e:g(e);if(u.length!==l.length)throw new Error("Arrays have different lengths actual: "+u.length+" vs expected: "+l.length+".\nActual:   "+u+".\nExpected: "+l+".");for(var c=0;c<l.length;++c){var h=u[c],p=l[c];if(!n(h,p))throw new Error("Arrays differ: actual["+c+"] = "+h+", expected["+c+"] = "+p+".\nActual:   "+u+".\nExpected: "+l+".")}}function Rh(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var Sh=Object.freeze({TEST_EPSILON_FLOAT16:bh,expectArraysClose:function(t,e,n){return null==n&&(n=Ch()),Eh(t,e,function(t,e){return Rh(t,e,n)})},testEpsilon:Ch,expectPromiseToFail:function(t,e){t().then(function(){return e.fail()},function(){return e()})},expectArraysEqual:function(t,e){var n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return B(t)||B(t[0])||B(e)||B(e[0])?Eh(t,n,function(t,e){return t==e}):Eh(t,e,function(t,e){return Rh(t,e,0)})},expectNumbersClose:function(t,e,n){if(null==n&&(n=Ch()),!Rh(t,e,n))throw new Error("Numbers differ: actual === "+t+", expected === "+e)},expectValuesInRange:function(t,e,n){for(var r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error("Value out of range:"+t[r]+" low: "+e+", high: "+n)},expectArrayBuffersEqual:function(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}}),Nh="1.1.2",kh=Object.freeze({gpgpu_util:La,webgl_util:ke,MathBackendWebGL:Ui,GPGPUContext:Wa}),Ih=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.minimize=function(t,e,n){void 0===e&&(e=!1);var r=this.computeGradients(t,n),o=r.value,a=r.grads;return this.applyGradients(a),Object.keys(a).forEach(function(t){return a[t].dispose()}),e?o:(o.dispose(),null)},n.prototype.computeGradients=function(t,e){return Nn(t,e)},n.prototype.dispose=function(){},n}(mh);Object.defineProperty(Ih,Symbol.hasInstance,{value:function(t){return null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients}});var Ah=function(t){function n(e,n,r){void 0===r&&(r=null);var o=t.call(this)||this;return o.learningRate=e,o.rho=n,o.epsilon=r,o.accumulatedGrads={},o.accumulatedUpdates={},null==r&&(o.epsilon=Dt.backend.epsilon()),o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedUpdates[n]){Fe(function(){e.accumulatedUpdates[n]=Xn(o).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n],s=r.accumulatedUpdates[n];Fe(function(){var t=i.mul(e.rho).add(a.square().mul(1-e.rho)),r=s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),u=s.mul(e.rho).add(r.square().mul(1-e.rho));e.accumulatedGrads[n].assign(t),e.accumulatedUpdates[n].assign(u);var l=r.mul(-e.learningRate).add(o);o.assign(l)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(e){return t.accumulatedUpdates[e].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()}))},n.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.rho,e.epsilon)},n.className="AdadeltaOptimizer",n}(Ih);yh(Ah);var Th=function(t){function n(e,n){void 0===n&&(n=.1);var r=t.call(this)||this;return r.learningRate=e,r.initialAccumulatorValue=n,r.accumulatedGrads={},r}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Hn(o.shape,e.initialAccumulatorValue).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n];Fe(function(){var t=i.add(a.square());e.accumulatedGrads[n].assign(t);var r=a.div(t.add(Dt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);o.assign(r)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},n.fromConfig=function(t,e){return new t(e.learningRate,e.initialAccumulatorValue)},n.className="AdagradOptimizer",n}(Ih);yh(Th);var Dh=function(t){function n(e,n,r,o){void 0===o&&(o=null);var a=t.call(this)||this;return a.learningRate=e,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment={},a.accumulatedSecondMoment={},Fe(function(){a.accBeta1=Bn(n).variable(),a.accBeta2=Bn(r).variable()}),null==o&&(a.epsilon=Dt.backend.epsilon()),a}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=ll(1,e.accBeta2);for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedSecondMoment[o]){i=!1;e.accumulatedSecondMoment[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedSecondMoment[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2).add(s.square().mul(1-e.beta2)),p=c.div(n),f=h.div(r);e.accumulatedFirstMoment[o].assign(c),e.accumulatedSecondMoment[o].assign(h);var d=p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);a.assign(d)}e.accBeta1.assign(e.accBeta1.mul(e.beta1)),e.accBeta2.assign(e.accBeta2.mul(e.beta2))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(e){return t.accumulatedSecondMoment[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)},n.className="AdamOptimizer",n}(Ih);yh(Dh);var Oh=function(t){function n(e,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=t.call(this)||this;return i.learningRate=e,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment={},i.accumulatedWeightedInfNorm={},Fe(function(){i.iteration=Bn(0).variable(),i.accBeta1=Bn(n).variable()}),null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=Ku(-e.learningRate,e.iteration.mul(e.decay).add(1));for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedWeightedInfNorm[o]){i=!1;e.accumulatedWeightedInfNorm[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedWeightedInfNorm[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2),p=s.abs(),f=h.maximum(p);e.accumulatedFirstMoment[o].assign(c),e.accumulatedWeightedInfNorm[o].assign(f);var d=r.div(n).mul(c.div(f.add(e.epsilon))).add(a);a.assign(d)}e.iteration.assign(e.iteration.add(1)),e.accBeta1.assign(e.accBeta1.mul(e.beta1))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(e){return t.accumulatedWeightedInfNorm[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},n.className="AdamaxOptimizer",n}(Ih);yh(Oh);var _h=function(t){function n(e){var n=t.call(this)||this;return n.learningRate=e,n.setLearningRate(e),n}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Object.keys(t).forEach(function(n){var r=t[n],o=Dt.registeredVariables[n];Fe(function(){var t=e.c.mul(r).add(o);o.assign(t)})})},n.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Pe(Bn(-t))},n.prototype.dispose=function(){this.c.dispose()},n.prototype.getConfig=function(){return{learningRate:this.learningRate}},n.fromConfig=function(t,e){return new t(e.learningRate)},n.className="SGDOptimizer",n}(Ih);yh(_h);var Mh=function(t){function n(e,n,r){void 0===r&&(r=!1);var o=t.call(this,e)||this;return o.learningRate=e,o.momentum=n,o.useNesterov=r,o.m=Bn(o.momentum),o.accumulations={},o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulations[n]){Fe(function(){e.accumulations[n]=Xn(o).variable(!1)})}var a=r.accumulations[n],i=t[n];Fe(function(){var t,r=e.m.mul(a).add(i);t=e.useNesterov?e.c.mul(i.add(r.mul(e.m))).add(o):e.c.mul(r).add(o),e.accumulations[n].assign(r),o.assign(t)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){if(t.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var e in this.accumulations)this.accumulations[e].dispose()},n.prototype.setMomentum=function(t){this.momentum=t},n.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},n.fromConfig=function(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)},n.className="MomentumOptimizer",n}(_h);yh(Mh);var Fh=function(t){function n(e,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=t.call(this)||this;return i.learningRate=e,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares={},i.accumulatedMeanGrads={},i.accumulatedMoments={},i.centered=a,null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedMeanSquares[n]){Fe(function(){e.accumulatedMeanSquares[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMeanGrads[n]&&r.centered){Fe(function(){e.accumulatedMeanGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMoments[n]){Fe(function(){e.accumulatedMoments[n]=Xn(o).variable(!1)})}var a=r.accumulatedMeanSquares[n],i=r.accumulatedMeanGrads[n],s=r.accumulatedMoments[n],u=t[n];Fe(function(){var t=a.mul(e.decay).add(u.square().mul(1-e.decay));if(e.centered){var r=i.mul(e.decay).add(u.mul(1-e.decay)),l=s.mul(e.momentum).add(u.mul(e.learningRate).div(t.sub(r.square().add(e.epsilon)).sqrt()));e.accumulatedMeanSquares[n].assign(t),e.accumulatedMeanGrads[n].assign(r),e.accumulatedMoments[n].assign(l);var c=o.sub(l);o.assign(c)}else{var h=a.mul(e.decay).add(u.square().mul(1-e.decay));l=s.mul(e.momentum).add(u.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));e.accumulatedMeanSquares[n].assign(h),e.accumulatedMoments[n].assign(l);c=o.sub(l);o.assign(c)}})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(e){return t.accumulatedMeanSquares[e].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(e){return t.accumulatedMeanGrads[e].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(e){return t.accumulatedMoments[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},n.fromConfig=function(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},n.className="RMSPropOptimizer",n}(Ih);yh(Fh);var Bh=function(){function t(){}return t.sgd=function(t){return new _h(t)},t.momentum=function(t,e,n){return void 0===n&&(n=!1),new Mh(t,e,n)},t.rmsprop=function(t,e,n,r,o){return void 0===e&&(e=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new Fh(t,e,n,r,o)},t.adam=function(t,e,n,r){return void 0===t&&(t=.001),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new Dh(t,e,n,r)},t.adadelta=function(t,e,n){return void 0===t&&(t=.001),void 0===e&&(e=.95),void 0===n&&(n=null),new Ah(t,e,n)},t.adamax=function(t,e,n,r,o){return void 0===t&&(t=.002),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new Oh(t,e,n,r,o)},t.adagrad=function(t,e){return void 0===e&&(e=.1),new Th(t,e)},t}(),Ph={sgd:Bh.sgd,momentum:Bh.momentum,adadelta:Bh.adadelta,adagrad:Bh.adagrad,rmsprop:Bh.rmsprop,adamax:Bh.adamax,adam:Bh.adam},Lh="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(t){return t()};function Wh(){return new Promise(function(t){return Lh(function(){return t()})})}ht=mc;
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js ***!
  \****************************************************************/
/*! exports provided: array, Dataset, zip, CSVDataset, TextLineDataset, csv, func, generator, webcam, FileDataSource, URLDataSource, version_data */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "array", function() { return array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dataset", function() { return Dataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSVDataset", function() { return CSVDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLineDataset", function() { return TextLineDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return csv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "func", function() { return func; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generator", function() { return generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webcam", function() { return webcam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileDataSource", function() { return FileDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URLDataSource", function() { return URLDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_data", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(t,e){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])})(t,e)};function __extends(t,e){function r(){this.constructor=t}extendStatics(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}function __awaiter(t,e,r,n){return new(r||(r=Promise))(function(i,o){function a(t){try{s(n.next(t))}catch(t){o(t)}}function u(t){try{s(n.throw(t))}catch(t){o(t)}}function s(t){t.done?i(t.value):new r(function(e){e(t.value)}).then(a,u)}s((n=n.apply(t,e||[])).next())})}function __generator(t,e){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=e.call(t,a)}catch(t){o=[6,t],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,u])}}}var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function unwrapExports(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var alea=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function i(t,e){var r=new function(t){var e,r=this,n=(e=4022871197,function(t){t=t.toString();for(var r=0;r<t.length;r++){var n=.02519603282416938*(e+=t.charCodeAt(r));n-=e=n>>>0,e=(n*=e)>>>0,e+=4294967296*(n-=e)}return 2.3283064365386963e-10*(e>>>0)});r.next=function(){var t=2091639*r.s0+2.3283064365386963e-10*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=t-(r.c=0|t)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(t),r.s0<0&&(r.s0+=1),r.s1-=n(t),r.s1<0&&(r.s1+=1),r.s2-=n(t),r.s2<0&&(r.s2+=1),n=null}(t),i=e&&e.state,o=r.next;return o.int32=function(){return 4294967296*r.next()|0},o.double=function(){return o()+1.1102230246251565e-16*(2097152*o()|0)},o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.alea=i}(0,t,!1)}),xor128=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function i(t,e){var r=new function(t){var e=this,r="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i}(0,t,!1)}),xorwow=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),n==r.length&&(e.d=e.x<<10^e.x>>>4),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i}(0,t,!1)}),xorshift7=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x.slice(),e.i=t.i,e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.x,i=e.i;return t=n[i],r=(t^=t>>>7)^t<<24,r^=(t=n[i+1&7])^t>>>10,r^=(t=n[i+3&7])^t>>>3,r^=(t=n[i+4&7])^t<<7,t=n[i+7&7],r^=(t^=t<<13)^t<<9,n[i]=r,e.i=i+1&7,r},function(t,e){var r,n=[];if(e===(0|e))n[0]=e;else for(e=""+e,r=0;r<e.length;++r)n[7&r]=n[7&r]<<15^e.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],t.x=n,t.i=0,r=256;r>0;--r)t.next()}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.x&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i}(0,t,!1)}),xor4096=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.w,i=e.X,o=e.i;return e.w=n=n+1640531527|0,r=i[o+34&127],t=i[o=o+1&127],r^=r<<13,t^=t<<17,r^=r>>>15,t^=t>>>12,r=i[o]=r^t,e.i=o,r+(n^n>>>16)|0},function(t,e){var r,n,i,o,a,u=[],s=128;for(e===(0|e)?(n=e,e=null):(e+="\0",n=0,s=Math.max(s,e.length)),i=0,o=-32;o<s;++o)e&&(n^=e.charCodeAt((o+32)%e.length)),0===o&&(a=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,o>=0&&(a=a+1640531527|0,i=0==(r=u[127&o]^=n+a)?i+1:0);for(i>=128&&(u[127&(e&&e.length||0)]=-1),i=127,o=512;o>0;--o)n=u[i+34&127],r=u[i=i+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,u[i]=n^r;t.w=a,t.X=u,t.i=i}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.X&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i}(0,t,!1)}),tychei=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.b,r=e.c,n=e.d,i=e.a;return t=t<<25^t>>>7^r,r=r-n|0,n=n<<24^n>>>8^i,i=i-t|0,e.b=t=t<<20^t>>>12^r,e.c=r=r-n|0,e.d=n<<16^r>>>16^i,e.a=i-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):r+=t;for(var n=0;n<r.length+20;n++)e.b^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i}(0,t,!1)}),seedrandom=createCommonjsModule(function(t){!function(e,r){var n,i=this,o=256,a=6,u="random",s=r.pow(o,a),c=r.pow(2,52),l=2*c,f=o-1;function h(t,h,v){var y=[],_=d(function t(e,r){var n,i=[],o=typeof e;if(r&&"object"==o)for(n in e)try{i.push(t(e[n],r-1))}catch(t){}return i.length?i:"string"==o?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return n&&(t=n.randomBytes)?t=t(o):(t=new Uint8Array(o),(i.crypto||i.msCrypto).getRandomValues(t)),m(t)}catch(t){var r=i.navigator,a=r&&r.plugins;return[+new Date,i,a,i.screen,m(e)]}}():t,3),y),w=new function(t){var e,r=t.length,n=this,i=0,a=n.i=n.j=0,u=n.S=[];r||(t=[r++]);for(;i<o;)u[i]=i++;for(i=0;i<o;i++)u[i]=u[a=f&a+t[i%r]+(e=u[i])],u[a]=e;(n.g=function(t){for(var e,r=0,i=n.i,a=n.j,u=n.S;t--;)e=u[i=f&i+1],r=r*o+u[f&(u[i]=u[a=f&a+e])+(u[a]=e)];return n.i=i,n.j=a,r})(o)}(y),g=function(){for(var t=w.g(a),e=s,r=0;t<c;)t=(t+r)*o,e*=o,r=w.g(1);for(;t>=l;)t/=2,e/=2,r>>>=1;return(t+r)/e};return g.int32=function(){return 0|w.g(4)},g.quick=function(){return w.g(4)/4294967296},g.double=g,d(m(w.S),e),(h.pass||v||function(t,e,n,i){return i&&(i.S&&p(i,w),t.state=function(){return p(w,{})}),n?(r[u]=t,e):t})(g,_,"global"in h?h.global:this==r,h.state)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function d(t,e){for(var r,n=t+"",i=0;i<n.length;)e[f&i]=f&(r^=19*e[f&i])+n.charCodeAt(i++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(r["seed"+u]=h,d(r.random(),e),t.exports){t.exports=h;try{n=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}else 0}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea;function deepMapInternal(t,e,r,n){if(void 0===r&&(r=new Map),void 0===n&&(n=new Set),null==t)return null;if(n.has(t))throw new Error("Circular references are not supported.");if(r.has(t))return r.get(t);var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(t)){var o=Array.isArray(t)?[]:{};for(var a in n.add(t),t){var u=deepMapInternal(t[a],e,r,n);o[a]=u}return n.delete(t),o}throw new Error("Can't recurse into non-iterable type: "+t)}return r.set(t,i.value),i.value}function deepZip(t,e){return void 0===e&&(e=zipToList),deepZipInternal(t,e)}function deepZipInternal(t,e,r){void 0===r&&(r=new Set);var n=t[0];if(r.has(n))throw new Error("Circular references are not supported.");var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(n)){var o=Array.isArray(n)?[]:{};r.add(n);var a=function(n){var i=deepZipInternal(t.map(function(t){return t[n]}),e,r);o[n]=i};for(var u in n)a(u);return r.delete(n),o}throw new Error("Can't recurse into non-iterable type: "+n)}return i.value}function zipToList(t){return null===t?null:isIterable(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function deepMapAndAwaitAll(t,e){return __awaiter(this,void 0,void 0,function(){var r,n,i,o,a,u;return __generator(this,function(s){switch(s.label){case 0:r=new Map,deepMapInternal(t,e,r),n=0,i=Array.from(r.keys()),s.label=1;case 1:return n<i.length?(o=i[n],(a=r.get(o))instanceof Promise?[4,a]:[3,3]):[3,4];case 2:u=s.sent(),r.set(o,u),s.label=3;case 3:return n++,[3,1];case 4:return[2,deepMapInternal(t,e,r)]}})})}function isIterable(t){return null!=t&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]))}function canTensorify(t){return null==t||isPrimitive(t)||Array.isArray(t)||"object"==typeof t&&t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isTypedArray(t)}function isPrimitive(t){return null===t||"object"!=typeof t&&"function"!=typeof t}var RingBuffer=function(){function t(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}return t.prototype.wrap=function(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity},t.prototype.get=function(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]},t.prototype.set=function(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e},t.prototype.length=function(){var t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t},t.prototype.isFull=function(){return this.length()===this.capacity},t.prototype.isEmpty=function(){return 0===this.length()},t.prototype.push=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)},t.prototype.pushAll=function(t){for(var e=0,r=t;e<r.length;e++){var n=r[e];this.push(n)}},t.prototype.pop=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);var t=this.get(this.end);return this.set(this.end,void 0),t},t.prototype.unshift=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)},t.prototype.shift=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t},t.prototype.shuffleExcise=function(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r},t}(),GrowingRingBuffer=function(t){function e(){return t.call(this,e.INITIAL_CAPACITY)||this}return __extends(e,t),e.prototype.isFull=function(){return!1},e.prototype.push=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.push.call(this,e)},e.prototype.unshift=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.unshift.call(this,e)},e.prototype.expand=function(){for(var t=2*this.capacity,e=new Array(t),r=this.length(),n=0;n<r;n++)e[n]=this.get(this.wrap(this.begin+n));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r},e.INITIAL_CAPACITY=32,e}(RingBuffer);function iteratorFromItems(t){return new ArrayIterator(t)}function iteratorFromFunction(t){return new FunctionCallIterator(t)}function iteratorFromConcatenated(t,e){return new ChainedIterator(t,e)}function iteratorFromZipped(t,e){return void 0===e&&(e=ZipMismatchMode.FAIL),new ZipIterator(t,e)}var ZipMismatchMode,LazyIterator=function(){function t(){}return t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return t=[],[4,this.next()];case 1:e=r.sent(),r.label=2;case 2:return e.done?[3,4]:(t.push(e.value),[4,this.next()]);case 3:return e=r.sent(),[3,2];case 4:return[2,t]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return t=this.prefetch(100),e=[],[4,t.next()];case 1:r=n.sent(),n.label=2;case 2:return r.done?[3,4]:(e.push(r.value),[4,t.next()]);case 3:return r=n.sent(),[3,2];case 4:return[2,e]}})})},t.prototype.resolveFully=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.next()];case 1:t=e.sent(),e.label=2;case 2:return t.done?[3,4]:[4,this.next()];case 3:return t=e.sent(),[3,2];case 4:return[2]}})})},t.prototype.resolveWhile=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.next()];case 1:e=n.sent(),r=t(e.value),n.label=2;case 2:return e.done||!r?[3,4]:[4,this.next()];case 3:return e=n.sent(),r=t(e.value),[3,2];case 4:return[2]}})})},t.prototype.handleErrors=function(t){return new ErrorHandlingLazyIterator(this,t)},t.prototype.filter=function(t){return new FilterIterator(this,t)},t.prototype.map=function(t){return new MapIterator(this,t)},t.prototype.mapAsync=function(t){return new AsyncMapIterator(this,t)},t.prototype.serialMapAsync=function(t){return new AsyncMapIterator(this,t).serial()},t.prototype.flatmap=function(t){return new FlatmapIterator(this,t)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.map(t).resolveFully()]})})},t.prototype.serialForEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.serialMapAsync(t).resolveWhile(function(t){return!0===t})]})})},t.prototype.rowMajorBatch=function(t,e){return void 0===e&&(e=!0),new RowMajorBatchIterator(this,t,e)},t.prototype.columnMajorBatch=function(t,e,r){return void 0===e&&(e=!0),void 0===r&&(r=zipToList),this.rowMajorBatch(t,e).map(function(t){return deepZip(t,r)})},t.prototype.concatenate=function(t,e){return new ChainedIterator(iteratorFromItems([this,t]),e)},t.prototype.take=function(t){return t<0||null==t?this:new TakeIterator(this,t)},t.prototype.skip=function(t){return t<0||null==t?this:new SkipIterator(this,t)},t.prototype.prefetch=function(t){return new PrefetchIterator(this,t)},t.prototype.shuffle=function(t,e){return new ShuffleIterator(this,t,e)},t.prototype.serial=function(){return new SerialIterator(this)},t}(),ArrayIterator=function(t){function e(e){var r=t.call(this)||this;return r.items=e,r.trav=0,r}return __extends(e,t),e.prototype.summary=function(){return"Array of "+this.items.length+" items"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){return this.trav>=this.items.length?[2,{value:null,done:!0}]:(t=this.items[this.trav],e=t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"])(t):t,this.trav++,[2,{value:e,done:!1}])})})},e}(LazyIterator),FunctionCallIterator=function(t){function e(e){var r=t.call(this)||this;return r.nextFn=e,r}return __extends(e,t),e.prototype.summary=function(){return"Function call"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){try{return[2,this.nextFn()]}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}return[2]})})},e}(LazyIterator),SerialIterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.lastRead=Promise.resolve({value:null,done:!1}),r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Serial"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.upstream.next()]})})},e}(LazyIterator),SkipIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Skip"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return this.count++<this.maxCount?[4,this.upstream.next()]:[3,2];case 1:return(t=e.sent()).done?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2,this.upstream.next()]}})})},e}(LazyIterator),TakeIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Take"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.count++>=this.maxCount?[2,{value:null,done:!0}]:[2,this.upstream.next()]})})},e}(LazyIterator),RowMajorBatchIterator=function(t){function e(e,r,n){void 0===n&&(n=!0);var i=t.call(this)||this;return i.upstream=e,i.batchSize=r,i.enableSmallLastBatch=n,i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> RowMajorBatch"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:t=[],r.label=1;case 1:return t.length<this.batchSize?[4,this.upstream.next()]:[3,3];case 2:return(e=r.sent()).done?this.enableSmallLastBatch&&t.length>0?[2,{value:t,done:!1}]:[2,{value:null,done:!0}]:(t.push(e.value),[3,1]);case 3:return[2,{value:t,done:!1}]}})})},e}(LazyIterator),FilterIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.predicate=r,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Filter"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.upstream.next()];case 1:return(t=e.sent()).done||this.predicate(t.value)?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2]}})})},e}(LazyIterator),MapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Map"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,{value:null,done:!0}];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),ErrorHandlingLazyIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.handler=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> handleErrors"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:e.label=1;case 1:return e.trys.push([1,3,,4]),[4,this.upstream.next()];case 2:return[2,e.sent()];case 3:return t=e.sent(),this.handler(t)?[3,4]:[2,{value:null,done:!0}];case 4:return[3,0];case 5:return[2]}})})},e}(LazyIterator),AsyncMapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> AsyncMap"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:return(t=u.sent()).done?[2,{value:null,done:!0}]:(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),[4,this.transform(t.value)]);case 2:for(r=u.sent(),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),OneToManyIterator=function(t){function e(){var e=t.call(this)||this;return e.outputQueue=new GrowingRingBuffer,e.lastRead=Promise.resolve({value:null,done:!1}),e}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return 0!==this.outputQueue.length()?[3,2]:[4,this.pump()];case 1:return t.sent()?[3,0]:[2,{value:null,done:!0}];case 2:return[2,{value:this.outputQueue.shift(),done:!1}]}})})},e}(LazyIterator),FlatmapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Flatmap"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,!1];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),this.outputQueue.pushAll(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,!0]}})})},e}(OneToManyIterator),ChainedIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.baseErrorHandler=r,n.lastRead=null,n.iterator=null,n.moreIterators=e,n}return __extends(e,t),e.prototype.summary=function(){return"TODO: fill in upstream of chained summaries -> Chained"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.lastRead=this.readFromChain(this.lastRead),[2,this.lastRead]})})},e.prototype.readFromChain=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,t];case 1:return n.sent(),null!=this.iterator?[3,3]:[4,this.moreIterators.next()];case 2:if((e=n.sent()).done)return[2,{value:null,done:!0}];this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler)),n.label=3;case 3:return[4,this.iterator.next()];case 4:return(r=n.sent()).done?(this.iterator=null,[2,this.readFromChain(t)]):[2,r]}})})},e}(LazyIterator);!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(ZipMismatchMode||(ZipMismatchMode={}));var ZipIterator=function(t){function e(e,r){void 0===r&&(r=ZipMismatchMode.FAIL);var n=t.call(this)||this;return n.iterators=e,n.mismatchMode=r,n.count=0,n.currentPromise=null,n}return __extends(e,t),e.prototype.summary=function(){return"{TODO: fill in upstream of zip summaries} -> Zip"},e.prototype.nextState=function(t){return __awaiter(this,void 0,void 0,function(){function e(t){return t instanceof LazyIterator?{value:t.next().then(function(t){return r++,t.done&&n++,t.value}),recurse:!1}:{value:null,recurse:!0}}var r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,t];case 1:return o.sent(),r=0,n=0,[4,deepMapAndAwaitAll(this.iterators,e)];case 2:if(i=o.sent(),r===n)return[2,{value:null,done:!0}];if(n>0)switch(this.mismatchMode){case ZipMismatchMode.FAIL:throw new Error("Zipped streams should have the same length. Mismatched at element "+this.count+".");case ZipMismatchMode.SHORTEST:return[2,{value:null,done:!0}];case ZipMismatchMode.LONGEST:}return this.count++,[2,{value:i,done:!1}]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.currentPromise=this.nextState(this.currentPromise),[4,this.currentPromise];case 1:return[2,t.sent()]}})})},e}(LazyIterator),PrefetchIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.bufferSize=r,n.buffer=new RingBuffer(r),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Prefetch"},e.prototype.refill=function(){for(;!this.buffer.isFull();){var t=this.upstream.next();this.buffer.push(t)}},e.prototype.next=function(){return this.refill(),this.buffer.shift()},e}(LazyIterator),ShuffleIterator=function(t){function e(e,r,n){var i=t.call(this,e,r)||this;return i.upstream=e,i.windowSize=r,i.upstreamExhausted=!1,i.random=seedrandom_1(n||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString()),i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.randomInt=function(t){return Math.floor(this.random()*t)},e.prototype.chooseIndex=function(){return this.randomInt(this.buffer.length())},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:this.upstreamExhausted||this.refill(),r.label=1;case 1:return this.buffer.isEmpty()?[3,3]:(t=this.chooseIndex(),[4,this.buffer.shuffleExcise(t)]);case 2:return(e=r.sent()).done?(this.upstreamExhausted=!0,[3,1]):(this.refill(),[2,e]);case 3:return[2,{value:null,done:!0}]}})})},e}(PrefetchIterator),Dataset=function(){function t(){this.size=null}return t.prototype.batch=function(t,e){var r=this;void 0===e&&(e=!0);var n=this;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>0,function(){return"batchSize needs to be positive, but it is\n      "+t}),datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return[4,n.iterator()];case 1:return[2,r.sent().columnMajorBatch(t,e,deepBatchConcat)]}})})},this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t))},t.prototype.concatenate=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e,n;return __generator(this,function(i){switch(i.label){case 0:return[4,r.iterator()];case 1:return n=(e=i.sent()).concatenate,[4,t.iterator()];case 2:return[2,n.apply(e,[i.sent()])]}})})},this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null)},t.prototype.filter=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().filter(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size===1/0?1/0:null)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,this.iterator()];case 1:return[2,e.sent().forEachAsync(t)]}})})},t.prototype.forEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"])("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"),[2,this.forEachAsync(t)]})})},t.prototype.map=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size)},t.prototype.mapAsync=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().mapAsync(t)]}})})},this.size)},t.prototype.prefetch=function(t){var e=this;if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");var r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().prefetch(t)]}})})},this.size)},t.prototype.repeat=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e=this;return __generator(this,function(n){return[2,iteratorFromConcatenated(iteratorFromFunction(function(){return __awaiter(e,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return t={},[4,r.iterator()];case 1:return[2,(t.value=e.sent(),t.done=!1,t)]}})})}).take(t))]})})},null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null)},t.prototype.skip=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().skip(t)]}})})},null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null)},t.prototype.shuffle=function(t,e,r){var n=this;if(void 0===r&&(r=!0),null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size ("+this.size+" elements)");var i=this,o=seedrandom_1(e||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString());return datasetFromIteratorFn(function(){return __awaiter(n,void 0,void 0,function(){var e;return __generator(this,function(n){switch(n.label){case 0:return e=o.int32(),r&&(e+=o.int32()),[4,i.iterator()];case 1:return[2,n.sent().shuffle(t,e.toString())]}})})},this.size)},t.prototype.take=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().take(t)]}})})},null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null)},t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArray()]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArrayForTest()]}})})},t.MAX_BUFFER_SIZE=1e4,t}();function datasetFromIteratorFn(t,e){return void 0===e&&(e=null),new(function(r){function n(){var t=null!==r&&r.apply(this,arguments)||this;return t.size=e,t}return __extends(n,r),n.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,t()]})})},n}(Dataset))}function array(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){return[2,iteratorFromItems(t)]})})},t.length)}function zip(t){var e,r=this;if(!isIterable(t))throw new Error("The argument to zip() must be an object or array.");if(Array.isArray(t))for(var n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(var i in t)e=null==e?t[i].size:Math.min(e,t[i].size);return datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,deepMapAndAwaitAll(t,function(t){if(t instanceof Dataset)return{value:t.iterator(),recurse:!1};if(isIterable(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})];case 1:return[2,iteratorFromZipped(e.sent(),ZipMismatchMode.SHORTEST)]}})})},e)}function deepBatchConcat(t){return null===t?null:canTensorify(t[0])?{value:batchConcat(t),recurse:!1}:{value:null,recurse:!0}}function batchConcat(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(t):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])(t)}var TextLineDataset=function(t){function e(e){var r=t.call(this)||this;return r.input=e,r}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return[4,this.input.iterator()];case 1:return t=r.sent(),e=t.decodeUTF8(),[2,e.split("\n")]}})})},e}(Dataset),CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote"),CSVDataset=function(t){function e(e,r){var n=t.call(this)||this;return n.input=e,n.hasHeader=!0,n.fullColumnNames=null,n.columnNamesValidated=!1,n.columnConfigs=null,n.configuredColumnsOnly=!1,n.delimiter=",",n.delimWhitespace=!1,n.base=new TextLineDataset(e),r||(r={}),n.hasHeader=!1!==r.hasHeader,n.fullColumnNames=r.columnNames,n.columnConfigs=r.columnConfigs,n.configuredColumnsOnly=r.configuredColumnsOnly,r.delimWhitespace?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==r.delimiter,function(){return"Delimiter should not be provided when delimWhitespace is true."}),n.delimWhitespace=!0,n.delimiter=" "):n.delimiter=r.delimiter?r.delimiter:",",n}return __extends(e,t),e.prototype.columnNames=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:t.sent(),t.label=2;case 2:return[2,this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames]}})})},e.prototype.setColumnNames=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a=this;return __generator(this,function(u){switch(u.label){case 0:return[4,this.maybeReadHeaderLine()];case 1:if(t=u.sent(),!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");if(this.fullColumnNames&&t&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t.length===this.fullColumnNames.length,function(){return"The length of provided columnNames ("+a.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."}),this.fullColumnNames||(this.fullColumnNames=t),e=this.fullColumnNames.reduce(function(t,e){return t[e]=t[e]+1||1,t},{}),r=Object.keys(e).filter(function(t){return e[t]>1}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(0===r.length,function(){return"Duplicate column names found: "+r.toString()}),this.columnConfigs)for(n=0,i=Object.keys(this.columnConfigs);n<i.length;n++)if(o=i[n],-1===this.fullColumnNames.indexOf(o))throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");return this.columnNamesValidated=!0,[2]}})})},e.prototype.maybeReadHeaderLine=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return this.hasHeader?[4,this.base.iterator()]:[3,3];case 1:return[4,r.sent().next()];case 2:if((t=r.sent()).done)throw new Error("No data was found for CSV parsing.");return e=t.value,[2,this.parseRow(e,!1)];case 3:return[2,null]}})})},e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e=this;return __generator(this,function(r){switch(r.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:r.sent(),r.label=2;case 2:return[4,this.base.iterator()];case 3:return t=r.sent(),this.hasHeader&&(t=t.skip(1)),[2,t.map(function(t){return e.makeDataElement(t)})]}})})},e.prototype.makeDataElement=function(t){for(var e=this.parseRow(t),r={},n={},i=0;i<this.fullColumnNames.length;i++){var o=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[o]:null;if(!this.configuredColumnsOnly||a){var u=e[i],s=null;if(""===u)if(a&&void 0!==a.default)s=a.default;else{if(a&&(a.required||a.isLabel))throw new Error("Required column "+o+" is empty in this line: "+t);s=void 0}else{var c=Number(u);if(isNaN(c))s=a&&"bool"===a.dtype?this.getBoolean(u):u;else if(a&&a.dtype)switch(a.dtype){case"float32":s=c;break;case"int32":s=Math.floor(c);break;case"bool":s=this.getBoolean(u);break;default:s=c}else s=c}a&&a.isLabel?n[o]=s:r[o]=s}}return 0===Object.keys(n).length?r:{xs:r,ys:n}},e.prototype.getBoolean=function(t){return"1"===t||"true"===t.toLowerCase()?1:0},e.prototype.parseRow=function(t,e){void 0===e&&(e=!0);for(var r=[],n=0,i=t.length,o=STATE_OUT,a=0;a<i;a++)switch(o){case STATE_OUT:switch(t.charAt(a)){case CODE_QUOTE:n=a+1,o=STATE_QUOTE;break;case this.delimiter:if(n=a+1," "===this.delimiter&&this.delimWhitespace)break;r.push(""),o=STATE_OUT;break;default:o=STATE_FIELD,n=a}break;case STATE_FIELD:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a)),o=STATE_OUT,n=a+1}break;case STATE_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE_AFTER_QUOTE}break;case STATE_QUOTE_AFTER_QUOTE:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a-1)),o=STATE_OUT,n=a+1;break;case CODE_QUOTE:o=STATE_QUOTE;break;default:o=STATE_WITHIN_QUOTE_IN_QUOTE}break;case STATE_WITHIN_QUOTE_IN_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE}}if(o===STATE_QUOTE_AFTER_QUOTE?r.push(t.substring(n,i-1)):r.push(t.substring(n)),e&&r.length!==this.fullColumnNames.length)throw new Error("Invalid row in csv file. Should have "+this.fullColumnNames.length+" elements in a row, but got "+r);return r},e}(Dataset),environment=createCommonjsModule(function(t,e){Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){var n=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+n+"."),this.set(t,n)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=n(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var r=e.split(":"),n=r[0],i=r[1];t.urlFlags[n]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(n,i)})}},t}();function n(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];return function(t,e,r){t[decodeURIComponent(e)]=decodeURIComponent(r||"")}(e,r[0],r[1]),r.join("=")}),e}e.Environment=r,e.getQueryParams=n,e.setEnvironmentGlobal=function(t){e.ENV=t}});unwrapExports(environment);var environment_1=environment.Environment,environment_2=environment.getQueryParams,environment_3=environment.ENV,environment_4=environment.setEnvironmentGlobal,util$1=createCommonjsModule(function(t,e){function r(t){for(var e=t.length,r=0,n=0;e>0;)n=Math.random()*e|0,r=t[--e],t[e]=t[n],t[n]=r}function n(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function i(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||c(t))for(var r=0;r<t.length;++r)i(t[r],e);else e.push(t);return e}function o(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function a(t){return t%1==0}function u(t,e){var r=e.length;return n((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-r&&t<r}),function(){return"All values in axis param must be in range [-"+r+", "+r+") but got axis "+t}),n(t.every(function(t){return a(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?r+t:t})}function s(t,e){for(var r=0;r<t.length;r++){var n=t[r];if(isNaN(n)||!isFinite(n))throw Error("A tensor of type "+e+" being uploaded contains "+n+".")}}function c(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function l(t){return"string"==typeof t||t instanceof String}function f(t){return"boolean"==typeof t}function h(t){return"number"==typeof t}function p(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}Object.defineProperty(e,"__esModule",{value:!0}),e.shuffle=r,e.clamp=function(t,e,r){return Math.max(t,Math.min(e,r))},e.nearestLargerEven=function(t){return t%2==0?t:t+1},e.sum=function(t){for(var e=0,r=0;r<t.length;r++)e+=t[r];return e},e.randUniform=function(t,e){var r=Math.random();return e*r+(1-r)*t},e.distSquared=function(t,e){for(var r=0,n=0;n<t.length;n++){var i=Number(t[n])-Number(e[n]);r+=i*i}return r},e.assert=n,e.assertShapesMatch=function(t,e,r){void 0===r&&(r=""),n(o(t,e),function(){return r+" Shapes "+t+" and "+e+" must match"})},e.assertNonNull=function(t){n(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})},e.flatten=i,e.sizeFromShape=function(t){if(0===t.length)return 1;for(var e=t[0],r=1;r<t.length;r++)e*=t[r];return e},e.isScalarShape=function(t){return 0===t.length},e.arraysEqual=o,e.isInt=a,e.tanh=function(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)},e.sizeToSquarishShape=function(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]},e.createShuffledIndices=function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return r(e),e},e.rightPad=function(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)},e.repeatedTry=function(t,e,r){return void 0===e&&(e=function(t){return 0}),new Promise(function(n,i){var o=0,a=function(){if(t())n();else{var u=e(++o);null!=r&&o>=r?i():setTimeout(a,u)}};a()})},e.inferFromImplicitShape=function(t,e){for(var r=1,n=-1,i=0;i<t.length;++i)if(t[i]>=0)r*=t[i];else if(-1===t[i]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+i);n=i}else if(t[i]<0)throw Error("Shapes can not be < 0. Found "+t[i]+" at dim "+i);if(-1===n){if(e>0&&e!==r)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===r)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%r!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+r);var o=t.slice();return o[n]=e/r,o},e.parseAxisParam=u,e.squeezeShape=function(t,e){for(var r=[],n=[],i=null==e?null:u(e,t).sort(),o=0,a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error("Can't squeeze axis "+a+" since its dim '"+t[a]+"' is not 1");(null==i[o]||i[o]>a)&&1===t[a]&&(r.push(t[a]),n.push(a)),i[o]<=a&&o++}1!==t[a]&&(r.push(t[a]),n.push(a))}return{newShape:r,keptDims:n}},e.getTypedArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);r=new Uint8Array(e)}return r},e.getArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else if("bool"===t)r=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);r=new Array(e)}return r},e.checkComputationForErrors=function(t,e,r){if("float32"===e)for(var n=0;n<t.length;n++){var i=t[n];if(isNaN(i)||!isFinite(i))throw Error("The result of the '"+r+"' is "+i+".")}},e.checkConversionForErrors=s,e.hasEncodingLoss=function(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)},e.isTypedArray=c,e.bytesPerElement=function(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)},e.bytesFromStringArray=function(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e},e.isString=l,e.isBoolean=f,e.isNumber=h,e.inferDtype=function t(e){return Array.isArray(e)?t(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":h(e)?"float32":l(e)?"string":f(e)?"bool":"float32"},e.isFunction=function(t){return!!(t&&t.constructor&&t.call&&t.apply)},e.nearestDivisor=function(t,e){for(var r=e;r<t;++r)if(t%r==0)return r;return t},e.computeStrides=function(t){var e=t.length;if(e<2)return[];var r=new Array(e-1);r[e-2]=t[e-1];for(var n=e-3;n>=0;--n)r[n]=r[n+1]*t[n+1];return r},e.toTypedArray=function(t,e,r){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=i(t)),r&&s(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var n=new Uint8Array(t.length),o=0;o<n.length;++o)0!==Math.round(t[o])&&(n[o]=1);return n}throw new Error("Unknown data type "+e)},e.toNestedArray=function(t,e){if(0===t.length)return e[0];var r=t.reduce(function(t,e){return t*e});if(0===r)return[];if(r!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,r,n){var i=new Array;if(1===r.length)for(var o=r[0],a=0;a<o;a++)i[a]=n[e+a];else{o=r[0];var u=r.slice(1),s=u.reduce(function(t,e){return t*e});for(a=0;a<o;a++)i[a]=t(e+a*s,u,n)}return i}(0,t,e)},e.makeOnesTypedArray=function(t,e){for(var r=p(t,e),n=0;n<r.length;n++)r[n]=1;return r},e.makeZerosTypedArray=p,e.now=function(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")},e.assertNonNegativeIntegerDimensions=function(t){t.forEach(function(e){n(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})};var d=function(){if(null!=environment.ENV.global.fetch)return environment.ENV.global.fetch;if(environment.ENV.get("IS_NODE"))return e.getNodeFetch.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")};e.getNodeFetch={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 5)}},e.fetch=function(t,r){return null==e.systemFetch&&(e.systemFetch=d()),e.systemFetch(t,r)}});unwrapExports(util$1);var util_1=util$1.shuffle,util_2=util$1.clamp,util_3=util$1.nearestLargerEven,util_4=util$1.sum,util_5=util$1.randUniform,util_6=util$1.distSquared,util_7=util$1.assert,util_8=util$1.assertShapesMatch,util_9=util$1.assertNonNull,util_10=util$1.flatten,util_11=util$1.sizeFromShape,util_12=util$1.isScalarShape,util_13=util$1.arraysEqual,util_14=util$1.isInt,util_15=util$1.tanh,util_16=util$1.sizeToSquarishShape,util_17=util$1.createShuffledIndices,util_18=util$1.rightPad,util_19=util$1.repeatedTry,util_20=util$1.inferFromImplicitShape,util_21=util$1.parseAxisParam,util_22=util$1.squeezeShape,util_23=util$1.getTypedArrayFromDType,util_24=util$1.getArrayFromDType,util_25=util$1.checkComputationForErrors,util_26=util$1.checkConversionForErrors,util_27=util$1.hasEncodingLoss,util_28=util$1.isTypedArray,util_29=util$1.bytesPerElement,util_30=util$1.bytesFromStringArray,util_31=util$1.isString,util_32=util$1.isBoolean,util_33=util$1.isNumber,util_34=util$1.inferDtype,util_35=util$1.isFunction,util_36=util$1.nearestDivisor,util_37=util$1.computeStrides,util_38=util$1.toTypedArray,util_39=util$1.toNestedArray,util_40=util$1.makeOnesTypedArray,util_41=util$1.makeZerosTypedArray,util_42=util$1.now,util_43=util$1.assertNonNegativeIntegerDimensions,util_44=util$1.getNodeFetch,util_45=util$1.systemFetch,util_46=util$1.fetch,WebcamIterator=function(t){function e(e,r){var n=t.call(this)||this;if(n.webcamVideoElement=e,n.webcamConfig=r,n.isClosed=!0,n.resize=!1,n.needToResize())if(n.resize=!0,n.cropSize=[n.webcamConfig.resizeHeight,n.webcamConfig.resizeWidth],n.cropBoxInd=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])([0],"int32"),n.webcamConfig.centerCrop){var i=1*n.webcamConfig.resizeWidth/n.webcamVideoElement.width,o=1*n.webcamConfig.resizeHeight/n.webcamVideoElement.height,a=(1-i)/2,u=(1-o)/2,s=a+i,c=o+u;n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([u,a,c,s],[1,4])}else n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([0,0,1,1],[1,4]);return n}return __extends(e,t),e.prototype.summary=function(){return"webcam"},e.create=function(t,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(i){switch(i.label){case 0:if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!r.resizeWidth||!r.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=r.resizeWidth,t.height=r.resizeHeight}return[4,(n=new e(t,r)).start()];case 1:return i.sent(),[2,n]}})})},e.prototype.start=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:this.webcamConfig.facingMode&&util_7("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,function(){return"Invalid webcam facing mode: "+r.webcamConfig.facingMode+". Please provide 'user' or 'environment'"}),n.label=1;case 1:return n.trys.push([1,3,,4]),t=this,[4,navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})];case 2:return t.stream=n.sent(),[3,4];case 3:throw(e=n.sent()).message="Error thrown while initializing video stream: "+e.message,e;case 4:if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,[2,new Promise(function(t){r.webcamVideoElement.onloadedmetadata=function(){t()}})]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){if(this.isClosed)return[2,{value:null,done:!0}];try{t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"].fromPixels(this.webcamVideoElement)}catch(t){throw new Error("Error thrown converting video to pixels: "+JSON.stringify(t))}if(!this.resize)return[2,{value:t,done:!1}];try{return[2,{value:this.cropAndResizeFrame(t),done:!1}]}catch(t){throw new Error("Error thrown cropping the video: "+t.message)}return[2]})})},e.prototype.needToResize=function(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)},e.prototype.cropAndResizeFrame=function(t){var e,r=t.toFloat().expandDims(0),n=(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(r,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return e.reshape(n.slice(1))},e.prototype.capture=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return[4,this.next()];case 1:return[2,t.sent().value]}})})},e.prototype.stop=function(){this.stream.getTracks().forEach(function(t){return t.stop()});try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0},e.prototype.toArray=function(){throw new Error("Can not convert infinite video stream to array.")},e}(LazyIterator),DataSource=function(){return function(){}}(),StringIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.split=function(t){return new SplitIterator(this,t)},e}(LazyIterator),SplitIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.impl=new SplitIteratorImpl(e,r),n}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),SplitIteratorImpl=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.separator=r,n.carryover="",n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Split('"+this.separator+"')"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,this.upstream.next()];case 1:if((t=o.sent()).done)return""===this.carryover?[2,!1]:(this.outputQueue.push(this.carryover),this.carryover="",[2,!0]);for((e=t.value.split(this.separator))[0]=this.carryover+e[0],r=0,n=e.slice(0,-1);r<n.length;r++)i=n[r],this.outputQueue.push(i);return this.carryover=e[e.length-1],[2,!0]}})})},e}(OneToManyIterator),ByteChunkIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.decodeUTF8=function(){return new Utf8Iterator(this)},e}(LazyIterator),Utf8Iterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.impl=new Utf8IteratorImpl(e),r}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),Utf8IteratorImpl=function(t){function e(e){var r=t.call(this)||this;if(r.upstream=e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER"))r.decoder=new TextDecoder("utf-8");else{var n=__webpack_require__(/*! string_decoder */ 6).StringDecoder;r.decoder=new n("utf8")}return r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Utf8"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.upstream.next()];case 1:return(t=n.sent()).done?[2,!1]:(e=t.value,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(r),[2,!0])}})})},e}(OneToManyIterator),FileChunkIterator=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.file=e,n.options=r,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e instanceof Uint8Array||!!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),function(){return"FileChunkIterator only supports File, Blob and Uint8Array right now."}),n.offset=r.offset||0,n.chunkSize=r.chunkSize||1048576,n}return __extends(e,t),e.prototype.summary=function(){return"FileChunks "+this.file},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?[2,{value:null,done:!0}]:(t=new Promise(function(t,e){var n=r.offset+r.chunkSize;if(r.file instanceof Uint8Array)t(new Uint8Array(r.file.slice(r.offset,n)));else{var i=new FileReader;i.onload=function(r){var n=i.result;if(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),!(n instanceof Uint8Array))return e(new TypeError("FileReader returned unknown type."));t(n)},i.onabort=function(t){return e(new Error("Aborted"))},i.onerror=function(t){return e(new Error(t.type))};var o=r.file.slice(r.offset,n);i.readAsArrayBuffer(o)}r.offset=n}),e={},[4,t]);case 1:return[2,(e.value=n.sent(),e.done=!1,e)]}})})},e}(ByteChunkIterator);function urlChunkIterator(t,e){return void 0===e&&(e={}),__awaiter(this,void 0,void 0,function(){var r,n,i,o;return __generator(this,function(a){switch(a.label){case 0:return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?[4,fetch(t)]:[3,5];case 1:return(r=a.sent()).ok?[4,r.blob()]:[3,3];case 2:return n=a.sent(),[2,new FileChunkIterator(n,e)];case 3:throw new Error(r.statusText);case 4:return[3,9];case 5:if(i=__webpack_require__(/*! node-fetch */ 5),"string"!=typeof t)throw new Error("URL must be a string. Request objects are not supported in the node.js environment yet.");return[4,i(t)];case 6:return(r=a.sent()).ok?[4,r.buffer()]:[3,8];case 7:return o=a.sent(),[2,new FileChunkIterator(o,e)];case 8:throw new Error(r.statusText);case 9:return[2]}})})}function isLocalPath(t){return"string"==typeof t&&"file://"===t.substr(0,7)}var FileDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.input=e,n.options=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){return isLocalPath(this.input)&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE")&&(t=__webpack_require__(/*! fs */ 7),this.input=t.readFileSync(this.input.substr(7))),[2,new FileChunkIterator(this.input,this.options)]})})},e}(DataSource),URLDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.url=e,n.fileOptions=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return isLocalPath(this.url)?[2,new FileDataSource(this.url,this.fileOptions).iterator()]:[2,urlChunkIterator(this.url,this.fileOptions)]})})},e}(DataSource);function csv(t,e){return void 0===e&&(e={}),new CSVDataset(new URLDataSource(t),e)}function func(t){var e=this,r=iteratorFromFunction(t);return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(t){return[2,r]})})})}function generator(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e;return __generator(this,function(r){switch(r.label){case 0:return[4,t()];case 1:return e=r.sent(),[2,iteratorFromFunction(function(){return e.next()})]}})})})}function webcam(t,e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,WebcamIterator.create(t,e)]})})}var version="1.1.2";
//# sourceMappingURL=tf-data.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js ***!
  \********************************************************************/
/*! exports provided: constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return exports_constraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return exports_initializers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return exports_layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return exports_metrics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "models", function() { return exports_models; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return exports_regularizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return CallbackList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return CustomCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "History", function() { return History; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return Callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return callbacks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return EarlyStopping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return InputSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return SymbolicTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return LayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "input", function() { return input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return loadLayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return registerCallbackConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return RNN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return Sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return LayerVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function __extends(e,t){function n(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var _epsilon,__assign=function(){return(__assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function __awaiter(e,t,n,r){return new(n||(n=Promise))(function(i,a){function o(e){try{l(r.next(e))}catch(e){a(e)}}function s(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(o,s)}l((r=r.apply(e,t||[])).next())})}function __generator(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(6===a[0]||2===a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}function epsilon(){return null==_epsilon&&(_epsilon=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"])().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}var AttributeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),RuntimeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),ValueError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),NotImplementedError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),AssertionError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),IndexError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error);function pyListRepeat(e,t){if(Array.isArray(e)){for(var n=[],r=0;r<t;r++)n=n.concat(e);return n}return(n=new Array(t)).fill(e),n}function assert(e,t){if(!e)throw new AssertionError(t)}function count(e,t){for(var n=0,r=0,i=e;r<i.length;r++){i[r]===t&&n++}return n}function singletonOrArray(e){return 1===e.length?e[0]:e}function toList(e){return Array.isArray(e)?e:[e]}function toSnakeCase(e){var t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function toCamelCase(e){return e.length<=1?e:-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,function(e,t){return t.toUpperCase()})}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(e){if(null===e||void 0===e)return null;var t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function convertNDArrayScalarsInConfig(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(function(e){return convertNDArrayScalarsInConfig(e)});else for(var t=0,n=Object.keys(e);t<n.length;t++){var r=n[t],i=e[r];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?convertNDArrayScalarsInConfig(i):e[r]=i.value)}}function deserializeKerasObject(e,t,n,r,i){var a,o,s;if(void 0===t&&(t={}),void 0===n&&(n={}),void 0===r&&(r="object"),void 0===i&&(i=!1),"string"==typeof e){var l=e,u=void 0;if(l in n)u=n[l];else if(l in _GLOBAL_CUSTOM_OBJECTS)u=_GLOBAL_CUSTOM_OBJECTS[l];else if(null==(u=t[l]))throw new ValueError("Unknown "+r+": "+e+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return u}var c=e;if(null==c.className||null==c.config)throw new ValueError(r+": Improper config format: "+JSON.stringify(c)+".\n'className' and 'config' must set.");var p=c.className,h=void 0,d=void 0;if(p in n?(h=(a=n[p])[0],d=a[1]):p in _GLOBAL_CUSTOM_OBJECTS?(h=(o=_GLOBAL_CUSTOM_OBJECTS.className)[0],d=o[1]):p in t&&(h=(s=t[p])[0],d=s[1]),null==h)throw new ValueError("Unknown "+r+": "+p+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=d){for(var f={},g=0,m=Object.keys(_GLOBAL_CUSTOM_OBJECTS);g<m.length;g++){f[S=m[g]]=_GLOBAL_CUSTOM_OBJECTS[S]}for(var y=0,v=Object.keys(n);y<v.length;y++){f[S=v[y]]=n[S]}c.config.customObjects=f;for(var b=__assign({},_GLOBAL_CUSTOM_OBJECTS),w=0,z=Object.keys(n);w<z.length;w++){var S=z[w];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}convertNDArrayScalarsInConfig(c.config);var I=d(h,c.config,n,i);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}b=__assign({},_GLOBAL_CUSTOM_OBJECTS);for(var A=0,_=Object.keys(n);A<_.length;A++){S=_[A];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}I=new h(c.config);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}function numberCompare(e,t){return e<t?-1:e>t?1:0}function reverseNumberCompare(e,t){return-1*numberCompare(e,t)}function unique(e){if(null==e)return e;for(var t=[],n=0,r=e;n<r.length;n++){var i=r[n];-1===t.indexOf(i)&&t.push(i)}return t}function isObjectEmpty(e){if(null==e)throw new ValueError("Invalid value in obj: "+JSON.stringify(e));for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function checkStringTypeUnionValue(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new ValueError(n+" is not a valid "+t+".  Valid values are "+e+" or null/undefined.")}function checkArrayTypeAndLength(e,t,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),assert(n>=0),assert(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(function(e){return typeof e===t})}function assertPositiveInteger(e,t){Array.isArray(e)?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.length>0,function(){return t+" is unexpectedly an empty array."}),e.forEach(function(e,n){return assertPositiveInteger(e,"element "+(n+1)+" of "+t)})):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Number.isInteger(e)&&e>0,function(){return"Expected "+t+" to be a positive integer, but got "+formatAsFriendlyString(e)+"."})}function formatAsFriendlyString(e){return null===e?"null":Array.isArray(e)?"["+e.map(function(e){return formatAsFriendlyString(e)}).join(",")+"]":"string"==typeof e?'"'+e+'"':""+e}function debounce(e,t){var n,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return function(){for(var i=[],a=0;a<arguments.length;a++)i[a]=arguments[a];var o=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return o-r<t?n:(r=o,n=e.apply(void 0,i))}}function calcL2Norms(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e),t,!0))})}var Constraint=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),MaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,t.maxValue);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},t.className="MaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxNorm);var UnitNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultAxis=0,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),calcL2Norms(e,t.axis)))})},t.prototype.getConfig=function(){return{axis:this.axis}},t.className="UnitNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UnitNorm);var NonNeg=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="NonNeg",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(NonNeg);var MinMaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=t.minValue?t.minValue:n.defaultMinValue,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.rate=null!=t.rate?t.rate:n.defaultRate,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.rate,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,t.minValue,t.maxValue)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1-t.rate,n));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},t.className="MinMaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(e){return serializeKerasObject(e)}function deserializeConstraint(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"constraint")}function getConstraint(e){return null==e?null:"string"==typeof e?deserializeConstraint({className:e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Constraint?e:deserializeConstraint(e)}function maxNorm(e){return new MaxNorm(e)}function unitNorm(e){return new UnitNorm(e)}function nonNeg(){return new NonNeg}function minMaxNorm(e){return new MinMaxNorm(e)}var exports_constraints=Object.freeze({maxNorm:maxNorm,unitNorm:unitNorm,nonNeg:nonNeg,minMaxNorm:minMaxNorm}),VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],nameMap=new Map;function checkDataFormat(e){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",e)}function checkPaddingMode(e){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",e)}function checkPoolMode(e){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",e)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(e,t){_nameScopeStack.push(e);try{var n=t();return _nameScopeStack.pop(),n}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");return currentNameScopePrefix()+e}function getUniqueTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");nameMap.has(e)||nameMap.set(e,0);var t=nameMap.get(e);if(nameMap.set(e,nameMap.get(e)+1),t>0){var n=e+"_"+t;return nameMap.set(n,1),n}return e}var tensorNameRegex=new RegExp(/^[A-Za-z][-A-Za-z0-9\._\/]*$/);function isValidTensorName(e){return!!e.match(tensorNameRegex)}function isInteger(e){return e===parseInt(e.toString(),10)}function arrayProd(e,t,n){null==t&&(t=0),null==n&&(n=e.length);for(var r=1,i=t;i<n;++i)r*=e[i];return r}function toArray1D(e){return e=Array.isArray(e)?new Float32Array(e):e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e)}function min$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(toArray1D(e)).dataSync()[0]}function max$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(toArray1D(e)).dataSync()[0]}function range(e,t){if(t<e)throw new ValueError("end ("+t+") < begin ("+e+") is forbidden.");for(var n=[],r=e;r<t;++r)n.push(r);return n}function cast$1(e,t){return e.asType(t)}function expandDims$1(e,t){void 0===t&&(t=-1);var n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function repeat(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.shape.length)throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-"+e.shape.length+" tensor.");return tile$1(expandDims$1(e,1),[1,t,1])})}function flatten(e){var t=[arrayProd(e.shape)];return e.reshape(t)}function batchFlatten(e){if(e.rank<=1)throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: "+e.rank+".");var t=[e.shape[0],arrayProd(e.shape,1)];return e.reshape(t)}function sliceAlongFirstAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[t,0],[n,e.shape[1]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);default:throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongLastAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[0,t],[e.shape[0],n]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongAxis(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function concatenate(e,t){var n;return void 0===t&&(t=-1),t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,t)}function concatAlongFirstAxis(e,t){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"])([e,t]);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"])([e,t],0);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"])([e,t],0);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"])([e,t],0);default:throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}}function tile$1(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ValueError("The length of input n ("+t.length+") does not match the number of dimensions in input x ("+e.rank+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(e,t)}function randomNormal$1(e,t,n,r,i){return void 0===t&&(t=0),void 0===n&&(n=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"])(e,t,n,r,i)}function dot(e,t,n,r){if(e.rank<2||t.rank<2)throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = "+e.shape+" and y shape = "+t.shape);if(t.rank>=3&&(s=e.shape.slice(-1)[0])!==(c=t.shape.slice(-2)[0]))throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+e.shape+" and  y shape = "+t.shape);if(2===e.rank&&2===t.rank){var i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n)}var o=e.shape.slice(),s=o.pop();e=e.reshape([-1,s]);var l=t.shape.slice(),u=l.pop(),c=l.pop(),p=l.concat([u]),h=Array.from({length:t.rank},function(e,n){return 0===n?t.rank-2:n<=t.rank-2?n-1:n});t=t.transpose(h).reshape([c,-1]);var d=o.concat(p);i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n).reshape(d)}function gather$1(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t=Array.isArray(t)?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(t,"int32"):t.toInt(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(e,t,n)})}function square(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e)}function reshapeBias(e,t,n){var r=t.shape;if(1!==t.rank&&t.rank!==e)throw new ValueError("Unexpected bias dimensions: "+t.rank+"; expected it to be 1 or "+e);if(5===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1,1]):t.reshape([1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,1,r[0]]):t.reshape([1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1]):t.reshape([1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,r[0]]):t.reshape([1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1]):t.reshape([1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,r[0]]):t.reshape([1].concat(r))}else if(e<3)return t;throw new ValueError("Unsupported input rank by biasAdd: "+t.rank)}function biasAdd(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==n&&(n=imageDataFormat()),checkDataFormat(n),e.add(reshapeBias(e.rank,t,n))})}function elu$1(e,t){if(void 0===t&&(t=1),1!==t)throw new NotImplementedError("Support for alpha values other than 1 ("+t+") is not implemented yet.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(e)}function softsign(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e).add(1))})}function dropout(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=n&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,n))throw new NotImplementedError("Non-default noise shape is not implemented yet: "+JSON.stringify(n));if(null!=r)throw new NotImplementedError("seed is not implemented for dropout yet.");var i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(-t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e.shape,0,1,"float32")));return i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/(1-t),i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,i)})}function hardSigmoid(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.2,e));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,0,1)})}function inTrainPhase(e,t,n){return void 0===n&&(n=!1),n?e():t()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];function checkFanMode(e){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",e)}function checkDistribution(e){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",e)}var Initializer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.fromConfigUsesCustomObjects=function(){return!1},t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Zeros=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e,t)},t.className="Zeros",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Zeros);var Ones=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t)},t.className="Ones",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Ones);var Constant=function(e){function t(t){var n=e.call(this)||this;if("object"!=typeof t)throw new ValueError("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new ValueError("config must have value set but got "+t);return n.value=t.value,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(n.value),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t))})},t.prototype.getConfig=function(){return{value:this.value}},t.className="Constant",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Constant);var RandomUniform=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=t.minval||n.DEFAULT_MINVAL,n.maxval=t.maxval||n.DEFAULT_MAXVAL,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,this.minval,this.maxval,t)},t.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},t.className="RandomUniform",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomUniform);var RandomNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("randomNormal does not support dType "+t+".");return randomNormal$1(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="RandomNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomNormal);var TruncatedNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("truncatedNormal does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="TruncatedNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TruncatedNormal);var Identity=function(e){function t(t){var n=e.call(this)||this;return n.gain=null!=t.gain?t.gain:1,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"])(e[0]))})},t.prototype.getConfig=function(){return{gain:this.gain}},t.className="Identity",t}(Initializer);function computeFans(e,t){var n,r;if(void 0===t&&(t="channelsLast"),checkDataFormat(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){var i=arrayProd(e,2);n=e[1]*i,r=e[0]*i}else if("channelsLast"===t){i=arrayProd(e,0,e.length-2);n=e[e.length-2]*i,r=e[e.length-1]*i}}else{var a=arrayProd(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Identity);var VarianceScaling=function(e){function t(t){var n=e.call(this)||this;if(t.scale<0)throw new ValueError("scale must be a positive float. Got: "+t.scale);return n.scale=null==t.scale?1:t.scale,n.mode=null==t.mode?"fanIn":t.mode,checkFanMode(n.mode),n.distribution=null==t.distribution?"normal":t.distribution,checkDistribution(n.distribution),n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=computeFans(e),r=n[0],i=n[1],a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),"normal"===this.distribution){var o=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(this.getClassName()+" does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,0,o,t,this.seed)}var s=Math.sqrt(3*a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,-s,s,t)},t.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},t.className="VarianceScaling",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(VarianceScaling);var GlorotUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotUniform);var GlorotNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotNormal);var HeNormal=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeNormal);var HeUniform=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeUniform);var LeCunNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunNormal);var LeCunUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunUniform);var Orthogonal=function(e){function t(t){var n=e.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==t.gain?n.DEFAULT_GAIN:t.gain,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");return n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length)throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+e[0]*e[1]+") elements: Slowness may result.");var t=randomNormal$1(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32"),r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"].gramSchmidt(t);return e[0]>e[1]&&(r=r.transpose()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,r)})},t.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},t.className="Orthogonal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"initializer")}function serializeInitializer(e){return serializeKerasObject(e)}function getInitializer(e){if("string"==typeof e){var t=e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e;if("GlorotNormal"===t)return new GlorotNormal;if("GlorotUniform"===t)return new GlorotUniform;if("HeNormal"===t)return new HeNormal;if("HeUniform"===t)return new HeUniform;if("LeCunNormal"===t)return new LeCunNormal;if("LeCunUniform"===t)return new LeCunUniform;var n={};return n.className=t,n.config={},deserializeInitializer(n)}return e instanceof Initializer?e:deserializeInitializer(e)}function zeros$1(){return new Zeros}function ones$1(){return new Ones}function constant(e){return new Constant(e)}function randomUniform$1(e){return new RandomUniform(e)}function randomNormal$2(e){return new RandomNormal(e)}function truncatedNormal$1(e){return new TruncatedNormal(e)}function identity(e){return new Identity(e)}function varianceScaling(e){return new VarianceScaling(e)}function glorotUniform(e){return new GlorotUniform(e)}function glorotNormal(e){return new GlorotNormal(e)}function heNormal(e){return new HeNormal(e)}function heUniform(e){return new HeUniform(e)}function leCunNormal(e){return new LeCunNormal(e)}function leCunUniform(e){return new LeCunUniform(e)}function orthogonal(e){return new Orthogonal(e)}var exports_initializers=Object.freeze({zeros:zeros$1,ones:ones$1,constant:constant,randomUniform:randomUniform$1,randomNormal:randomNormal$2,truncatedNormal:truncatedNormal$1,identity:identity,varianceScaling:varianceScaling,glorotUniform:glorotUniform,glorotNormal:glorotNormal,heNormal:heNormal,heUniform:heUniform,leCunNormal:leCunNormal,leCunUniform:leCunUniform,orthogonal:orthogonal}),_nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(e){return void 0===e&&(e=""),e in _uidPrefixes||(_uidPrefixes[e]=0),_uidPrefixes[e]+=1,e+_uidPrefixes[e].toString()}function isArrayOfShapes(e){return Array.isArray(e)&&Array.isArray(e[0])}function normalizeShapeList(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function getExactlyOneTensor(e){var t;if(Array.isArray(e)){if(1!==e.length)throw new ValueError("Expected Tensor length to be 1; got "+e.length);t=e[0]}else t=e;return t}function getExactlyOneShape(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new ValueError("Expected exactly 1 Shape; got "+e.length)}return e}function countParamsInWeights(e){for(var t=0,n=0,r=e;n<r.length;n++){var i=r[n];0===i.shape.length?t+=1:t+=i.shape.reduce(function(e,t){return e*t})}return t}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=function(){function e(e,t,n,r,i){void 0===t&&(t="float32"),void 0===n&&(n=DEFAULT_VARIABLE_NAME_PREFIX),void 0===r&&(r=!0),void 0===i&&(i=null),this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=getNextUniqueTensorId(),n=null==n?DEFAULT_VARIABLE_NAME_PREFIX:n,this.originalName=getScopedTensorName(n),this.name=getUniqueTensorName(this.originalName),this.trainable_=r,this.constraint=i,this.val=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"])(e,this.trainable_,this.name,this.dtype)}return e.prototype.read=function(){return this.assertNotDisposed(),this.val},e.prototype.write=function(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},e.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},e.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},Object.defineProperty(e.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.trainable_=e,this.val.trainable=e},enumerable:!0,configurable:!0}),e}();function checkShapesMatch(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function batchGetValue(e){return e.map(function(e){return e.read()})}function batchSetValue(e){e.forEach(function(e){e[0].write(e[1])})}var InputSpec=function(){return function(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}(),SymbolicTensor=function(){return function(e,t,n,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=getNextUniqueTensorId(),null!=a&&(this.originalName=getScopedTensorName(a),this.name=getUniqueTensorName(this.originalName)),this.rank=t.length}}(),_nextNodeID=0,Node=function(){function e(e,t){this.callArgs=t,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(var n=0,r=e.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}e.outboundLayer.inboundNodes.push(this)}return e.prototype.getConfig=function(){for(var e=[],t=0,n=this.inboundLayers;t<n.length;t++){var r=n[t];null!=r?e.push(r.name):e.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},e}(),_nextLayerID=0,Layer=function(e){function t(t){var n=e.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=_nextLayerID++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=t.name;if(!r){var i=n.getClassName();r=toSnakeCase(i)+"_"+getUid(i)}if(n.name=r,n.trainable_=null==t.trainable||t.trainable,n.updatable=null==t.updatable||t.updatable,null!=t.inputShape||null!=t.batchInputShape){var a=void 0;if(null!=t.batchInputShape)a=t.batchInputShape;else if(null!=t.inputShape){var o=null;null!=t.batchSize&&(o=t.batchSize),a=[o].concat(t.inputShape)}n.batchInputShape=a;var s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),n.dtype=s}return null!=t.weights?n.initialWeights=t.weights:n.initialWeights=null,n._refCount=null,n.fastWeightInitDuringBuild=!1,n}return __extends(t,e),t.nodeKey=function(e,t){return e.name+"_ib-"+t.toString()},t.prototype.getNodeAtIndex=function(e,t){if(0===this.inboundNodes.length)throw new RuntimeError("The layer has never been called and thus has no defined "+t+".");if(this.inboundNodes.length<=e)throw new ValueError("Asked to get "+t+" at node "+e+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[e]},t.prototype.getInputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)},t.prototype.getOutputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)},Object.defineProperty(t.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" is not connected, no input to return.");return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),t.prototype.calculateLosses=function(){return this.losses.map(function(e){return e()})},Object.defineProperty(t.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"built",{get:function(){return this._built},set:function(e){this._built=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this._trainableWeights.forEach(function(t){return t.trainable=e}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter(function(e){return e.trainable}):[]},set:function(e){this._trainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._trainableWeights.filter(function(e){return!e.trainable}).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(e){this._nonTrainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},t.prototype.assertInputCompatibility=function(e){if(e=toList(e),null!=this.inputSpec&&0!==this.inputSpec.length){var t=toList(this.inputSpec);if(e.length!==t.length)throw new ValueError("Layer "+this.name+" expects "+t.length+" inputs, but it received "+e.length+" input tensors. Input received: "+e);for(var n=0;n<e.length;n++){var r=e[n],i=t[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var o=r.shape;for(var s in i.axes){var l=Number(s),u=i.axes[s],c=l>=0?o[l]:o[o.length+l];if(null!=u&&-1===[u,null].indexOf(c))throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected axis "+l+" of input shape to have value "+u+" but got shape "+o+".")}}if(null!=i.shape)for(var p=0;p<i.shape.length;++p){var h=i.shape[p],d=r.shape[p];if(null!=h&&null!=d&&h!==d)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape="+r.shape+".")}}}}},t.prototype.call=function(e,t){return e},t.prototype.invokeCallHook=function(e,t){null!=this._callHook&&this._callHook(e,t)},t.prototype.setCallHook=function(e){this._callHook=e},t.prototype.clearCallHook=function(){this._callHook=null},t.prototype.apply=function(e,t){var n=this;t=t||{},this.assertNotDisposed();for(var r=toList(e),i=!0,a=0,o=r;a<o.length;a++){if(!(o[a]instanceof SymbolicTensor)){i=!1;break}}for(var s=!0,l=0,u=r;l<u.length;l++){if(u[l]instanceof SymbolicTensor){s=!1;break}}if(i===s)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,function(){if(!n.built){n.assertInputCompatibility(e);for(var i=[],a=0,o=toList(e);a<o.length;a++){var l=o[a];i.push(l.shape)}n.build(singletonOrArray(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&s&&(n._refCount=1)}if(n.assertInputCompatibility(e),s){for(var u=[],c=0,p=toList(g=n.call(e,t));c<p.length;c++){var h=p[c];-1!==r.indexOf(h)&&(h=h.clone()),u.push(h)}if(g=singletonOrArray(u),null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=collectInputShape(e),f=n.computeOutputShape(d),g=void 0,m=guessOutputDType(e);if(n.warnOnIncompatibleInputShape(Array.isArray(e)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map(function(r,i){return new SymbolicTensor(m,r,n,toList(e),t,n.name,i)}):new SymbolicTensor(m,f,n,toList(e),t,n.name),n.addInboundNode(e,g,null,null,d,f,t),n._refCount++,null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g})},t.prototype.warnOnIncompatibleInputShape=function(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(e)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var t=!1;this.batchInputShape.forEach(function(n,r){null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor ("+JSON.stringify(e)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(t.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var e=[],t=0,n=this.inboundNodes;t<n.length;t++){var r=n[t],i=JSON.stringify(r.outputShapes);-1===e.indexOf(i)&&e.push(i)}if(1===e.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new AttributeError("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),t.prototype.countParams=function(){if(!this.built)throw new RuntimeError("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return countParamsInWeights(this.weights)},t.prototype.build=function(e){this.built=!0},t.prototype.getWeights=function(e){return void 0===e&&(e=!1),batchGetValue(e?this.trainableWeights:this.weights)},t.prototype.setWeights=function(e){var t=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.weights;if(n.length!==e.length)throw new ValueError('You called setWeights(weights) on layer "'+t.name+'" with a weight list of length '+e.length+", but the layer was expecting "+n.length+" weights. Provided weights: "+e+"...");if(0!==n.length){for(var r=[],i=batchGetValue(n),a=0;a<i.length;++a){var o=i[a],s=n[a],l=e[a];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(o.shape,l.shape))throw new ValueError("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);r.push([s,l])}batchSetValue(r)}})},t.prototype.addWeight=function(e,t,n,r,i,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new ValueError("Duplicate weight name "+e+" for layer "+this.name);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=getInitializer("zeros"));var s=r.apply(t,n),l=new LayerVariable(s,n,e,a,o);return s.dispose(),null!=i&&this.addLoss(function(){return i.apply(l.read())}),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l},t.prototype.setFastWeightInitDuringBuild=function(e){this.fastWeightInitDuringBuild=e},t.prototype.addLoss=function(e){var t;null==e||Array.isArray(e)&&0===e.length||(e=toList(e),void 0!==this._losses&&null!==this._losses&&(t=this.losses).push.apply(t,e))},t.prototype.computeOutputShape=function(e){return e},t.prototype.computeMask=function(e,t){var n=this;if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");t.forEach(function(e){if(null!=e)throw new TypeError("Layer "+n.name+" does not support masking, but was passed an inputMask.")})}return null}return t},t.prototype.addInboundNode=function(e,t,n,r,i,a,o){void 0===o&&(o=null);var s=toList(e);t=toList(t),n=toList(n),r=toList(r),i=normalizeShapeList(i),a=normalizeShapeList(a);for(var l=[],u=[],c=[],p=0,h=s;p<h.length;p++){var d=h[p];l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex)}new Node({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},o);for(var f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f},t.prototype.getConfig=function(){var e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e},t.prototype.disposeWeights=function(){return this.weights.forEach(function(e){return e.dispose()}),this.weights.length},t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable);function collectInputShape(e){for(var t=[],n=0,r=e=toList(e);n<r.length;n++){var i=r[n];t.push(i.shape)}return singletonOrArray(t)}function guessOutputDType(e){return"float32"}function getSourceInputs(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];var r=t.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var o=0,s=getSourceInputs(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);o<s.length;o++){var l=s[o];-1===i.indexOf(l)&&i.push(l)}return i}var ModelLoggingVerbosity,InputLayer=function(e){function t(t){var n=e.call(this,{dtype:t.dtype,name:null!=t.name?t.name:getUid("input").toString()})||this;if(null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=t.batchInputShape;if(null==r){if(null==t.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");var i=t.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new SymbolicTensor(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new Node({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return __extends(t,e),t.prototype.apply=function(e,t){throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},t.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},t.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},t.className="InputLayer",t}(Layer);function Input(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));var n=e.dtype;return null==n&&(n="float32"),new InputLayer({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function resolveScalarsInLogs(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==e)return[2];for(i in t=[],n=[],r=[],e)"number"!=typeof(a=e[i])&&(o=a,t.push(o.data()),n.push(i),r.push(o));return t.length>0?[4,Promise.all(t)]:[3,2];case 1:for(s=u.sent(),l=0;l<s.length;++l)e[n[l]]=s[l][0];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),u.label=2;case 2:return[2]}})})}function disposeTensorsInLogs(e){if(null!=e)for(var t in e){var n=e[t];"number"!=typeof n&&n.dispose()}}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(InputLayer),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var DEFAULT_YIELD_EVERY_MS=125,BaseCallback=function(){function e(){this.validationData=null}return e.prototype.setParams=function(e){this.params=e},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.setModel=function(e){},e}(),CallbackList=function(){function e(e,t){void 0===t&&(t=10),null==e&&(e=[]),this.callbacks=e,this.queueLength=t}return e.prototype.append=function(e){this.callbacks.push(e)},e.prototype.setParams=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setParams(e)}},e.prototype.setModel=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setModel(e)}},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainBegin(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainEnd(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e}(),BaseLogger=function(e){function t(){return e.call(this)||this}return __extends(t,e),t.prototype.onEpochBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.seen=0,this.totals={},[2]})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a=this;return __generator(this,function(o){for(i in null==t&&(t={}),e=null==t.size?0:t.size,this.seen+=e,n=function(n){var i=t[n];if("number"==typeof i)r.totals.hasOwnProperty(n)||(r.totals[n]=0),r.totals[n]=r.totals[n]+i*e;else{var o=void 0;n in r.totals?o=r.totals[n]:r.totals[n]=0,r.totals[n]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a.totals[n],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,e))}),null!=o&&o.dispose()}},r=this,t)n(i);return[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a,o=this;return __generator(this,function(s){if(null!=t)for(e=function(e){if(null==n.totals[e])return"continue";"number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(1,o.seen),o.totals[e]),o.totals[e].dispose(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(t[e])})},n=this,r=0,i=this.params.metrics;r<i.length;r++)a=i[r],e(a);return[2]})})},t}(BaseCallback),History=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.epoch=[],this.history={},[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){for(n in null==t&&(t={}),this.epoch.push(e),t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n]);return[2]})})},t.prototype.syncData=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:for(r in e=[],t=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(o=i[a],e.push(o.data()),t.push(r),n.push(a));return[4,Promise.all(e)];case 1:for(s=u.sent(),l=0;l<s.length;++l)this.history[t[l]][n[l]].dispose(),this.history[t[l]][n[l]]=s[l][0];return[2]}})})},t}(BaseCallback),CustomCallback=function(e){function t(t,n){var r=e.call(this)||this;if(r.currentEpoch=0,r.yieldEvery=n||"auto","auto"===r.yieldEvery&&(r.yieldEvery=DEFAULT_YIELD_EVERY_MS),"never"===r.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(r.yieldEvery)&&(r.maybeWait=debounce(r.maybeWait.bind(r),r.yieldEvery)),r.trainBegin=t.onTrainBegin,r.trainEnd=t.onTrainEnd,r.epochBegin=t.onEpochBegin,r.epochEnd=t.onEpochEnd,r.batchBegin=t.onBatchBegin,r.batchEnd=t.onBatchEnd,r.yield=t.onYield,r}return __extends(t,e),t.prototype.maybeWait=function(e,t,n){return __awaiter(this,void 0,void 0,function(){var r;return __generator(this,function(i){switch(i.label){case 0:return r=[],null==this.yield?[3,2]:[4,resolveScalarsInLogs(n)];case 1:i.sent(),r.push(this.yield(e,t,n)),i.label=2;case 2:return r.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(r)];case 3:return i.sent(),[2]}})})},t.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return this.currentEpoch=e,null==this.epochBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.epochBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.epochEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.epochEnd(e,t)),r.label=2;case 2:return"epoch"===this.yieldEvery&&n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.batchBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.batchEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.batchEnd(e,t)),r.label=2;case 2:return"batch"===this.yieldEvery?n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainBegin(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainEnd(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t}(BaseCallback);function standardizeCallbacks(e,t){return null==e&&(e={}),e instanceof BaseCallback?[e]:Array.isArray(e)&&e[0]instanceof BaseCallback?e:toList(e).map(function(e){return new CustomCallback(e,t)})}var CallbackConstructorRegistry=function(){function e(){}return e.registerCallbackConstructor=function(t,n){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>=0&&Number.isInteger(t),function(){return"Verbosity level is expected to be an integer >= 0, but got "+t}),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)},e.checkForDuplicate=function(t){for(var n in e.constructors){e.constructors[+n].forEach(function(e){if(e===t)throw new ValueError("Duplicate callback constructor.")})}},e.clear=function(){e.constructors={}},e.createCallbacks=function(t){var n=[];for(var r in e.constructors){var i=+r;t>=i&&n.push.apply(n,e.constructors[i])}return n.map(function(e){return new e})},e.constructors={},e}();function configureCallbacks(e,t,n,r,i,a,o,s,l){var u=new History,c=[new BaseLogger].concat(CallbackConstructorRegistry.createCallbacks(t));null!=e&&c.push.apply(c,e),c.push(u);var p=new CallbackList(c);return p.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:o,verbose:t,doValidation:s,metrics:l}),{callbackList:p,history:u}}function l2Normalize(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){"float32"!==e.dtype&&(e=e.asType("float32"));var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(square(e),t,!0),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(n.shape,epsilon()),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,i)})}function meanSquaredError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsoluteError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsolutePercentageError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(e,t),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e),epsilon(),Number.MAX_VALUE),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(100,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1))})}function meanSquaredLogarithmicError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),Number.MAX_VALUE),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,n)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),Number.MAX_VALUE),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,i));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,a)),-1)})}function squaredHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(n),-1)})}function hinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(n,-1)})}function categoricalHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t),-1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,e),t),-1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,n)))})}function logcosh(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Math.log(2),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(-2,r))),n);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1)})}function categoricalCrossentropy(e,t,n){return void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(t);else{var r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(t,t.shape.length-1,!0);t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(t,r)}return t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e.toFloat(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(t)),t.shape.length-1))})}function sparseCategoricalCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(flatten(e)).toInt(),r=(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon())).shape;return categoricalCrossentropy(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(n,r[r.length-1]).reshape(r),t,!1)})}function sigmoidCrossEntropyWithLogits(e,t){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,t.shape))throw new ValueError("logits and labels must have the same shape, but got shapes "+JSON.stringify(e.shape)+" and "+JSON.stringify(t.shape));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())})}function binaryCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n;return n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,n))),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(sigmoidCrossEntropyWithLogits(e,n),-1)})}function kullbackLeiblerDivergence(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r))),-1)})}function poisson(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),t));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,n)),-1)})}function cosineProximity(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=l2Normalize(e,-1),r=l2Normalize(t,-1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n,r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(i,-1))})}function get(e){var t={meanSquaredError:meanSquaredError,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};if("string"==typeof e){if(e in t)return t[e];var n="Unknown loss "+e;throw e.toLowerCase().includes("softmaxcrossentropy")&&(n="Unknown loss "+e+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new ValueError(n)}return e}function binaryAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(t)),r=cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(t,n),e.dtype);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,r),-1)})}function categoricalAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(e,-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(t,-1)),"float32")})}function truePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(1)).sum().cast("float32")})}function falseNegatives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(0)).sum().cast("float32")})}function falsePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(0),t.equal(1)).sum().cast("float32")})}function precision(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falsePositives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function recall(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falseNegatives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function binaryCrossentropy$1(e,t){return binaryCrossentropy(e,t)}function sparseCategoricalAccuracy(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,t).asType("float32")}var mse$1=meanSquaredError,MSE$1=meanSquaredError,mae$1=meanAbsoluteError,MAE$1=meanAbsoluteError,mape$1=meanAbsolutePercentageError,MAPE$1=meanAbsolutePercentageError,categoricalCrossentropy$1=categoricalCrossentropy,cosine$1=cosineProximity,sparseCategoricalCrossentropy$1=sparseCategoricalCrossentropy;function get$1(e){var t={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,mse:mse$1,MSE:MSE$1,mae:mae$1,MAE:MAE$1,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};if("string"==typeof e&&e in t)return t[e];if("string"!=typeof e&&null!=e)return e;throw new ValueError("Unknown metric "+e)}function getOptimizer(e){var t={Adagrad:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adagrad(.01)},Adadelta:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adadelta(1,.95,epsilon())},Adam:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adam(.001,.9,.999,epsilon())},Adamax:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adamax(.002,.9,.999,epsilon(),0)},RMSProp:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].rmsprop(.001,.9,0,epsilon())},SGD:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].sgd(.01)}};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ValueError("Unknown Optimizer "+e)}function printSummary(e,t,n,r){void 0===r&&(r=console.log);var i,a=isModelSequentialLike(e),o=["Layer (type)","Output shape","Param #"];if(a?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(function(e){return Math.floor(t*e)})),!a)for(var s in o.push("Receives inputs"),i=[],e.nodesByDepth)i.push.apply(i,e.nodesByDepth[s]);r("_".repeat(t)),printRow(o,n,r),r("=".repeat(t));for(var l=e.layers,u=0;u<l.length;++u)a?printLayerSummary(l[u],n,r):printLayerSummaryWithConnections(l[u],n,i,r),r((u===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();var c=countTrainableParams(e),p=countParamsInWeights(e.nonTrainableWeights);r("Total params: "+(c+p)),r("Trainable params: "+c),r("Non-trainable params: "+p),r("_".repeat(t))}function countTrainableParams(e){return null!=e.collectedTrainableWeights?countParamsInWeights(e.collectedTrainableWeights):countParamsInWeights(e.trainableWeights)}function isModelSequentialLike(e){var t=!0,n=[],r=[];for(var i in e.nodesByDepth)n.push(e.nodesByDepth[i]);for(var a=0,o=n;a<o.length;a++){var s=o[a];if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push.apply(r,s)}if(t)for(var l=0,u=e.layers;l<u.length;l++){for(var c=!1,p=0,h=u[l].inboundNodes;p<h.length;p++){var d=h[p];if(-1!==r.indexOf(d)){if(c){t=!1;break}c=!0}}if(!t)break}return t}function printRow(e,t,n){void 0===n&&(n=console.log);for(var r="",i=0;i<e.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=e[i]).slice(0,t[i]),r+=" ".repeat(t[i]-r.length);n(r)}function printLayerSummary(e,t,n){var r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}printRow([e.name+" ("+e.getClassName()+")",r,e.countParams().toString()],t,n)}function printLayerSummaryWithConnections(e,t,n,r){var i;try{i=JSON.stringify(e.outputShape)}catch(e){i="multiple"}for(var a=[],o=0,s=e.inboundNodes;o<s.length;o++){var l=s[o];if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(var u=0;u<l.inboundLayers.length;++u){var c=l.inboundLayers[u].name,p=l.nodeIndices[u],h=l.tensorIndices[u];a.push(c+"["+p+"]["+h+"]")}}var d=e.name,f=e.getClassName(),g=0===a.length?"":a[0];printRow([d+" ("+f+")",i,e.countParams().toString(),g],t,r);for(u=1;u<a.length;++u)printRow(["","","",a[u]],t,r)}var version="1.1.2";function deserialize(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=!1),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"layer",n)}function isArrayItemInputOrOutputName(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function convertPythonicToTs(e,t){if(null===e)return null;if("string"==typeof e)return toCamelCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertPythonicToTs(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u];if("name"===u&&"string"==typeof c)o[u]=c;else{var p=toCamelCase(u);o[p]=convertPythonicToTs(c,p)}}return o}function convertTsToPythonic(e,t){if(null===e||void 0===e)return null;if("string"==typeof e)return toSnakeCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertTsToPythonic(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u],p=toSnakeCase(u);o[p]="name"!==u&&"className"!==u||"string"!=typeof c?convertTsToPythonic(c,u):c}return o}function assertFeedCompatibility(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(t,e.dtype)}catch(n){throw new ValueError("The dtype of the feed ("+t.dtype+") can not be cast to the dtype of the key '"+e.name+"' ("+e.dtype+").")}}var FeedDict=function(){function e(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(var n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(null==t)return;for(var r=0,i=t;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return e.prototype.add=function(e,t,n){if(null!=this.id2Value[e.id])throw new ValueError("Duplicate key: name="+e.name+", id="+e.id);return this.id2Value[e.id]=assertFeedCompatibility(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this},e.prototype.addFeed=function(e){this.add(e.key,e.value)},e.prototype.hasKey=function(e){return null!=this.id2Value[e.id]},e.prototype.names=function(){return Object.keys(this.name2Id)},e.prototype.getValue=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Value[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Value[t]},e.prototype.getMask=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Mask[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Mask[t]},e.prototype.disposeMasks=function(){null!=this.id2Mask&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(this.id2Mask)},e}(),cachedSorted={},cachedRecipientCounts={};function execute(e,t,n,r){for(var i=null!=n&&n.training,a=Array.isArray(e),o=a?e:[e],s=o.map(function(e){return e.name}),l=[],u=t.names(),c=0,p=s;c<p.length;c++){var h=p[c];-1!==u.indexOf(h)?l.push(t.getValue(h)):l.push(null)}null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);var d,f,g=s.join(",")+"|"+t.names().join(",");if(null==cachedSorted[g]){var m=getTopologicalSortAndRecipientCounts(o,t);d=m.sorted,f=m.recipientCounts,cachedSorted[g]=d,cachedRecipientCounts[g]=f}d=cachedSorted[g],f={},i||Object.assign(f,cachedRecipientCounts[g]);for(var y=new FeedDict(t),v=0;v<d.length;++v){if(null!=r){var b=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;b>r.maxNumTensors&&(r.maxNumTensors=b),b<r.minNumTensors&&(r.minNumTensors=b)}var w=d[v],z=w.sourceLayer;if(!(z instanceof InputLayer)){for(var S=[],I=[],A=[],_=!1,C=0,N=w.inputs;C<N.length;C++){var E=N[C],k=y.getValue(E),L=y.getMask(E);S.push(k),I.push(L),null!=L&&(_=!0),i||(f[E.name]--,0!==f[E.name]||t.hasKey(E)||-1!==s.indexOf(E.name)||k.isDisposed||!0===E.sourceLayer.stateful||A.push(k))}_&&((n=n||{}).mask=I[0]);var x=toList(z.apply(S,n)),T=null;z.supportsMasking&&(T=z.computeMask(S,I));for(var D=getNodeOutputs(w),O=Array.isArray(D)?D:[D],R=0;R<O.length;++R){y.hasKey(O[R])||y.add(O[R],x[R],Array.isArray(T)?T[0]:T);var M=s.indexOf(O[R].name);-1!==M&&(l[M]=x[R])}i||Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(A)}}return y.disposeMasks(),a?l:l[0]}function getTopologicalSortAndRecipientCounts(e,t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e&&e.length>0,function(){return"Expected at least one fetch, got none"});var n=[],r={};if(1===e.length){var i=getTopologicalSortAndRecipientCountsForOneFetch(e[0],t);n=i.sorted,r=i.recipientMap}else for(var a=new Set,o=0,s=e;o<s.length;o++){for(var l=getTopologicalSortAndRecipientCountsForOneFetch(s[o],t),u=l.sorted,c=l.recipientMap,p=0,h=u;p<h.length;p++){var d=h[p];a.has(d.name)||(n.push(d),a.add(d.name))}var f=function(e){null==r[e]&&(r[e]=new Set),c[e].forEach(function(t){return r[e].add(t)})};for(var g in c)f(g)}return{sorted:n,recipientCounts:recipientMap2Counts(r)}}function recipientMap2Counts(e){var t={};for(var n in e)t[n]=e[n].size;return t}function getTopologicalSortAndRecipientCountsForOneFetch(e,t){for(var n=new Set,r=[],i={},a=0,o=t.names();a<o.length;a++){var s=o[a];n.add(s)}var l=[],u=[];for(l.push(e);l.length>0;){var c=l[l.length-1];if(n.has(c.name))l.pop();else{var p=u[u.length-1]===l.length-1;if(0===c.inputs.length||p)l.pop(),r.push(c),n.add(c.name),p&&u.pop();else{u.push(l.length-1);for(var h=0,d=c.inputs;h<d.length;h++){var f=d[h];null==i[f.name]&&(i[f.name]=new Set),i[f.name].add(c.name),n.has(f.name)||l.push(f)}}}}return{sorted:r,recipientMap:i}}function getNodeOutputs(e){var t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{for(var n=null,r=0;r<e.sourceLayer.inboundNodes.length;++r)for(var i=0,a=e.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===e.id){n=r;break}}t=e.sourceLayer.getOutputAt(n)}return t}var Container=function(e){function t(n){var r=e.call(this,{})||this;if(r.containerNodes=new Set,r.name=n.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=getUid(i)}if(r.supportsMasking=!1,r.trainable_=!0,r.updatable=!0,Array.isArray(n.inputs)?r.inputs=n.inputs.slice():r.inputs=[n.inputs],Array.isArray(n.outputs)?r.outputs=n.outputs.slice():r.outputs=[n.outputs],unique(r.inputs).length!==r.inputs.length)throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map(function(e){return e.name}));unique(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map(function(e){return e.name})),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[];for(var a=0,o=r.outputs;a<o.length;a++){var s=(C=o[a]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;r.outputLayers.push(s),r.outputLayersNodeIndices.push(l),r.outputLayersTensorIndices.push(u)}for(var c=0,p=r.inputs;c<p.length;c++){s=(C=p[c]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;assert(0===l,"input layer has >1 nodes"),assert(0===u,"input layer has >1 tensors"),r.inputLayers.push(s),r.inputLayersNodeIndices.push(l),r.inputLayersTensorIndices.push(u)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var h=0;h<r.inputLayers.length;h++){if(!((s=r.inputLayers[h])instanceof InputLayer))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+n.inputs+". Input "+h+" (0-based) originates from layer type "+s.getClassName()+".");r.inputNames.push(s.name),r.feedInputShapes.push(s.batchInputShape),r.feedInputNames.push(s.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){s=f[d];r.outputNames.push(s.name)}r.internalInputShapes=r.inputs.map(function(e){return e.shape}),r.internalOutputShapes=r.outputs.map(function(e){return e.shape});for(var g={},m={},y={},v={},b={},w=[],z=function(e,n,i,a,o,s){null!=a&&null!=o&&null!=s||(a=e.sourceLayer,o=e.nodeIndex,s=e.tensorIndex);var l=a.inboundNodes[o];if(-1!==i.indexOf(l))throw new RuntimeError("The tensor "+e.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===n.indexOf(l)){r.containerNodes.add(t.nodeKey(a,o)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(l)&&i.push(l);for(var u=l.inboundLayers.length,c=0;c<u;c++){var p=l.inputTensors[c],h=l.inboundLayers[c],d=l.nodeIndices[c],f=l.tensorIndices[c];z(p,n,i,h,d,f)}for(n.push(l);i.indexOf(l)>=0;)i.splice(i.indexOf(l),1);w.push(l)}},S=[],I=[],A=0,_=r.outputs;A<_.length;A++){var C=_[A];z(C,S,I)}for(var N=0,E=w.slice().reverse();N<E.length;N++){m[(K=E[N]).id]=K,K.id in g||(g[K.id]=0);var k=g[K.id],L=null==y[K.outboundLayer.id]?0:y[K.outboundLayer.id];k=Math.max(k,L),y[K.outboundLayer.id]=k,v[K.outboundLayer.id]=K.outboundLayer,g[K.id]=k;for(h=0;h<K.inboundLayers.length;h++){var x=K.inboundLayers[h],T=(l=K.nodeIndices[h],x.inboundNodes[l]),D=null==g[T.id]?0:g[T.id];g[T.id]=Math.max(k+1,D),m[T.id]=T}}var O={};for(var R in g){(k=g[R])in O||(O[k]=[]),O[k].push(m[R])}var M={};for(var P in y){(k=y[P])in M||(M[k]=[]),M[k].push(v[P])}var F=Object.keys(M).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);r.layers=[];for(var V=0,B=F;V<B.length;V++){var U=M[k=B[V]];U.sort(function(e,t){var n=b[e.id],r=b[t.id];return n<r?-1:n>r?1:0});for(var j=0,W=U;j<W.length;j++){s=W[j];r.layers.push(s)}}r.layersByDepth=M,F=Object.keys(O).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);for(var $=r.inputs.slice(),q=[],G=0,H=F;G<H.length;G++)for(var J=0,Z=O[k=H[G]];J<Z.length;J++){var K;if(null!=(s=(K=Z[J]).outboundLayer)){for(var Y=0,X=K.inputTensors;Y<X.length;Y++){C=X[Y];if(-1===$.indexOf(C))throw new RuntimeError("Graph disconnected: cannot obtain value for tensor "+C+' at layer "'+s.name+'". The following previous layers were accessed without issue: '+q)}for(var Q=0,ee=K.outputTensors;Q<ee.length;Q++){C=ee[Q];$.push(C)}q.push(s.name)}}r.nodesByDepth=O;for(var te=r.layers.map(function(e){return e.name}),ne=function(e){var t=te.filter(function(t){return t===e}).length;if(1!==t)throw new RuntimeError('The name "'+e+'" is used '+t+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(te))},re=0,ie=te;re<ie.length;re++){ne(ie[re])}return r.outboundNodes=[],r.inboundNodes=[],new Node({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map(function(e){return null}),outputMasks:r.outputs.map(function(e){return null}),inputShapes:r.inputs.map(function(e){return e.shape}),outputShapes:r.outputs.map(function(e){return e.shape})}),r.built=!0,r._refCount=1,r}return __extends(t,e),t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){this.assertNotDisposed();var e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount)for(var t=0,n=this.layers;t<n.length;t++){var r=n[t];e.numDisposedVariables+=r.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e},Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.layers.forEach(function(t){t._trainableWeights.forEach(function(t){return t.trainable=e})}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e=e.concat(r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.layers;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.loadWeights=function(e,t){void 0===t&&(t=!0);for(var n={},r=0,i=0,a=this.layers;i<a.length;i++)for(var o=0,s=a[i].weights;o<s.length;o++){var l=s[o];if(null!=n[l.originalName])throw new ValueError("Duplicate weight name: "+l.originalName);n[l.originalName]=l,r++}var u=[];for(var c in e){if(null!=n[c])u.push([n[c],e[c]]);else if(t)throw new ValueError("Provided weight data has no target variable: "+c);delete n[c]}if(t){var p=[];for(var h in n)p.push(h);if(p.length>0)throw new ValueError(p.length+" of "+r+" weights are not set: "+p)}batchSetValue(u)},t.prototype.updatedConfig=function(){var e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers "+version,t.backend="TensorFlow.js",t},t.prototype.toJSON=function(e,t){void 0===t&&(t=!0);var n=convertTsToPythonic(this.updatedConfig());return t?JSON.stringify(n):n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e=toList(e);for(var r=new FeedDict,i=0;i<n.inputs.length;++i)r.add(n.inputs[i],e[i]);return execute(n.outputs,r,t)})},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r;return e=toList(e),r=null==t?pyListRepeat(null,e.length):toList(t),n.runInternalGraph(e,r)[1]})},t.prototype.computeOutputShape=function(e){var t=normalizeShapeList(e);if(t.length!==this.inputLayers.length)throw new ValueError("Invalid inputShape argument "+e+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<t.length;r++){var i=this.inputLayers[r],a=t[r];n[I=i.name+"_0_0"]=a}var o=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);if(o.length>1)for(var s=0,l=o;s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){var h=p[c];i=h.outboundLayer;if(-1===this.inputLayers.map(function(e){return e.id}).indexOf(i.id)){for(var d=[],f=0;f<h.inboundLayers.length;f++){var g=h.inboundLayers[f],m=h.nodeIndices[f],y=h.tensorIndices[f],v=n[I=g.name+"_"+m+"_"+y];d.push(v)}var b=normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),w=i.inboundNodes.indexOf(h);for(f=0;f<b.length;f++){n[I=i.name+"_"+w+"_"+f]=b[f]}}}var z=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var I=i.name+"_"+w+"_"+y;S.push(I)}for(r=0;r<S.length;r++){var A=S[r];assert(A in n),z.push(n[A])}return singletonOrArray(z)},t.prototype.runInternalGraph=function(e,t){null==t&&(t=pyListRepeat(null,e.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=e[r],o=t[r];n[i.id]=[a,o]}for(var s=0,l=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){for(var h=p[c],d=h.outboundLayer,f=h.inputTensors,g=h.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,z=void 0,S=void 0,I=void 0;if(null!=h.callArgs&&(b=h.callArgs),1===m.length){var A=m[0],_=A[0],C=A[1];null==b.mask&&(b.mask=C),S=toList(d.call(_,b)),I=toList(d.computeMask(_,C)),w=[_],z=[C]}else w=m.map(function(e){return e[0]}),z=m.map(function(e){return e[1]}),null==b.mask&&(b.mask=z),S=toList(d.call(w,b)),I=toList(d.computeMask(w,z));if(d.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],o=I[r];n[i.id]=[a,o]}}}for(var N=[],E=[],k=[],L=0,x=this.outputs;L<x.length;L++){assert((i=x[L]).id in n,"Could not compute output "+i.name+" : "+i.id);var T=n[i.id],D=T[0];o=T[1];k.push(D.shape),N.push(D),E.push(o)}return[N,E,k]},t.prototype.buildNodeConversionMap=function(e){for(var n,r={},i=0,a=this.layers;i<a.length;i++){var o=a[i];n=o instanceof t?1:0;for(var s=0;s<o.inboundNodes.length;s++){var l=t.nodeKey(o,s);this.containerNodes.has(l)&&(r[l]=n,n+=1)}}return r},t.prototype.getLayer=function(e,t){if(null!=t){if(this.layers.length<=t)throw new ValueError("Was asked to retrieve layer at index "+t+", but model only has "+this.layers.length+" layer(s).");return this.layers[t]}if(null==e)throw new ValueError("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===e)return i}throw new ValueError("No such layer: "+e)},t.prototype.calculateLosses=function(){var e=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n=[],r=0,i=e.layers;r<i.length;r++)for(var a=i[r],o=0;o<a.inboundNodes.length;++o){var s=t.nodeKey(a,o);e.containerNodes.has(s)&&n.push.apply(n,a.calculateLosses())}return n})},t.prototype.getConfig=function(){for(var e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var o=(w=a[i]).getClassName(),s=w.getConfig(),l=[],u=0;u<w.inboundNodes.length;u++){var c=w.inboundNodes[u],p=t.nodeKey(w,u),h={};if(this.containerNodes.has(p)){if(c.callArgs)try{JSON.stringify(c.callArgs),h=c.callArgs}catch(e){console.warn("Layer "+w.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),h={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(S=n[t.nodeKey(g,m)])&&(S=0),d.push([g.name,S,y,h])}l.push(d)}}}var v={};v.name=w.name,v.className=o,v.config=s,v.inboundNodes=l,r.push(v)}e.layers=r;var b=[];for(f=0;f<this.inputLayers.length;f++){var w=this.inputLayers[f];m=this.inputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){null!==(S=n[p])&&void 0!==S||(S=0);y=this.inputLayersTensorIndices[f];b.push([w.name,S,y])}}e.inputLayers=b;var z=[];for(f=0;f<this.outputLayers.length;f++){w=this.outputLayers[f],m=this.outputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){var S;null!==(S=n[p])&&void 0!==S||(S=0);y=this.outputLayersTensorIndices[f];z.push([w.name,S,y])}}return e.outputLayers=z,e},t.fromConfig=function(e,t,n,r){void 0===n&&(n={}),void 0===r&&(r=!1);var i={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function s(e,t){for(var n,r=[],a=0,s=t;a<s.length;a++){var l=s[a],u=l[0],c=l[1],p=l[2];if(n=null==l[3]?{}:l[3],!(u in i))return void o(e,t);var h=i[u];if(h.inboundNodes.length<=c)return void o(e,t);var d=h.inboundNodes[c];r.push(d.outputTensors[p])}r.length>0&&e.apply(singletonOrArray(r),n)}function l(e){var n=e.name,a=deserialize(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),i[n]=a,e.inboundNodes.forEach(function(e){if(!(e instanceof Array))throw new ValueError("Corrupted configuration, expected array for nodeData: "+e);o(a,e)})}for(var u=t.name,c=t.layers,p=0,h=c;p<h.length;p++){l(g=h[p])}for(;!isObjectEmpty(a);)for(var d=0,f=c;d<f.length;d++){var g=f[d];if((k=i[g.name]).name in a){var m=a[k.name];delete a[k.name];for(var y=0,v=m;y<v.length;y++){s(k,v[y])}}}for(var b=[],w=[],z=0,S=t.inputLayers;z<S.length;z++){var I=(g=S[z])[0],A=g[1],_=g[2];assert(I in i);var C=(k=i[I]).inboundNodes[A].outputTensors;b.push(C[_])}for(var N=0,E=t.outputLayers;N<E.length;N++){I=(g=E[N])[0],A=g[1],_=g[2];assert(I in i);var k;C=(k=i[I]).inboundNodes[A].outputTensors;w.push(C[_])}return new e({inputs:b,outputs:w,name:u})},Object.defineProperty(t.prototype,"stateful",{get:function(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var e=0,t=this.layers;e<t.length;e++){if(t[e].stateful)return!0}return!1},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){var e=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e.layers.forEach(function(e){e.stateful&&e.resetStates()})})},t}(Layer),DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(e,t){var n,r,i=t;n=i.xs,r=i.ys,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n&&null!=r,function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+t});var a=flattenTensorOrArrayOrMap("input",e.inputNames,n),o=flattenTensorOrArrayOrMap("output",e.outputNames,r),s=a[0].shape[0];_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a.length===e.inputs.length,function(){return"LayersModel has "+e.inputs.length+" inputs, but the dataset provides "+a.length+" inputs.  (Expected input keys: "+JSON.stringify(e.inputNames)+")"}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o.length===e.outputs.length,function(){return"LayersModel has "+e.outputs.length+" outputs, but the dataset provides "+o.length+" outputs.  (Expected output keys: "+JSON.stringify(e.outputNames)+")"});var l=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a[t].shape[0]===s,function(){return"Batch size mismatch: input "+e.inputNames[t]+" has "+a[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var u in a)l(u);var c=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o[t].shape[0]===s,function(){return"Batch size mismatch: output "+e.outputNames[t]+" has "+o[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var p in o)c(p);return a.concat(o)}function flattenTensorOrArrayOrMap(e,t,n){if(n instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])return[n];if(Array.isArray(n))return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.length===t.length,function(){return"Received an array of "+n.length+" Tensors, but expected "+t.length+" to match the "+e+" keys "+t+"."}),n;for(var r=[],i=0,a=t;i<a.length;i++){var o=a[i];if(null==n[o])throw new ValueError("The feature data generated by the dataset lacks the required "+e+" key '"+o+"'.");r.push(n[o])}return r}function standardizeTensorValidationData(e){if(3===e.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function fitDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S,I,A,_,C,N,E,k;return __generator(this,function(L){switch(L.label){case 0:if(r=null!=n.batchesPerEpoch,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e.optimizer,function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n,function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationSplit,function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."}),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,L.label=1;case 1:return L.trys.push([1,,22,23]),i=null!=n.validationData,a=void 0,o=void 0,i&&(isDatasetObject(n.validationData)?_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches}):(s=standardizeTensorValidationData(n.validationData),a=s.xs,o=s.ys)),l=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c=void 0,c=i?u.slice().concat(u.map(function(e){return"val_"+e})):u.slice(),p=standardizeCallbacks(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,d=configureCallbacks(p,h,n.epochs,null,null,getStepsPerEpoch(t,n),null,i,c),f=d.callbackList,g=d.history,f.setModel(e),e.history=g,[4,f.onTrainBegin()];case 2:return L.sent(),e.stopTraining_=!1,m=null==n.initialEpoch?0:n.initialEpoch,[4,t.iterator()];case 3:y=L.sent(),L.label=4;case 4:return m<n.epochs?(v={},[4,f.onEpochBegin(m)]):[3,19];case 5:return L.sent(),b=0,w=0,r?[3,7]:[4,t.iterator()];case 6:y=L.sent(),L.label=7;case 7:return!r||b<n.batchesPerEpoch?[4,y.next()]:[3,17];case 8:return z=L.sent(),r&&z.done?(console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+b+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,17]):null==z.value?[3,11]:(S=standardizeDataIteratorOutput(e,z.value),(I={}).batch=w,I.size=S[0].shape[0],[4,f.onBatchBegin(w,I)]);case 9:for(L.sent(),A=l(S),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(S),k=0;k<u.length;++k)_=u[k],C=A[k],I[_]=C,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(C);return[4,f.onBatchEnd(w,I)];case 10:L.sent(),disposeTensorsInLogs(I),w++,b++,L.label=11;case 11:return(r?b>=n.batchesPerEpoch:z.done)?i?(N=void 0,isDatasetObject(n.validationData)?(E=toList,[4,e.evaluateDataset(n.validationData,{batches:n.validationBatches})]):[3,13]):[3,15]:[3,16];case 12:return N=E.apply(void 0,[L.sent()]),[3,14];case 13:N=toList(e.evaluate(a,o,{batchSize:null==n.validationBatchSize?DEFAULT_VALIDATION_BATCH_SIZE:n.validationBatchSize,verbose:0})),L.label=14;case 14:for(k=0;k<e.metricsNames.length;++k)v["val_"+e.metricsNames[k]]=N[k];L.label=15;case 15:return[3,17];case 16:return e.stopTraining_?[3,17]:[3,7];case 17:return[4,f.onEpochEnd(m,v)];case 18:return L.sent(),m++,e.stopTraining_?[3,19]:[3,4];case 19:return[4,f.onTrainEnd()];case 20:return L.sent(),[4,e.history.syncData()];case 21:return L.sent(),[2,e.history];case 22:return e.isTraining=!1,[7];case 23:return[2]}})})}function getStepsPerEpoch(e,t){var n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function isDatasetObject(e){return"function"==typeof e.iterator}function isLazyIteratorObject(e){return"function"==typeof e.next}function evaluateDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h;return __generator(this,function(d){switch(d.label){case 0:if(r=null!=(n=n||{}).batches,i=e.testFunction,a=[],n.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batches>0&&Number.isInteger(n.batches),function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches)}),isLazyIteratorObject(t)?(s=t,[3,3]):[3,1];case 1:return[4,t.iterator()];case 2:s=d.sent(),d.label=3;case 3:o=s,l=0,u=0,c=function(){var t;return __generator(this,function(s){switch(s.label){case 0:return[4,o.next()];case 1:return t=s.sent(),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(t.value){var n=standardizeDataIteratorOutput(e,t.value),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return i(n)});if(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n),0===u)for(var o=0;o<r.length;++o)a.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));var s=n[0].shape[0],c=function(e){var t=r[e],n=a[e];a[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a[e],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,t))}),u>0&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n)};for(o=0;o<r.length;++o)c(o);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),l+=s,++u}return a}),t.done?(r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+n.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}})},d.label=4;case 4:return!r||u<n.batches?[5,c()]:[3,6];case 5:return"break"===d.sent()?[3,6]:[3,4];case 6:for(p=0;p<a.length;++p)h=a[p],a[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(a[p],l),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(h);return[2,singletonOrArray(a)]}})})}function checkBatchSize(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e>0&&Number.isInteger(e),function(){return"batchSize is required to be a positive integer, but got "+e})}function sliceArrays(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(function(e){return sliceAlongFirstAxis(e,t,n-t)}):sliceAlongFirstAxis(e,t,n-t)}function sliceArraysByIndices(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==e?null:Array.isArray(e)?e.map(function(e){return sliceArraysByIndices(e,t)}):gather$1(e,"int32"===t.dtype?t:t.toInt())})}function makeBatches(e,t){for(var n=[],r=0,i=null;r<e;)(i=r+t)>=e&&(i=e),n.push([r,i]),r=i;return n}function fitLoop(e,t,n,r,i,a,o,s,l,u,c,p,h,d,f){return __awaiter(this,void 0,void 0,function(){var g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(null==i&&(i=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0),g=!1,null!=l&&null!=u&&(g=!0),null!=f&&(g=!0,null==d))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(m=e.checkNumSamples(n,i,d,"steps_per_epoch"))&&(y=range(0,m)),null==o&&(o=1),v=configureCallbacks(s,o,a,h,m,d,i,g,p),b=v.callbackList,w=v.history,b.setModel(e),e.history=w,[4,b.onTrainBegin()];case 1:I.sent(),e.stopTraining_=!1,z=function(a){var o,s,p,h,f;return __generator(this,function(v){switch(v.label){case 0:return[4,b.onEpochBegin(a)];case 1:if(v.sent(),o={},null==d)return[3,2];throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===c)throw new NotImplementedError("batch shuffling is not implemneted yet");c&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].shuffle(y),s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(y),p=makeBatches(m,i),h=function(a){var c;return __generator(this,function(h){switch(h.label){case 0:return c={},[4,b.onBatchBegin(a,c)];case 1:return h.sent(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var h=p[a][0],d=p[a][1],f=sliceAlongFirstAxis(s,h,d-h);c.batch=a,c.size=d-h;for(var m=sliceArraysByIndices(n,f),y=t(m),v=0;v<r.length;++v){var b=r[v],w=y[v];c[b]=w,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w)}if(a===p.length-1&&g){var z=e.testLoop(l,u,i);for(v=0;v<r.length;++v){b=r[v],w=z[v];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w),o["val_"+b]=w}}}),[4,b.onBatchEnd(a,c)];case 2:return h.sent(),disposeTensorsInLogs(c),e.stopTraining_?[2,"break"]:[2]}})},f=0,v.label=3;case 3:return f<p.length?[5,h(f)]:[3,6];case 4:if("break"===v.sent())return[3,6];v.label=5;case 5:return++f,[3,3];case 6:s.dispose(),v.label=7;case 7:return[4,b.onEpochEnd(a,o)];case 8:return v.sent(),e.stopTraining_?[2,"break"]:[2]}})},S=h,I.label=2;case 2:return S<a?[5,z(S)]:[3,5];case 3:if("break"===I.sent())return[3,5];I.label=4;case 4:return++S,[3,2];case 5:return[4,b.onTrainEnd()];case 6:return I.sent(),[4,e.history.syncData()];case 7:return I.sent(),[2,e.history]}})})}function fitTensors(e,t,n,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,I.label=1;case 1:if(I.trys.push([1,,3,4]),checkBatchSize(c=null==r.batchSize?32:r.batchSize),p=e.standardizeUserData(t,n,!1,c),i=p[0],a=p[1],h=!1,d=void 0,null!=r.validationData&&r.validationData.length>0){if(h=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+r.validationData+" is invalid.");o=r.validationData[0],s=r.validationData[1],f=e.standardizeUserData(o,s,!0,c),l=f[0],u=f[1],d=l.concat(u)}else null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1?(h=!0,g=Math.floor(i[0].shape[0]*(1-r.validationSplit)),m=i[0].shape[0],l=sliceArrays(i,g,m),i=sliceArrays(i,0,g),u=sliceArrays(a,g,m),a=sliceArrays(a,0,g),d=l.concat(u)):null!=r.validationSteps&&(h=!0);return y=i.concat(a),e.checkTrainableWeightsConsistency(),v=e.makeTrainFunction(),b=e.getDedupedMetricsNames(),w=void 0,z=void 0,h?(e.makeTestFunction(),w=e.testFunction,z=b.slice().concat(b.map(function(e){return"val_"+e}))):(w=null,d=[],z=b.slice()),S=standardizeCallbacks(r.callbacks,r.yieldEvery),[4,fitLoop(e,v,y,b,c,r.epochs,r.verbose,S,w,d,r.shuffle,z,r.initialEpoch,null,null)];case 2:return[2,I.sent()];case 3:return e.isTraining=!1,disposeNewTensors(i,t),disposeNewTensors(a,n),disposeNewTensors(l,o),disposeNewTensors(u,s),[7];case 4:return[2]}})})}function ensureTensorsRank2OrHigher(e){var t=[];e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]);for(var n=0;n<e.length;++n){var r=e[n];if(1===r.rank)t.push(expandDims$1(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function disposeNewTensors(e,t){if(null!=e){var n=[];if(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])n.push(t.id);else if(Array.isArray(t))t.forEach(function(e){return n.push(e.id)});else if(null!=t)for(var r in t){var i=t[r];n.push(i.id)}var a=[];if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(function(e){-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(var o in e){var s=e[o];-1===n.indexOf(s.id)&&a.push(s)}a.forEach(function(e){e.isDisposed||e.dispose()})}}function isDataTensor(e){return e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]}function isDataArray(e){return Array.isArray(e)}function isDataDict(e){return!isDataTensor(e)&&!isDataArray(e)}function standardizeInputData(e,t,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==t||0===t.length){if(null!=e){var a=!1;if(isDataArray(e)&&e.length>0)a=!0;else if(isDataDict(e)){for(var o in e)if(e.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ValueError("Error when checking model "+i+" expected no data, but got "+e)}return[]}if(null==e)return t.map(function(e){return null});var s;if(isDataDict(e)){e=e,s=[];for(var l=0,u=t;l<u.length;l++){var c=u[l];if(null==e[c])throw new ValueError('No data provided for "'+c+'". Need data for each key in: '+t);s.push(e[c])}}else if(isDataArray(e)){if((e=e).length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+t.length+" Tensor(s), but instead got the following list of Tensor(s): "+e);s=e}else{if(e=e,t.length>1)throw new ValueError("The model "+i+" expects "+t.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+e.shape);s=[e]}if(s=ensureTensorsRank2OrHigher(s),null!=n)for(var p=0;p<t.length;++p)if(null!=n[p]){var h=s[p];if(h.shape.length!==n[p].length)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have "+n[p].length+" dimension(s). but got array with shape "+h.shape);for(var d=0;d<n[p].length;++d)if(0!==d||r){var f=h.shape[d],g=n[p][d];if(null!=g&&g>=0&&f!==g)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have shape ["+n[p]+"], but got array with shape ["+h.shape+"].")}}return s}function checkArrayLengths(e,t,n){var r=unique(e.map(function(e){return e.shape[0]}));r.sort();var i=unique(t.map(function(e){return e.shape[0]}));if(i.sort(),r.length>1)throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(function(e){return e.shape})));if(i.length>1)throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(function(e){return e.shape})));if(r.length>0&&i.length>0&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r,i))throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found "+r[0]+" input sample(s) and "+i[0]+" target sample(s).")}function checkLossAndTargetCompatibility(e,t,n){for(var r=[meanSquaredError,binaryCrossentropy,categoricalCrossentropy],i=0;i<e.length;++i){var a=e[i],o=t[i],s=n[i];if(null!=o){if(o===categoricalCrossentropy&&1===a.shape[a.shape.length-1])throw new ValueError("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o))for(var l=a.shape.slice(1),u=s.slice(1),c=0;c<l.length;++c){var p=l[c],h=u[c];if(null!=h&&p!==h)throw new ValueError("A target Tensor with shape "+a.shape+" was passed for an output of shape "+s+", while using a loss function that expects targets to have the same shape as the output.")}}}}function checkInputData(e,t,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(e)){if(e.length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+t.length+" Tensor(s), but instead got "+e.length+" Tensors(s).");a=e}else{if(t.length>1)throw new ValueError("The model expects "+t.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(e.shape)+".");a=[e]}if(null!=n)for(var o=0;o<t.length;++o)if(null!=n[o]){var s=a[o];if(s.shape.length!==n[o].length)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have "+n[o].length+" dimension(s), but got array with shape "+JSON.stringify(s.shape));for(var l=0;l<n[o].length;++l)if(0!==l||r){var u=s.shape[l],c=n[o][l];if(null!=c&&c!==u)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have shape "+JSON.stringify(n[o])+" but got array with shape "+JSON.stringify(s.shape)+".")}}}function collectMetrics(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(function(e){return[]});if(Array.isArray(e))return t.map(function(t){return e});if(null!=e){for(var n=[],r=0,i=t;r<i.length;r++){var a=i[r],o=e.hasOwnProperty(a)?e[a]:[];Array.isArray(o)||(o=[o]),n.push(o)}return n}throw new TypeError("Type of metrics argument not understood. Expected an Array or Object, found: "+e)}var LAYERS_MODEL_FORMAT_NAME="layers-model",LayersModel=function(e){function t(t){var n=e.call(this,t)||this;return n.isTraining=!1,n}return __extends(t,e),t.prototype.summary=function(e,t,n){if(void 0===n&&(n=console.log),!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,t,n)},t.prototype.compile=function(e){var t=this;if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=getOptimizer(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}var n=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+e.loss+".");var r=e.loss;n=r.map(function(e){return get(e)})}else{var i=get(e.loss);this.outputs.forEach(function(e){n.push(i)})}else{for(var a in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(a))throw new ValueError('Unknown entry in loss dictionary: "'+a+'". Only expected the following keys: '+this.outputNames);for(var o=0,s=this.outputNames;o<s.length;o++){var l=s[o];null==e.loss[l]&&console.warn('Output "'+l+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+l+" during training"),n.push(get(e.loss[l]))}}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var u=0;u<this.outputs.length;++u){var c=this.internalOutputShapes[u],p=this.outputNames[u];this.feedOutputNames.push(p),this.feedOutputShapes.push(c),this.feedLossFns.push(this.lossFunctions[u])}var h=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",function(){for(var e=0;e<t.outputs.length;++e)if(-1===h.indexOf(e)){var n=t.lossFunctions[e];t.outputs.length>1&&(t.metricsTensors.push([n,e]),t.metricsNames.push(t.outputNames[e]+"_loss"))}});var d=collectMetrics(e.metrics,this.outputNames);nameScope("metric",function(){for(var e=function(e){if(-1!==h.indexOf(e))return"continue";!function(n){for(var r,i,a,o=function(n){if(-1!==["accuracy","acc","crossentropy","ce"].indexOf(n)){var o=t.internalOutputShapes[e];1===o[o.length-1]||t.lossFunctions[e]===binaryCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=binaryAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=binaryCrossentropy$1):t.lossFunctions[e]===sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=sparseCategoricalCrossentropy$1):-1!==["accuracy","acc"].indexOf(n)?i=categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=categoricalCrossentropy$1);var s=void 0;-1!==["accuracy","acc"].indexOf(n)?s="acc":-1!==["crossentropy","ce"].indexOf(n)&&(s="ce"),a=i,r=""+s}else{var l=get$1(n);a=l,r=""+n}var u;nameScope(r,function(){u=a}),function(e,n,r){t.outputNames.length>1&&(n=t.outputNames[e]+"_"+n),t.metricsNames.push(n),t.metricsTensors.push([r,e])}(e,r,u)},s=0,l=n;s<l.length;s++)o(l[s])}(d[e])},n=0;n<t.outputs.length;++n)e(n)}),this.collectedTrainableWeights=this.trainableWeights},t.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},t.prototype.evaluate=function(e,t,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;checkBatchSize(r);var i=this.standardizeUserData(e,t,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var o=this.testFunction;return singletonOrArray(this.testLoop(o,a,r,n.verbose,n.steps))}finally{disposeNewTensors(i[0],e),disposeNewTensors(i[1],t)}},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return this.makeTestFunction(),[2,evaluateDataset(this,e,t)]})})},t.prototype.checkNumSamples=function(e,t,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=t)throw new ValueError("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+t)}else{if(null==e)throw new ValueError("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i},t.prototype.execute=function(e,t){if(Array.isArray(t)&&0===t.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");var n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),a=new FeedDict;if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError("The number of inputs provided ("+e.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(var s=0,l=this.inputs;s<l.length;s++){var u=l[s],c=e[u.name];if(null==c)throw new ValueError("No value is provided for the model's input "+u.name);a.add(u,c)}var p=execute(i,a);return n?p:p[0]},t.prototype.retrieveSymbolicTensors=function(e){for(var t=pyListRepeat(null,e.length),n=e.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],o=Array.isArray(a.output)?a.output:[a.output],s=o.map(function(e){return e.name}),l=0;l<e.length;++l){var u=s.indexOf(e[l]);if(-1!==u&&(t[l]=o[u],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw t.forEach(function(t,n){null==t&&c.push(e[n])}),new ValueError("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return t},t.prototype.predictLoop=function(e,t,n){var r=this;return void 0===t&&(t=32),void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var i=r.checkNumSamples(e);if(n)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");for(var a=makeBatches(i,t),o=r.outputs.map(function(e){return[]}),s=function(t){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=a[t][0],i=a[t][1],o=sliceArrays(e,n,i),s=[];if(Array.isArray(o))for(var l=0;l<o.length;++l)s.push({key:r.inputs[l],value:o[l]});else s.push({key:r.inputs[0],value:o});var u=new FeedDict(s);return execute(r.outputs,u)}).forEach(function(e,t){return o[t].push(e)})},l=0;l<a.length;++l)s(l);return singletonOrArray(o.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,0)}))})},t.prototype.predict=function(e,t){void 0===t&&(t={});var n=ensureTensorsRank2OrHigher(e);checkInputData(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==t.batchSize?32:t.batchSize;return checkBatchSize(r),this.predictLoop(n,r)}finally{disposeNewTensors(n,e)}},t.prototype.predictOnBatch=function(e){return checkInputData(e,this.inputNames,this.feedInputShapes,!0),this.predictLoop(e,e.shape[0])},t.prototype.standardizeUserData=function(e,t,n,r){if(void 0===n&&(n=!0),null==this.optimizer_)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");for(var i=[],a=0;a<this.feedOutputShapes.length;++a){var o=this.feedOutputShapes[a];this.feedLossFns[a]===sparseCategoricalCrossentropy?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(checkArrayLengths(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=standardizeInputData(t,this.feedOutputNames,i,!1,"target"),null),checkLossAndTargetCompatibility(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+r+". Found: "+e[0].shape[0]+" sample(s).");return[e,t,null]},t.prototype.testLoop=function(e,t,n,r,i){var a=this;return void 0===r&&(r=0),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o=a.checkNumSamples(t,n,i,"steps"),s=[];if(r>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=i)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");for(var l=makeBatches(o,n),u=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(range(0,o)),c=0;c<l.length;++c){var p=l[c][0],h=l[c][1],d=sliceAlongFirstAxis(u,p,h-p),f=sliceArraysByIndices(t,d),g=e(f);if(0===c)for(var m=0;m<g.length;++m)s.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));for(m=0;m<g.length;++m){var y=g[m];s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(s[m],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(h-p,y))}}for(m=0;m<s.length;++m)s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(s[m],o);return s})},t.prototype.getDedupedMetricsNames=function(){for(var e=this.metricsNames,t=[],n=0;n<e.length;++n){var r=e[n],i=r;if(count(e,r)>1)i+="_"+count(e.slice(0,n),r);t.push(i)}return t},t.prototype.makeTrainFunction=function(){var e=this;return function(t){var n=t.slice(0,e.inputs.length),r=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),i=[],a=e.collectedTrainableWeights.map(function(e){return e.read()});return[e.optimizer_.minimize(function(){for(var t=[],a=0;a<e.inputs.length;++a)t.push({key:e.inputs[a],value:n[a]});var o,s=new FeedDict(t),l=execute(e.outputs,s,{training:!0});for(a=0;a<e.lossFunctions.length;++a){var u=(0,e.lossFunctions[a])(r[a],l[a]);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(u),o=0===a?u:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,u)}for(a=0;a<e.metricsTensors.length;++a){var c=e.metricsTensors[a][0],p=e.metricsTensors[a][1],h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(r[p],l[p]));Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(h),i.push(h)}return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(o),e.calculateLosses().forEach(function(e){o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,e)}),o},!0,a)].concat(i)}},t.prototype.makeTestFunction=function(){var e=this;this.testFunction=function(t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n,r=[],i=t.slice(0,e.inputs.length),a=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),o=[],s=0;s<e.inputs.length;++s)o.push({key:e.inputs[s],value:i[s]});var l=new FeedDict(o),u=execute(e.outputs,l);for(s=0;s<e.lossFunctions.length;++s){var c=e.lossFunctions[s],p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(a[s],u[s]));n=0===s?p:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,p),r.push(n)}for(s=0;s<e.metricsTensors.length;++s){var h=e.metricsTensors[s][0],d=e.metricsTensors[s][1],f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(h(a[d],u[d]));r.push(f)}return r})}},t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,fitTensors(this,e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,fitDataset(this,e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u,c;return __generator(this,function(p){switch(p.label){case 0:n=this.standardizeUserData(e,t),r=n[0],i=n[1],a=this.makeTrainFunction(),o=a(r.concat(i)),s=[],l=0,u=o,p.label=1;case 1:return l<u.length?[4,u[l].data()]:[3,4];case 2:c=p.sent(),s.push(c[0]),p.label=3;case 3:return l++,[3,1];case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(o),[2,singletonOrArray(s)]}})})},t.prototype.getNamedWeights=function(e){for(var t={},n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||(t[r[a].originalName]=i[a]);return t},Object.defineProperty(t.prototype,"stopTraining",{get:function(){return this.stopTraining_},set:function(e){this.stopTraining_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=e.prototype.dispose.call(this);if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors}return t},t.prototype.save=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o;return __generator(this,function(s){switch(s.label){case 0:if("string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getSaveHandlers(e)).length)throw new ValueError("Cannot find any save handlers for URL '"+e+"'");if(n.length>1)throw new ValueError("Found more than one ("+n.length+") save handlers for URL '"+e+"'");e=n[0]}if(null==e.save)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].encodeWeights(this.getNamedWeights(t))];case 1:return r=s.sent(),i=!1,a=null,o=this.toJSON(a,i),[2,e.save({modelTopology:o,weightData:r.data,weightSpecs:r.specs,format:LAYERS_MODEL_FORMAT_NAME,generatedBy:"TensorFlow.js tfjs-layers v"+version,convertedBy:null})]}})})},t.className="Model",t}(Container);function modelFromJSON(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u;return __generator(this,function(c){switch(c.label){case 0:return"modelTopology"in e||(e={modelTopology:e}),null!=(n=(e=e).modelTopology).model_config&&(n=n.model_config),r=convertPythonicToTs(n),i=deserialize(r,t),null==e.weightsManifest?[3,2]:[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].loadWeights(e.weightsManifest,e.pathPrefix,i.weights.map(function(e){return e.originalName}))];case 1:for(a=c.sent(),o={},s=0,l=i.weights;s<l.length;s++)u=l[s],o[u.originalName]=a[u.originalName];i.loadWeights(o),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(a),c.label=2;case 2:return[2,i]}})})}function loadLayersModelInternal(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){if(null==t&&(t={}),"string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e)).length)n.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,t));else if(n.length>1)throw new ValueError("Found more than one ("+n.length+") load handlers for URL '"+e+"'");e=n[0]}return[2,loadLayersModelFromIOHandler(e,void 0,t)]})})}function loadLayersModelFromIOHandler(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==n&&(n={}),null==e.load)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,e.load()];case 1:if(r=u.sent(),null!=(i=r.modelTopology).model_config&&(i=i.model_config),a=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&a,s=deserialize(convertPythonicToTs(i),t,o),null!=r.weightData){if(null==r.weightSpecs)throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");l=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(r.weightData,r.weightSpecs),s.loadWeights(l,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(l)}return[2,s]}})})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LayersModel);var Sequential=function(e){function t(t){var n=e.call(this,{inputs:[],outputs:[]})||this;if(t=t||{},n.trainable=!0,n._updatable=!0,n.built=!1,n.name=null!=t.name?t.name:getUid("sequential_"),null!=t.layers)for(var r=0,i=t.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return __extends(t,e),t.prototype.checkShape=function(e){if(e.inboundNodes[0].outputTensors[0].shape.some(function(e){return e<0}))throw new ValueError("Negative dimension size caused by adding layer "+e.name+" with input shape ["+e.inboundNodes[0].inputTensors[0].shape+"]")},t.prototype.add=function(e){var n,r=e instanceof t||e instanceof LayersModel;if(r){if(1!==(n=e).outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+e.name+" which has "+e.inboundNodes.length+" pre-existing inbound connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(e){return e.shape}),outputShapes:this.outputs[0].shape})}else{var a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1},t.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},t.prototype.call=function(e,t){return null==this.model&&this.build(),this.model.call(e,t)},t.prototype.build=function(e){if(getExactlyOneShape(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.model.updatable=this.updatable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},t.prototype.countParams=function(){return this.built||this.build(),e.prototype.countParams.call(this)},t.prototype.summary=function(t,n,r){void 0===r&&(r=console.log),this.built||this.build(),e.prototype.summary.call(this,t,n,r)},t.prototype.setWeights=function(e){null==this.model&&this.build(),this.model.setWeights(e)},Object.defineProperty(t.prototype,"updatable",{get:function(){return this._updatable},set:function(e){this.built&&(this.model.updatable=e),this._updatable=e},enumerable:!0,configurable:!0}),t.prototype.evaluate=function(e,t,n){if(void 0===n&&(n={}),!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(e,t)]})})},t.prototype.predict=function(e,t){return void 0===t&&(t={}),null==this.model&&this.build(),this.model.predict(e,t)},t.prototype.predictOnBatch=function(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)},t.prototype.compile=function(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.model.optimizer},set:function(e){this.model.optimizer=e},enumerable:!0,configurable:!0}),t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fit(e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fitDataset(e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,this.model.trainOnBatch(e,t)]})})},t.fromConfig=function(e,n,r,i){var a;void 0===r&&(r={}),void 0===i&&(i=!1);var o={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new ValueError("Legacy serialization format not supported yet.");a=n}else _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.layers,function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."}),a=n.layers,delete n.layers,o=n;var s=new e(o);if(!(s instanceof t))throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: "+s);for(var l=0,u=a;l<u.length;l++){var c=deserialize(u[l],void 0,i);i&&c.setFastWeightInitDuringBuild(!0),s.add(c)}return s},Object.defineProperty(t.prototype,"stopTraining",{get:function(){if(null==this.model)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining},set:function(e){if(null==this.model)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t],i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return e},t.className="Sequential",t}(LayersModel);function model(e){return new LayersModel(e)}function sequential(e){return new Sequential(e)}function loadLayersModel(e,t){return null==t&&(t={}),loadLayersModelInternal(e,t)}function input(e){return Input(e)}function registerCallbackConstructor(e,t){CallbackConstructorRegistry.registerCallbackConstructor(e,t)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sequential);var Activation=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Elu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=1),elu$1(e,t)},t.className="elu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Elu);var Selu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(e)},t.className="selu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Selu);var Relu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="relu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu);var Relu6=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(6,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e))})},t.className="relu6",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu6);var Linear=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return e},t.className="linear",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Linear);var Sigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(e)},t.className="sigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sigmoid);var HardSigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return hardSigmoid(e)},t.className="hardSigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HardSigmoid);var Softplus=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(e)},t.className="softplus",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softplus);var Softsign=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return softsign(e)},t.className="softsign",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softsign);var Tanh=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(e)},t.className="tanh",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Tanh);var Softmax=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(e,t)},t.className="softmax",t}(Activation);function serializeActivation(e){return e.getClassName()}function deserializeActivation(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"activation")}function getActivation(e){var t;return null==e?deserializeActivation(t={className:"linear",config:{}}):"string"==typeof e?((t={}).className=e,t.config={},deserializeActivation(t)):e instanceof Activation?e:deserializeActivation(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax);var Regularizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),L1L2=function(e){function t(t){var n=e.call(this)||this;return n.l1=null==t||null==t.l1?.01:t.l1,n.l2=null==t||null==t.l2?.01:t.l2,n.hasL1=0!==n.l1,n.hasL2=0!==n.l2,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([1]);return t.hasL1&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e))))),t.hasL2&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l2,square(e))))),n.asScalar()})},t.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}},t.fromConfig=function(e,t){return new e({l1:t.l1,l2:t.l2})},t.className="L1L2",t}(Regularizer);function l1(e){return new L1L2({l1:null!=e?e.l1:null,l2:0})}function l2(e){return new L1L2({l2:null!=e?e.l2:null,l1:0})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(e){return serializeKerasObject(e)}function deserializeRegularizer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"regularizer")}function getRegularizer(e){return null==e?null:"string"==typeof e?deserializeRegularizer({className:e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Regularizer?e:deserializeRegularizer(e)}var ReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,null!=t&&(n.maxValue=t.maxValue),n}return __extends(t,e),t.prototype.call=function(e,t){e=getExactlyOneTensor(e);var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e);return null!=this.maxValue&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,this.maxValue)),n},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={maxValue:this.maxValue},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ReLU);var LeakyReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_ALPHA=.3,null==t&&(t={}),n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(n,this.alpha)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LeakyReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeakyReLU);var PReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),n.supportsMasking=!0,n.alphaInitializer=getInitializer(t.alphaInitializer||n.DEFAULT_ALPHA_INITIALIZER),n.alphaRegularizer=getRegularizer(t.alphaRegularizer),n.alphaConstraint=getConstraint(t.alphaConstraint),null==t.sharedAxes)n.sharedAxes=null;else if(Array.isArray(t.sharedAxes))n.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);n.sharedAxes=[t.sharedAxes]}return n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e)).slice(1);if(null!=this.sharedAxes)for(var n=0,r=this.sharedAxes;n<r.length;n++){t[(a=r[n])-1]=1}this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);var i={};if(null!=this.sharedAxes)for(var a=1;a<e.length;++a)i[a]=e[a];this.inputSpec=[new InputSpec({ndim:e.length,axes:i})],this.built=!0},t.prototype.call=function(e,t){return e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"])(e,this.alpha.read())},t.prototype.getConfig=function(){var t={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="PReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(PReLU);var ELU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==n.DEFAULT_ALPHA)throw new NotImplementedError("Non-default alpha value ("+t.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(n)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ELU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ELU);var ThresholdedReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_THETA=1,null==t&&(t={}),n.theta=null==t.theta?n.DEFAULT_THETA:t.theta,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return n.mul(cast$1(n.greater(this.theta),"float32"))},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={theta:this.theta},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ThresholdedReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ThresholdedReLU);var Softmax$1=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_AXIS=1,null==t&&(t={}),n.softmax=(new Softmax).apply,n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return this.softmax(n,this.axis)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Softmax",t}(Layer);function normalizeArray(e,t,n){if("number"==typeof e)return pyListRepeat(e,t);if(e.length!==t)throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+e.length+" elements.");for(var r=0;r<t;++r){var i=e[r];if(!isInteger(i))throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+JSON.stringify(e)+" including a non-integer number "+i)}return e}function convOutputLength(e,t,n,r,i){return void 0===i&&(i=1),null==e?e:(a="same"===n?e:e-(t+(t-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function deconvLength(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+max$1([n-t,0]);else{if("same"!==r)throw new ValueError("Unsupport padding mode: "+r+".");e*=t}return e}function preprocessConv2DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1]):e})}function preprocessConv3DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,4,1]):e})}function conv1dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=1),void 0===i&&(i="valid"),void 0===o&&(o=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.shape.length)throw new ValueError("The input of a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead.");if(3!==t.shape.length)throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is "+t.shape.length+" instead");if("channelsFirst"===a&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,1])),"causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(e,t,r,"same"===i?"same":"valid","NWC",o);return null!=n&&(s=biasAdd(s,n)),s})}function conv2dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.rank&&4!==e.rank)throw new ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received "+e.rank+".");if(3!==t.rank&&4!==t.rank)throw new ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received "+e.rank+".");var s=preprocessConv2DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(s,t,r,"same"===i?"same":"valid","NHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,3,1,2])),s})}function conv3dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),4!==e.rank&&5!==e.rank)throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received "+e.rank+".");if(4!==t.rank&&5!==t.rank)throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+e.rank+".");var s=preprocessConv3DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"])(s,t,r,"same"===i?"same":"valid","NDHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,4,1,2,3])),s})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax$1);var BaseConv=function(e){function t(n,r){var i=e.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyArgs(r),i.rank=n,assertPositiveInteger(i.rank,"rank"),1!==i.rank&&2!==i.rank&&3!==i.rank)throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 ("+i.rank+") is not implemented yet.");if(i.kernelSize=normalizeArray(r.kernelSize,n,"kernelSize"),i.strides=normalizeArray(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,checkPaddingMode(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,checkDataFormat(i.dataFormat),i.activation=getActivation(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=getInitializer(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=getConstraint(r.biasConstraint),i.biasRegularizer=getRegularizer(r.biasRegularizer),i.activityRegularizer=getRegularizer(r.activityRegularizer),i.dilationRate=normalizeArray(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank){if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate))}else if(3===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate,i.dilationRate];else if(3!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(i.dilationRate));return i}return __extends(t,e),t.verifyArgs=function(e){if(assert("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+JSON.stringify(e.kernelSize)+".")},t.prototype.getConfig=function(){var t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),Conv=function(e){function t(n,r){var i=e.call(this,n,r)||this;return i.kernel=null,t.verifyArgs(r),i.filters=r.filters,assertPositiveInteger(i.filters,"filters"),i.kernelInitializer=getInitializer(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=getConstraint(r.kernelConstraint),i.kernelRegularizer=getRegularizer(r.kernelRegularizer),i}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the input should be defined. Found "+e[n]);var r=e[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(t={},t[n]=r,t)}],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;e=getExactlyOneTensor(e);var r=null==n.bias?null:n.bias.read();if(1===n.rank)t=conv1dWithBias(e,n.kernel.read(),r,n.strides[0],n.padding,n.dataFormat,n.dilationRate[0]);else if(2===n.rank)t=conv2dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate);else{if(3!==n.rank)throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");t=conv3dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate)}return null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);for(var t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2),r=0;r<n.length;++r){var i=convOutputLength(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(i)}var a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t)).push(this.filters):(a.push(this.filters),a=a.concat(t)),a},t.prototype.getConfig=function(){var t={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.verifyArgs=function(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(e.filters))},t}(BaseConv),Conv2D=function(e){function t(n){var r=e.call(this,2,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv2D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2D);var Conv3D=function(e){function t(n){var r=e.call(this,3,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv3D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv3D);var Conv2DTranspose=function(e){function t(t){var n=e.call(this,t)||this;if(n.inputSpec=[new InputSpec({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return __extends(t,e),t.prototype.build=function(e){var t;if(4!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");var r=e[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);if(4!==t.shape.length)throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+t.shape.length);var r,i,a=t.shape,o=a[0];"channelsFirst"===n.dataFormat?(r=2,i=3):(r=1,i=2);var s=a[r],l=a[i],u=n.kernelSize[0],c=n.kernelSize[1],p=n.strides[0],h=n.strides[1],d=[o,deconvLength(s,p,u,n.padding),deconvLength(l,h,c,n.padding),n.filters];"channelsLast"!==n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]));var f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(t,n.kernel.read(),d,n.strides,n.padding);return"channelsLast"!==n.dataFormat&&(f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(f,[0,3,1,2])),null!=n.bias&&(f=biasAdd(f,n.bias.read(),n.dataFormat)),null!=n.activation&&(f=n.activation.apply(f)),f})},t.prototype.computeOutputShape=function(e){var t,n,r,i=(e=getExactlyOneShape(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);var a=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],l=this.strides[1];return i[t]=this.filters,i[n]=deconvLength(i[n],s,a,this.padding),i[r]=deconvLength(i[r],l,o,this.padding),i},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.dilationRate,t},t.className="Conv2DTranspose",t}(Conv2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2DTranspose);var SeparableConv=function(e){function t(t,n){var r=e.call(this,t,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=getRegularizer(n.depthwiseRegularizer),r.depthwiseConstraint=getConstraint(n.depthwiseConstraint),r.pointwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=getRegularizer(n.pointwiseRegularizer),r.pointwiseConstraint=getConstraint(n.pointwiseConstraint),r}return __extends(t,e),t.prototype.build=function(e){var t;if((e=getExactlyOneShape(e)).length<this.rank+2)throw new ValueError("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n]||e[n]<0)throw new ValueError("The channel dimension of the inputs should be defined, but found "+JSON.stringify(e[n]));for(var r=e[n],i=this.kernelSize.concat([r,this.depthMultiplier]),a=[],o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;if(e=getExactlyOneTensor(e),1===n.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===n.rank&&("channelsFirst"===n.dataFormat&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1])),t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"])(e,n.depthwiseKernel.read(),n.pointwiseKernel.read(),n.strides,n.padding,n.dilationRate,"NHWC")),n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),"channelsFirst"===n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,3,1,2])),t})},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),t.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),t},t.className="SeparableConv",t}(Conv),SeparableConv2D=function(e){function t(t){return e.call(this,2,t)||this}return __extends(t,e),t.className="SeparableConv2D",t}(SeparableConv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SeparableConv2D);var Conv1D=function(e){function t(n){var r=e.call(this,1,n)||this;return t.verifyArgs(n),r.inputSpec=[{ndim:3}],r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.dataFormat,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv1D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv1D);var Cropping2D=function(e){function t(t){var n=e.call(this,t)||this;return"number"==typeof t.cropping?n.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?n.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:n.cropping=t.cropping,n.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,n.inputSpec=[{ndim:4}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e=getExactlyOneTensor(e),"channelsLast"===n.dataFormat?sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[1]-n.cropping[0][0]-n.cropping[0][1],2),n.cropping[1][0],e.shape[2]-n.cropping[1][1]-n.cropping[1][0],3):sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[2]-n.cropping[0][0]-n.cropping[0][1],3),n.cropping[1][0],e.shape[3]-n.cropping[1][1]-n.cropping[1][0],4)})},t.prototype.getConfig=function(){var t={cropping:this.cropping,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Cropping2D",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Cropping2D);var UpSampling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_SIZE=[2,2],n.inputSpec=[{ndim:4}],n.size=null==t.size?n.DEFAULT_SIZE:t.size,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){if("channelsFirst"===this.dataFormat){var t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e),r=t.shape;if("channelsFirst"===n.dataFormat){t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]);var i=n.size[0]*r[2],a=n.size[1]*r[3],o=t.resizeNearestNeighbor([i,a]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])}i=n.size[0]*r[1],a=n.size[1]*r[2];return t.resizeNearestNeighbor([i,a])})},t.prototype.getConfig=function(){var t={size:this.size,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="UpSampling2D",t}(Layer);function depthwiseConv2d$1(e,t,n,r,i,a){return void 0===n&&(n=[1,1]),void 0===r&&(r="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null==i&&(i=imageDataFormat()),checkDataFormat(i);var o=preprocessConv2DInput(e,i);if(4!==e.rank)throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+e.rank+"-D");if(4!==t.rank)throw new ValueError("depthwiseKernel is required to be 4-D, but is instead "+t.rank+"-D");return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(o,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UpSampling2D);var DepthwiseConv2D=function(e){function t(t){var n=e.call(this,2,t)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,n.depthwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=getConstraint(t.depthwiseConstraint),n.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),n}return __extends(t,e),t.prototype.build=function(e){if((e=getExactlyOneShape(e)).length<4)throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(e)+".");var t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+e[t]+").");var n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=depthwiseConv2d$1(e=getExactlyOneTensor(e),n.depthwiseKernel.read(),n.strides,n.padding,n.dataFormat,null);return n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=convOutputLength(t,this.kernelSize[0],this.padding,this.strides[0]),a=convOutputLength(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,i,a]:[e[0],i,a,r]},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),t},t.className="DepthwiseConv2D",t}(BaseConv);function mapActivationToFusedKernel(e){return"relu"===e?"relu":"linear"===e?"linear":null}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(DepthwiseConv2D);var Dropout=function(e){function t(t){var n=e.call(this,t)||this;if(n.rate=Math.max(Math.min(t.rate,1),0),n.noiseShape=t.noiseShape,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Non-default seed is not implemented in Dropout layer yet: "+n.seed);return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.getNoiseShape=function(e){if(null==this.noiseShape)return this.noiseShape;for(var t=e.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(null!=n.noiseShape&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.shape,n.noiseShape))throw new NotImplementedError("Non-default noise shape is not implemented in Dropout layer yet: "+JSON.stringify(n.noiseShape));if(0<n.rate&&n.rate<1){var i=null!=t.training&&t.training,a=n.getNoiseShape(r);return inTrainPhase(function(){return dropout(r,n.rate,a,n.seed)},function(){return r},i)}return e})},t.prototype.getConfig=function(){var t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.dispose=function(){return e.prototype.dispose.call(this)},t.className="Dropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dropout);var Dense=function(e){function t(t){var n=e.call(this,t)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){var r=null;null!=t.batchSize&&(r=t.batchSize),n.batchInputShape=[r,t.inputDim]}return n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(t.activation),null!=t.useBias&&(n.useBias=t.useBias),n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=getConstraint(t.kernelConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.supportsMasking=!0,n.inputSpec=[{minNDim:2}],n}return __extends(t,e),t.prototype.build=function(e){var t,n=(e=getExactlyOneShape(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(t={},t[-1]=n,t)}],this.built=!0},t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return t[t.length-1]=this.units,t},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r,i=getExactlyOneTensor(e),a=mapActivationToFusedKernel(n.activation.getClassName());return null!=a?r=dot(i,n.kernel.read(),a,n.bias?n.bias.read():null):(r=dot(i,n.kernel.read()),null!=n.bias&&(r=biasAdd(r,n.bias.read())),null!=n.activation&&(r=n.activation.apply(r))),r})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dense",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dense);var Flatten=function(e){function t(t){var n=e.call(this,t||{})||this;return n.inputSpec=[{minNDim:3}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){for(var t=0,n=(e=getExactlyOneShape(e)).slice(1);t<n.length;t++){if(null==n[t])throw new ValueError('The shape of the input to "Flatten" is not fully defined (got '+e.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[e[0],arrayProd(e,1)]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),batchFlatten(getExactlyOneTensor(e))})},t.className="Flatten",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Flatten);var Activation$1=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.activation=getActivation(t.activation),n}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return n.activation.apply(r)})},t.prototype.getConfig=function(){var t={activation:serializeActivation(this.activation)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Activation",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Activation$1);var RepeatVector=function(e){function t(t){var n=e.call(this,t)||this;return n.n=t.n,n.inputSpec=[{ndim:2}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],this.n,e[1]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return repeat(e=getExactlyOneTensor(e),n.n)})},t.prototype.getConfig=function(){var t={n:this.n},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="RepeatVector",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RepeatVector);var Reshape=function(e){function t(t){var n=e.call(this,t)||this;n.targetShape=t.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return __extends(t,e),t.prototype.isUnknown=function(e){return e<0||null==e},t.prototype.fixUnknownDimension=function(e,t){for(var n="Total size of new array must be unchanged.",r=t.slice(),i=1,a=null,o=0;o<r.length;++o){var s=r[o];if(this.isUnknown(s)){if(null!==a)throw new ValueError("Can only specifiy one unknown dimension.");a=o}else i*=s}var l=arrayProd(e);if(null!==a){if(0===i||l%i!=0)throw new ValueError(n);r[a]=l/i}else if(l!==i)throw new ValueError(n);return r},t.prototype.computeOutputShape=function(e){for(var t=!1,n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=r.shape,a=i.slice(0,1).concat(n.fixUnknownDimension(i.slice(1),n.targetShape));return r.reshape(a)})},t.prototype.getConfig=function(){var t={targetShape:this.targetShape},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Reshape",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Reshape);var Permute=function(e){function t(t){var n=e.call(this,t)||this;if(null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");var r=range(1,t.dims.length+1);if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");return n.dims=t.dims,n.dimsIncludingBatch=[0].concat(n.dims),n.inputSpec=[new InputSpec({ndim:n.dims.length+1})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return this.dims.forEach(function(n,r){t[r+1]=e[n]}),t},t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getExactlyOneTensor(e),this.dimsIncludingBatch)},t.prototype.getConfig=function(){var t={dims:this.dims},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Permute",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Permute);var Masking=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,n.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={maskValue:this.maskValue};return Object.assign(n,t),n},t.prototype.computeMask=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(n,this.maskValue),-1)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(r,n.maskValue),-1,!0);return r.mul(i.asType(r.dtype))})},t.className="Masking",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Masking);var Embedding=function(e){function t(t){var n=e.call(this,t)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){var r=null;null!=t.batchSize&&(r=t.batchSize),null==t.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(toList(t.inputLength))}return n.inputDim=t.inputDim,assertPositiveInteger(n.inputDim,"inputDim"),n.outputDim=t.outputDim,assertPositiveInteger(n.outputDim,"outputDim"),n.embeddingsInitializer=getInitializer(t.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=getRegularizer(t.embeddingsRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.embeddingsConstraint=getConstraint(t.embeddingsConstraint),n.maskZero=t.maskZero,n.supportsMasking=t.maskZero,n.inputLength=t.inputLength,n}return __extends(t,e),t.prototype.build=function(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},t.prototype.warnOnIncompatibleInputShape=function(e){},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.maskZero?(e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(e))):null})},t.prototype.computeOutputShape=function(e){if(e=getExactlyOneShape(e),null==this.inputLength)return e.concat([this.outputDim]);var t=toList(this.inputLength);if(t.length!==e.length-1)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);for(var n=0,r=0;r<t.length;++r){var i=t[r],a=e[r+1];if(null!=i&&null!=a&&i!==a)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);null==i&&(t[n]=a),n++}return[e[0]].concat(t,[this.outputDim])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return"int32"!==r.dtype&&(r=cast$1(r,"int32")),gather$1(n.embeddings.read(),r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)))})},t.prototype.getConfig=function(){var t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Embedding",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Embedding);var Merge=function(e){function t(t){var n=e.call(this,t||{})||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.mergeFunction=function(e){throw new NotImplementedError},t.prototype.computeElementwiseOpOutputShape=function(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;for(var n=e.slice(0,e.length-t.length),r=0;r<t.length;++r){var i=e[e.length-t.length+r],a=t[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(i)}}return n},t.prototype.build=function(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),(e=e).length<2)throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got "+e.length+" input(s).");for(var t=[],n=0,r=e;n<r.length;n++){null!=(o=r[n])&&null!==o[0]&&t.push(o[0])}if((t=unique(t)).length>1)throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(e)+".");for(var i=null==e[0]?null:e[0].slice(1),a=1;a<e.length;++a){var o=null==e[a]?null:e[a].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}var s=e.map(function(e){return e.length});-1===e.indexOf(null)&&1===unique(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(e=e,n.reshapeRequired){var t=[],r=e.map(function(e){return e.rank});if(-1===r.indexOf(null)){for(var i=max$1(r),a=0,o=e;a<o.length;a++){for(var s=(h=o[a]).rank,l=0;l<i-s;++l)h=expandDims$1(h,1);t.push(h)}return n.mergeFunction(t)}for(var u=!1,c=0,p=e;c<p.length;c++){var h;if(null==(s=(h=p[c]).rank)){var d=h.shape,f=d[0],g=d.slice(1).concat([f]),m=h.reshape([f].concat(arrayProd(d.slice(1))));m=(m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(m,[1,0])).reshape(g),t.push(m),u=!0}else if(s>1){var y=range(1,s).concat([0]);t.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(h,y)),u=!0}else t.push(h)}var v=n.mergeFunction(t),b=v.rank;if(u)if(null==b){var w=v.shape;g=[f=w[w.length-1]].concat(w.slice(0,w.length-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v.reshape([-1,f]),[1,0]).reshape(g)}else if(b>1){y=[b-1].concat(range(0,b-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v,y)}return v}return n.mergeFunction(e)})},t.prototype.computeOutputShape=function(e){var t;t=null==(e=e)[0]?null:e[0].slice(1);for(var n=1;n<e.length;++n){var r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}for(var i=[],a=0,o=e;a<o.length;a++){null!=(r=o[a])&&null!==r[0]&&i.push(r[0])}return t=1===(i=unique(i)).length?i.concat(t):[null].concat(t)},t.prototype.computeMask=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new ValueError("`inputs` should be an Array");if(t.length!==e.length)throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+e.length+" vs "+t.length+")");if(t.every(function(e){return null==e}))return null;for(var n=(t=t.map(function(e){return null==e?e:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(e,0)}))[0],r=1;r<t.length-1;++r)n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(n,t[r]);return n})},t}(Layer),Add=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return t})},t.className="Add",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Add);var Multiply=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t,e[n]);return t})},t.className="Multiply",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Multiply);var Average=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/e.length,t)})},t.className="Average",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Average);var Maximum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(t,e[n]);return t})},t.className="Maximum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Maximum);var Minimum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(t,e[n]);return t})},t.className="Minimum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Minimum);var Concatenate=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_AXIS=-1,null==t&&(t={}),n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var t=!0,n=0,r=e=e;n<r.length;n++){if(null!=(c=r[n])){t=!1;break}}if(!t){for(var i=[],a=0;a<e.length;++a){var o=e[a].slice();o.splice(this.axis,1);for(var s=!1,l=0,u=i;l<u.length;l++){var c=u[l];if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,o)){s=!0;break}}s||i.push(o)}if(i.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}},t.prototype.mergeFunction=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return concatenate(e,t.axis)})},t.prototype.computeOutputShape=function(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");for(var t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=t.slice(1);i<a.length;i++){var o=a[i];if(null==n[r]||null==o[r]){n[r]=null;break}n[r]+=o[r]}return n},t.prototype.computeMask=function(e,t){var n=this;if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ValueError("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ValueError("Mismatch in the length of mask ("+t.length+") and the legnth of inputs ("+e.length+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=!0;if(t.forEach(function(e){null==e||(r=!1)}),r)return null;for(var i=[],a=0;a<e.length;++a)null==t[a]?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e[a]).asType("bool")):t[a].rank<e[a].rank?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(t[a],-1)):i.push(t[a]);var o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(i,n.axis);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(o,-1,!1)})},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Concatenate",t}(Merge);function interpretAxis(e,t){for(;e<0;)e+=t;return e}function batchDot(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of x to be >= 2, but got "+e.shape.length}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of y to be >= 2, but got "+t.shape.length}),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");var r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);var a=n;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n,o;if(r>i){n=r-i;for(var s=[],l=0;l<n;++l)s.push(1);t=t.reshape(t.shape.concat(s))}else if(i>r){n=i-r;for(s=[],l=0;l<n;++l)s.push(1);e=e.reshape(e.shape.concat(s))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=a[0]===a[1]?e.mulStrict(t).sum(a[0]):e.transpose([1,0]).mulStrict(t).sum(a[1]);else{var u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;o=e.matMul(t,u,c)}if(n>0){var p=void 0,h=[];for(l=p=r>i?r+i-3:r-1;l<p+n;++l)h.push(l);o=o.squeeze(h)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Concatenate);var Dot=function(e){function t(t){var n=e.call(this,t)||this;return n.axes=t.axes,n.normalize=null!=t.normalize&&t.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new ValueError("Dimension incompatibility: "+t[r[0]]+" !== "+n[r[1]])},t.prototype.mergeFunction=function(e){if(2!==e.length)throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received "+e.length+" input(s).");var t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(function(t,n){return interpretAxis(t,e[n].shape.length)}):[interpretAxis(this.axes,n.shape.length),interpretAxis(this.axes,r.shape.length)],this.normalize&&(n=l2Normalize(n,t[0]),r=l2Normalize(r,t[1])),batchDot(n,r,t)},t.prototype.interpretAxes=function(e,t){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,e.length),interpretAxis(this.axes,t.length)]},t.prototype.computeOutputShape=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);var i=t.concat(n);return 1===i.length&&i.push(1),i},t.prototype.computeMask=function(e,t){return null},t.prototype.getConfig=function(){var t={axes:this.axes,normalize:this.normalize},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dot",t}(Merge);function batchNormalization(e,t,n,r,i,a){var o;if(void 0===a&&(a=.001),2===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"])(e,t,n,r,i,a);else if(3===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"])(e,t,n,r,i,a);else{if(4!==e.rank)throw new NotImplementedError("batchNormalization is not implemented for array of rank "+e.rank+" yet");o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"])(e,t,n,r,i,a)}return o}function regularNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance;return[batchNormalization(e,o,s,n,t,i),o,s]})}function broadcastNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance,l=[],u=0,c=range(0,e.rank);u<c.length;u++){var p=c[u];-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p])}var h=o.reshape(l),d=s.reshape(l),f=null==t?null:t.reshape(l),g=null==n?null:n.reshape(l);return[batchNormalization(e,h,d,g,f,i),o,s]})}function normalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.slice().sort(),range(0,e.rank-1))?regularNormalizeBatchInTraining(e,t,n,r,i):broadcastNormalizeBatchInTraining(e,t,n,r,i)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dot);var BatchNormalization=function(e){function t(t){var n=this;return null==t&&(t={}),(n=e.call(this,t)||this).supportsMasking=!0,n.axis=null==t.axis?-1:t.axis,n.momentum=null==t.momentum?.99:t.momentum,n.epsilon=null==t.epsilon?.001:t.epsilon,n.center=null==t.center||t.center,n.scale=null==t.scale||t.scale,n.betaInitializer=getInitializer(t.betaInitializer||"zeros"),n.gammaInitializer=getInitializer(t.gammaInitializer||"ones"),n.movingMeanInitializer=getInitializer(t.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=getInitializer(t.movingVarianceInitializer||"ones"),n.betaConstraint=getConstraint(t.betaConstraint),n.gammaConstraint=getConstraint(t.gammaConstraint),n.betaRegularizer=getRegularizer(t.betaRegularizer),n.gammaRegularizer=getRegularizer(t.gammaRegularizer),n}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n=this.axis>=0?this.axis:this.axis+e.length,r=e[n];if(null==r)throw new ValueError("Axis "+n+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(e)+".");this.inputSpec=[new InputSpec({ndim:e.length,axes:(t={},t[n]=r,t)})];var i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training,i=getExactlyOneTensor(e),a=i.shape,o=a.length,s=range(0,o),l=n.axis>=0?n.axis:n.axis+o;s.splice(l,1);var u=pyListRepeat(1,o);u[l]=a[l];var c=s.slice();c.sort();var p=!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,range(0,o).slice(0,o-1));if(!r)return function(){if(p){var e=n.movingMean.read().reshape(u),t=n.movingVariance.read().reshape(u),r=n.center?n.beta.read().reshape(u):null,a=n.scale?n.gamma.read().reshape(u):null;return batchNormalization(i,e,t,r,a,n.epsilon)}return batchNormalization(i,n.movingMean.read(),n.movingVariance.read(),null==n.beta?null:n.beta.read(),null==n.gamma?null:n.gamma.read(),n.epsilon)}();var h=normalizeBatchInTraining(i,n.gamma.read(),n.beta.read(),s,n.epsilon),d=h[0],f=h[1],g=h[2],m=function(e,t,n){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=1-n,i=e.read(),a=i.sub(t).mul(r);e.write(i.sub(a))})};return m(n.movingMean,f,n.momentum),m(n.movingVariance,g,n.momentum),d})},t.prototype.getConfig=function(){var t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="BatchNormalization",t}(Layer);function spatial2dPadding(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(4!==e.rank)throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=imageDataFormat()),"channelsLast"!==n&&"channelsFirst"!==n)throw new ValueError("Unknown data format: "+n+". Supported data formats are 'channelsLast' and 'channelsFirst.");var r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(e,r)})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(BatchNormalization);var ZeroPadding2D=function(e){function t(t){var n=this;if(null==t&&(t={}),(n=e.call(this,t)||this).dataFormat=null==t.dataFormat?imageDataFormat():t.dataFormat,null==t.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)n.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+t.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof t.padding[0])r=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+t.padding[0].length+" array.");if(r=t.padding[0],2!==t.padding[1].length)throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+t.padding[1].length+" array.");i=t.padding[1]}n.padding=[r,i]}return n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t,n;return e=getExactlyOneShape(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return spatial2dPadding(getExactlyOneTensor(e),n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={padding:this.padding,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ZeroPadding2D",t}(Layer);function pool2d(e,t,n,r,i,a){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o;checkDataFormat(i),checkPoolMode(a),checkPaddingMode(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i=imageDataFormat()),null==a&&(a="max"),e=preprocessConv2DInput(e,i);var s="same"===r?"same":"valid";return o="max"===a?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(e,t,n,s):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(e,t,n,s),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ZeroPadding2D);var Pooling1D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=2),n=e.call(this,t)||this,"number"==typeof t.poolSize)n.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));n.poolSize=t.poolSize}if(assertPositiveInteger(n.poolSize,"poolSize"),null==t.strides)n.strides=n.poolSize;else if("number"==typeof t.strides)n.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));n.strides=t.strides}return assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=convOutputLength((e=getExactlyOneShape(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t),e=expandDims$1(getExactlyOneTensor(e),2);var r=n.poolingFunction(getExactlyOneTensor(e),[n.poolSize[0],1],[n.strides[0],1],n.padding,"channelsLast");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(r,[2])})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling1D);var AveragePooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling1D);var Pooling2D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=[2,2]),(n=e.call(this,t)||this).poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)n.strides=n.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");n.strides=t.strides}else n.strides=[t.strides,t.strides];return assertPositiveInteger(n.poolSize,"poolSize"),assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),n.poolingFunction(getExactlyOneTensor(e),n.poolSize,n.strides,n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling2D);var AveragePooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling2D);var GlobalPooling1D=function(e){function t(t){var n=e.call(this,t)||this;return n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],e[2]]},t.prototype.call=function(e,t){throw new NotImplementedError},t}(Layer),GlobalAveragePooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,1)})},t.className="GlobalAveragePooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,1)})},t.className="GlobalMaxPooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling1D);var GlobalPooling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]},t.prototype.call=function(e,t){throw new NotImplementedError},t.prototype.getConfig=function(){var t={dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),GlobalAveragePooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[2,3])})},t.className="GlobalAveragePooling2D",t}(GlobalPooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[2,3])})},t.className="GlobalMaxPooling2D",t}(GlobalPooling2D);function standardizeArgs(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=i(t),constants:n=i(n)}}function rnn(e,t,n,r,i,a,o,s){return void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===s&&(s=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var l=t.shape.length;if(l<3)throw new ValueError("Input should be at least 3D, but is "+l+"D.");var u=[1,0].concat(range(2,l));if(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,u),null!=a)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=i.asType("bool").asType("float32")).rank===l-1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(i,-1)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(i,u)),r&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(t,0),null!=i&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,0)));var c,p,h=[],d=n,f=t.shape[0],g=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t);null!=i&&(p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(i));for(var m,y=function(t){var n=g[t],r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e(n,d)});if(null==i)c=r[0],d=r[1];else{var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var e=p[t],n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e).sub(e);return{output:r[0].mul(e).addStrict(d[0].mul(n)),newStates:d.map(function(t,i){return r[1][i].mul(e).addStrict(t.mul(n))})}});c=a.output,d=a.newStates}s&&h.push(c)},v=0;v<f;++v)y(v);if(s){m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(h,1)}return[c,m,d]})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling2D);var RNN=function(e){function t(t){var n,r=e.call(this,t)||this;if(null==t.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(t.cell)?new StackedRNNCells({cells:t.cell}):t.cell).stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=t.returnSequences&&t.returnSequences,r.returnState=null!=t.returnState&&t.returnState,r.goBackwards=null!=t.goBackwards&&t.goBackwards,r._stateful=null!=t.stateful&&t.stateful,r.unroll=null!=t.unroll&&t.unroll,r.supportsMasking=!0,r.inputSpec=[new InputSpec({ndim:3})],r.stateSpec=null,r.states_=null,r.numConstants=null,r.keptStates=[],r}return __extends(t,e),t.prototype.getStates=function(){return null==this.states_?range(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(function(e){return null}):this.states_},t.prototype.setStates=function(e){this.states_=e},t.prototype.computeOutputShape=function(e){isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.cell.stateSize;Array.isArray(t)||(t=[t]);var n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){for(var i=[],a=0,o=t;a<o.length;a++){var s=o[a];i.push([e[0],s])}return[n].concat(i)}return n},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){Array.isArray(t)&&(t=t[0]);var e=n.returnSequences?t:null;if(n.returnState){var r=n.states.map(function(e){return null});return[e].concat(r)}return e})},Object.defineProperty(t.prototype,"states",{get:function(){if(null==this.states_){for(var e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[],n=0;n<e;++n)t.push(null);return t}return this.states_},set:function(e){this.states_=e},enumerable:!0,configurable:!0}),t.prototype.build=function(e){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.stateful?e[0]:null,n=e[e.length-1];this.inputSpec[0]=new InputSpec({shape:[t,null,n]});var r,i=[e[0]].concat(e.slice(2));if(this.cell.build(i),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(this.stateSpec.map(function(e){return e.shape[e.shape.length-1]}),r))throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=r.map(function(e){return new InputSpec({shape:[null,e]})});this.stateful&&this.resetStates()},t.prototype.resetStates=function(e,t){var n=this;void 0===t&&(t=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(!n.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");var r=n.inputSpec[0].shape[0];if(null==r)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==n.states_)Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_=[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize])];else if(null==e)Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_),null!=n.keptStates&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.keptStates),n.keptStates=[]),Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_[0]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==n.states_.length)throw new ValueError("Layer "+n.name+" expects "+n.states_.length+" state(s), but it received "+e.length+" state value(s). Input received: "+e);!0===t?n.keptStates.push(n.states_.slice()):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_);for(var i=0;i<n.states_.length;++i){var a=e[i],o=Array.isArray(n.cell.stateSize)?n.cell.stateSize[i]:n.cell.stateSize,s=[r,o];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(a.shape,s))throw new ValueError("State "+i+" is incompatible with layer "+n.name+": expected shape="+s+", received shape="+a.shape);n.states_[i]=a}}n.states_=n.states_.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})})},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);t=a.inputs,r=a.initialState,i=a.constants;var o=[],s=[];if(null!=r){n.initialState=r,o=o.concat(r),this.stateSpec=[];for(var l=0,u=r;l<u.length;l++){var c=u[l];this.stateSpec.push(new InputSpec({shape:c.shape}))}s=s.concat(this.stateSpec)}if(null!=i&&(n.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof SymbolicTensor){var p=[t].concat(o),h=this.inputSpec.concat(s),d=this.inputSpec;this.inputSpec=h;var f=e.prototype.apply.call(this,p,n);return this.inputSpec=d,f}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;e=getExactlyOneTensor(e),null==a&&(a=n.stateful?n.states_:n.getInitialState(e));var o=Array.isArray(n.cell.stateSize)?n.cell.stateSize.length:1;if(a.length!==o)throw new ValueError("RNN Layer has "+o+" state(s) but was passed "+a.length+" initial state(s).");n.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var s={training:i},l=rnn(function(e,t){var r=n.cell.call([e].concat(t),s);return[r[0],r.slice(1)]},e,a,n.goBackwards,r,null,n.unroll,n.returnSequences),u=l[0],c=l[1],p=l[2];n.stateful&&n.resetStates(p,i);var h=n.returnSequences?c:u;return n.returnState?[h].concat(p):h})},t.prototype.getInitialState=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e.shape);return n=expandDims$1(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(n,[1,2])),Array.isArray(t.cell.stateSize)?t.cell.stateSize.map(function(e){return e>1?tile$1(n,[1,e]):n}):t.cell.stateSize>1?[tile$1(n,[1,t.cell.stateSize])]:[n]})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);var n=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:n};var r=e.prototype.getConfig.call(this);return Object.assign(t,r),t},t.className="RNN",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RNN);var RNNCell=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(Layer),SimpleRNNCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(null==t.activation?n.DEFAULT_ACTIVATION:t.activation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("SimpleRNNCell expects 2 input Tensors, got "+e.length+".");var r=e[1];e=e[0];var i,a=null!=t.training&&t.training;0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,a)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(r)},n.recurrentDropout,a));var o=n.dropoutMask,s=n.recurrentDropoutMask;i=dot(null!=o?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,o):e,n.kernel.read()),null!=n.bias&&(i=biasAdd(i,n.bias.read())),null!=s&&(r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,s));var l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(i,dot(r,n.recurrentKernel.read()));return null!=n.activation&&(l=n.activation.apply(l)),[l,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="SimpleRNNCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNNCell);var SimpleRNN=function(e){function t(t){return t.cell=new SimpleRNNCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.className="SimpleRNN",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNN);var GRUCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+e.length+".");var r=null!=t.training&&t.training,i=e[1];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,3)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,3));var a,o,s,l=n.dropoutMask,u=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,l[0]));var c=dot(e,n.kernel.read());n.useBias&&(c=biasAdd(c,n.bias.read())),0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,u[0]));var p=n.recurrentKernel.read(),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(p,[2*n.units,n.units],p.rank-1),d=h[0],f=h[1],g=dot(i,d),m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(c,3,c.rank-1),y=m[0],v=m[1],b=m[2],w=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(g,2,g.rank-1),z=w[0],S=w[1];a=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(y,z)),o=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(v,S));var I=dot(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,i),f);s=n.activation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(b,I));var A=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(a,i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(a)),s));return[A,A]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="GRUCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRUCell);var GRU=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new GRUCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="GRU",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRU);var LSTMCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=t.unitForgetBias,n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t,n,r=(e=getExactlyOneShape(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;n=new((t=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){var n=i.apply([a]),r=(new Ones).apply([a]),o=i.apply([2*a]);return concatAlongFirstAxis(concatAlongFirstAxis(n,r),o)},t}(Initializer)).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training;if(3!==(e=e).length)throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+e.length+".");var i=e[1],a=e[2];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,4)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,4));var o,s,l,u,c=n.dropoutMask,p=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,c[0]));var h=dot(e,n.kernel.read());0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,p[0])),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(h,dot(i,n.recurrentKernel.read())),n.useBias&&(h=biasAdd(h,n.bias.read()));var d=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(h,4,h.rank-1),f=d[0],g=d[1],m=d[2],y=d[3];o=n.recurrentActivation.apply(f),s=n.recurrentActivation.apply(g),l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,n.activation.apply(m))),u=n.recurrentActivation.apply(y);var v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(u,n.activation.apply(l));return[v,v,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LSTMCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTMCell);var LSTM=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new LSTMCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"unitForgetBias",{get:function(){return this.cell.unitForgetBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="LSTM",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTM);var StackedRNNCells=function(e){function t(t){var n=e.call(this,t)||this;return n.cells=t.cells,n}return __extends(t,e),Object.defineProperty(t.prototype,"stateSize",{get:function(){for(var e=[],t=0,n=this.cells.slice().reverse();t<n.length;t++){var r=n[t];Array.isArray(r.stateSize)?e.push.apply(e,r.stateSize):e.push(r.stateSize)}return e},enumerable:!0,configurable:!0}),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var r=(e=e).slice(1),i=[],a=0,o=n.cells.slice().reverse();a<o.length;a++){var s=o[a];Array.isArray(s.stateSize)?i.push(r.splice(0,s.stateSize.length)):i.push(r.splice(0,1))}i.reverse();for(var l,u=[],c=0;c<n.cells.length;++c){s=n.cells[c];r=i[c],l=0===c?[e[0]].concat(r):[l[0]].concat(r),l=s.call(l,t),u.push(l.slice(1))}r=[];for(var p=0,h=u.slice().reverse();p<h.length;p++){var d=h[p];r.push.apply(r,d)}return[l[0]].concat(r)})},t.prototype.build=function(e){var t;isArrayOfShapes(e)&&(e=e[0]),e=e;for(var n=0,r=this.cells;n<r.length;n++){var i=r[n];i.build(e),t=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],t]}this.built=!0},t.prototype.getConfig=function(){for(var t=[],n=0,r=this.cells;n<r.length;n++){var i=r[n];t.push({className:this.getClassName(),config:i.getConfig()})}var a={cells:t},o=e.prototype.getConfig.call(this);return Object.assign(a,o),a},t.fromConfig=function(e,t,n){void 0===n&&(n={});for(var r=[],i=0,a=t.cells;i<a.length;i++){var o=a[i];r.push(deserialize(o,n))}return new e({cells:r})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.cells;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.weights)}return batchGetValue(e)},t.prototype.setWeights=function(e){for(var t=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,o=e.splice(a),s=0;s<i.weights.length;++s)t.push([i.weights[s],o[s]]);batchSetValue(t)},t.className="StackedRNNCells",t}(RNNCell);function generateDropoutMask(e,t,n,r){function i(){return dropout(e(),t)}if(void 0===n&&(n=null),void 0===r&&(r=1),r>1){for(var a=[],o=0;o<r;o++)a.push(inTrainPhase(i,e,n));return a.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})}return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(inTrainPhase(i,e,n).clone())}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(StackedRNNCells);var Wrapper=function(e){function t(t){var n=e.call(this,t)||this;return n.layer=t.layer,n}return __extends(t,e),t.prototype.build=function(e){this.built=!0},Object.defineProperty(t.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(e){null!=this.layer&&(this.layer.trainable=e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.layer.getWeights()},t.prototype.setWeights=function(e){this.layer.setWeights(e)},t.prototype.getConfig=function(){var t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)},t.fromConfig=function(e,t,n){void 0===n&&(n={});var r=deserialize(t.layer,n);delete t.layer;var i={layer:r};return Object.assign(i,t),new e(i)},t}(Layer),TimeDistributed=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.build=function(t){if((t=getExactlyOneShape(t)).length<3)throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];var n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),e.prototype.build.call(this,t)},t.prototype.computeOutputShape=function(e){var t=[(e=getExactlyOneShape(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return rnn(function(e,r){return[getExactlyOneTensor(n.layer.call(e,t)),[]]},e=getExactlyOneTensor(e),[],!1,null,null,!1,!0)[1]})},t.className="TimeDistributed",t}(Wrapper);function checkBidirectionalMergeMode(e){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TimeDistributed);var DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat",Bidirectional=function(e){function t(t){var n=e.call(this,t)||this,r=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=r,n.forwardLayer=deserialize(i),r.goBackwards=!0!==r.goBackwards;var a={};if(a.className=t.layer.getClassName(),a.config=r,n.backwardLayer=deserialize(a),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,n.mergeMode=void 0===t.mergeMode?DEFAULT_BIDIRECTIONAL_MERGE_MODE:t.mergeMode,checkBidirectionalMergeMode(n.mergeMode),t.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");return n._stateful=t.layer.stateful,n.returnSequences=t.layer.returnSequences,n.returnState=t.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=t.layer.inputSpec,n.numConstants=null,n}return __extends(t,e),Object.defineProperty(t.prototype,"trainable",{get:function(){return this._trainable},set:function(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},t.prototype.setWeights=function(e){var t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))},t.prototype.computeOutputShape=function(e){var t,n,r,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),t=i[0]):t=i[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):singletonOrArray(n)},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);if(t=a.inputs,r=a.initialState,i=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(null==r||0===r.length)&&null==i)return e.prototype.apply.call(this,t,n);var o=[],s=[];if(null!=r){var l=r.length;if(l%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,o.push.apply(o,r);var u=r.map(function(e){return new InputSpec({shape:e.shape})});this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),s.push.apply(s,u)}if(null!=i)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");for(var c=o[0]instanceof SymbolicTensor,p=0,h=o;p<h.length;p++){if(h[p]instanceof SymbolicTensor!==c)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[t].concat(o),f=this.inputSpec.concat(s),g=this.inputSpec;this.inputSpec=f;var m=e.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=t.mask)throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");var r,i,a,o,s=t.initialState;if(null==s)r=n.forwardLayer.call(e,t),i=n.backwardLayer.call(e,t);else{var l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=n.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=n.backwardLayer.call(e,Object.assign(t,{initialState:u}))}return n.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),n.returnSequences&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,1)),"concat"===n.mergeMode?o=concatenate([r,i]):"sum"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i):"ave"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i)):"mul"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,i):null==n.mergeMode&&(o=[r,i]),n.returnState?null==n.mergeMode?o.concat(a):[o].concat(a):o})},t.prototype.resetStates=function(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},t.prototype.build=function(e){var t=this;nameScope(this.forwardLayer.name,function(){t.forwardLayer.build(e)}),nameScope(this.backwardLayer.name,function(){t.backwardLayer.build(e)}),this.built=!0},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={mergeMode:this.mergeMode},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.fromConfig=function(e,t){var n=deserialize(t.layer);if(delete t.layer,null!=t.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=t;return r.layer=n,new e(r)},t.className="Bidirectional",t}(Wrapper);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Bidirectional);var GaussianNoise=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.stddev=t.stddev,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={stddev:this.stddev};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return inTrainPhase(function(){return randomNormal$1(r.shape,0,n.stddev).add(r)},function(){return r},t.training||!1)})},t.className="GaussianNoise",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianNoise);var GaussianDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(n.rate>0&&n.rate<1){return inTrainPhase(function(){var e=Math.sqrt(n.rate/(1-n.rate));return dot(r,randomNormal$1(r.shape,1,e))},function(){return r},t.training||!1)}return r})},t.className="GaussianDropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianDropout);var AlphaDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n.noiseShape=t.noiseShape,n}return __extends(t,e),t.prototype._getNoiseShape=function(e){return this.noiseShape||getExactlyOneTensor(e).shape},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n.rate<1&&n.rate>0){var r=n._getNoiseShape(e);return inTrainPhase(function(){var t=getExactlyOneTensor(e),i=-1.7580993408473766,a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(r),n.rate);a=cast$1(a,"float32");var o=Math.pow((1-n.rate)*(1+n.rate*Math.pow(i,2)),-.5),s=-o*i*n.rate;return dot(t,a).add(a.add(-1).mul(i)).mul(o).add(s)},function(){return getExactlyOneTensor(e)},t.training||!1)}return e})},t.className="AlphaDropout",t}(Layer);function inputLayer(e){return new InputLayer(e)}function elu$2(e){return new ELU(e)}function reLU(e){return new ReLU(e)}function leakyReLU(e){return new LeakyReLU(e)}function prelu$1(e){return new PReLU(e)}function softmax$1(e){return new Softmax$1(e)}function thresholdedReLU(e){return new ThresholdedReLU(e)}function conv1d$2(e){return new Conv1D(e)}function conv2d$2(e){return new Conv2D(e)}function conv2dTranspose$1(e){return new Conv2DTranspose(e)}function conv3d$2(e){return new Conv3D(e)}function separableConv2d$1(e){return new SeparableConv2D(e)}function cropping2D(e){return new Cropping2D(e)}function upSampling2d(e){return new UpSampling2D(e)}function depthwiseConv2d$2(e){return new DepthwiseConv2D(e)}function activation(e){return new Activation$1(e)}function dense(e){return new Dense(e)}function dropout$1(e){return new Dropout(e)}function flatten$1(e){return new Flatten(e)}function repeatVector(e){return new RepeatVector(e)}function reshape(e){return new Reshape(e)}function permute(e){return new Permute(e)}function embedding(e){return new Embedding(e)}function add$2(e){return new Add(e)}function average$1(e){return new Average(e)}function concatenate$2(e){return new Concatenate(e)}function maximum$2(e){return new Maximum(e)}function minimum$2(e){return new Minimum(e)}function multiply$1(e){return new Multiply(e)}function dot$1(e){return new Dot(e)}function batchNormalization$1(e){return new BatchNormalization(e)}function zeroPadding2d(e){return new ZeroPadding2D(e)}function averagePooling1d(e){return new AveragePooling1D(e)}function avgPool1d(e){return averagePooling1d(e)}function avgPooling1d(e){return averagePooling1d(e)}function averagePooling2d(e){return new AveragePooling2D(e)}function avgPool2d(e){return averagePooling2d(e)}function avgPooling2d(e){return averagePooling2d(e)}function globalAveragePooling1d(e){return new GlobalAveragePooling1D(e)}function globalAveragePooling2d(e){return new GlobalAveragePooling2D(e)}function globalMaxPooling1d(e){return new GlobalMaxPooling1D(e)}function globalMaxPooling2d(e){return new GlobalMaxPooling2D(e)}function maxPooling1d(e){return new MaxPooling1D(e)}function maxPooling2d(e){return new MaxPooling2D(e)}function gru(e){return new GRU(e)}function gruCell(e){return new GRUCell(e)}function lstm(e){return new LSTM(e)}function lstmCell(e){return new LSTMCell(e)}function simpleRNN(e){return new SimpleRNN(e)}function simpleRNNCell(e){return new SimpleRNNCell(e)}function rnn$1(e){return new RNN(e)}function stackedRNNCells(e){return new StackedRNNCells(e)}function bidirectional(e){return new Bidirectional(e)}function timeDistributed(e){return new TimeDistributed(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AlphaDropout);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d;function gaussianNoise(e){return new GaussianNoise(e)}function gaussianDropout(e){return new GaussianDropout(e)}function alphaDropout(e){return new AlphaDropout(e)}function masking(e){return new Masking(e)}var exports_layers=Object.freeze({inputLayer:inputLayer,elu:elu$2,reLU:reLU,leakyReLU:leakyReLU,prelu:prelu$1,softmax:softmax$1,thresholdedReLU:thresholdedReLU,conv1d:conv1d$2,conv2d:conv2d$2,conv2dTranspose:conv2dTranspose$1,conv3d:conv3d$2,separableConv2d:separableConv2d$1,cropping2D:cropping2D,upSampling2d:upSampling2d,depthwiseConv2d:depthwiseConv2d$2,activation:activation,dense:dense,dropout:dropout$1,flatten:flatten$1,repeatVector:repeatVector,reshape:reshape,permute:permute,embedding:embedding,add:add$2,average:average$1,concatenate:concatenate$2,maximum:maximum$2,minimum:minimum$2,multiply:multiply$1,dot:dot$1,batchNormalization:batchNormalization$1,zeroPadding2d:zeroPadding2d,averagePooling1d:averagePooling1d,avgPool1d:avgPool1d,avgPooling1d:avgPooling1d,averagePooling2d:averagePooling2d,avgPool2d:avgPool2d,avgPooling2d:avgPooling2d,globalAveragePooling1d:globalAveragePooling1d,globalAveragePooling2d:globalAveragePooling2d,globalMaxPooling1d:globalMaxPooling1d,globalMaxPooling2d:globalMaxPooling2d,maxPooling1d:maxPooling1d,maxPooling2d:maxPooling2d,gru:gru,gruCell:gruCell,lstm:lstm,lstmCell:lstmCell,simpleRNN:simpleRNN,simpleRNNCell:simpleRNNCell,rnn:rnn$1,stackedRNNCells:stackedRNNCells,bidirectional:bidirectional,timeDistributed:timeDistributed,globalMaxPool1d:globalMaxPool1d,globalMaxPool2d:globalMaxPool2d,maxPool1d:maxPool1d,maxPool2d:maxPool2d,Layer:Layer,RNN:RNN,RNNCell:RNNCell,input:input,gaussianNoise:gaussianNoise,gaussianDropout:gaussianDropout,alphaDropout:alphaDropout,masking:masking});function binaryAccuracy$1(e,t){return binaryAccuracy(e,t)}function binaryCrossentropy$2(e,t){return binaryCrossentropy$1(e,t)}function sparseCategoricalAccuracy$1(e,t){return sparseCategoricalAccuracy(e,t)}function categoricalAccuracy$1(e,t){return categoricalAccuracy(e,t)}function categoricalCrossentropy$2(e,t){return categoricalCrossentropy$1(e,t)}function precision$1(e,t){return precision(e,t)}function recall$1(e,t){return recall(e,t)}function cosineProximity$1(e,t){return cosineProximity(e,t)}function meanAbsoluteError$1(e,t){return meanAbsoluteError(e,t)}function meanAbsolutePercentageError$1(e,t){return meanAbsolutePercentageError(e,t)}function MAPE$2(e,t){return meanAbsolutePercentageError(e,t)}function mape$2(e,t){return meanAbsolutePercentageError(e,t)}function meanSquaredError$1(e,t){return meanSquaredError(e,t)}function MSE$2(e,t){return meanSquaredError(e,t)}function mse$2(e,t){return meanSquaredError(e,t)}var exports_metrics=Object.freeze({binaryAccuracy:binaryAccuracy$1,binaryCrossentropy:binaryCrossentropy$2,sparseCategoricalAccuracy:sparseCategoricalAccuracy$1,categoricalAccuracy:categoricalAccuracy$1,categoricalCrossentropy:categoricalCrossentropy$2,precision:precision$1,recall:recall$1,cosineProximity:cosineProximity$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,MAPE:MAPE$2,mape:mape$2,meanSquaredError:meanSquaredError$1,MSE:MSE$2,mse:mse$2}),exports_models=Object.freeze({modelFromJSON:modelFromJSON});function l1l2(e){return new L1L2(e)}function l1$1(e){return l1(e)}function l2$1(e){return l2(e)}var exports_regularizers=Object.freeze({l1l2:l1l2,l1:l1$1,l2:l2$1}),Callback=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.model=null,t}return __extends(t,e),t.prototype.setModel=function(e){if(!(e instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=e},t}(BaseCallback);function less(e,t){return e<t}function greater$1(e,t){return e>t}var EarlyStopping=function(e){function t(t){var n=e.call(this)||this;if(null==t&&(t={}),t.restoreBestWeights)throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");return n.monitor=t.monitor||"val_loss",n.minDelta=Math.abs(t.minDelta||0),n.patience=t.patience||0,n.verbose=t.verbose||0,n.mode=t.mode||"auto",n.baseline=t.baseline,-1===["auto","min","max"].indexOf(n.mode)&&(console.warn("EarlyStopping mode '"+n.mode+"' is invalid. Falling back to mode 'auto'."),n.mode="auto"),"min"===n.mode?n.monitorFunc=less:"max"===n.mode?n.monitorFunc=greater$1:-1!==n.monitor.indexOf("acc")?n.monitorFunc=greater$1:n.monitorFunc=less,n.monitorFunc===less&&(n.minDelta*=-1),n}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===less?1/0:-1/0,[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return[4,resolveScalarsInLogs(t)];case 1:return r.sent(),null==(n=this.getMonitorValue(t))?[2]:(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)),[2])}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.stoppedEpoch>0&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping."),[2]})})},t.prototype.getMonitorValue=function(e){null==e&&(e={});var t=e[this.monitor];return null==t&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(e)),t},t}(Callback);function earlyStopping(e){return new EarlyStopping(e)}var callbacks={earlyStopping:earlyStopping};
//# sourceMappingURL=tf-layers.esm.js.map


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs/dist/tf.esm.js ***!
  \******************************************************/
/*! exports provided: data, version, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike, constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers, GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version$1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdadeltaOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdagradOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamaxOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["DataStorage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["KernelBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["MomentumOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["RMSPropOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Rank"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Reduction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["SGDOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["TensorBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["basicLSTMCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["complex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dDerFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cumsum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["customGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disableDeprecationWarnings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disposeVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "div", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["divStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dropout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableDebugMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equalStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackendFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["getBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hammingWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hannWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["imag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "io", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isFinite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isInf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isNaN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "less", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSumExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalXor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["losses"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["math"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["modStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multiRNNCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multinomial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["norm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "op", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["op"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["outerProduct"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["powStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["print"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["profile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ready"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["real"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["registerBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["removeBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "round", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "square", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifferenceStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "step", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["subStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor5d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor6d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["test_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "time", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "train", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unsortedSegmentSum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variableGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["webgl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"]; });

/* harmony import */ var _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-layers */ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["constraints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["initializers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["layers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["metrics"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "models", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["models"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["regularizers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CallbackList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CustomCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "History", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["History"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Callback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["callbacks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["EarlyStopping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["InputSpec"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["SymbolicTensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "input", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["input"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["loadLayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "model", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["registerCallbackConstructor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["RNN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayerVariable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"]; });

/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["GraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["loadGraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"]; });

/* harmony import */ var _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tensorflow/tfjs-data */ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "data", function() { return _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__; });
// @tensorflow/tfjs Copyright 2019 Google
var version="1.1.2",version$1={"tfjs-core":_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"],"tfjs-data":_tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__["version_data"],"tfjs-layers":_tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"],"tfjs-converter":_tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"],tfjs:version};
//# sourceMappingURL=tf.esm.js.map


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

asn1.define = __webpack_require__(/*! ./asn1/api */ "./node_modules/asn1.js/lib/asn1/api.js").define;
asn1.base = __webpack_require__(/*! ./asn1/base */ "./node_modules/asn1.js/lib/asn1/base/index.js");
asn1.constants = __webpack_require__(/*! ./asn1/constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ "./node_modules/asn1.js/lib/asn1/decoders/index.js");
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ "./node_modules/asn1.js/lib/asn1/encoders/index.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(/*! vm */ "./node_modules/vm-browserify/index.js").runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(/*! ./reporter */ "./node_modules/asn1.js/lib/asn1/base/reporter.js").Reporter;
base.DecoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").DecoderBuffer;
base.EncoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").EncoderBuffer;
base.Node = __webpack_require__(/*! ./node */ "./node_modules/asn1.js/lib/asn1/base/node.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var EncoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").EncoderBuffer;
var DecoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").DecoderBuffer;
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(/*! ../constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/constants/der.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");
decoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/decoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var DERDecoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");
encoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/encoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var DEREncoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(/*! buffer */ 3).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 4);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var GHASH = __webpack_require__(/*! ./ghash */ "./node_modules/browserify-aes/ghash.js")
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var incr32 = __webpack_require__(/*! ./incr32 */ "./node_modules/browserify-aes/incr32.js")

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(/*! ./encrypter */ "./node_modules/browserify-aes/encrypter.js")
var deciphers = __webpack_require__(/*! ./decrypter */ "./node_modules/browserify-aes/decrypter.js")
var modes = __webpack_require__(/*! ./modes/list.json */ "./node_modules/browserify-aes/modes/list.json")

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var incr32 = __webpack_require__(/*! ../incr32 */ "./node_modules/browserify-aes/incr32.js")

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ "./node_modules/browserify-aes/modes/ecb.js"),
  CBC: __webpack_require__(/*! ./cbc */ "./node_modules/browserify-aes/modes/cbc.js"),
  CFB: __webpack_require__(/*! ./cfb */ "./node_modules/browserify-aes/modes/cfb.js"),
  CFB8: __webpack_require__(/*! ./cfb8 */ "./node_modules/browserify-aes/modes/cfb8.js"),
  CFB1: __webpack_require__(/*! ./cfb1 */ "./node_modules/browserify-aes/modes/cfb1.js"),
  OFB: __webpack_require__(/*! ./ofb */ "./node_modules/browserify-aes/modes/ofb.js"),
  CTR: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js"),
  GCM: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js")
}

var modes = __webpack_require__(/*! ./list.json */ "./node_modules/browserify-aes/modes/list.json")

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

module.exports = {"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}};

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(/*! browserify-des */ "./node_modules/browserify-des/index.js")
var aes = __webpack_require__(/*! browserify-aes/browser */ "./node_modules/browserify-aes/browser.js")
var aesModes = __webpack_require__(/*! browserify-aes/modes */ "./node_modules/browserify-aes/modes/index.js")
var desModes = __webpack_require__(/*! browserify-des/modes */ "./node_modules/browserify-des/modes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var des = __webpack_require__(/*! des.js */ "./node_modules/des.js/lib/des.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./browser/algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")


/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var sign = __webpack_require__(/*! ./sign */ "./node_modules/browserify-sign/browser/sign.js")
var verify = __webpack_require__(/*! ./verify */ "./node_modules/browserify-sign/browser/verify.js")

var algorithms = __webpack_require__(/*! ./algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Legacy = __webpack_require__(/*! ./legacy */ "./node_modules/create-hmac/legacy.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")

var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")

var algos = __webpack_require__(/*! browserify-sign/algos */ "./node_modules/browserify-sign/algos.js")
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(/*! browserify-cipher */ "./node_modules/browserify-cipher/browser.js")

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(/*! diffie-hellman */ "./node_modules/diffie-hellman/browser.js")

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(/*! browserify-sign */ "./node_modules/browserify-sign/browser/index.js")

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(/*! create-ecdh */ "./node_modules/create-ecdh/browser.js")

var publicEncrypt = __webpack_require__(/*! public-encrypt */ "./node_modules/public-encrypt/browser.js")

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(/*! randomfill */ "./node_modules/randomfill/browser.js")

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ "./node_modules/des.js/lib/des/utils.js");
exports.Cipher = __webpack_require__(/*! ./des/cipher */ "./node_modules/des.js/lib/des/cipher.js");
exports.DES = __webpack_require__(/*! ./des/des */ "./node_modules/des.js/lib/des/des.js");
exports.CBC = __webpack_require__(/*! ./des/cbc */ "./node_modules/des.js/lib/des/cbc.js");
exports.EDE = __webpack_require__(/*! ./des/ede */ "./node_modules/des.js/lib/des/ede.js");


/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js")
var primes = __webpack_require__(/*! ./lib/primes.json */ "./node_modules/diffie-hellman/lib/primes.json")

var DH = __webpack_require__(/*! ./lib/dh */ "./node_modules/diffie-hellman/lib/dh.js")

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/elliptic/lib/elliptic.js");

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/hmac-drbg/lib/hmac-drbg.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: _args, _development, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = {"_args":[["elliptic@6.4.1","/Users/joeyklee/Cosmos/src/github/joeyklee/magenta-js/sketch"]],"_development":true,"_from":"elliptic@6.4.1","_id":"elliptic@6.4.1","_inBundle":false,"_integrity":"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"elliptic@6.4.1","name":"elliptic","escapedName":"elliptic","rawSpec":"6.4.1","saveSpec":null,"fetchSpec":"6.4.1"},"_requiredBy":["/browserify-sign","/create-ecdh"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz","_spec":"6.4.1","_where":"/Users/joeyklee/Cosmos/src/github/joeyklee/magenta-js/sketch","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"description":"EC cryptography","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.4.1"};

/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var brorand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/timers-browserify/main.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"};

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

exports.certificate = __webpack_require__(/*! ./certificate */ "./node_modules/parse-asn1/certificate.js")

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ./asn1 */ "./node_modules/parse-asn1/asn1.js")
var aesid = __webpack_require__(/*! ./aesid.json */ "./node_modules/parse-asn1/aesid.json")
var fixProc = __webpack_require__(/*! ./fixProc */ "./node_modules/parse-asn1/fixProc.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var compat = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/pbkdf2/lib/async.js")
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/pbkdf2/lib/sync-browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ "./node_modules/public-encrypt/publicEncrypt.js")
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ "./node_modules/public-encrypt/privateDecrypt.js")

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 1);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 2);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough


/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform


/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");


/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/core/sketch_support.ts":
/*!************************************!*\
  !*** ./src/core/sketch_support.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function stringToUint8array(b64encoded) {
    var u8 = new Uint8Array(atob(b64encoded)
        .split("")
        .map(function (c) {
        return c.charCodeAt(0);
    }));
    return u8;
}
exports.stringToUint8array = stringToUint8array;
function stringToArray(b64encoded) {
    var u = stringToUint8array(b64encoded);
    var result = new Int16Array(u.buffer);
    return result;
}
exports.stringToArray = stringToArray;
var returnV = false;
var vVal = 0.0;
function gaussRandom() {
    if (returnV) {
        returnV = false;
        return vVal;
    }
    var u = 2 * Math.random() - 1;
    var v = 2 * Math.random() - 1;
    var r = u * u + v * v;
    if (r === 0 || r > 1) {
        return gaussRandom();
    }
    var c = Math.sqrt(-2 * Math.log(r) / r);
    vVal = v * c;
    returnV = true;
    return u * c;
}
exports.gaussRandom = gaussRandom;
function randf(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randf = randf;
function randi(a, b) {
    return Math.floor(Math.random() * (b - a) + a);
}
exports.randi = randi;
function randn(mu, std) {
    return mu + gaussRandom() * std;
}
exports.randn = randn;
function birandn(mu1, mu2, std1, std2, rho) {
    var z1 = randn(0, 1);
    var z2 = randn(0, 1);
    var x = Math.sqrt(1 - rho * rho) * std1 * z1 + rho * std1 * z2 + mu1;
    var y = std2 * z2 + mu2;
    return [x, y];
}
exports.birandn = birandn;
function sampleSoftmax(zSample) {
    var x = randf(0, 1);
    var N = zSample.length;
    var accumulate = 0;
    var i;
    for (i = 0; i < N; i++) {
        accumulate += zSample[i];
        if (accumulate >= x) {
            return i;
        }
    }
    console.log('error sampling pi index');
    return -1;
}
exports.sampleSoftmax = sampleSoftmax;
function simplifyLine(V, tolerance) {
    if (tolerance === void 0) { tolerance = 2.0; }
    var tol = tolerance;
    function diff(u, v) {
        return [u[0] - v[0], u[1] - v[1]];
    }
    function dot(u, v) {
        return u[0] * v[0] + u[1] * v[1];
    }
    function norm2(v) {
        return v[0] * v[0] + v[1] * v[1];
    }
    function d2(u, v) { return norm2(diff(u, v)); }
    function simplifyDP(tol, v, j, k, mk) {
        if (k <= j + 1) {
            return;
        }
        var maxi = j;
        var maxd2 = 0;
        var tol2 = tol * tol;
        var S = [v[j], v[k]];
        var u = diff(S[1], S[0]);
        var cu = norm2(u);
        var w;
        var pb;
        var b, cw, dv2;
        for (var i_1 = j + 1; i_1 < k; i_1++) {
            w = diff(v[i_1], S[0]);
            cw = dot(w, u);
            if (cw <= 0) {
                dv2 = d2(v[i_1], S[0]);
            }
            else if (cu <= cw) {
                dv2 = d2(v[i_1], S[1]);
            }
            else {
                b = cw / cu;
                pb = [S[0][0] + b * u[0], S[0][1] + b * u[1]];
                dv2 = d2(v[i_1], pb);
            }
            if (dv2 <= maxd2) {
                continue;
            }
            maxi = i_1;
            maxd2 = dv2;
        }
        if (maxd2 > tol2) {
            mk[maxi] = 1;
            simplifyDP(tol, v, j, maxi, mk);
            simplifyDP(tol, v, maxi, k, mk);
        }
        return;
    }
    var n = V.length;
    var sV = [];
    var i, k, m, pv;
    var tol2 = tol * tol;
    var vt = [];
    var mk = [];
    vt[0] = V[0];
    for (i = k = 1, pv = 0; i < n; i++) {
        if (d2(V[i], V[pv]) < tol2) {
            continue;
        }
        vt[k++] = V[i];
        pv = i;
    }
    if (pv < n - 1) {
        vt[k++] = V[n - 1];
    }
    mk[0] = mk[k - 1] = 1;
    simplifyDP(tol, vt, 0, k - 1, mk);
    for (i = m = 0; i < k; i++) {
        if (mk[i]) {
            sV[m++] = vt[i];
        }
    }
    return sV;
}
exports.simplifyLine = simplifyLine;
function simplifyLines(lines, tolerance) {
    var result = [];
    var tol = 2.0;
    if (tolerance) {
        tol = tolerance;
    }
    for (var i = 0; i < lines.length; i++) {
        result.push(simplifyLine(lines[i], tol));
    }
    return result;
}
exports.simplifyLines = simplifyLines;
function linesToStrokes(rawData) {
    var x, y;
    var px = 0, py = 0;
    var dx, dy;
    var pon, poff;
    var stroke = [];
    var i, j;
    var len;
    var p;
    for (i = 0; i < rawData.length; i++) {
        len = rawData[i].length;
        if (len > 1) {
            for (j = 0; j < len; j++) {
                p = rawData[i][j];
                x = p[0];
                y = p[1];
                if (j === len - 1) {
                    poff = 1;
                    pon = 0;
                }
                else {
                    poff = 0;
                    pon = 1;
                }
                dx = x - px;
                dy = y - py;
                px = x;
                py = y;
                stroke.push([dx, dy, pon, poff, 0]);
            }
        }
    }
    stroke.push([0, 0, 0, 0, 1]);
    return stroke.slice(1);
}
exports.linesToStrokes = linesToStrokes;
function lineToStroke(line, lastPoint) {
    var pon, poff;
    var stroke = [];
    var len;
    var p;
    var dx, dy;
    var x, y;
    var px, py;
    var j;
    px = lastPoint[0];
    py = lastPoint[1];
    len = line.length;
    if (len > 1) {
        for (j = 0; j < len; j++) {
            p = line[j];
            x = p[0];
            y = p[1];
            if (j === len - 1) {
                poff = 1;
                pon = 0;
            }
            else {
                poff = 0;
                pon = 1;
            }
            dx = x - px;
            dy = y - py;
            px = x;
            py = y;
            stroke.push([dx, dy, pon, poff, 0]);
        }
    }
    return stroke;
}
exports.lineToStroke = lineToStroke;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs */ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js");
exports.tf = tf;
__export(__webpack_require__(/*! ./sketch_rnn */ "./src/sketch_rnn/index.ts"));


/***/ }),

/***/ "./src/sketch_rnn/index.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = __webpack_require__(/*! ./model */ "./src/sketch_rnn/model.ts");
exports.SketchRNN = model_1.SketchRNN;


/***/ }),

/***/ "./src/sketch_rnn/model.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/model.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
var support = __webpack_require__(/*! ../core/sketch_support */ "./src/core/sketch_support.ts");
var SketchRNN = (function () {
    function SketchRNN(checkpointURL) {
        this.NMIXTURE = 20;
        this.checkpointURL = checkpointURL;
        this.initialized = false;
    }
    SketchRNN.prototype.isInitialized = function () {
        return this.initialized;
    };
    SketchRNN.prototype.instantiateFromJSON = function (info, weightDims, weightStrings) {
        this.forgetBias = tf.scalar(1.0);
        this.info = info;
        this.setPixelFactor(2.0);
        this.weightDims = weightDims;
        this.numUnits = this.weightDims[0][0];
        var rawWeights;
        var maxWeight = 10.0;
        this.weights = [];
        for (var i = 0; i < weightStrings.length; i++) {
            rawWeights = new Float32Array(support.stringToArray(weightStrings[i]));
            var N = rawWeights.length;
            for (var j = 0; j < N; j++) {
                rawWeights[j] = maxWeight * rawWeights[j] / 32767;
            }
            this.weights.push(rawWeights);
        }
        this.outputKernel = tf.tensor2d(this.weights[0], [this.weightDims[0][0], this.weightDims[0][1]]);
        this.outputBias = tf.tensor1d(this.weights[1]);
        var lstmKernelXH = tf.tensor2d(this.weights[2], [this.weightDims[2][0], this.weightDims[2][1]]);
        var lstmKernelHH = tf.tensor2d(this.weights[3], [this.weightDims[3][0], this.weightDims[3][1]]);
        var axis = 0;
        this.lstmKernel = tf.concat2d([lstmKernelXH, lstmKernelHH], axis);
        this.lstmBias = tf.tensor1d(this.weights[4]);
        this.rawVars = [
            this.outputKernel,
            this.outputBias,
            this.lstmKernel,
            this.lstmBias
        ];
    };
    SketchRNN.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var vars;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.dispose();
                        return [4, fetch(this.checkpointURL)
                                .then(function (response) { return response.json(); })];
                    case 1:
                        vars = _a.sent();
                        this.instantiateFromJSON(vars[0], vars[1], vars[2]);
                        this.initialized = true;
                        console.log('Initialized SketchRNN.');
                        return [2];
                }
            });
        });
    };
    SketchRNN.prototype.dispose = function () {
        if (this.rawVars) {
            for (var i = 0; i < this.rawVars.length; i++) {
                this.rawVars[i].dispose();
            }
            this.rawVars = undefined;
        }
        if (this.forgetBias) {
            this.forgetBias.dispose();
            this.forgetBias = undefined;
        }
        this.initialized = false;
    };
    SketchRNN.prototype.setPixelFactor = function (scale) {
        this.pixelFactor = scale;
        this.scaleFactor = this.info.scale_factor / this.pixelFactor;
    };
    SketchRNN.prototype.update = function (stroke, state) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke = [stroke[0] / s, stroke[1] / s, stroke[2], stroke[3], stroke[4]];
            var x = tf.tensor2d(normStroke, [1, 5]);
            var c = tf.tensor2d(state.c, [1, numUnits]);
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.updateStrokes = function (strokes, state, steps) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke;
            var x;
            var c;
            var h;
            var newState;
            var numSteps = strokes.length;
            if (steps) {
                numSteps = steps;
            }
            c = tf.tensor2d(state.c, [1, numUnits]);
            h = tf.tensor2d(state.h, [1, numUnits]);
            for (var i = 0; i < numSteps; i++) {
                normStroke = [strokes[i][0] / s,
                    strokes[i][1] / s,
                    strokes[i][2],
                    strokes[i][3],
                    strokes[i][4]];
                x = tf.tensor2d(normStroke, [1, 5]);
                newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
                c = newState[0];
                h = newState[1];
            }
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.getPDF = function (state, temperature, softmaxTemperature) {
        var _this = this;
        if (temperature === void 0) { temperature = 0.65; }
        var temp = temperature;
        var discreteTemp = 0.5 + temp * 0.5;
        if (softmaxTemperature) {
            discreteTemp = softmaxTemperature;
        }
        var NOUT = this.NMIXTURE;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var sqrttemp = tf.scalar(Math.sqrt(temp));
            var softtemp = tf.scalar(discreteTemp);
            var z = tf.add(tf.matMul(h, _this.outputKernel), _this.outputBias)
                .squeeze();
            var _a = tf.split(z, [3, NOUT * 6]), rawPen = _a[0], rst = _a[1];
            var _b = tf.split(rst, 6), rawPi = _b[0], mu1 = _b[1], mu2 = _b[2], rawSigma1 = _b[3], rawSigma2 = _b[4], rawCorr = _b[5];
            var pen = tf.softmax(rawPen.div(softtemp));
            var pi = tf.softmax(rawPi.div(softtemp));
            var sigma1 = tf.exp(rawSigma1).mul(sqrttemp);
            var sigma2 = tf.exp(rawSigma2).mul(sqrttemp);
            var corr = tf.tanh(rawCorr);
            var result = [pi, mu1, mu2, sigma1, sigma2, corr, pen];
            return tf.concat(result);
        });
        var result = out.dataSync();
        out.dispose();
        var pdf = {
            pi: new Float32Array(result.slice(0, NOUT)),
            muX: new Float32Array(result.slice(1 * NOUT, 2 * NOUT)),
            muY: new Float32Array(result.slice(2 * NOUT, 3 * NOUT)),
            sigmaX: new Float32Array(result.slice(3 * NOUT, 4 * NOUT)),
            sigmaY: new Float32Array(result.slice(4 * NOUT, 15 * NOUT)),
            corr: new Float32Array(result.slice(5 * NOUT, 6 * NOUT)),
            pen: new Float32Array(result.slice(6 * NOUT, 6 * NOUT + 3))
        };
        return pdf;
    };
    SketchRNN.prototype.zeroState = function () {
        var result = {
            c: new Float32Array(this.numUnits),
            h: new Float32Array(this.numUnits)
        };
        return result;
    };
    SketchRNN.prototype.copyState = function (rnnState) {
        var result = {
            c: new Float32Array(rnnState.c),
            h: new Float32Array(rnnState.h)
        };
        return result;
    };
    SketchRNN.prototype.zeroInput = function () {
        return [0, 0, 1, 0, 0];
    };
    SketchRNN.prototype.sample = function (pdf) {
        var idx = support.sampleSoftmax(pdf.pi);
        var mu1 = pdf.muX[idx];
        var mu2 = pdf.muY[idx];
        var sigma1 = pdf.sigmaX[idx];
        var sigma2 = pdf.sigmaY[idx];
        var corr = pdf.corr[idx];
        var penIdx = support.sampleSoftmax(pdf.pen);
        var penstate = [0, 0, 0];
        penstate[penIdx] = 1;
        var delta = support.birandn(mu1, mu2, sigma1, sigma2, corr);
        var stroke = [
            delta[0] * this.scaleFactor,
            delta[1] * this.scaleFactor,
            penstate[0],
            penstate[1],
            penstate[2]
        ];
        return stroke;
    };
    SketchRNN.prototype.simplifyLine = function (line, tolerance) {
        return support.simplifyLine(line, tolerance);
    };
    SketchRNN.prototype.simplifyLines = function (lines, tolerance) {
        return support.simplifyLines(lines, tolerance);
    };
    SketchRNN.prototype.linesToStroke = function (lines) {
        return support.linesToStrokes(lines);
    };
    SketchRNN.prototype.lineToStroke = function (line, lastPoint) {
        return support.lineToStroke(line, lastPoint);
    };
    return SketchRNN;
}());
exports.SketchRNN = SketchRNN;


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!********************************!*\
  !*** string_decoder (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZGVtb3Mvc2ltcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L3RmLWNvbnZlcnRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RmLWNvcmUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWRhdGEvZGlzdC90Zi1kYXRhLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC90Zi1sYXllcnMuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzL2Rpc3QvdGYuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL3JlcG9ydGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Flcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZGVjcnlwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9pbmNyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NiYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmI4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL29mYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci92ZXJpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci14b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvbGVnYWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2NiYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2VkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9kaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvc2hvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Eva2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Evc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjI0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzM4NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvNTEyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2htYWMtZHJiZy9saWIvaG1hYy1kcmJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZDUuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYXNuMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9jZXJ0aWZpY2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9kZWZhdWx0LWVuY29kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvbGliL3ByZWNvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9zeW5jLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L21nZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHJpdmF0ZURlY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3hvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tZmlsbC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3NrZXRjaF9zdXBwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2tldGNoX3Jubi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2tldGNoX3Jubi9tb2RlbC50cyIsIndlYnBhY2s6Ly8vbm9kZS1mZXRjaCAoaWdub3JlZCk/ZWZkMiIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpPzZhM2YiLCJ3ZWJwYWNrOi8vL2J1ZmZlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL25vZGUtZmV0Y2ggKGlnbm9yZWQpIiwid2VicGFjazovLy9zdHJpbmdfZGVjb2RlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2ZzIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQzs7QUFFbkM7QUFDQSxpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCOztBQUVBLGFBQWE7QUFDYixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5Qixl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QixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLDRCQUE0QixVQUFVLFdBQVcsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixVQUFVLDBEQUEwRCxFQUFFLDBEQUEwRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLHVFQUF1RSxFQUFFLHVFQUF1RSxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUs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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDem5CQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hIQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFPOzs7Ozs7Ozs7Ozs7QUNsQi9CLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsV0FBVyxtQkFBTyxDQUFDLHNEQUFZO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGVBQVE7QUFDN0IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUErQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCOzs7Ozs7Ozs7Ozs7O0FDbDJHaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFhhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxRUFBVTtBQUM5QixlQUFlLG1CQUFPLENBQUMsK0RBQWdCO0FBQ3ZDLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hiYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsa0VBQVE7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4NkJhOztBQUViOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxtREFBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsNERBQWE7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEhhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTzs7QUFFeEIsZUFBZSxtQkFBTyxDQUFDLCtEQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0Qiw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsaUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsbURBQVM7O0FBRTVCLHNCQUFzQixtQkFBTyxDQUFDLCtEQUFlOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pIRDtB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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQsaUVBQWlFO0FBQ3BIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyw4RUFBUTtBQUN6QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUZBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFnQzs7QUFFN0Q7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5SGE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUEsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeklBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDSUEsU0FBZ0Isa0JBQWtCLENBQUMsVUFBa0I7SUFDbkQsSUFBTSxFQUFFLEdBQWUsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUNuRCxLQUFLLENBQUMsRUFBRSxDQUFDO1NBQ1QsR0FBRyxDQUFDLFVBQUMsQ0FBUztRQUNiLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ04sT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBUEQsZ0RBT0M7QUFRRCxTQUFnQixhQUFhLENBQUMsVUFBa0I7SUFDOUMsSUFBTSxDQUFDLEdBQWUsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBTSxNQUFNLEdBQWUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3BELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFKRCxzQ0FJQztBQUtELElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNwQixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7QUFDZixTQUFnQixXQUFXO0lBQ3pCLElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sV0FBVyxFQUFFLENBQUM7S0FDdEI7SUFDRCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDYixPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsQ0FBQztBQWZELGtDQWVDO0FBQ0QsU0FBZ0IsS0FBSyxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQ3hDLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBRkQsc0JBRUM7QUFDRCxTQUFnQixLQUFLLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDeEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBRkQsc0JBRUM7QUFDRCxTQUFnQixLQUFLLENBQUMsRUFBVSxFQUFFLEdBQVc7SUFDM0MsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBQ2xDLENBQUM7QUFGRCxzQkFFQztBQUVELFNBQWdCLE9BQU8sQ0FDckIsR0FBVyxFQUNYLEdBQVcsRUFDWCxJQUFZLEVBQ1osSUFBWSxFQUNaLEdBQVc7SUFDWCxJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ3ZFLElBQU0sQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDaEIsQ0FBQztBQVhELDBCQVdDO0FBS0QsU0FBZ0IsYUFBYSxDQUFDLE9BQWdDO0lBQzVELElBQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEIsSUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUN6QixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDbkIsSUFBSSxDQUFTLENBQUM7SUFDZCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN0QixVQUFVLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLElBQUksVUFBVSxJQUFJLENBQUMsRUFBRTtZQUNuQixPQUFPLENBQUMsQ0FBQztTQUNWO0tBQ0Y7SUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDdkMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUM7QUFiRCxzQ0FhQztBQUlELFNBQWdCLFlBQVksQ0FBQyxDQUFhLEVBQUUsU0FBYTtJQUFiLDJDQUFhO0lBZXZELElBQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQztJQUV0QixTQUFTLElBQUksQ0FBQyxDQUFXLEVBQUUsQ0FBVztRQUNwQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNELFNBQVMsR0FBRyxDQUFDLENBQVcsRUFBRSxDQUFXO1FBQ25DLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxTQUFTLEtBQUssQ0FBQyxDQUFXO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFXLEVBQUUsQ0FBVyxJQUFXLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDO0lBRXpFLFNBQVMsVUFBVSxDQUFDLEdBQVcsRUFBRSxDQUFhLEVBQzVDLENBQVMsRUFBRSxDQUFTLEVBQUUsRUFBWTtRQU9sQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUN2QixJQUFNLENBQUMsR0FBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFNLENBQUMsR0FBYSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQU0sRUFBRSxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQU01QixJQUFJLENBQVcsQ0FBQztRQUNoQixJQUFJLEVBQVksQ0FBQztRQUNqQixJQUFJLENBQVMsRUFBRSxFQUFVLEVBQUUsR0FBVyxDQUFDO1FBQ3ZDLEtBQUssSUFBSSxHQUFDLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUMsRUFBRSxFQUFFO1lBRXRDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUNYLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RCO2lCQUFNLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRTtnQkFDbkIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdEI7aUJBQU07Z0JBQ0wsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ1osRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDcEI7WUFFRCxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7Z0JBQ2hCLFNBQVM7YUFDVjtZQUVELElBQUksR0FBRyxHQUFDLENBQUM7WUFDVCxLQUFLLEdBQUcsR0FBRyxDQUFDO1NBQ2I7UUFDRCxJQUFJLEtBQUssR0FBRyxJQUFJLEVBQUU7WUFFaEIsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUViLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDaEMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNqQztRQUVELE9BQU87SUFDVCxDQUFDO0lBRUQsSUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNuQixJQUFNLEVBQUUsR0FBZSxFQUFFLENBQUM7SUFDMUIsSUFBSSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxFQUFVLENBQUM7SUFDaEQsSUFBTSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUMvQixJQUFNLEVBQUUsR0FBZSxFQUFFLENBQUM7SUFDMUIsSUFBTSxFQUFFLEdBQWEsRUFBRSxDQUFDO0lBR3hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDYixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNsQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFO1lBQzFCLFNBQVM7U0FDVjtRQUNELEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNmLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDUjtJQUNELElBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDZCxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0lBR0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBR2xDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxQixJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNULEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQjtLQUNGO0lBQ0QsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBckhELG9DQXFIQztBQUtELFNBQWdCLGFBQWEsQ0FBQyxLQUFtQixFQUMvQyxTQUFrQjtJQUNsQixJQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO0lBQ2hDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNkLElBQUksU0FBUyxFQUFFO1FBQ2IsR0FBRyxHQUFHLFNBQVMsQ0FBQztLQUNqQjtJQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzFDO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQVhELHNDQVdDO0FBS0QsU0FBZ0IsY0FBYyxDQUFDLE9BQXFCO0lBQ2xELElBQUksQ0FBUyxFQUFFLENBQVMsQ0FBQztJQUN6QixJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNuQixJQUFJLEVBQVUsRUFBRSxFQUFVLENBQUM7SUFDM0IsSUFBSSxHQUFXLEVBQUUsSUFBWSxDQUFDO0lBQzlCLElBQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQztJQUM5QixJQUFJLENBQVMsRUFBRSxDQUFTLENBQUM7SUFDekIsSUFBSSxHQUFXLENBQUM7SUFDaEIsSUFBSSxDQUFXLENBQUM7SUFDaEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3hCLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtZQUNYLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNULENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRTtvQkFDakIsSUFBSSxHQUFHLENBQUMsQ0FBQztvQkFDVCxHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUNUO3FCQUFNO29CQUNMLElBQUksR0FBRyxDQUFDLENBQUM7b0JBQ1QsR0FBRyxHQUFHLENBQUMsQ0FBQztpQkFDVDtnQkFDRCxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDWixFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDWixFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNQLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1AsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1NBQ0Y7S0FDRjtJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQztBQWpDRCx3Q0FpQ0M7QUFLRCxTQUFnQixZQUFZLENBQUMsSUFBZ0IsRUFDM0MsU0FBbUI7SUFDbkIsSUFBSSxHQUFXLEVBQUUsSUFBWSxDQUFDO0lBQzlCLElBQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQztJQUM5QixJQUFJLEdBQVcsQ0FBQztJQUNoQixJQUFJLENBQVcsQ0FBQztJQUNoQixJQUFJLEVBQVUsRUFBRSxFQUFVLENBQUM7SUFDM0IsSUFBSSxDQUFTLEVBQUUsQ0FBUyxDQUFDO0lBQ3pCLElBQUksRUFBVSxFQUFFLEVBQVUsQ0FBQztJQUMzQixJQUFJLENBQVMsQ0FBQztJQUNkLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsRUFBRSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNsQixJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUU7UUFDWCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QixDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ1osQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNULENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDVCxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFO2dCQUNqQixJQUFJLEdBQUcsQ0FBQyxDQUFDO2dCQUNULEdBQUcsR0FBRyxDQUFDLENBQUM7YUFDVDtpQkFBTTtnQkFDTCxJQUFJLEdBQUcsQ0FBQyxDQUFDO2dCQUNULEdBQUcsR0FBRyxDQUFDLENBQUM7YUFDVDtZQUNELEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1osRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDWixFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ1AsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNQLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQztLQUNGO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWpDRCxvQ0FpQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlTRCx1R0FBdUM7QUFDL0IsZ0JBQUU7QUFFViwrRUFBNkI7Ozs7Ozs7Ozs7Ozs7OztBQ0g3Qiw4RUFBa0M7QUFBMUIscUNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSWpCLHNIQUE0QztBQUU1QyxnR0FBa0Q7QUF3RWxEO0lBZ0NFLG1CQUFZLGFBQXFCO1FBUHpCLGFBQVEsR0FBRyxFQUFFLENBQUM7UUFRcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUtELGlDQUFhLEdBQWI7UUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQU1PLHVDQUFtQixHQUEzQixVQUE0QixJQUFtQixFQUM3QyxVQUFzQixFQUN0QixhQUF1QjtRQUV2QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUF3QixDQUFDO1FBQzdCLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3QyxVQUFVLEdBQUcsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLElBQU0sQ0FBQyxHQUFXLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDMUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2FBQ25EO1lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDL0I7UUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDN0MsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUM5QyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUM5QyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLFVBQVUsR0FBRyxF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ZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoic2ltcGxlX2J1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZGVtb3Mvc2ltcGxlLmpzXCIpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBtcyBmcm9tICcuLi9zcmMvaW5kZXgnO1xuXG5jb25zdCBza2V0Y2ggPSBmdW5jdGlvbihwKSB7XG4gIGxldCBtb2RlbFN0YXRlOyAvLyBTdG9yZSB0aGUgaGlkZGVuIHN0YXRlcyBvZiBybm4ncyBuZXVyb25zLlxuICBjb25zdCB0ZW1wZXJhdHVyZSA9IDAuNDU7IC8vIENvbnRyb2xzIHRoZSBhbW91bnQgb2YgdW5jZXJ0YWludHkgb2YgdGhlIG1vZGVsLlxuICBsZXQgbW9kZWxMb2FkZWQgPSBmYWxzZTtcblxuICBsZXQgZHgsIGR5OyAvLyBPZmZzZXRzIG9mIHRoZSBwZW4gc3Ryb2tlcywgaW4gcGl4ZWxzLlxuICBsZXQgeCwgeTsgLy8gQWJzb2x1dGUgY29vcmRpbmF0ZXMgb24gdGhlIHNjcmVlbiBvZiB3aGVyZSB0aGUgcGVuIGlzLlxuICBsZXQgcGVuID0gWzAsMCwwXTsgLy8gQ3VycmVudCBwZW4gc3RhdGUsIFtwZW5fZG93biwgcGVuX3VwLCBwZW5fZW5kXS5cbiAgbGV0IHByZXZpb3VzUGVuID0gWzEsIDAsIDBdOyAvLyBQcmV2aW91cyBwZW4gc3RhdGUuXG4gIGNvbnN0IFBFTiA9IHtET1dOOiAwLCBVUDogMSwgRU5EOiAyfTtcblxuICAvLyBMb2FkIHRoZSBtb2RlbC5cbiAgY29uc3QgbW9kZWwgPSBuZXcgbXMuU2tldGNoUk5OKCdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vcXVpY2tkcmF3LW1vZGVscy9za2V0Y2hSTk4vbGFyZ2VfbW9kZWxzL2JpcmQuZ2VuLmpzb24nKTtcblxuXG4gIC8qXG4gICAqIE1haW4gcDUgY29kZVxuICAgKi9cbiAgcC5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2tldGNoJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgY2FudmFzLlxuICAgIGNvbnN0IHNjcmVlbldpZHRoID0gTWF0aC5mbG9vcihjb250YWluZXJTaXplLndpZHRoKTtcbiAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSBwLndpbmRvd0hlaWdodCAvIDI7XG4gICAgcC5jcmVhdGVDYW52YXMoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG4gICAgcC5mcmFtZVJhdGUoNjApO1xuXG4gICAgbW9kZWwuaW5pdGlhbGl6ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBzY2FsZSBmYWN0b3IgZm9yIHRoZSBtb2RlbC4gQmlnZ2VyIC0+IGxhcmdlIG91dHB1dHNcbiAgICAgIG1vZGVsLnNldFBpeGVsRmFjdG9yKDMuMCk7XG4gICAgICBtb2RlbExvYWRlZCA9IHRydWU7XG4gICAgICByZXN0YXJ0KCk7XG4gICAgICBjb25zb2xlLmxvZygnU2tldGNoUk5OIG1vZGVsIGxvYWRlZC4nKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBEcmF3aW5nIGxvb3AuXG4gIHAuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghbW9kZWxMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBmaW5pc2hlZCB0aGUgcHJldmlvdXMgZHJhd2luZywgc3RhcnQgYSBuZXcgb25lLlxuICAgIGlmIChwcmV2aW91c1BlbltQRU4uRU5EXSA9PT0gMSkge1xuICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIC8vIE5ldyBzdGF0ZS5cbiAgICBbZHgsIGR5LCAuLi5wZW5dID0gc2FtcGxlTmV3U3RhdGUoKTtcblxuICAgIC8vIE9ubHkgZHJhdyBvbiB0aGUgcGFwZXIgaWYgdGhlIHBlbiBpcyBzdGlsbCB0b3VjaGluZyB0aGUgcGFwZXIuXG4gICAgaWYgKHByZXZpb3VzUGVuW1BFTi5ET1dOXSA9PSAxKSB7XG4gICAgICBwLmxpbmUoeCwgeSwgeCtkeCwgeStkeSk7IC8vIERyYXcgbGluZSBjb25uZWN0aW5nIHByZXYgcG9pbnQgdG8gY3VycmVudCBwb2ludC5cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIGZyb20gdGhlIG9mZnNldHNcbiAgICB4ICs9IGR4O1xuICAgIHkgKz0gZHk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByZXZpb3VzIHBlbidzIHN0YXRlIHRvIHRoZSBjdXJyZW50IG9uZSB3ZSBqdXN0IHNhbXBsZWQuXG4gICAgcHJldmlvdXNQZW4gPSBwZW47XG4gIH07XG5cbiAgLypcbiAgICogSGVscGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNhbXBsZU5ld1N0YXRlKCkge1xuICAgIC8vIFVzaW5nIHRoZSBwcmV2aW91cyBwZW4gc3RhdGVzLCBhbmQgaGlkZGVuIHN0YXRlLCBnZXQgbmV4dCBoaWRkZW4gc3RhdGVcbiAgICAvLyB0aGUgYmVsb3cgbGluZSB0YWtlcyB0aGUgbW9zdCBDUFUgcG93ZXIsIGVzcGVjaWFsbHkgZm9yIGxhcmdlIG1vZGVscy5cbiAgICBtb2RlbFN0YXRlID0gbW9kZWwudXBkYXRlKFtkeCwgZHksIC4uLnBlbl0sIG1vZGVsU3RhdGUpO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24gKHBkZikgZnJvbSBoaWRkZW4gc3RhdGUuXG4gICAgY29uc3QgcGRmID0gbW9kZWwuZ2V0UERGKG1vZGVsU3RhdGUsIHRlbXBlcmF0dXJlKTtcblxuICAgIC8vIFNhbXBsZSB0aGUgbmV4dCBwZW4ncyBzdGF0ZXMgZnJvbSBvdXIgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uLlxuICAgIHJldHVybiBtb2RlbC5zYW1wbGUocGRmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTmV3RHJhd2luZygpIHtcbiAgICBwLmJhY2tncm91bmQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcbiAgICB4ID0gcC53aWR0aCAvIDIuMDtcbiAgICB5ID0gcC5oZWlnaHQgLyAzLjA7XG4gICAgY29uc3QgbGluZUNvbG9yID0gcC5jb2xvcihwLnJhbmRvbSg2NCwgMjI0KSwgcC5yYW5kb20oNjQsIDIyNCksIHAucmFuZG9tKDY0LCAyMjQpKTtcblxuICAgIHAuc3Ryb2tlV2VpZ2h0KDMuMCk7XG4gICAgcC5zdHJva2UobGluZUNvbG9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgW2R4LCBkeSwgLi4ucGVuXSA9IG1vZGVsLnplcm9JbnB1dCgpOyAgLy8gUmVzZXQgdGhlIHBlbiBzdGF0ZS5cbiAgICBtb2RlbFN0YXRlID0gbW9kZWwuemVyb1N0YXRlKCk7ICAvLyBSZXNldCB0aGUgbW9kZWwgc3RhdGUuXG4gICAgc2V0dXBOZXdEcmF3aW5nKCk7XG4gIH1cbn07XG5cbm5ldyBwNShza2V0Y2gsICdza2V0Y2gnKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydHtFTlYsY29uY2F0LHNsaWNlLHN0YWNrLHRlbnNvcix0aWR5LHVuc3RhY2ssdXRpbCxpbyxUZW5zb3IsYWRkLGFkZE4sbW9kLG11bCxkaXYsZmxvb3JEaXYsc3ViLG1pbmltdW0sbWF4aW11bSxwb3csc3F1YXJlZERpZmZlcmVuY2UsYWJzLGFjb3MsYWNvc2gsYXNpbixhc2luaCxhdGFuLGF0YW4yLGF0YW5oLGNlaWwsY29zLGNvc2gsZWx1LGVyZixleHAsZXhwbTEsZmxvb3IsbG9nLGxvZzFwLG5lZyxyZWNpcHJvY2FsLHJlbHUscm91bmQsc2VsdSxzaWdtb2lkLHNpbixzaWduLHNpbmgsc29mdHBsdXMsc3FydCxzcXVhcmUsdGFuaCx0YW4sY2xpcEJ5VmFsdWUscnNxcnQscHJvZCxsZWFreVJlbHUsc2NhbGFyLGNvbnYxZCxjb252MmQsY29udjJkVHJhbnNwb3NlLGRlcHRod2lzZUNvbnYyZCxhdmdQb29sLG1heFBvb2wsZmlsbCxsaW5zcGFjZSxvbmVIb3Qsb25lcyxvbmVzTGlrZSxyYW5kb21Vbmlmb3JtLHJhbmdlLHRydW5jYXRlZE5vcm1hbCx6ZXJvcyx6ZXJvc0xpa2UsaW1hZ2Usd2hlcmVBc3luYyxzZXRkaWZmMWRBc3luYyx0b3BrLHRlbnNvcjFkLGVxdWFsLG5vdEVxdWFsLGdyZWF0ZXIsZ3JlYXRlckVxdWFsLGxlc3MsbGVzc0VxdWFsLGxvZ2ljYWxBbmQsbG9naWNhbE5vdCxsb2dpY2FsT3Isd2hlcmUsbWF0TXVsLHRyYW5zcG9zZSxiYXRjaE5vcm0sbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24sc29mdG1heCxsb2dTb2Z0bWF4LHNwYXJzZVRvRGVuc2UsbWF4LG1lYW4sbWluLHN1bSxhbGwsYW55LGFyZ01heCxhcmdNaW4sZ2F0aGVyLHJldmVyc2Usc3RyaWRlZFNsaWNlLHRpbGUsc3BsaXQsc2NhdHRlck5ELGdhdGhlck5ELGZmdCxpZmZ0LHJmZnQsaXJmZnQsY2FzdCxleHBhbmREaW1zLHNxdWVlemUscmVzaGFwZSxwYWQsc3BhY2VUb0JhdGNoTkQsYmF0Y2hUb1NwYWNlTkQsZGVwdGhUb1NwYWNlfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO3ZhciBEYXRhVHlwZSxTYXZlckRlZixfX2Fzc2lnbj1mdW5jdGlvbigpe3JldHVybihfX2Fzc2lnbj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQsYT0xLHI9YXJndW1lbnRzLmxlbmd0aDthPHI7YSsrKWZvcih2YXIgbiBpbiB0PWFyZ3VtZW50c1thXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIF9fYXdhaXRlcihlLHQsYSxyKXtyZXR1cm4gbmV3KGF8fChhPVByb21pc2UpKShmdW5jdGlvbihuLHMpe2Z1bmN0aW9uIG8oZSl7dHJ5e2koci5uZXh0KGUpKX1jYXRjaChlKXtzKGUpfX1mdW5jdGlvbiBwKGUpe3RyeXtpKHIudGhyb3coZSkpfWNhdGNoKGUpe3MoZSl9fWZ1bmN0aW9uIGkoZSl7ZS5kb25lP24oZS52YWx1ZSk6bmV3IGEoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pLnRoZW4obyxwKX1pKChyPXIuYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBfX2dlbmVyYXRvcihlLHQpe3ZhciBhLHIsbixzLG89e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmblswXSl0aHJvdyBuWzFdO3JldHVybiBuWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIHM9e25leHQ6cCgwKSx0aHJvdzpwKDEpLHJldHVybjpwKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihzW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHM7ZnVuY3Rpb24gcChzKXtyZXR1cm4gZnVuY3Rpb24ocCl7cmV0dXJuIGZ1bmN0aW9uKHMpe2lmKGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtvOyl0cnl7aWYoYT0xLHImJihuPTImc1swXT9yLnJldHVybjpzWzBdP3IudGhyb3d8fCgobj1yLnJldHVybikmJm4uY2FsbChyKSwwKTpyLm5leHQpJiYhKG49bi5jYWxsKHIsc1sxXSkpLmRvbmUpcmV0dXJuIG47c3dpdGNoKHI9MCxuJiYocz1bMiZzWzBdLG4udmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOm49czticmVhaztjYXNlIDQ6cmV0dXJuIG8ubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6by5sYWJlbCsrLHI9c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1vLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG49KG49by50cnlzKS5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSkmJig2PT09c1swXXx8Mj09PXNbMF0pKXtvPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighbnx8c1sxXT5uWzBdJiZzWzFdPG5bM10pKXtvLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJm8ubGFiZWw8blsxXSl7by5sYWJlbD1uWzFdLG49czticmVha31pZihuJiZvLmxhYmVsPG5bMl0pe28ubGFiZWw9blsyXSxvLm9wcy5wdXNoKHMpO2JyZWFrfW5bMl0mJm8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZX1zPXQuY2FsbChlLG8pfWNhdGNoKGUpe3M9WzYsZV0scj0wfWZpbmFsbHl7YT1uPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLHBdKX19fWZ1bmN0aW9uIGdldFBhcmFtVmFsdWUoZSx0LGEscil7dmFyIG49dC5pbnB1dFBhcmFtc1tlXTtpZihuJiZ2b2lkIDAhPT1uLmlucHV0SW5kZXhTdGFydCl7dmFyIHM9bi5pbnB1dEluZGV4U3RhcnQsbz0wPT09bi5pbnB1dEluZGV4RW5kP3ZvaWQgMDp2b2lkIDA9PT1uLmlucHV0SW5kZXhFbmQ/cysxOm4uaW5wdXRJbmRleEVuZDtpZihcInRlbnNvclwiPT09bi50eXBlKXJldHVybiBnZXRUZW5zb3IodC5pbnB1dE5hbWVzW24uaW5wdXRJbmRleFN0YXJ0XSxhLHIpO2lmKFwidGVuc29yc1wiPT09bi50eXBlKXJldHVybiB0LmlucHV0TmFtZXMuc2xpY2UocyxvKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGdldFRlbnNvcihlLGEscil9KTt2YXIgcD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRUZW5zb3IodC5pbnB1dE5hbWVzLnNsaWNlKHMpWzBdLGEscikuZGF0YVN5bmMoKSk7cmV0dXJuXCJudW1iZXJcIj09PW4udHlwZT9wWzBdOnB9dmFyIGk9dC5hdHRyUGFyYW1zW2VdO3JldHVybiBpJiZpLnZhbHVlfWZ1bmN0aW9uIGdldFRlbnNvcihlLHQsYSl7dmFyIHI9cGFyc2VOb2RlTmFtZShlKSxuPXJbMF0scz1yWzFdLG89YS5jdXJyZW50Q29udGV4dElkcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiEhdFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobixlKV19KTtyZXR1cm4gdm9pZCAwIT09bz90W2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChuLG8pXVtzXTp2b2lkIDB9ZnVuY3Rpb24gZ2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dChlLHQsYSl7cmV0dXJuIHRbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKGUsYS5jdXJyZW50Q29udGV4dElkKV19ZnVuY3Rpb24gZ2V0Tm9kZU5hbWVBbmRJbmRleChlLHQpe3ZhciBhPXBhcnNlTm9kZU5hbWUoZSkscj1hWzBdLG49YVsxXTtyZXR1cm5bZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKHIsdCYmdC5jdXJyZW50Q29udGV4dElkKSxuXX1mdW5jdGlvbiBnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQoZSx0KXtyZXR1cm4gdD9lK1wiLVwiK3Q6ZX1mdW5jdGlvbiBwYXJzZU5vZGVOYW1lKGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCI6XCIpO3JldHVybi0xPT09dD9bZSwwXTpbZS5zdWJzdHJpbmcoMCx0KSxOdW1iZXIoZS5zdWJzdHJpbmcodCsxKSldfWZ1bmN0aW9uIHNwbGl0JDEoZSx0KXtmb3IodmFyIGE9W10scj0wO3I8ZS5sZW5ndGg7cis9dClhLnB1c2goZS5zbGljZShyLHIrdCkpO3JldHVybiBhfSFmdW5jdGlvbihlKXtlW2UuRFRfSU5WQUxJRD0wXT1cIkRUX0lOVkFMSURcIixlW2UuRFRfRkxPQVQ9MV09XCJEVF9GTE9BVFwiLGVbZS5EVF9ET1VCTEU9Ml09XCJEVF9ET1VCTEVcIixlW2UuRFRfSU5UMzI9M109XCJEVF9JTlQzMlwiLGVbZS5EVF9VSU5UOD00XT1cIkRUX1VJTlQ4XCIsZVtlLkRUX0lOVDE2PTVdPVwiRFRfSU5UMTZcIixlW2UuRFRfSU5UOD02XT1cIkRUX0lOVDhcIixlW2UuRFRfU1RSSU5HPTddPVwiRFRfU1RSSU5HXCIsZVtlLkRUX0NPTVBMRVg2ND04XT1cIkRUX0NPTVBMRVg2NFwiLGVbZS5EVF9JTlQ2ND05XT1cIkRUX0lOVDY0XCIsZVtlLkRUX0JPT0w9MTBdPVwiRFRfQk9PTFwiLGVbZS5EVF9RSU5UOD0xMV09XCJEVF9RSU5UOFwiLGVbZS5EVF9RVUlOVDg9MTJdPVwiRFRfUVVJTlQ4XCIsZVtlLkRUX1FJTlQzMj0xM109XCJEVF9RSU5UMzJcIixlW2UuRFRfQkZMT0FUMTY9MTRdPVwiRFRfQkZMT0FUMTZcIixlW2UuRFRfRkxPQVRfUkVGPTEwMV09XCJEVF9GTE9BVF9SRUZcIixlW2UuRFRfRE9VQkxFX1JFRj0xMDJdPVwiRFRfRE9VQkxFX1JFRlwiLGVbZS5EVF9JTlQzMl9SRUY9MTAzXT1cIkRUX0lOVDMyX1JFRlwiLGVbZS5EVF9VSU5UOF9SRUY9MTA0XT1cIkRUX1VJTlQ4X1JFRlwiLGVbZS5EVF9JTlQxNl9SRUY9MTA1XT1cIkRUX0lOVDE2X1JFRlwiLGVbZS5EVF9JTlQ4X1JFRj0xMDZdPVwiRFRfSU5UOF9SRUZcIixlW2UuRFRfU1RSSU5HX1JFRj0xMDddPVwiRFRfU1RSSU5HX1JFRlwiLGVbZS5EVF9DT01QTEVYNjRfUkVGPTEwOF09XCJEVF9DT01QTEVYNjRfUkVGXCIsZVtlLkRUX0lOVDY0X1JFRj0xMDldPVwiRFRfSU5UNjRfUkVGXCIsZVtlLkRUX0JPT0xfUkVGPTExMF09XCJEVF9CT09MX1JFRlwiLGVbZS5EVF9RSU5UOF9SRUY9MTExXT1cIkRUX1FJTlQ4X1JFRlwiLGVbZS5EVF9RVUlOVDhfUkVGPTExMl09XCJEVF9RVUlOVDhfUkVGXCIsZVtlLkRUX1FJTlQzMl9SRUY9MTEzXT1cIkRUX1FJTlQzMl9SRUZcIixlW2UuRFRfQkZMT0FUMTZfUkVGPTExNF09XCJEVF9CRkxPQVQxNl9SRUZcIn0oRGF0YVR5cGV8fChEYXRhVHlwZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtlW2UuTEVHQUNZPTBdPVwiTEVHQUNZXCIsZVtlLlYxPTFdPVwiVjFcIixlW2UuVjI9Ml09XCJWMlwifShlLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9ufHwoZS5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbj17fSkpfShTYXZlckRlZnx8KFNhdmVyRGVmPXt9KSk7dmFyIGpzb249W3t0Zk9wTmFtZTpcIkFkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFkZE5cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJCaWFzQWRkXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3ViXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVhbERpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yRGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTXVsXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4aW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIk1pbmltdW1cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJQb3dcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVkRGlmZmVyZW5jZVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1vZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yTW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGFyaXRobWV0aWM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29ufSksanNvbiQxPVt7dGZPcE5hbWU6XCJBYnNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFjb3NcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW4yXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ2VpbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ2xpcEJ5VmFsdWVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJjbGlwX3ZhbHVlX21pblwiLG5hbWU6XCJjbGlwVmFsdWVNaW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJjbGlwX3ZhbHVlX21heFwiLG5hbWU6XCJjbGlwVmFsdWVNYXhcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQ29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb3NoXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmVnXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1NlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJjbGlwVmFsdWVNaW5cIixuYW1lOlwiY2xpcFZhbHVlTWluXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiY2xpcFZhbHVlTWF4XCIsbmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6Nn1dfSx7dGZPcE5hbWU6XCJTZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaWdtb2lkXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJzcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGFuaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUm91bmRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cG0xXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2cxcFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVjaXByb2NhbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU29mdHBsdXNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVyZlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUHJvZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZWFreVJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbHBoYVwiLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxiYXNpY01hdGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDF9KSxqc29uJDI9W3t0Zk9wTmFtZTpcIkxvb3BDb25kXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTd2l0Y2hcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNZXJnZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkVudGVyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZnJhbWVfbmFtZVwiLG5hbWU6XCJmcmFtZU5hbWVcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJpc19jb25zdGFudFwiLG5hbWU6XCJpc0NvbnN0YW50XCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJFeGl0XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5leHRJdGVyYXRpb25cIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlXCIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHluYW1pY19zaXplXCIsbmFtZTpcImR5bmFtaWNTaXplXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImNsZWFyX2FmdGVyX3JlYWRcIixuYW1lOlwiY2xlYXJBZnRlclJlYWRcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiaWRlbnRpY2FsX2VsZW1lbnRfc2hhcGVzXCIsbmFtZTpcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwidGVuc29yX2FycmF5X25hbWVcIixuYW1lOlwibmFtZVwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVdyaXRlVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlSZWFkVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5R2F0aGVyVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUNvbmNhdFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVfZXhjZXB0MFwiLG5hbWU6XCJlbGVtZW50U2hhcGVFeGNlcHQwXCIsdHlwZTpcInNoYXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U3BsaXRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJsZW5ndGhzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNpemVWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDbG9zZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sY29udHJvbD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMn0pLGpzb24kMz1be3RmT3BOYW1lOlwiQXZnUG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2xcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb252MURcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlXCIsbmFtZTpcInN0cmlkZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOV0NcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJkaWxhdGlvblwiLG5hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJDb252MkRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsbmFtZTpcInVzZUN1ZG5uT25HcHVcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiQ29udjJEQmFja3Byb3BJbnB1dFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDoyLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MCxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19XSxjb252b2x1dGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kM30pLGpzb24kND1be3RmT3BOYW1lOlwiRmlsbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMaW5TcGFjZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInN0b3BcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJudW1cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lSG90XCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkZXB0aFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcIm9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHtzdGFydDozLG5hbWU6XCJvZmZWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiT25lc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJSYW5kb21Vbmlmb3JtXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pbnZhbFwiLG5hbWU6XCJtaW52YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJtYXh2YWxcIixuYW1lOlwibWF4dmFsXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmFuZ2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3RhcnRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwic3RlcFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiVGlkeFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRydW5jYXRlZE5vcm1hbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZWFuc1wiLG5hbWU6XCJtZWFuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic3RkZGV2XCIsbmFtZTpcInN0ZERldlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlplcm9zXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJaZXJvc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19XSxjcmVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNH0pLGpzb24kNT1be3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WMlwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYzXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NCxuYW1lOlwic2NvcmVUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiV2hlcmVcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJjb25kaXRpb25cIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGlzdERpZmZcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwieVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sZHluYW1pYz1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNX0pLGpzb24kNj1be3RmT3BOYW1lOlwiVG9wS1YyXCIsY2F0ZWdvcnk6XCJldmFsdWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNvcnRlZFwiLG5hbWU6XCJzb3J0ZWRcIix0eXBlOlwiYm9vbFwifV19XSxldmFsdWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ2fSksanNvbiQ3PVt7dGZPcE5hbWU6XCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRlZmF1bHRcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNoYXBlXCIsbmFtZTpcInNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlBsYWNlaG9sZGVyXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGF0dHJzOlt7dGZOYW1lOlwic2hhcGVcIixuYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiQ29uc3RcIixjYXRlZ29yeTpcImdyYXBoXCJ9LHt0Zk9wTmFtZTpcIklkZW50aXR5XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiSWRlbnRpdHlOXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIlNuYXBzaG90XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUmFua1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNpemVcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaGFwZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNoYXBlTlwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJQcmludFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1lc3NhZ2VcIixuYW1lOlwibWVzc2FnZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImZpcnN0X25cIixuYW1lOlwiZmlyc3ROXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcInN1bW1hcml6ZVwiLG5hbWU6XCJzdW1tYXJpemVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjN9XX0se3RmT3BOYW1lOlwiTm9PcFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W119LHt0Zk9wTmFtZTpcIlN0b3BHcmFkaWVudFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkZha2VRdWFudFdpdGhNaW5NYXhWYXJzXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pblwiLG5hbWU6XCJtaW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJtYXhcIixuYW1lOlwibWF4XCIsdHlwZTpcIm51bWJlclwifV19XSxncmFwaD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kN30pLGpzb24kOD1be3RmT3BOYW1lOlwiUmVzaXplQmlsaW5lYXJcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsbmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFsaWduX2Nvcm5lcnNcIixuYW1lOlwiYWxpZ25Db3JuZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ3JvcEFuZFJlc2l6ZVwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYm94SW5kXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiY3JvcFNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWV0aG9kXCIsbmFtZTpcIm1ldGhvZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImV4dHJhcG9sYXRpb25fdmFsdWVcIixuYW1lOlwiZXh0cmFwb2xhdGlvblZhbHVlXCIsdHlwZTpcIm51bWJlclwifV19XSxpbWFnZSQxPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ4fSksanNvbiQ5PVt7dGZPcE5hbWU6XCJFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5vdEVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiR3JlYXRlclwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlc3NcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dpY2FsQW5kXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE5vdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE9yXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2VsZWN0XCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGxvZ2ljYWw9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDl9KSxqc29uJDEwPVt7dGZPcE5hbWU6XCJNYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInRyYW5zcG9zZV9hXCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcInRyYW5zcG9zZV9iXCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQmF0Y2hNYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFkal94XCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcImFkal95XCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVHJhbnNwb3NlXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwZXJtXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLG1hdHJpY2VzPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMH0pLGpzb24kMTE9W3t0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjQsbmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVYyXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjQsbmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMUk5cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkZXB0aF9yYWRpdXNcIixuYW1lOlwicmFkaXVzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTo1fSx7dGZOYW1lOlwiYmlhc1wiLG5hbWU6XCJiaWFzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiYWxwaGFcIixuYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJiZXRhXCIsbmFtZTpcImJldGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi41fV19LHt0Zk9wTmFtZTpcIlNvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkxvZ1NvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNwYXJzZVRvRGVuc2VcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzcGFyc2VJbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNwYXJzZVZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLG5hbWU6XCJ2YWxpZGF0ZUluZGljZXNcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMCxub3RTdXBwb3J0ZWQ6ITB9XX1dLG5vcm1hbGl6YXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDExfSksanNvbiQxMj1be3RmT3BOYW1lOlwiTWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1lYW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTWluXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIlN1bVwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbGxcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQW55XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFyZ01heFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWluXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQcm9kXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19XSxyZWR1Y3Rpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDEyfSksanNvbiQxMz1be3RmT3BOYW1lOlwiQ29uY2F0VjJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDotMSxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHtzdGFydDotMSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJDb25jYXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDoxLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn0se3N0YXJ0OjAsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiR2F0aGVyVjJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiR2F0aGVyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixuYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmV2ZXJzZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkaW1zXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmV2ZXJzZVYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiZWdpblwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlN0cmlkZWRTbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiZWdpblwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZW5kXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImJlZ2luX21hc2tcIixuYW1lOlwiYmVnaW5NYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiZW5kX21hc2tcIixuYW1lOlwiZW5kTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcIm5ld19heGlzX21hc2tcIixuYW1lOlwibmV3QXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJlbGxpcHNpc19tYXNrXCIsbmFtZTpcImVsbGlwc2lzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNocmlua19heGlzX21hc2tcIixuYW1lOlwic2hyaW5rQXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiVW5wYWNrXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJudW1cIixuYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUaWxlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInJlcHNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcGxpdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHtzdGFydDoxLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJudW1fc3BsaXRcIixuYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfV19LHt0Zk9wTmFtZTpcIlNwbGl0VlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJudW1PclNpemVTcGxpdHNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiU2NhdHRlck5kXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiR2F0aGVyTmRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VUb0RlbnNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3BhcnNlSW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJzcGFyc2VWYWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixuYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITEsbm90U3VwcG9ydGVkOiEwfV19XSxzbGljZUpvaW49T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDEzfSksanNvbiQxND1be3RmT3BOYW1lOlwiRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiSUZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZmdF9sZW5ndGhcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIklSRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmZnRfbGVuZ3RoXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfV0sc3BlY3RyYWw9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDE0fSksanNvbiQxNT1be3RmT3BOYW1lOlwiQ2FzdFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJTcmNUXCIsbmFtZTpcInNkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIkRzdFRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJFeHBhbmREaW1zXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlBhZFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGFkZGluZ1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJjb25zdGFudF92YWx1ZVwiLG5hbWU6XCJjb25zdGFudFZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhZFYyXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJjb25zdGFudFZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlJlc2hhcGVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3F1ZWV6ZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsdGZEZXByZWNhdGVkTmFtZTpcInNxdWVlemVfZGltc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BhY2VUb0JhdGNoTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJsb2NrU2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiQmF0Y2hUb1NwYWNlTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJsb2NrU2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImNyb3BzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGVwdGhUb1NwYWNlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImJsb2NrX3NpemVcIixuYW1lOlwiYmxvY2tTaXplXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIn1dfV0sdHJhbnNmb3JtYXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDE1fSksQ09OVFJPTF9GTE9XX09QUz1bXCJTd2l0Y2hcIixcIk1lcmdlXCIsXCJFbnRlclwiLFwiRXhpdFwiLFwiTmV4dEl0ZXJhdGlvblwiXSxEWU5BTUlDX1NIQVBFX09QUz1bXCJOb25NYXhTdXBwcmVzc2lvblYyXCIsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsXCJXaGVyZVwiXSxPcGVyYXRpb25NYXBwZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIGU9W2FyaXRobWV0aWMsYmFzaWNNYXRoLGNvbnRyb2wsY29udm9sdXRpb24sY3JlYXRpb24sZHluYW1pYyxldmFsdWF0aW9uLGxvZ2ljYWwsaW1hZ2UkMSxncmFwaCxtYXRyaWNlcyxub3JtYWxpemF0aW9uLHJlZHVjdGlvbixzbGljZUpvaW4sc3BlY3RyYWwsdHJhbnNmb3JtYXRpb25dLHQ9W10uY29uY2F0LmFwcGx5KFtdLGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmpzb259KSk7dGhpcy5vcE1hcHBlcnM9dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0LnRmT3BOYW1lXT10LGV9LHt9KX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJJbnN0YW5jZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW5zdGFuY2V8fCh0aGlzLl9pbnN0YW5jZT1uZXcgdGhpcyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuaXNDb250cm9sRmxvdz1mdW5jdGlvbihlKXtyZXR1cm4gQ09OVFJPTF9GTE9XX09QUy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZS5vcH0pfSxlLnByb3RvdHlwZS5pc0R5bmFtaWNTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gRFlOQU1JQ19TSEFQRV9PUFMuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdD09PWUub3B9KX0sZS5wcm90b3R5cGUudHJhbnNmb3JtR3JhcGg9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPSExLHI9ITEsbj1bXSxzPVtdLG89ZS5ub2RlLnJlZHVjZShmdW5jdGlvbihlLG8pe3JldHVybiBlW28ubmFtZV09dC5tYXBOb2RlKG8pLHQuaXNDb250cm9sRmxvdyhvKSYmKGE9ITApLHQuaXNEeW5hbWljU2hhcGUobykmJihyPSEwKSxcIlBsYWNlaG9sZGVyXCI9PT1vLm9wJiZuLnB1c2goZVtvLm5hbWVdKSxcIkNvbnN0XCI9PT1vLm9wJiZzLnB1c2goZVtvLm5hbWVdKSxlfSx7fSkscD1bXSxpPVtdO3JldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW9bZV07dC5pbnB1dE5hbWVzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGE9Z2V0Tm9kZU5hbWVBbmRJbmRleChlKVswXTt0LmlucHV0cy5wdXNoKG9bYV0pLG9bYV0uY2hpbGRyZW4ucHVzaCh0KX0pLDA9PT10LmlucHV0cy5sZW5ndGgmJnAucHVzaCh0KX0pLE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9b1tlXTswPT09dC5jaGlsZHJlbi5sZW5ndGgmJmkucHVzaCh0KX0pLHtub2RlczpvLGlucHV0czpwLG91dHB1dHM6aSx3ZWlnaHRzOnMscGxhY2Vob2xkZXJzOm4sd2l0aENvbnRyb2xGbG93OmEsd2l0aER5bmFtaWNTaGFwZTpyfX0sZS5wcm90b3R5cGUubWFwTm9kZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9dGhpcy5vcE1hcHBlcnNbZS5vcF07aWYodm9pZCAwPT09YSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JmbG93IE9wIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiK2Uub3ApO3ZhciByPXtuYW1lOmUubmFtZSxvcDplLm9wLGNhdGVnb3J5OmEuY2F0ZWdvcnksaW5wdXROYW1lczooZS5pbnB1dHx8W10pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGFydHNXaXRoKFwiXlwiKT9lLnN1YnN0cigxKTplfSksaW5wdXRzOltdLGNoaWxkcmVuOltdLGlucHV0UGFyYW1zOnt9LGF0dHJQYXJhbXM6e319O3JldHVybiBudWxsPT1lLmF0dHImJihlLmF0dHI9e30pLG51bGwhPWEuaW5wdXRzJiYoci5pbnB1dFBhcmFtcz1hLmlucHV0cy5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0Lm5hbWVdPXt0eXBlOnQudHlwZSxpbnB1dEluZGV4U3RhcnQ6dC5zdGFydCxpbnB1dEluZGV4RW5kOnQuZW5kfSxlfSx7fSkpLG51bGwhPWEuYXR0cnMmJihyLmF0dHJQYXJhbXM9YS5hdHRycy5yZWR1Y2UoZnVuY3Rpb24oYSxyKXt2YXIgbj1yLnR5cGUscz12b2lkIDA7c3dpdGNoKHIudHlwZSl7Y2FzZVwic3RyaW5nXCI6dm9pZCAwPT09KHM9dC5nZXRTdHJpbmdQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldFN0cmluZ1BhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJudW1iZXJcIjp2b2lkIDA9PT0ocz10LmdldE51bWJlclBhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZXx8MCkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0TnVtYmVyUGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlcltdXCI6dm9pZCAwPT09KHM9dC5nZXROdW1lcmljQXJyYXlQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldE51bWVyaWNBcnJheVBhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJib29sXCI6dm9pZCAwPT09KHM9dC5nZXRCb29sUGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXRCb29sUGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInNoYXBlXCI6dm9pZCAwPT09KHM9dC5nZXRUZW5zb3JTaGFwZVBhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0VGVuc29yU2hhcGVQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiZHR5cGVcIjp2b2lkIDA9PT0ocz10LmdldER0eXBlUGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXREdHlwZVBhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJ0ZW5zb3JcIjpjYXNlXCJ0ZW5zb3JzXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXJhbSB0eXBlOiBcIityLnR5cGUrXCIgZm9yIG9wOiBcIitlLm9wKX1yZXR1cm4gYVtyLm5hbWVdPXt2YWx1ZTpzLHR5cGU6bn0sYX0se30pKSxyfSxlLnByb3RvdHlwZS5kZWNvZGVCYXNlNjQ9ZnVuY3Rpb24oZSl7dmFyIHQ9RU5WLmdsb2JhbDtpZih2b2lkIDAhPT10LmF0b2IpcmV0dXJuIHQuYXRvYihlKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyKXJldHVybiBuZXcgQnVmZmVyKGUsXCJiYXNlNjRcIikudG9TdHJpbmcoKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIGJhc2U2NCBpbiB0aGlzIGVudmlyb25tZW50LiBNaXNzaW5nIGJ1aWx0LWluIGF0b2IoKSBvciBCdWZmZXIoKVwiKX0sZS5wcm90b3R5cGUuZ2V0U3RyaW5nUGFyYW09ZnVuY3Rpb24oZSx0LGEscil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBuPWVbdF07aWYodm9pZCAwIT09bil7dmFyIHM9QXJyYXkuaXNBcnJheShuLnMpP1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuLnMpOnRoaXMuZGVjb2RlQmFzZTY0KG4ucyk7cmV0dXJuIHI/czpzLnRvTG93ZXJDYXNlKCl9cmV0dXJuIGF9LGUucHJvdG90eXBlLmdldEJvb2xQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XTtyZXR1cm4gcj9yLmI6YX0sZS5wcm90b3R5cGUuZ2V0TnVtYmVyUGFyYW09ZnVuY3Rpb24oZSx0LGEpe3ZhciByPWVbdF18fHt9LG49ci5pP3IuaTpyLmY/ci5mOmE7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIG4/bjpwYXJzZUludChuLDEwKX0sZS5wcm90b3R5cGUuZ2V0RHR5cGVQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XTtpZihyJiZyLnR5cGUpe3ZhciBuPXIudHlwZTtzd2l0Y2goXCJzdHJpbmdcIj09dHlwZW9mIHIudHlwZSYmKG49RGF0YVR5cGVbci50eXBlXSksbil7Y2FzZSBEYXRhVHlwZS5EVF9GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIERhdGFUeXBlLkRUX0lOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIERhdGFUeXBlLkRUX0JPT0w6cmV0dXJuXCJib29sXCI7ZGVmYXVsdDpyZXR1cm4gYX19cmV0dXJuIGF9LGUucHJvdG90eXBlLmdldFRlbnNvclNoYXBlUGFyYW09ZnVuY3Rpb24oZSx0LGEpe3ZhciByPWVbdF07aWYociYmci5zaGFwZSl7aWYoci5zaGFwZS51bmtub3duUmFuaylyZXR1cm47aWYobnVsbCE9ci5zaGFwZS5kaW0pcmV0dXJuIHIuc2hhcGUuZGltLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZS5zaXplP2Uuc2l6ZTpwYXJzZUludChlLnNpemUsMTApfSl9cmV0dXJuIGF9LGUucHJvdG90eXBlLmdldE51bWVyaWNBcnJheVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByPyhyLmxpc3QuZiYmci5saXN0LmYubGVuZ3RoP3IubGlzdC5mOnIubGlzdC5pKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/ZTpwYXJzZUludChlLDEwKX0pOmF9LGV9KCksZXhlY3V0ZU9wPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQmlhc0FkZFwiOmNhc2VcIkFkZFwiOnJldHVyblthZGQoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJBZGROXCI6cmV0dXJuW2FkZE4oZ2V0UGFyYW1WYWx1ZShcInRlbnNvcnNcIixlLHQsYSkpXTtjYXNlXCJGbG9vck1vZFwiOmNhc2VcIk1vZFwiOnJldHVyblttb2QoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJNdWxcIjpyZXR1cm5bbXVsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiUmVhbERpdlwiOmNhc2VcIkRpdlwiOnJldHVybltkaXYoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJGbG9vckRpdlwiOnJldHVybltmbG9vckRpdihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlN1YlwiOnJldHVybltzdWIoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJNaW5pbXVtXCI6cmV0dXJuW21pbmltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJNYXhpbXVtXCI6cmV0dXJuW21heGltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJQb3dcIjpyZXR1cm5bcG93KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiU3F1YXJlZERpZmZlcmVuY2VcIjpyZXR1cm5bc3F1YXJlZERpZmZlcmVuY2UoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQWJzXCI6cmV0dXJuW2FicyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFjb3NcIjpyZXR1cm5bYWNvcyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFjb3NoXCI6cmV0dXJuW2Fjb3NoKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXNpblwiOnJldHVyblthc2luKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXNpbmhcIjpyZXR1cm5bYXNpbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBdGFuXCI6cmV0dXJuW2F0YW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBdGFuMlwiOnJldHVyblthdGFuMihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwieVwiLGUsdCxhKSldO2Nhc2VcIkF0YW5oXCI6cmV0dXJuW2F0YW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQ2VpbFwiOnJldHVybltjZWlsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQ29zXCI6cmV0dXJuW2NvcyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkNvc2hcIjpyZXR1cm5bY29zaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkVsdVwiOnJldHVybltlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFcmZcIjpyZXR1cm5bZXJmKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRXhwXCI6cmV0dXJuW2V4cChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkV4cG0xXCI6cmV0dXJuW2V4cG0xKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRmxvb3JcIjpyZXR1cm5bZmxvb3IoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJMb2dcIjpyZXR1cm5bbG9nKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTG9nMXBcIjpyZXR1cm5bbG9nMXAoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJOZWdcIjpyZXR1cm5bbmVnKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUmVjaXByb2NhbFwiOnJldHVybltyZWNpcHJvY2FsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUmVsdVwiOnJldHVybltyZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUm91bmRcIjpyZXR1cm5bcm91bmQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTZWx1XCI6cmV0dXJuW3NlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTaWdtb2lkXCI6cmV0dXJuW3NpZ21vaWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTaW5cIjpyZXR1cm5bc2luKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2lnblwiOnJldHVybltzaWduKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2luaFwiOnJldHVybltzaW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU29mdHBsdXNcIjpyZXR1cm5bc29mdHBsdXMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTcXJ0XCI6cmV0dXJuW3NxcnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTcXVhcmVcIjpyZXR1cm5bc3F1YXJlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiVGFuaFwiOnJldHVyblt0YW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiVGFuXCI6cmV0dXJuW3RhbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlbHU2XCI6Y2FzZVwiQ2xpcEJ5VmFsdWVcIjpyZXR1cm5bY2xpcEJ5VmFsdWUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImNsaXBWYWx1ZU1pblwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiY2xpcFZhbHVlTWF4XCIsZSx0LGEpKV07Y2FzZVwiUnNxcnRcIjpyZXR1cm5bcnNxcnQoZ2V0VGVuc29yKGUuaW5wdXROYW1lc1swXSx0LGEpKV07Y2FzZVwiUHJvZFwiOnJldHVybltwcm9kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJheGVzXCIsZSx0LGEpKV07Y2FzZVwiTGVha3lSZWx1XCI6cmV0dXJuW2xlYWt5UmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LFRlbnNvckFycmF5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGEscixuLHMsbyxwKXt0aGlzLm5hbWU9dCx0aGlzLmR0eXBlPWEsdGhpcy5tYXhTaXplPXIsdGhpcy5lbGVtZW50U2hhcGU9bix0aGlzLmlkZW50aWNhbEVsZW1lbnRTaGFwZXM9cyx0aGlzLmR5bmFtaWNTaXplPW8sdGhpcy5jbGVhckFmdGVyUmVhZD1wLHRoaXMudGVuc29ycz1bXSx0aGlzLmNsb3NlZF89ITEsdGhpcy5pZD1lLm5leHRJZCsrfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjbG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvc2VkX30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5jbGVhckFuZENsb3NlPWZ1bmN0aW9uKCl7dGhpcy50ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVuc29yLmRpc3Bvc2UoKX0pLHRoaXMudGVuc29ycz1bXSx0aGlzLmNsb3NlZF89ITB9LGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZW5zb3JzLmxlbmd0aH0sZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihlKXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtpZihlPDB8fGU+PXRoaXMudGVuc29ycy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gcmVhZCBmcm9tIGluZGV4IFwiK2UrXCIsIGJ1dCBhcnJheSBzaXplIGlzOiBcIit0aGlzLnRlbnNvcnMubGVuZ3RoKTt2YXIgdD10aGlzLnRlbnNvcnNbZV07aWYodC5jbGVhcmVkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHJlYWQgaW5kZXggXCIrZStcIiB0d2ljZSBiZWNhdXNlIGl0IHdhcyBjbGVhcmVkIGFmdGVyIGEgcHJldmlvdXMgcmVhZCAocGVyaGFwcyB0cnkgc2V0dGluZyBjbGVhcl9hZnRlcl9yZWFkID0gZmFsc2U/KS5cIik7cmV0dXJuIHRoaXMuY2xlYXJBZnRlclJlYWQmJih0LmNsZWFyZWQ9ITApLHQucmVhZD0hMCx0LnRlbnNvcn0sZS5wcm90b3R5cGUucmVhZE1hbnk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHQucmVhZChlKX0pfSxlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQpe2lmKHRoaXMuY2xvc2VkXyl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCIgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO2lmKGU8MHx8IXRoaXMuZHluYW1pY1NpemUmJmU+PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byB3cml0ZSB0byBpbmRleCBcIitlK1wiLCBidXQgYXJyYXkgaXMgbm90IHJlc2l6ZWFibGUgYW5kIHNpemUgaXM6IFwiK3RoaXMubWF4U2l6ZSk7dmFyIGE9dGhpcy50ZW5zb3JzW2VdfHx7fTtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLFxcbiAgICAgICAgICBiZWNhdXNlIHRoZSB2YWx1ZSBkdHlwZSBpcyBcIit0LmR0eXBlK1wiLCBidXQgVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIi5cIik7aWYoMCE9PXRoaXMuc2l6ZSgpfHxudWxsIT10aGlzLmVsZW1lbnRTaGFwZSYmMCE9PXRoaXMuZWxlbWVudFNoYXBlLmxlbmd0aHx8KHRoaXMuZWxlbWVudFNoYXBlPXQuc2hhcGUpLHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGhpcy5lbGVtZW50U2hhcGUsdC5zaGFwZSxcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK2UrXCIuXCIpLGEmJmEucmVhZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcmVhZC5cIik7aWYoYSYmYS53cml0dGVuKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK2UrXCIsIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuLlwiKTthLnRlbnNvcj10LGEud3JpdHRlbj0hMCx0aGlzLnRlbnNvcnNbZV09YX0sZS5wcm90b3R5cGUud3JpdGVNYW55PWZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcztpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogY291bGQgbm90IHdyaXRlIG11bHRpcGxlIHRlbnNvcnMsYmVjYXVzZSB0aGUgaW5kZXggc2l6ZTogXCIrZS5sZW5ndGgrXCIgaXMgbm90IHRoZSBzYW1lIGFzIHRlbnNvcnMgc2l6ZTogXCIrdC5sZW5ndGgrXCIuXCIpO2UuZm9yRWFjaChmdW5jdGlvbihlLHIpe3JldHVybiBhLndyaXRlKGUsdFtyXSl9KX0sZS5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKGUsdCl7aWYodCYmdCE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgZ2F0aGVyIHJlcXVlc3RlZCBkdHlwZSBcIit0KTtpZighZSl7ZT1bXTtmb3IodmFyIGE9MDthPHRoaXMuc2l6ZSgpO2ErKyllLnB1c2goYSl9aWYoMD09PWUubGVuZ3RoKXJldHVybiB0ZW5zb3IoW10sWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO3ZhciByPXRoaXMucmVhZE1hbnkoZSk7cmV0dXJuIHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGhpcy5lbGVtZW50U2hhcGUsclswXS5zaGFwZSxcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiBcIiksc3RhY2sociwwKX0sZS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUpe2lmKGUmJmUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgXCIrZSk7aWYoMD09PXRoaXMuc2l6ZSgpKXJldHVybiB0ZW5zb3IoW10sWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO2Zvcih2YXIgdD1bXSxhPTA7YTx0aGlzLnNpemUoKTthKyspdC5wdXNoKGEpO3ZhciByPXRoaXMucmVhZE1hbnkodCk7cmV0dXJuIHRoaXMuYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUodGhpcy5lbGVtZW50U2hhcGUsclswXS5zaGFwZSxcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiB0ZW5zb3IgYXJyYXkgc2hhcGUgKFwiK3RoaXMuZWxlbWVudFNoYXBlK1wiKSB2cyBmaXJzdCB0ZW5zb3Igc2hhcGUgKFwiK3JbMF0uc2hhcGUrXCIpXCIpLGNvbmNhdChyLDApfSxlLnByb3RvdHlwZS5zY2F0dGVyPWZ1bmN0aW9uKGUsdCl7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgdGVuc29yIGhhcyBkdHlwZSBcIit0LmR0eXBlKTtpZihlLmxlbmd0aCE9PXQuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGVuKGluZGljZXMpID09IHRlbnNvci5zaGFwZVswXSwgYnV0IHNhdzogXCIrZS5sZW5ndGgrXCIgdnMuIFwiK3Quc2hhcGVbMF0pO3ZhciBhPU1hdGgubWF4LmFwcGx5KE1hdGgsZSk7aWYoIXRoaXMuZHluYW1pY1NpemUmJmE+PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJNYXggaW5kZXggbXVzdCBiZSA8IGFycmF5IHNpemUgKFwiK2ErXCIgIHZzLiBcIit0aGlzLm1heFNpemUrXCIpXCIpO3RoaXMud3JpdGVNYW55KGUsdW5zdGFjayh0LDApKX0sZS5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzO2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IHRlbnNvciBoYXMgZHR5cGUgXCIrdC5kdHlwZSk7dmFyIHI9MCxuPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByKz1lfSk7aWYociE9PXQuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cXG4gICAgICAgICAgdGVuc29yLnNoYXBlWzBdLCBidXQgc3VtIG9mIGxlbmd0aHMgaXNcXG4gICAgICAgIFwiK3IrXCIsIGFuZCB0ZW5zb3IncyBzaGFwZSBpczogXCIrdC5zaGFwZSk7aWYoIXRoaXMuZHluYW1pY1NpemUmJmUubGVuZ3RoIT09dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5J3Mgc2l6ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHNpemUgb2YgbGVuZ3RocyAoXCIrdGhpcy5tYXhTaXplK1wiIHZzLiBcIitlLmxlbmd0aCtcIiksIGFuZCB0aGUgVGVuc29yQXJyYXkgaXMgbm90IG1hcmtlZCBhcyBkeW5hbWljYWxseSByZXNpemVhYmxlXCIpO3ZhciBzPTA9PT1yPzA6dC5zaXplL3Isbz1bXTt0aWR5KGZ1bmN0aW9uKCl7dD10LnJlc2hhcGUoWzEscixzXSk7Zm9yKHZhciBwPTA7cDxlLmxlbmd0aDsrK3Ape3ZhciBpPVswLDA9PT1wPzA6bltwLTFdLDBdLHU9WzEsZVtwXSxzXTtvW3BdPXNsaWNlKHQsaSx1KS5yZXNoYXBlKGEuZWxlbWVudFNoYXBlKX1yZXR1cm4gb30pO2Zvcih2YXIgcD1bXSxpPTA7aTxlLmxlbmd0aDtpKyspcFtpXT1pO3RoaXMud3JpdGVNYW55KHAsbyl9LGUucHJvdG90eXBlLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplPWZ1bmN0aW9uKGUsdCxhKXt2b2lkIDA9PT1hJiYoYT1cIlwiKSx1dGlsLmFzc2VydCh0aGlzLnNoYXBlc0VxdWFsQWxsb3dVbmRlZmluZWRTaXplKGUsdCksZnVuY3Rpb24oKXtyZXR1cm4gYStcIiBTaGFwZXMgXCIrZStcIiBhbmQgXCIrdCtcIiBtdXN0IG1hdGNoXCJ9KX0sZS5wcm90b3R5cGUuc2hhcGVzRXF1YWxBbGxvd1VuZGVmaW5lZFNpemU9ZnVuY3Rpb24oZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKWlmKC0xIT09ZVthXSYmLTEhPT10W2FdJiZlW2FdIT09dFthXSlyZXR1cm4hMTtyZXR1cm4hMH0sZS5uZXh0SWQ9MCxlfSgpO2Z1bmN0aW9uIGV4ZWN1dGVPcCQyKGUsdCxhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4scyxvLHAsaSx1LG0sYyxsLGQseSxmLGgsZyxOLHgsYixWLFAsVCxPLHYsUyxfLHcsQSxELEUsSSxNLEMsayxqLHo7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oRil7c3dpdGNoKEYubGFiZWwpe2Nhc2UgMDpzd2l0Y2goZS5vcCl7Y2FzZVwiTG9vcENvbmRcIjpyZXR1cm5bMywxXTtjYXNlXCJTd2l0Y2hcIjpyZXR1cm5bMywyXTtjYXNlXCJNZXJnZVwiOnJldHVyblszLDRdO2Nhc2VcIkVudGVyXCI6cmV0dXJuWzMsNV07Y2FzZVwiRXhpdFwiOnJldHVyblszLDZdO2Nhc2VcIk5leHRJdGVyYXRpb25cIjpyZXR1cm5bMyw3XTtjYXNlXCJUZW5zb3JBcnJheVYzXCI6cmV0dXJuWzMsOF07Y2FzZVwiVGVuc29yQXJyYXlXcml0ZVYzXCI6cmV0dXJuWzMsOV07Y2FzZVwiVGVuc29yQXJyYXlSZWFkVjNcIjpyZXR1cm5bMywxMF07Y2FzZVwiVGVuc29yQXJyYXlHYXRoZXJWM1wiOnJldHVyblszLDExXTtjYXNlXCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiOnJldHVyblszLDEyXTtjYXNlXCJUZW5zb3JBcnJheUNvbmNhdFYzXCI6cmV0dXJuWzMsMTNdO2Nhc2VcIlRlbnNvckFycmF5U3BsaXRWM1wiOnJldHVyblszLDE0XTtjYXNlXCJUZW5zb3JBcnJheVNpemVWM1wiOnJldHVyblszLDE1XTtjYXNlXCJUZW5zb3JBcnJheUNsb3NlVjNcIjpyZXR1cm5bMywxNl19cmV0dXJuWzMsMTddO2Nhc2UgMTpyZXR1cm5bMixbZ2V0UGFyYW1WYWx1ZShcInByZWRcIixlLHQsYSkuY2xvbmUoKV1dO2Nhc2UgMjpyZXR1cm4gcj1nZXRQYXJhbVZhbHVlKFwicHJlZFwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJkYXRhXCIsZSx0LGEpLFs0LHIuZGF0YSgpXTtjYXNlIDM6cmV0dXJuWzIsRi5zZW50KClbMF0/W3ZvaWQgMCxuLmNsb25lKCldOltuLmNsb25lKCksdm9pZCAwXV07Y2FzZSA0OnJldHVyblsyLChzPWUuaW5wdXROYW1lcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1nZXRUZW5zb3IoZSx0LGEpfSkpP1tnZXRUZW5zb3Iocyx0LGEpLmNsb25lKCldOnZvaWQgMF07Y2FzZSA1OnJldHVybiBvPWdldFBhcmFtVmFsdWUoXCJmcmFtZU5hbWVcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZW50ZXJGcmFtZShvKSxbMixbcC5jbG9uZSgpXV07Y2FzZSA2OnJldHVybiBpPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5leGl0RnJhbWUoKSxbMixbaS5jbG9uZSgpXV07Y2FzZSA3OnJldHVybiB1PWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5uZXh0SXRlcmF0aW9uKCksWzIsW3UuY2xvbmUoKV1dO2Nhc2UgODpyZXR1cm4gbT1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLGUsdCxhKSxjPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxsPWdldFBhcmFtVmFsdWUoXCJlbGVtZW50U2hhcGVcIixlLHQsYSksZD1nZXRQYXJhbVZhbHVlKFwiZHluYW1pY1NpemVcIixlLHQsYSkseT1nZXRQYXJhbVZhbHVlKFwiY2xlYXJBZnRlclJlYWRcIixlLHQsYSksZj1nZXRQYXJhbVZhbHVlKFwiaWRlbnRpY2FsRWxlbWVudFNoYXBlc1wiLGUsdCxhKSxoPWdldFBhcmFtVmFsdWUoXCJuYW1lXCIsZSx0LGEpLGc9bmV3IFRlbnNvckFycmF5KGgsYyxtLGwsZixkLHkpLGEuYWRkVGVuc29yQXJyYXkoZyksWzIsW3NjYWxhcihnLmlkKSxzY2FsYXIoMSldXTtjYXNlIDk6cmV0dXJuIE49Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSkseD1nZXRQYXJhbVZhbHVlKFwiaW5kZXhcIixlLHQsYSksYj1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoTikud3JpdGUoeCxiKSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxMDpyZXR1cm4gVj1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxQPWdldFBhcmFtVmFsdWUoXCJpbmRleFwiLGUsdCxhKSxbMixbYS5nZXRUZW5zb3JBcnJheShWKS5yZWFkKFApXV07Y2FzZSAxMTpyZXR1cm4gVD1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxPPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLHY9Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLFsyLFthLmdldFRlbnNvckFycmF5KFQpLmdhdGhlcihPLHYpXV07Y2FzZSAxMjpyZXR1cm4gUz1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxfPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLHc9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KFMpLnNjYXR0ZXIoXyx3KSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxMzpyZXR1cm4gQT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxEPWEuZ2V0VGVuc29yQXJyYXkoQSksRT1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksWzIsW0QuY29uY2F0KEUpXV07Y2FzZSAxNDpyZXR1cm4gST1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxNPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksQz1nZXRQYXJhbVZhbHVlKFwibGVuZ3Roc1wiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KEkpLnNwbGl0KEMsTSksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTU6cmV0dXJuIGs9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksaj1hLmdldFRlbnNvckFycmF5KGspLFsyLFtzY2FsYXIoai5zaXplKCksXCJpbnQzMlwiKV1dO2Nhc2UgMTY6cmV0dXJuIHo9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheSh6KS5jbGVhckFuZENsb3NlKCksWzIsW11dO2Nhc2UgMTc6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0pfSl9dmFyIGV4ZWN1dGVPcCQzPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQ29udjFEXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZVwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpLG89Z2V0UGFyYW1WYWx1ZShcImRpbGF0aW9uXCIsZSx0LGEpO3JldHVybltjb252MWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxyLG4scyxvKV07Y2FzZVwiQ29udjJEXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpO3ZhciBwPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvbnNcIixlLHQsYSk7cmV0dXJuW2NvbnYyZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLFtyWzFdLHJbMl1dLG4scyxbcFswXSxwWzFdXSldO2Nhc2VcIkNvbnYyREJhY2twcm9wSW5wdXRcIjpjYXNlXCJDb252MmRUcmFuc3Bvc2VcIjp2YXIgaT1nZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixlLHQsYSk7cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSk7cmV0dXJuW2NvbnYyZFRyYW5zcG9zZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLGksW3JbMV0sclsyXV0sbildO2Nhc2VcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiOmNhc2VcIkRlcHRod2lzZUNvbnYyZFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcImRpbGF0aW9uc1wiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2RlcHRod2lzZUNvbnYyZChnZXRQYXJhbVZhbHVlKFwiaW5wdXRcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxbclsxXSxyWzJdXSxuLHMsW3BbMF0scFsxXV0pXTtjYXNlXCJBdmdQb29sXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSk7dmFyIHU9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW2F2Z1Bvb2woZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksW3VbMV0sdVsyXV0sW3JbMV0sclsyXV0sbildO2Nhc2VcIk1heFBvb2xcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSx1PWdldFBhcmFtVmFsdWUoXCJrZXJuZWxTaXplXCIsZSx0LGEpO3JldHVyblttYXhQb29sKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLFt1WzFdLHVbMl1dLFtyWzFdLHJbMl1dLG4pXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ0PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiRmlsbFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJ2YWx1ZVwiLGUsdCxhKTtyZXR1cm5bZmlsbChyLHMsbildO2Nhc2VcIkxpblNwYWNlXCI6dmFyIG89Z2V0UGFyYW1WYWx1ZShcInN0YXJ0XCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcInN0b3BcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwibnVtXCIsZSx0LGEpO3JldHVybltsaW5zcGFjZShvLHAsaSldO2Nhc2VcIk9uZUhvdFwiOnZhciB1PWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLG09Z2V0UGFyYW1WYWx1ZShcImRlcHRoXCIsZSx0LGEpLGM9Z2V0UGFyYW1WYWx1ZShcIm9uVmFsdWVcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwib2ZmVmFsdWVcIixlLHQsYSk7cmV0dXJuW29uZUhvdCh1LG0sYyxsKV07Y2FzZVwiT25lc1wiOnJldHVybltvbmVzKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJPbmVzTGlrZVwiOnJldHVybltvbmVzTGlrZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJhbmRvbVVuaWZvcm1cIjpyZXR1cm5bcmFuZG9tVW5pZm9ybShnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1pbnZhbFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwibWF4dmFsXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIlJhbmdlXCI6bz1nZXRQYXJhbVZhbHVlKFwic3RhcnRcIixlLHQsYSk7dmFyIGQ9Z2V0UGFyYW1WYWx1ZShcInN0b3BcIixlLHQsYSkseT1nZXRQYXJhbVZhbHVlKFwic3RlcFwiLGUsdCxhKTtyZXR1cm5bcmFuZ2UobyxkLHksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiVHJ1bmNhdGVkTm9ybWFsXCI6cj1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSk7dmFyIGY9Z2V0UGFyYW1WYWx1ZShcIm1lYW5cIixlLHQsYSksaD1nZXRQYXJhbVZhbHVlKFwic3RkRGV2XCIsZSx0LGEpLGc9Z2V0UGFyYW1WYWx1ZShcInNlZWRcIixlLHQsYSk7cmV0dXJuW3RydW5jYXRlZE5vcm1hbChyLGYsaCxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksZyldO2Nhc2VcIlplcm9zXCI6cmV0dXJuW3plcm9zKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJaZXJvc0xpa2VcIjpyZXR1cm5bemVyb3NMaWtlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fTtmdW5jdGlvbiBleGVjdXRlT3AkNShlLHQsYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLHMsbyxwO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6c3dpdGNoKGUub3Ape2Nhc2VcIk5vbk1heFN1cHByZXNzaW9uVjNcIjpjYXNlXCJOb25NYXhTdXBwcmVzc2lvblYyXCI6cmV0dXJuWzMsMV07Y2FzZVwiV2hlcmVcIjpyZXR1cm5bMywzXTtjYXNlXCJMaXN0RGlmZlwiOnJldHVyblszLDVdfXJldHVyblszLDddO2Nhc2UgMTpyZXR1cm4gcj1nZXRQYXJhbVZhbHVlKFwiYm94ZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwic2NvcmVzXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcIm1heE91dHB1dFNpemVcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwiaW91VGhyZXNob2xkXCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcInNjb3JlVGhyZXNob2xkXCIsZSx0LGEpLFs0LGltYWdlLm5vbk1heFN1cHByZXNzaW9uQXN5bmMocixuLHMsbyxwKV07Y2FzZSAyOnJldHVyblsyLFtpLnNlbnQoKV1dO2Nhc2UgMzpyZXR1cm5bNCx3aGVyZUFzeW5jKGdldFBhcmFtVmFsdWUoXCJjb25kaXRpb25cIixlLHQsYSkpXTtjYXNlIDQ6cmV0dXJuWzIsW2kuc2VudCgpXV07Y2FzZSA1OnJldHVybls0LHNldGRpZmYxZEFzeW5jKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ5XCIsZSx0LGEpKV07Y2FzZSA2OnJldHVyblsyLGkuc2VudCgpXTtjYXNlIDc6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0pfSl9dmFyIGV4ZWN1dGVPcCQ2PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiVG9wS1YyXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia1wiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJzb3J0ZWRcIixlLHQsYSksbz10b3BrKHIsbixzKTtyZXR1cm5bby52YWx1ZXMsby5pbmRpY2VzXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ3PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQ29uc3RcIjpyZXR1cm4gdFtlLm5hbWVdO2Nhc2VcIlBsYWNlaG9sZGVyV2l0aERlZmF1bHRcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiZGVmYXVsdFwiLGUsdCxhKTtyZXR1cm5bZ2V0VGVuc29yKGUubmFtZSx0LGEpfHxyXTtjYXNlXCJQbGFjZWhvbGRlclwiOnJldHVybltnZXRUZW5zb3IoZS5uYW1lLHQsYSldO2Nhc2VcIklkZW50aXR5XCI6Y2FzZVwiU3RvcEdyYWRpZW50XCI6Y2FzZVwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIjpyZXR1cm5bZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkuY2xvbmUoKV07Y2FzZVwiSWRlbnRpdHlOXCI6cmV0dXJuIGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5jbG9uZSgpfSk7Y2FzZVwiU25hcHNob3RcIjpyZXR1cm5bZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkuY2xvbmUoKV07Y2FzZVwiU2hhcGVcIjpyZXR1cm5bdGVuc29yMWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkuc2hhcGUsXCJpbnQzMlwiKV07Y2FzZVwiU2hhcGVOXCI6cmV0dXJuIGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdGVuc29yMWQoZS5zaGFwZSl9KTtjYXNlXCJTaXplXCI6cmV0dXJuW3NjYWxhcihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5zaXplLFwiaW50MzJcIildO2Nhc2VcIlJhbmtcIjpyZXR1cm5bc2NhbGFyKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLnJhbmssXCJpbnQzMlwiKV07Y2FzZVwiTm9PcFwiOnJldHVybltdO2Nhc2VcIlByaW50XCI6dmFyIG49Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YVwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJtZXNzYWdlXCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcInN1bW1hcml6ZVwiLGUsdCxhKTtjb25zb2xlLndhcm4oXCJUaGUgZ3JhcGggaGFzIGEgdGYucHJpbnQoKSBvcGVyYXRpb24sdXN1YWxseSB1c2VkIGZvciBkZWJ1Z2dpbmcsIHdoaWNoIHNsb3dzIGRvd24gcGVyZm9ybWFuY2UuXCIpLGNvbnNvbGUubG9nKG8pO2Zvcih2YXIgaT0wO2k8cy5sZW5ndGg7aSsrKWNvbnNvbGUubG9nKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNbaV0uZGF0YVN5bmMoKSkuc2xpY2UoMCxwKSk7cmV0dXJuW25dO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDg9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJSZXNpemVCaWxpbmVhclwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJpbWFnZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJhbGlnbkNvcm5lcnNcIixlLHQsYSk7cmV0dXJuW2ltYWdlLnJlc2l6ZUJpbGluZWFyKHIsW25bMF0sblsxXV0scyldO2Nhc2VcIlJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiOnI9Z2V0UGFyYW1WYWx1ZShcImltYWdlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImFsaWduQ29ybmVyc1wiLGUsdCxhKTtyZXR1cm5baW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKHIsW25bMF0sblsxXV0scyldO2Nhc2VcIkNyb3BBbmRSZXNpemVcIjp2YXIgbz1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwiYm94ZXNcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwiYm94SW5kXCIsZSx0LGEpLHU9Z2V0UGFyYW1WYWx1ZShcImNyb3BTaXplXCIsZSx0LGEpLG09Z2V0UGFyYW1WYWx1ZShcIm1ldGhvZFwiLGUsdCxhKSxjPWdldFBhcmFtVmFsdWUoXCJleHRyYXBvbGF0aW9uVmFsdWVcIixlLHQsYSk7cmV0dXJuW2ltYWdlLmNyb3BBbmRSZXNpemUobyxwLGksdSxtLGMpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ5PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiRXF1YWxcIjpyZXR1cm5bZXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJOb3RFcXVhbFwiOnJldHVybltub3RFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkdyZWF0ZXJcIjpyZXR1cm5bZ3JlYXRlcihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkdyZWF0ZXJFcXVhbFwiOnJldHVybltncmVhdGVyRXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMZXNzXCI6cmV0dXJuW2xlc3MoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMZXNzRXF1YWxcIjpyZXR1cm5bbGVzc0VxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTG9naWNhbEFuZFwiOnJldHVybltsb2dpY2FsQW5kKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTG9naWNhbE5vdFwiOnJldHVybltsb2dpY2FsTm90KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpKV07Y2FzZVwiTG9naWNhbE9yXCI6cmV0dXJuW2xvZ2ljYWxPcihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlNlbGVjdFwiOnJldHVyblt3aGVyZShnZXRQYXJhbVZhbHVlKFwiY29uZGl0aW9uXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTA9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJCYXRjaE1hdE11bFwiOmNhc2VcIk1hdE11bFwiOnJldHVyblttYXRNdWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInRyYW5zcG9zZUFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInRyYW5zcG9zZUJcIixlLHQsYSkpXTtjYXNlXCJUcmFuc3Bvc2VcIjpyZXR1cm5bdHJhbnNwb3NlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJwZXJtXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTE9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJGdXNlZEJhdGNoTm9ybVwiOmNhc2VcIkZ1c2VkQmF0Y2hOb3JtVjJcIjpyZXR1cm5bYmF0Y2hOb3JtKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJtZWFuXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ2YXJpYW5jZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwib2Zmc2V0XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzY2FsZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZXBzaWxvblwiLGUsdCxhKSldO2Nhc2VcIkxSTlwiOnJldHVybltsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwicmFkaXVzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiaWFzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJhbHBoYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYmV0YVwiLGUsdCxhKSldO2Nhc2VcIlNvZnRtYXhcIjpyZXR1cm5bc29mdG1heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkxvZ1NvZnRtYXhcIjpyZXR1cm5bbG9nU29mdG1heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNwYXJzZVRvRGVuc2VcIjpyZXR1cm5bc3BhcnNlVG9EZW5zZShnZXRQYXJhbVZhbHVlKFwic3BhcnNlSW5kaWNlc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNwYXJzZVZhbHVlc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZGVmYXVsdFZhbHVlXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTI9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJNYXhcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bbWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIk1lYW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblttZWFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIk1pblwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW21pbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJTdW1cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVybltzdW0oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiQWxsXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bYWxsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIkFueVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW2FueShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJBcmdNYXhcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVyblthcmdNYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIkFyZ01pblwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2FyZ01pbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyKV07Y2FzZVwiUHJvZFwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW3Byb2QoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTM9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDb25jYXRWMlwiOmNhc2VcIkNvbmNhdFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInRlbnNvcnNcIixlLHQsYSk7cmV0dXJuW2NvbmNhdChuLHIpXTtjYXNlXCJHYXRoZXJWMlwiOmNhc2VcIkdhdGhlclwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7dmFyIHM9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTtyZXR1cm5bZ2F0aGVyKHMsby5hc1R5cGUoXCJpbnQzMlwiKSxyKV07Y2FzZVwiUmV2ZXJzZVYyXCI6Y2FzZVwiUmV2ZXJzZVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtyZXR1cm5bcmV2ZXJzZShzLHIpXTtjYXNlXCJTbGljZVwiOnZhciBwPWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpO3JldHVybltzbGljZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxwLGkpXTtjYXNlXCJTdHJpZGVkU2xpY2VcIjpwPWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKTt2YXIgdT1nZXRQYXJhbVZhbHVlKFwiZW5kXCIsZSx0LGEpLG09Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwiYmVnaW5NYXNrXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcImVuZE1hc2tcIixlLHQsYSksZD1nZXRQYXJhbVZhbHVlKFwiZWxsaXBzaXNNYXNrXCIsZSx0LGEpLHk9Z2V0UGFyYW1WYWx1ZShcIm5ld0F4aXNNYXNrXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcInNocmlua0F4aXNNYXNrXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSk7aWYoMT09PXAubGVuZ3RoJiZoLnNoYXBlLmxlbmd0aD4xKWZvcih2YXIgZz0xO2c8aC5zaGFwZS5sZW5ndGg7ZysrKXAucHVzaCgwKSx1LnB1c2goaC5zaGFwZVtnXSksbS5wdXNoKG1bMF0pO3JldHVybltzdHJpZGVkU2xpY2UoaCxwLHUsbSxjLGwsZCx5LGYpXTtjYXNlXCJQYWNrXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsZSx0LGEpLHM9blswXS5zaGFwZSxvPW5bMF0uc3F1ZWV6ZSgpLnNoYXBlLHA9bi5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9dXRpbC5hcnJheXNFcXVhbChlLnNoYXBlLHMpO2lmKCF0JiYhdXRpbC5hcnJheXNFcXVhbChlLnNxdWVlemUoKS5zaGFwZSxvKSl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgaW5wdXQgdGVuc29ycyBzaGFwZSBkb2VzIG5vdCBtYXRjaFwiKTtyZXR1cm4gdD9lOmUucmVzaGFwZShzKX0pO3JldHVybltzdGFjayhwLHIpXX0pO2Nhc2VcIlVucGFja1wiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpO3JldHVybiB1bnN0YWNrKG4scil9KTtjYXNlXCJUaWxlXCI6dmFyIE49Z2V0UGFyYW1WYWx1ZShcInJlcHNcIixlLHQsYSk7cmV0dXJuW3RpbGUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksTildO2Nhc2VcIlNwbGl0XCI6Y2FzZVwiU3BsaXRWXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTt2YXIgeD1nZXRQYXJhbVZhbHVlKFwibnVtT3JTaXplU3BsaXRzXCIsZSx0LGEpO3JldHVybiBzcGxpdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSx4LHIpO2Nhc2VcIlNjYXR0ZXJOZFwiOm89Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSk7dmFyIGI9Z2V0UGFyYW1WYWx1ZShcInZhbHVlc1wiLGUsdCxhKSxWPWdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKTtyZXR1cm5bc2NhdHRlck5EKG8sYixWKV07Y2FzZVwiR2F0aGVyTmRcIjp2YXIgUD1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtvPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpO3JldHVybltnYXRoZXJORChQLG8pXTtjYXNlXCJTcGFyc2VUb0RlbnNlXCI6bz1nZXRQYXJhbVZhbHVlKFwic3BhcnNlSW5kaWNlc1wiLGUsdCxhKSxWPWdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLGUsdCxhKTt2YXIgVD1nZXRQYXJhbVZhbHVlKFwic3BhcnNlVmFsdWVzXCIsZSx0LGEpLE89Z2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLGUsdCxhKTtyZXR1cm5bc3BhcnNlVG9EZW5zZShvLFQsVixULmR0eXBlPT09Ty5kdHlwZT9POk8uYXNUeXBlKFQuZHR5cGUpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTQ9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJGRlRcIjpyZXR1cm5bZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiSUZGVFwiOnJldHVybltpZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUkZGVFwiOnJldHVybltyZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiSVJGRlRcIjpyZXR1cm5baXJmZnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxNT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkNhc3RcIjpyZXR1cm5bY2FzdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJFeHBhbmREaW1zXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2V4cGFuZERpbXMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIlNxdWVlemVcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVybltzcXVlZXplKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJSZXNoYXBlXCI6cmV0dXJuW3Jlc2hhcGUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpKV07Y2FzZVwiUGFkVjJcIjpjYXNlXCJQYWRcIjpyZXR1cm5bcGFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHNwbGl0JDEoZ2V0UGFyYW1WYWx1ZShcInBhZGRpbmdcIixlLHQsYSksMiksZ2V0UGFyYW1WYWx1ZShcImNvbnN0YW50VmFsdWVcIixlLHQsYSkpXTtjYXNlXCJTcGFjZVRvQmF0Y2hORFwiOnZhciBuPWdldFBhcmFtVmFsdWUoXCJibG9ja1NoYXBlXCIsZSx0LGEpLHM9c3BsaXQkMShnZXRQYXJhbVZhbHVlKFwicGFkZGluZ3NcIixlLHQsYSksMik7cmV0dXJuW3NwYWNlVG9CYXRjaE5EKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG4scyldO2Nhc2VcIkJhdGNoVG9TcGFjZU5EXCI6bj1nZXRQYXJhbVZhbHVlKFwiYmxvY2tTaGFwZVwiLGUsdCxhKTt2YXIgbz1zcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJjcm9wc1wiLGUsdCxhKSwyKTtyZXR1cm5bYmF0Y2hUb1NwYWNlTkQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbixvKV07Y2FzZVwiRGVwdGhUb1NwYWNlXCI6dmFyIHA9Z2V0UGFyYW1WYWx1ZShcImJsb2NrU2l6ZVwiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2RlcHRoVG9TcGFjZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxwLGkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19O2Z1bmN0aW9uIGV4ZWN1dGVPcCQxNihlLHQsYSl7dmFyIHI9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLmNhdGVnb3J5KXtjYXNlXCJhcml0aG1ldGljXCI6cmV0dXJuIGV4ZWN1dGVPcChlLHQsYSk7Y2FzZVwiYmFzaWNfbWF0aFwiOnJldHVybiBleGVjdXRlT3AkMShlLHQsYSk7Y2FzZVwiY29udHJvbFwiOnJldHVybiBleGVjdXRlT3AkMihlLHQsYSk7Y2FzZVwiY29udm9sdXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDMoZSx0LGEpO2Nhc2VcImNyZWF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQ0KGUsdCxhKTtjYXNlXCJkeW5hbWljXCI6cmV0dXJuIGV4ZWN1dGVPcCQ1KGUsdCxhKTtjYXNlXCJldmFsdWF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQ2KGUsdCxhKTtjYXNlXCJpbWFnZVwiOnJldHVybiBleGVjdXRlT3AkOChlLHQsYSk7Y2FzZVwiZ3JhcGhcIjpyZXR1cm4gZXhlY3V0ZU9wJDcoZSx0LGEpO2Nhc2VcImxvZ2ljYWxcIjpyZXR1cm4gZXhlY3V0ZU9wJDkoZSx0LGEpO2Nhc2VcIm1hdHJpY2VzXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMChlLHQsYSk7Y2FzZVwibm9ybWFsaXphdGlvblwiOnJldHVybiBleGVjdXRlT3AkMTEoZSx0LGEpO2Nhc2VcInJlZHVjdGlvblwiOnJldHVybiBleGVjdXRlT3AkMTIoZSx0LGEpO2Nhc2VcInNsaWNlX2pvaW5cIjpyZXR1cm4gZXhlY3V0ZU9wJDEzKGUsdCxhKTtjYXNlXCJzcGVjdHJhbFwiOnJldHVybiBleGVjdXRlT3AkMTQoZSx0LGEpO2Nhc2VcInRyYW5zZm9ybWF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxNShlLHQsYSk7ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fShlLHQsYSk7cmV0dXJuIHIgaW5zdGFuY2VvZiBQcm9taXNlP3IudGhlbihmdW5jdGlvbihlKXtyZXR1cm5bXS5jb25jYXQoZSl9KTpbXS5jb25jYXQocil9dmFyIEV4ZWN1dGlvbkNvbnRleHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dGhpcy53ZWlnaHRNYXA9ZSx0aGlzLnRlbnNvckFycmF5TWFwPXQsdGhpcy5yb290Q29udGV4dD17aWQ6MCxmcmFtZU5hbWU6XCJcIixpdGVyYXRpb25JZDowfSx0aGlzLmNvbnRleHRzPVt0aGlzLnJvb3RDb250ZXh0XSx0aGlzLmxhc3RJZD0wLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpfXJldHVybiBlLnByb3RvdHlwZS5uZXdGcmFtZT1mdW5jdGlvbihlLHQpe3JldHVybntpZDplLGZyYW1lTmFtZTp0LGl0ZXJhdGlvbklkOjB9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0c30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuY29udGV4dHMhPT1lJiYodGhpcy5jb250ZXh0cz1lLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc1swXX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjdXJyZW50Q29udGV4dElkc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDx0aGlzLmNvbnRleHRzLmxlbmd0aC0xO3QrKyl7dmFyIGE9dGhpcy5jb250ZXh0cy5zbGljZSgwLHRoaXMuY29udGV4dHMubGVuZ3RoLXQpO2UucHVzaCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKGEpKX1lLnB1c2goXCJcIiksdGhpcy5fY3VycmVudENvbnRleHRJZHM9ZX0sZS5wcm90b3R5cGUuY29udGV4dElkZm9yQ29udGV4dHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1lLmlkJiYwPT09ZS5pdGVyYXRpb25JZD9cIlwiOmUuZnJhbWVOYW1lK1wiLVwiK2UuaXRlcmF0aW9uSWR9KS5qb2luKFwiL1wiKTpcIlwifSxlLnByb3RvdHlwZS5lbnRlckZyYW1lPWZ1bmN0aW9uKGUpe3RoaXMuY29udGV4dHMmJih0aGlzLmxhc3RJZCsrLHRoaXMuY29udGV4dHM9dGhpcy5jb250ZXh0cy5zbGljZSgpLHRoaXMuY29udGV4dHMucHVzaCh0aGlzLm5ld0ZyYW1lKHRoaXMubGFzdElkLGUpKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcy51bnNoaWZ0KHRoaXMuY29udGV4dElkZm9yQ29udGV4dHModGhpcy5jb250ZXh0cykpKX0sZS5wcm90b3R5cGUuZXhpdEZyYW1lPWZ1bmN0aW9uKCl7aWYoISh0aGlzLmNvbnRleHRzJiZ0aGlzLmNvbnRleHRzLmxlbmd0aD4xKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXhpdCBmcmFtZSwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpLHRoaXMuY3VycmVudENvbnRleHRJZHMuc2hpZnQoKX0sZS5wcm90b3R5cGUubmV4dEl0ZXJhdGlvbj1mdW5jdGlvbigpe2lmKCEodGhpcy5jb250ZXh0cyYmdGhpcy5jb250ZXh0cy5sZW5ndGg+MCkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY3JlYXNlIGZyYW1lIGl0ZXJhdGlvbiwgdGhlIGNvbnRleHQgaXMgZW1wdHlcIik7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5sYXN0SWQrKzt2YXIgZT1PYmplY3QuYXNzaWduKHt9LHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGgtMV0pO2UuaXRlcmF0aW9uSWQrPTEsZS5pZD10aGlzLmxhc3RJZCx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSwxLGUpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLDEsdGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSl9LGUucHJvdG90eXBlLmdldFdlaWdodD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXBbZV19LGUucHJvdG90eXBlLmFkZFRlbnNvckFycmF5PWZ1bmN0aW9uKGUpe3RoaXMudGVuc29yQXJyYXlNYXBbZS5pZF09ZX0sZS5wcm90b3R5cGUuZ2V0VGVuc29yQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGVuc29yQXJyYXlNYXBbZV19LGV9KCksR3JhcGhFeGVjdXRvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5ncmFwaD1lLHRoaXMuY29tcGlsZWRNYXA9bmV3IE1hcCx0aGlzLl93ZWlnaHRNYXA9e30sdGhpcy5TRVBFUkFUT1I9XCIsXCIsdGhpcy5wbGFjZWhvbGRlcnM9ZS5wbGFjZWhvbGRlcnMsdGhpcy5fb3V0cHV0cz1lLm91dHB1dHMsdGhpcy5jb21waWxlKCl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodE1hcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd2VpZ2h0TWFwfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSk7dGhpcy53ZWlnaHRJZHM9W10uY29uY2F0LmFwcGx5KFtdLHQpLHRoaXMuX3dlaWdodE1hcD1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZWhvbGRlcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOmUubmFtZSxzaGFwZTplLmF0dHJQYXJhbXMuc2hhcGU/ZS5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlOnZvaWQgMCxkdHlwZTplLmF0dHJQYXJhbXMuZHR5cGU/ZS5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlOnZvaWQgMH19KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bmFtZTplLm5hbWUsc2hhcGU6ZS5hdHRyUGFyYW1zLnNoYXBlP2UuYXR0clBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6ZS5hdHRyUGFyYW1zLmR0eXBlP2UuYXR0clBhcmFtcy5kdHlwZS52YWx1ZTp2b2lkIDB9fSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wbGFjZWhvbGRlcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaXNDb250cm9sRmxvd01vZGVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLndpdGhDb250cm9sRmxvd30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpc0R5bmFtaWNTaGFwZU1vZGVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLndpdGhEeW5hbWljU2hhcGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuY29tcGlsZT1mdW5jdGlvbihlKXtpZighdGhpcy5ncmFwaC53aXRoQ29udHJvbEZsb3cmJiF0aGlzLmdyYXBoLndpdGhEeW5hbWljU2hhcGUpe3ZhciB0PVtdLGE9ZXx8dGhpcy5ncmFwaC5wbGFjZWhvbGRlcnMscj1hLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkuc29ydCgpLmpvaW4odGhpcy5TRVBFUkFUT1IpO2lmKCF0aGlzLmNvbXBpbGVkTWFwLmdldChyKSl7Zm9yKHZhciBuPWEuY29uY2F0KHRoaXMuZ3JhcGgud2VpZ2h0cykscz17fTtuLmxlbmd0aD4wOyl7dmFyIG89bi5wb3AoKTtzW28ubmFtZV09ITAsdC5wdXNoKG8pLG8uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihlKXshc1tlLm5hbWVdJiZlLmlucHV0TmFtZXMuZXZlcnkoZnVuY3Rpb24oZSl7dmFyIHQ9Z2V0Tm9kZU5hbWVBbmRJbmRleChlKVswXTtyZXR1cm4gc1t0XX0pJiZuLnB1c2goZSl9KX10aGlzLmNvbXBpbGVkTWFwLnNldChyLHQpfX19LGUucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oZSx0LGEpe3ZhciByPXRoaXM7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciBuPU9iamVjdC5rZXlzKGUpLnNvcnQoKTt0aGlzLmNoZWNrSW5wdXQoZSx0KSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUoZSx0KSx0aGlzLmNvbXBpbGUobi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHIuZ3JhcGgubm9kZXNbZV19KSk7dmFyIHM9dGhpcy5jYWxjdWxhdGVPdXRwdXRzKGEpO3RoaXMuY2hlY2tPdXRwdXQodGhpcy5jb21waWxlZE1hcC5nZXQobi5qb2luKHRoaXMuU0VQRVJBVE9SKSkscyk7dmFyIG89e307cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEV4ZWN1dGlvbkNvbnRleHQoci5fd2VpZ2h0TWFwLG8pLGE9X19hc3NpZ24oe30sci53ZWlnaHRNYXAsZSkscD1yLmdldEZyb3plblRlbnNvcklkcyhhKSxpPXt9LHU9ci5jb21waWxlZE1hcC5nZXQobi5qb2luKHIuU0VQRVJBVE9SKSksbT0wO208dS5sZW5ndGg7bSsrKXt2YXIgYz11W21dO2lmKGFbYy5uYW1lXXx8KGFbYy5uYW1lXT1leGVjdXRlT3AkMTYoYyxhLHQpLHIuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChjLm5hbWUsYyxhLHQscCxzLGkpKSxzLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiEhYVtlXX0pKWJyZWFrfXJldHVybiByLmZpbmRPdXRwdXRzKGEsdCxzKX0pfSxlLnByb3RvdHlwZS5nZXRGcm96ZW5UZW5zb3JJZHM9ZnVuY3Rpb24oZSl7dmFyIHQ9W10uY29uY2F0LmFwcGx5KFtdLE9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KX0pKTtyZXR1cm4gbmV3IFNldCh0KX0sZS5wcm90b3R5cGUuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbD1mdW5jdGlvbihlLHQsYSxyLG4scyxvKXtcImNvbnRyb2xcIiE9PXQuY2F0ZWdvcnkmJi0xPT09cy5pbmRleE9mKGUpJiYoYVtlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPWUmJihvW2UuaWRdPShvW2UuaWRdfHwwKSt0LmNoaWxkcmVuLmxlbmd0aCl9KSx0LmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKFwiY29udHJvbFwiIT09ZS5jYXRlZ29yeSl7dmFyIHQ9Z2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dChlLm5hbWUsYSxyKTtudWxsIT10JiZ0LmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZSYmIW4uaGFzKGUuaWQpKXt2YXIgdD1vW2UuaWRdOzE9PT10PyhlLmRpc3Bvc2UoKSxkZWxldGUgb1tlLmlkXSk6bnVsbCE9dCYmb1tlLmlkXS0tfX0pfX0pKX0sZS5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxyLG4scyxvLHAsaSx1LG09dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihjKXtzd2l0Y2goYy5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmNoZWNrSW5wdXQoZSwhMSksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKGUsITEpLGE9e30scj1uZXcgRXhlY3V0aW9uQ29udGV4dCh0aGlzLl93ZWlnaHRNYXAsYSksbj10aGlzLmNhbGN1bGF0ZU91dHB1dHModCksWzQsdGhpcy5leGVjdXRlV2l0aENvbnRyb2xGbG93KGUscixuKV07Y2FzZSAxOnJldHVybiBzPWMuc2VudCgpLG89dGhpcy5maW5kT3V0cHV0cyhzLHIsdCkscD1PYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG9bZV0uaWR9KSxpPU9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KX0pLHU9W10uY29uY2F0LmFwcGx5KFtdLGkpLE9iamVjdC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24oZSl7c1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UmJiFlLmlzRGlzcG9zZWQmJi0xPT09cC5pbmRleE9mKGUuaWQpJiYtMT09PXUuaW5kZXhPZihlLmlkKSYmLTE9PT1tLndlaWdodElkcy5pbmRleE9mKGUuaWQpJiZlLmRpc3Bvc2UoKX0pfSksWzIsb119fSl9KX0sZS5wcm90b3R5cGUuZXhlY3V0ZVdpdGhDb250cm9sRmxvdz1mdW5jdGlvbihlLHQsYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLHMsbyxwLGksdSxtLGM9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihsKXtzd2l0Y2gobC5sYWJlbCl7Y2FzZSAwOnI9T2JqZWN0LmtleXMoZSksbj1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gYy5ncmFwaC5ub2Rlc1tlXX0pLHM9bi5jb25jYXQodGhpcy5ncmFwaC53ZWlnaHRzKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue25vZGU6ZSxjb250ZXh0czp0LmN1cnJlbnRDb250ZXh0fX0pLG89X19hc3NpZ24oe30sdGhpcy53ZWlnaHRNYXAsZSkscD17fSxpPXRoaXMuZ2V0RnJvemVuVGVuc29ySWRzKG8pLHU9e30sbC5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gcy5sZW5ndGg+MD8obT10aGlzLnByb2Nlc3NTdGFjayhuLHMsdCxvLHUsaSxhLHApLFs0LFByb21pc2UuYWxsKG0pXSk6WzMsM107Y2FzZSAyOnJldHVybiBsLnNlbnQoKSxbMywxXTtjYXNlIDM6cmV0dXJuWzIsb119fSl9KX0sZS5wcm90b3R5cGUucHJvY2Vzc1N0YWNrPWZ1bmN0aW9uKGUsdCxhLHIsbixzLG8scCl7Zm9yKHZhciBpPXRoaXMsdT1bXSxtPWZ1bmN0aW9uKCl7dmFyIG09dC5wb3AoKTthLmN1cnJlbnRDb250ZXh0PW0uY29udGV4dHM7dmFyIGw9XCJcIjtpZihcIkVudGVyXCI9PT1tLm5vZGUub3AmJmdldFBhcmFtVmFsdWUoXCJpc0NvbnN0YW50XCIsbS5ub2RlLHIsYSkmJihsPWdldE5vZGVOYW1lQW5kSW5kZXgobS5ub2RlLm5hbWUsYSlbMF0pLC0xPT09ZS5pbmRleE9mKG0ubm9kZSkpe3ZhciBkPWV4ZWN1dGVPcCQxNihtLm5vZGUscixhKTtsfHwobD1nZXROb2RlTmFtZUFuZEluZGV4KG0ubm9kZS5uYW1lLGEpWzBdKTt2YXIgeT1hLmN1cnJlbnRDb250ZXh0O2QgaW5zdGFuY2VvZiBQcm9taXNlP3UucHVzaChkLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHJbbF09ZSxhLmN1cnJlbnRDb250ZXh0PXksaS5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGwsbS5ub2RlLHIsYSxzLG8scCksaS5wcm9jZXNzQ2hpbGROb2RlcyhtLm5vZGUsdCxhLHIsbiksZX0pKToocltsXT1kLGMuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChsLG0ubm9kZSxyLGEscyxvLHApLGMucHJvY2Vzc0NoaWxkTm9kZXMobS5ub2RlLHQsYSxyLG4pKX1lbHNlIGMucHJvY2Vzc0NoaWxkTm9kZXMobS5ub2RlLHQsYSxyLG4pfSxjPXRoaXM7dC5sZW5ndGg+MDspbSgpO3JldHVybiB1fSxlLnByb3RvdHlwZS5wcm9jZXNzQ2hpbGROb2Rlcz1mdW5jdGlvbihlLHQsYSxyLG4pe2UuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcz1nZXROb2RlTmFtZUFuZEluZGV4KGUubmFtZSxhKVswXTtuW3NdfHwoXCJNZXJnZVwiPT09ZS5vcD9lLmlucHV0TmFtZXMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4hIWdldFRlbnNvcihlLHIsYSl9KSYmKG5bc109ITAsdC5wdXNoKHtjb250ZXh0czphLmN1cnJlbnRDb250ZXh0LG5vZGU6ZX0pKTplLmlucHV0TmFtZXMuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuISFnZXRUZW5zb3IoZSxyLGEpfSkmJihuW3NdPSEwLHQucHVzaCh7Y29udGV4dHM6YS5jdXJyZW50Q29udGV4dCxub2RlOmV9KSkpfSl9LGUucHJvdG90eXBlLmNhbGN1bGF0ZU91dHB1dHM9ZnVuY3Rpb24oZSl7cmV0dXJuIWV8fGUgaW5zdGFuY2VvZiBBcnJheXx8KGU9W2VdKSxlfHx0aGlzLmdyYXBoLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KX0sZS5wcm90b3R5cGUuZmluZE91dHB1dHM9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiB0aGlzLmNhbGN1bGF0ZU91dHB1dHMoYSkucmVkdWNlKGZ1bmN0aW9uKGEscil7cmV0dXJuIGFbcl09Z2V0VGVuc29yKHIsZSx0KSxhfSx7fSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO09iamVjdC5rZXlzKHRoaXMud2VpZ2h0TWFwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLndlaWdodE1hcFt0XS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRpc3Bvc2UoKX0pfSl9LGUucHJvdG90eXBlLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGU9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMCksdGhpcy5wbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgcj1lW2EubmFtZV07aWYodHx8cil7dmFyIG49clswXTtpZihhLmF0dHJQYXJhbXMuc2hhcGUmJmEuYXR0clBhcmFtcy5zaGFwZS52YWx1ZSl7dmFyIHM9YS5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlLG89cy5sZW5ndGg9PT1uLnNoYXBlLmxlbmd0aCYmbi5zaGFwZS5ldmVyeShmdW5jdGlvbihlLHQpe3JldHVybi0xPT09c1t0XXx8c1t0XT09PWV9KTt1dGlsLmFzc2VydChvLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgc2hhcGUgb2YgZGljdFsnXCIrYS5uYW1lK1wiJ10gcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBtdXN0IGJlIFtcIitzK1wiXSwgYnV0IHdhcyBbXCIrbi5zaGFwZStcIl1cIn0pfWEuYXR0clBhcmFtcy5kdHlwZSYmYS5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlJiZ1dGlsLmFzc2VydChuLmR0eXBlPT09YS5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgb2YgZGljdFsnXCIrYS5uYW1lK1wiJ10gcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBtdXN0IGJlIFwiK2EuYXR0clBhcmFtcy5kdHlwZS52YWx1ZStcIiwgYnV0IHdhcyBcIituLmR0eXBlfSl9fSl9LGUucHJvdG90eXBlLmNoZWNrSW5wdXQ9ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzO3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgcj1PYmplY3Qua2V5cyhlKSxuPVtdLHM9W107dGhpcy5pbnB1dE5vZGVzLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT1yLmluZGV4T2YoZSkmJm4ucHVzaChlKX0pLHIuZm9yRWFjaChmdW5jdGlvbihlKXstMT09PWEuaW5wdXROb2Rlcy5pbmRleE9mKGUpJiZzLnB1c2goZSl9KTt2YXIgbz1zLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hYS5ncmFwaC5ub2Rlc1tlXX0pO2lmKG4ubGVuZ3RoPjAmJnQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgdGhlIGtleXMgW1wiK3IrXCJdLCBidXQgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQga2V5czogW1wiK24rXCJdLlwiKTtpZihzLmxlbmd0aD4wJiZ0KXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIHVudXNlZCBrZXlzOiBbXCIrcytcIl0uIFBsZWFzZSBwcm92aWRlIG9ubHkgdGhlIGZvbGxvd2luZyBrZXlzOiBbXCIrdGhpcy5pbnB1dE5vZGVzK1wiXS5cIik7aWYoby5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyBrZXlzOiBbXCIrbytcIl0gbm90IHBhcnQgb2YgbW9kZWwgZ3JhcGguXCIpfSxlLnByb3RvdHlwZS5jaGVja091dHB1dD1mdW5jdGlvbihlLHQpe3ZhciBhPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSxyPVtdO2lmKHQuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1wYXJzZU5vZGVOYW1lKGUpWzBdOy0xPT09YS5pbmRleE9mKHQpJiZyLnB1c2godCl9KSxyLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIlRoZSBmb2xsb3dpbmcgb3V0cHV0cyBhcmUgbm90IGdlbmVyYXRlZCBieSB0aGUgZXhlY3V0aW9uOiBbXCIrcitcIl0uXCIpfSxlfSgpLFRGSFVCX1NFQVJDSF9QQVJBTT1cIj90ZmpzLWZvcm1hdD1maWxlXCIsREVGQVVMVF9NT0RFTF9OQU1FPVwibW9kZWwuanNvblwiLEdyYXBoTW9kZWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pLHRoaXMubW9kZWxVcmw9ZSx0aGlzLmxvYWRPcHRpb25zPXQsdGhpcy52ZXJzaW9uPVwibi9hXCIsbnVsbD09dCYmKHRoaXMubG9hZE9wdGlvbnM9e30pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJtb2RlbFZlcnNpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVyc2lvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbnB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0Tm9kZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0Tm9kZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwid2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci53ZWlnaHRNYXB9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuZmluZElPSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubW9kZWxVcmw7aWYobnVsbCE9ZS5sb2FkKXRoaXMuaGFuZGxlcj1lO2Vsc2UgaWYobnVsbCE9dGhpcy5sb2FkT3B0aW9ucy5yZXF1ZXN0SW5pdCl0aGlzLmhhbmRsZXI9aW8uYnJvd3NlckhUVFBSZXF1ZXN0KGUsdGhpcy5sb2FkT3B0aW9ucyk7ZWxzZXt2YXIgdD1pby5nZXRMb2FkSGFuZGxlcnMoZSx0aGlzLmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MpO2lmKDA9PT10Lmxlbmd0aCl0LnB1c2goaW8uYnJvd3NlckhUVFBSZXF1ZXN0KGUsdGhpcy5sb2FkT3B0aW9ucykpO2Vsc2UgaWYodC5sZW5ndGg+MSl0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIit0Lmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3IgVVJMICdcIitbZV0rXCInXCIpO3RoaXMuaGFuZGxlcj10WzBdfX0sZS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsdCxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYodGhpcy5maW5kSU9IYW5kbGVyKCksbnVsbD09dGhpcy5oYW5kbGVyLmxvYWQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLlwiKTtyZXR1cm5bNCx0aGlzLmhhbmRsZXIubG9hZCgpXTtjYXNlIDE6cmV0dXJuIGU9ci5zZW50KCksdD1lLm1vZGVsVG9wb2xvZ3ksdGhpcy52ZXJzaW9uPXQudmVyc2lvbnMucHJvZHVjZXIrXCIuXCIrdC52ZXJzaW9ucy5taW5Db25zdW1lcixhPWlvLmRlY29kZVdlaWdodHMoZS53ZWlnaHREYXRhLGUud2VpZ2h0U3BlY3MpLHRoaXMuZXhlY3V0b3I9bmV3IEdyYXBoRXhlY3V0b3IoT3BlcmF0aW9uTWFwcGVyLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKHQpKSx0aGlzLmV4ZWN1dG9yLndlaWdodE1hcD10aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoYSksWzIsITBdfX0pfSl9LGUucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5leGVjdXRlXyhlLCEwLHRoaXMub3V0cHV0Tm9kZXMpfSxlLnByb3RvdHlwZS5jb25zdHJ1Y3RUZW5zb3JNYXA9ZnVuY3Rpb24oZSl7dmFyIHQ9ZSBpbnN0YW5jZW9mIFRlbnNvcj9bZV06ZTtpZih0Lmxlbmd0aCE9PXRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdGVuc29yIGNvdW50IG1pc21hdGNoLHRoZSBncmFwaCBtb2RlbCBoYXMgXCIrdGhpcy5pbnB1dE5vZGVzLmxlbmd0aCtcIiBwbGFjZWhvbGRlcnMsIHdoaWxlIHRoZXJlIGFyZSBcIit0Lmxlbmd0aCtcIiBpbnB1dCB0ZW5zb3JzLlwiKTtyZXR1cm4gdGhpcy5pbnB1dE5vZGVzLnJlZHVjZShmdW5jdGlvbihlLGEscil7cmV0dXJuIGVbYV09dFtyXSxlfSx7fSl9LGUucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5leGVjdXRlXyhlLCExLHQpfSxlLnByb3RvdHlwZS5leGVjdXRlXz1mdW5jdGlvbihlLHQsYSl7aWYodm9pZCAwPT09dCYmKHQ9ITApLGE9YXx8dGhpcy5vdXRwdXROb2RlcywoZSBpbnN0YW5jZW9mIFRlbnNvcnx8QXJyYXkuaXNBcnJheShlKSkmJihlPXRoaXMuY29uc3RydWN0VGVuc29yTWFwKGUpKSx0aGlzLmV4ZWN1dG9yLmlzQ29udHJvbEZsb3dNb2RlbHx8dGhpcy5leGVjdXRvci5pc0R5bmFtaWNTaGFwZU1vZGVsKXRocm93IG5ldyBFcnJvcihcIlRoZSBtb2RlbCBjb250YWlucyBjb250cm9sIGZsb3cgb3IgZHluYW1pYyBzaGFwZSBvcHMsIHBsZWFzZSB1c2UgZXhlY3V0ZUFzeW5jIG1ldGhvZFwiKTt2YXIgcj10aGlzLmV4ZWN1dG9yLmV4ZWN1dGUodGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKGUpLHQsYSksbj1PYmplY3Qua2V5cyhyKTtyZXR1cm4gQXJyYXkuaXNBcnJheShhKSYmYS5sZW5ndGg+MT9hLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcltlXX0pOnJbblswXV19LGUucHJvdG90eXBlLmV4ZWN1dGVBc3luYz1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGEscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOmlmKCF0aGlzLmV4ZWN1dG9yLmlzQ29udHJvbEZsb3dNb2RlbCYmIXRoaXMuZXhlY3V0b3IuaXNEeW5hbWljU2hhcGVNb2RlbCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kZWwgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGZsb3cgb3IgZHluYW1pYyBzaGFwZSBvcHMsIHBsZWFzZSB1c2UgZXhlY3V0ZSBtZXRob2QgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cIik7cmV0dXJuIHQ9dHx8dGhpcy5vdXRwdXROb2RlcywoZSBpbnN0YW5jZW9mIFRlbnNvcnx8QXJyYXkuaXNBcnJheShlKSkmJihlPXRoaXMuY29uc3RydWN0VGVuc29yTWFwKGUpKSxbNCx0aGlzLmV4ZWN1dG9yLmV4ZWN1dGVBc3luYyh0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoZSksdCldO2Nhc2UgMTpyZXR1cm4gYT1uLnNlbnQoKSxyPU9iamVjdC5rZXlzKGEpLFsyLEFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPjE/dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGFbZV19KTphW3JbMF1dXX19KX0pfSxlLnByb3RvdHlwZS5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoZnVuY3Rpb24odCxhKXtyZXR1cm4gdFthXT1bZVthXV0sdH0se30pfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5leGVjdXRvci5kaXNwb3NlKCl9LGV9KCk7ZnVuY3Rpb24gbG9hZEdyYXBoTW9kZWwoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwibW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWwoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgYSB1cmwgb3IgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgdGhlIG1vZGVsXCIpO3JldHVybiBudWxsPT10JiYodD17fSksdC5mcm9tVEZIdWImJm51bGw9PWUubG9hZCYmKGUuZW5kc1dpdGgoXCIvXCIpfHwoZSs9XCIvXCIpLGU9XCJcIitlK0RFRkFVTFRfTU9ERUxfTkFNRStURkhVQl9TRUFSQ0hfUEFSQU0pLFs0LChhPW5ldyBHcmFwaE1vZGVsKGUsdCkpLmxvYWQoKV07Y2FzZSAxOnJldHVybiByLnNlbnQoKSxbMixhXX19KX0pfXZhciB2ZXJzaW9uPVwiMS4xLjJcIjtleHBvcnR7R3JhcGhNb2RlbCxsb2FkR3JhcGhNb2RlbCx2ZXJzaW9uIGFzIHZlcnNpb25fY29udmVydGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvbnZlcnRlci5lc20uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgdD1mdW5jdGlvbihlLG4pe3JldHVybih0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfSkoZSxuKX07ZnVuY3Rpb24gZShlLG4pe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLG4pLGUucHJvdG90eXBlPW51bGw9PT1uP09iamVjdC5jcmVhdGUobik6KHIucHJvdG90eXBlPW4ucHJvdG90eXBlLG5ldyByKX12YXIgbj1mdW5jdGlvbigpe3JldHVybihuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBvIGluIGU9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gcih0LGUsbixyKXtyZXR1cm4gbmV3KG58fChuPVByb21pc2UpKShmdW5jdGlvbihvLGEpe2Z1bmN0aW9uIGkodCl7dHJ5e3Uoci5uZXh0KHQpKX1jYXRjaCh0KXthKHQpfX1mdW5jdGlvbiBzKHQpe3RyeXt1KHIudGhyb3codCkpfWNhdGNoKHQpe2EodCl9fWZ1bmN0aW9uIHUodCl7dC5kb25lP28odC52YWx1ZSk6bmV3IG4oZnVuY3Rpb24oZSl7ZSh0LnZhbHVlKX0pLnRoZW4oaSxzKX11KChyPXIuYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBvKHQsZSl7dmFyIG4scixvLGEsaT17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZvWzBdKXRocm93IG9bMV07cmV0dXJuIG9bMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gYT17bmV4dDpzKDApLHRocm93OnMoMSkscmV0dXJuOnMoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGFbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksYTtmdW5jdGlvbiBzKGEpe3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm4gZnVuY3Rpb24oYSl7aWYobil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO2k7KXRyeXtpZihuPTEsciYmKG89MiZhWzBdP3IucmV0dXJuOmFbMF0/ci50aHJvd3x8KChvPXIucmV0dXJuKSYmby5jYWxsKHIpLDApOnIubmV4dCkmJiEobz1vLmNhbGwocixhWzFdKSkuZG9uZSlyZXR1cm4gbztzd2l0Y2gocj0wLG8mJihhPVsyJmFbMF0sby52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6bz1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gaS5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTppLmxhYmVsKysscj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPWkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz0obz1pLnRyeXMpLmxlbmd0aD4wJiZvW28ubGVuZ3RoLTFdKSYmKDY9PT1hWzBdfHwyPT09YVswXSkpe2k9MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFvfHxhWzFdPm9bMF0mJmFbMV08b1szXSkpe2kubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmaS5sYWJlbDxvWzFdKXtpLmxhYmVsPW9bMV0sbz1hO2JyZWFrfWlmKG8mJmkubGFiZWw8b1syXSl7aS5sYWJlbD1vWzJdLGkub3BzLnB1c2goYSk7YnJlYWt9b1syXSYmaS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlfWE9ZS5jYWxsKHQsaSl9Y2F0Y2godCl7YT1bNix0XSxyPTB9ZmluYWxseXtuPW89MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2Esc10pfX19dmFyIGEsaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5nbG9iYWw9dCx0aGlzLmZsYWdzPXt9LHRoaXMuZmxhZ1JlZ2lzdHJ5PXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9cmV0dXJuIHQucHJvdG90eXBlLnJlZ2lzdGVyRmxhZz1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5mbGFnUmVnaXN0cnlbdF09e2V2YWx1YXRpb25GbjplLHNldEhvb2s6bn0sbnVsbCE9dGhpcy51cmxGbGFnc1t0XSl7dmFyIHI9dGhpcy51cmxGbGFnc1t0XTtjb25zb2xlLndhcm4oXCJTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgXCIrdCtcIjogXCIrcitcIi5cIiksdGhpcy5zZXQodCxyKX19LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLmZsYWdzP3RoaXMuZmxhZ3NbdF06KHRoaXMuZmxhZ3NbdF09dGhpcy5ldmFsdWF0ZUZsYWcodCksdGhpcy5mbGFnc1t0XSl9LHQucHJvdG90eXBlLmdldE51bWJlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRGbGFncz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJmZWF0dXJlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGZsYWcgXCIrdCtcIiBhcyBpdCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cIik7dGhpcy5mbGFnc1t0XT1lLG51bGwhPXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2smJnRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2soZSl9LHQucHJvdG90eXBlLmV2YWx1YXRlRmxhZz1mdW5jdGlvbih0KXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXZhbHVhdGUgZmxhZyAnXCIrdCtcIic6IG5vIGV2YWx1YXRpb24gZnVuY3Rpb24gZm91bmQuXCIpO3JldHVybiB0aGlzLmZsYWdSZWdpc3RyeVt0XS5ldmFsdWF0aW9uRm4oKX0sdC5wcm90b3R5cGUuc2V0RmxhZ3M9ZnVuY3Rpb24odCl7dGhpcy5mbGFncz1PYmplY3QuYXNzaWduKHt9LHQpfSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuZmxhZ3M9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX0sdC5wcm90b3R5cGUucG9wdWxhdGVVUkxGbGFncz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodm9pZCAwIT09dGhpcy5nbG9iYWwmJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpe3ZhciBlPXModGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKTtpZihcInRmanNmbGFnc1wiaW4gZSllLnRmanNmbGFncy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLnNwbGl0KFwiOlwiKSxyPW5bMF0sbz1uWzFdO3QudXJsRmxhZ3Nbcl09ZnVuY3Rpb24odCxlKXtpZihcInRydWVcIj09PShlPWUudG9Mb3dlckNhc2UoKSl8fFwiZmFsc2VcIj09PWUpcmV0dXJuXCJ0cnVlXCI9PT1lO2lmKFwiXCIrICtlPT09ZSlyZXR1cm4rZTt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgdmFsdWUgZmxhZyB2YWx1ZSBcIitlK1wiIGZvciBmbGFnIFwiK3QrXCIuXCIpfShyLG8pfSl9fSx0fSgpO2Z1bmN0aW9uIHModCl7dmFyIGU9e307cmV0dXJuIHQucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZyxmdW5jdGlvbih0KXtmb3IodmFyIG49W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RbZGVjb2RlVVJJQ29tcG9uZW50KGUpXT1kZWNvZGVVUklDb21wb25lbnQobnx8XCJcIil9KGUsblswXSxuWzFdKSxuLmpvaW4oXCI9XCIpfSksZX1mdW5jdGlvbiB1KHQpe2E9dH12YXIgbD1PYmplY3QuZnJlZXplKHtFbnZpcm9ubWVudDppLGdldFF1ZXJ5UGFyYW1zOnMsZ2V0IEVOVigpe3JldHVybiBhfSxzZXRFbnZpcm9ubWVudEdsb2JhbDp1fSk7ZnVuY3Rpb24gYyh0KXtmb3IodmFyIGU9dC5sZW5ndGgsbj0wLHI9MDtlPjA7KXI9TWF0aC5yYW5kb20oKSplfDAsbj10Wy0tZV0sdFtlXT10W3JdLHRbcl09bn1mdW5jdGlvbiBoKHQsZSxuKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKX1mdW5jdGlvbiBwKHQpe3JldHVybiB0JTI9PTA/dDp0KzF9ZnVuY3Rpb24gZih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBkKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX1mdW5jdGlvbiB2KHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIlwiKSxkKHgodCxlKSxmdW5jdGlvbigpe3JldHVybiBuK1wiIFNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiIG11c3QgbWF0Y2hcIn0pfWZ1bmN0aW9uIG0odCl7ZChudWxsIT10LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgaW5wdXQgdG8gdGhlIHRlbnNvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgbm9uLW51bGwgdmFsdWUuXCJ9KX1mdW5jdGlvbiBnKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9W10pLG51bGw9PWUmJihlPVtdKSxBcnJheS5pc0FycmF5KHQpfHxfKHQpKWZvcih2YXIgbj0wO248dC5sZW5ndGg7KytuKWcodFtuXSxlKTtlbHNlIGUucHVzaCh0KTtyZXR1cm4gZX1mdW5jdGlvbiB5KHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gMTtmb3IodmFyIGU9dFswXSxuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiB4KHQsZSl7aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09dHx8bnVsbD09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl0hPT1lW25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHcodCl7cmV0dXJuIHQlMT09MH1mdW5jdGlvbiBiKHQpe2lmKG51bGwhPU1hdGgudGFuaClyZXR1cm4gTWF0aC50YW5oKHQpO2lmKHQ9PT0xLzApcmV0dXJuIDE7aWYodD09PS0xLzApcmV0dXJuLTE7dmFyIGU9TWF0aC5leHAoMip0KTtyZXR1cm4oZS0xKS8oZSsxKX1mdW5jdGlvbiBDKHQpe3ZhciBlPU1hdGguY2VpbChNYXRoLnNxcnQodCkpO3JldHVybltlLE1hdGguY2VpbCh0L2UpXX1mdW5jdGlvbiBFKHQsZSl7cmV0dXJuIGU8PXQubGVuZ3RoP3Q6dCtcIiBcIi5yZXBlYXQoZS10Lmxlbmd0aCl9ZnVuY3Rpb24gUih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPWZ1bmN0aW9uKHQpe3JldHVybiAwfSksbmV3IFByb21pc2UoZnVuY3Rpb24ocixvKXt2YXIgYT0wLGk9ZnVuY3Rpb24oKXtpZih0KCkpcigpO2Vsc2V7dmFyIHM9ZSgrK2EpO251bGwhPW4mJmE+PW4/bygpOnNldFRpbWVvdXQoaSxzKX19O2koKX0pfWZ1bmN0aW9uIFModCxlKXtmb3IodmFyIG49MSxyPS0xLG89MDtvPHQubGVuZ3RoOysrbylpZih0W29dPj0wKW4qPXRbb107ZWxzZSBpZigtMT09PXRbb10pe2lmKC0xIT09cil0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gRm91bmQgLTEgYXQgZGltIFwiK3IrXCIgYW5kIGRpbSBcIitvKTtyPW99ZWxzZSBpZih0W29dPDApdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8IDAuIEZvdW5kIFwiK3Rbb10rXCIgYXQgZGltIFwiK28pO2lmKC0xPT09cil7aWYoZT4wJiZlIT09bil0aHJvdyBFcnJvcihcIlNpemUoXCIrZStcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIit0KTtyZXR1cm4gdH1pZigwPT09bil0aHJvdyBFcnJvcihcIkNhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBzaXplIGluIFtcIit0K1wiXSB3aGVuIHRoZXJlIGFyZSAwIGVsZW1lbnRzXCIpO2lmKGUlbiE9MCl0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBHb3QgXCIrZStcIiAvIFwiK24pO3ZhciBhPXQuc2xpY2UoKTtyZXR1cm4gYVtyXT1lL24sYX1mdW5jdGlvbiBOKHQsZSl7dmFyIG49ZS5sZW5ndGg7cmV0dXJuIGQoKHQ9bnVsbD09dD9lLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBlfSk6W10uY29uY2F0KHQpKS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdD49LW4mJnQ8bn0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiK24rXCIsIFwiK24rXCIpIGJ1dCBnb3QgYXhpcyBcIit0fSksZCh0LmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB3KHQpfSksZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyBcIit0fSksdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9uK3Q6dH0pfWZ1bmN0aW9uIGsodCxlKXtmb3IodmFyIG49W10scj1bXSxvPW51bGw9PWU/bnVsbDpOKGUsdCkuc29ydCgpLGE9MCxpPTA7aTx0Lmxlbmd0aDsrK2kpe2lmKG51bGwhPW8pe2lmKG9bYV09PT1pJiYxIT09dFtpXSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzcXVlZXplIGF4aXMgXCIraStcIiBzaW5jZSBpdHMgZGltICdcIit0W2ldK1wiJyBpcyBub3QgMVwiKTsobnVsbD09b1thXXx8b1thXT5pKSYmMT09PXRbaV0mJihuLnB1c2godFtpXSksci5wdXNoKGkpKSxvW2FdPD1pJiZhKyt9MSE9PXRbaV0mJihuLnB1c2godFtpXSksci5wdXNoKGkpKX1yZXR1cm57bmV3U2hhcGU6bixrZXB0RGltczpyfX1mdW5jdGlvbiBJKHQsZSl7dmFyIG49bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpbj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dCluPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2V7aWYoXCJib29sXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO249bmV3IFVpbnQ4QXJyYXkoZSl9cmV0dXJuIG59ZnVuY3Rpb24gQSh0LGUpe3ZhciBuPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KW49bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpbj1uZXcgSW50MzJBcnJheShlKTtlbHNlIGlmKFwiYm9vbFwiPT09dCluPW5ldyBVaW50OEFycmF5KGUpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7bj1uZXcgQXJyYXkoZSl9cmV0dXJuIG59ZnVuY3Rpb24gVCh0LGUsbil7aWYoXCJmbG9hdDMyXCI9PT1lKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO2lmKGlzTmFOKG8pfHwhaXNGaW5pdGUobykpdGhyb3cgRXJyb3IoXCJUaGUgcmVzdWx0IG9mIHRoZSAnXCIrbitcIicgaXMgXCIrbytcIi5cIil9fWZ1bmN0aW9uIEQodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtpZihpc05hTihyKXx8IWlzRmluaXRlKHIpKXRocm93IEVycm9yKFwiQSB0ZW5zb3Igb2YgdHlwZSBcIitlK1wiIGJlaW5nIHVwbG9hZGVkIGNvbnRhaW5zIFwiK3IrXCIuXCIpfX1mdW5jdGlvbiBPKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIiE9PWUmJigoXCJmbG9hdDMyXCIhPT1lfHxcImNvbXBsZXg2NFwiPT09dCkmJigoXCJpbnQzMlwiIT09ZXx8XCJmbG9hdDMyXCI9PT10fHxcImNvbXBsZXg2NFwiPT09dCkmJihcImJvb2xcIiE9PWV8fFwiYm9vbFwiIT09dCkpKX1mdW5jdGlvbiBfKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9ZnVuY3Rpb24gTSh0KXtpZihcImZsb2F0MzJcIj09PXR8fFwiaW50MzJcIj09PXQpcmV0dXJuIDQ7aWYoXCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIDg7aWYoXCJib29sXCI9PT10KXJldHVybiAxO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrdCl9ZnVuY3Rpb24gRih0KXtpZihudWxsPT10KXJldHVybiAwO3ZhciBlPTA7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZSs9Mip0Lmxlbmd0aH0pLGV9ZnVuY3Rpb24gQih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIFN0cmluZ31mdW5jdGlvbiBQKHQpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdH1mdW5jdGlvbiBMKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIFcodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/Vyh0WzBdKTp0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P1wiZmxvYXQzMlwiOnQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheT9cImludDMyXCI6TCh0KT9cImZsb2F0MzJcIjpCKHQpP1wic3RyaW5nXCI6UCh0KT9cImJvb2xcIjpcImZsb2F0MzJcIn1mdW5jdGlvbiBVKHQpe3JldHVybiEhKHQmJnQuY29uc3RydWN0b3ImJnQuY2FsbCYmdC5hcHBseSl9ZnVuY3Rpb24geih0LGUpe2Zvcih2YXIgbj1lO248dDsrK24paWYodCVuPT0wKXJldHVybiBuO3JldHVybiB0fWZ1bmN0aW9uIFYodCl7dmFyIGU9dC5sZW5ndGg7aWYoZTwyKXJldHVybltdO3ZhciBuPW5ldyBBcnJheShlLTEpO25bZS0yXT10W2UtMV07Zm9yKHZhciByPWUtMztyPj0wOy0tciluW3JdPW5bcisxXSp0W3IrMV07cmV0dXJuIG59ZnVuY3Rpb24gRyh0LGUsbil7aWYoXCJzdHJpbmdcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYSBzdHJpbmdbXSB0byBhIFR5cGVkQXJyYXlcIik7aWYoQXJyYXkuaXNBcnJheSh0KSYmKHQ9Zyh0KSksbiYmRCh0LGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkmJlwiZmxvYXQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXkmJlwiaW50MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZcImJvb2xcIj09PWV9KHQsZSkpcmV0dXJuIHQ7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpe2Zvcih2YXIgcj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksbz0wO288ci5sZW5ndGg7KytvKTAhPT1NYXRoLnJvdW5kKHRbb10pJiYocltvXT0xKTtyZXR1cm4gcn10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX1mdW5jdGlvbiBxKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlWzBdO3ZhciBuPXQucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pO2lmKDA9PT1uKXJldHVybltdO2lmKG4hPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrdCtcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIGlucHV0IHNpemUuXCIpO3JldHVybiBmdW5jdGlvbiB0KGUsbixyKXt2YXIgbz1uZXcgQXJyYXk7aWYoMT09PW4ubGVuZ3RoKWZvcih2YXIgYT1uWzBdLGk9MDtpPGE7aSsrKW9baV09cltlK2ldO2Vsc2V7YT1uWzBdO3ZhciBzPW4uc2xpY2UoMSksdT1zLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KTtmb3IoaT0wO2k8YTtpKyspb1tpXT10KGUraSp1LHMscil9cmV0dXJuIG99KDAsdCxlKX1mdW5jdGlvbiBIKHQsZSl7Zm9yKHZhciBuPSQodCxlKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT0xO3JldHVybiBufWZ1bmN0aW9uICQodCxlKXtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCk7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9ZnVuY3Rpb24gaigpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwZXJmb3JtYW5jZSlyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3Mpe3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZWFzdXJlIHRpbWUgaW4gdGhpcyBlbnZpcm9ubWVudC4gWW91IHNob3VsZCBydW4gdGYuanMgaW4gdGhlIGJyb3dzZXIgb3IgaW4gTm9kZS5qc1wiKX1mdW5jdGlvbiBLKHQpe3QuZm9yRWFjaChmdW5jdGlvbihlKXtkKE51bWJlci5pc0ludGVnZXIoZSkmJmU+PTAsZnVuY3Rpb24oKXtyZXR1cm5cIlRlbnNvciBtdXN0IGhhdmUgYSBzaGFwZSBjb21wcmlzZWQgb2YgcG9zaXRpdmUgaW50ZWdlcnMgYnV0IGdvdCBzaGFwZSBbXCIrdCtcIl0uXCJ9KX0pfXZhciBYLFk9ZnVuY3Rpb24oKXtpZihudWxsIT1hLmdsb2JhbC5mZXRjaClyZXR1cm4gYS5nbG9iYWwuZmV0Y2g7aWYoYS5nZXQoXCJJU19OT0RFXCIpKXJldHVybiBRLmZldGNoSW1wb3J0KCk7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIGZldGNoKCkgbWV0aG9kLiBQbGVhc2UgYWRkIHlvdXIgb3duIGZldGNoKCkgZnVuY3Rpb24gdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2UuXCIpfSxRPXtmZXRjaEltcG9ydDpmdW5jdGlvbigpe3JldHVybiByZXF1aXJlKFwibm9kZS1mZXRjaFwiKX19O2Z1bmN0aW9uIEoodCxlKXtyZXR1cm4gbnVsbD09WCYmKFg9WSgpKSxYKHQsZSl9dmFyIFo9T2JqZWN0LmZyZWV6ZSh7c2h1ZmZsZTpjLGNsYW1wOmgsbmVhcmVzdExhcmdlckV2ZW46cCxzdW06ZixyYW5kVW5pZm9ybTpmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGgucmFuZG9tKCk7cmV0dXJuIGUqbisoMS1uKSp0fSxkaXN0U3F1YXJlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89TnVtYmVyKHRbcl0pLU51bWJlcihlW3JdKTtuKz1vKm99cmV0dXJuIG59LGFzc2VydDpkLGFzc2VydFNoYXBlc01hdGNoOnYsYXNzZXJ0Tm9uTnVsbDptLGZsYXR0ZW46ZyxzaXplRnJvbVNoYXBlOnksaXNTY2FsYXJTaGFwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQubGVuZ3RofSxhcnJheXNFcXVhbDp4LGlzSW50OncsdGFuaDpiLHNpemVUb1NxdWFyaXNoU2hhcGU6QyxjcmVhdGVTaHVmZmxlZEluZGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50MzJBcnJheSh0KSxuPTA7bjx0OysrbillW25dPW47cmV0dXJuIGMoZSksZX0scmlnaHRQYWQ6RSxyZXBlYXRlZFRyeTpSLGluZmVyRnJvbUltcGxpY2l0U2hhcGU6UyxwYXJzZUF4aXNQYXJhbTpOLHNxdWVlemVTaGFwZTprLGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6SSxnZXRBcnJheUZyb21EVHlwZTpBLGNoZWNrQ29tcHV0YXRpb25Gb3JFcnJvcnM6VCxjaGVja0NvbnZlcnNpb25Gb3JFcnJvcnM6RCxoYXNFbmNvZGluZ0xvc3M6Tyxpc1R5cGVkQXJyYXk6XyxieXRlc1BlckVsZW1lbnQ6TSxieXRlc0Zyb21TdHJpbmdBcnJheTpGLGlzU3RyaW5nOkIsaXNCb29sZWFuOlAsaXNOdW1iZXI6TCxpbmZlckR0eXBlOlcsaXNGdW5jdGlvbjpVLG5lYXJlc3REaXZpc29yOnosY29tcHV0ZVN0cmlkZXM6Vix0b1R5cGVkQXJyYXk6Ryx0b05lc3RlZEFycmF5OnEsbWFrZU9uZXNUeXBlZEFycmF5OkgsbWFrZVplcm9zVHlwZWRBcnJheTokLG5vdzpqLGFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnM6SyxnZXROb2RlRmV0Y2g6USxnZXQgc3lzdGVtRmV0Y2goKXtyZXR1cm4gWH0sZmV0Y2g6Sn0pLHR0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuYmFja2VuZFRpbWVyPXQsdGhpcy5sb2dnZXI9ZSxudWxsPT1lJiYodGhpcy5sb2dnZXI9bmV3IGV0KX1yZXR1cm4gdC5wcm90b3R5cGUucHJvZmlsZUtlcm5lbD1mdW5jdGlvbih0LGUpe3ZhciBuLHI9dGhpcyxvPXRoaXMuYmFja2VuZFRpbWVyLnRpbWUoZnVuY3Rpb24oKXtuPWUoKX0pO3JldHVybihBcnJheS5pc0FycmF5KG4pP246W25dKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUuZGF0YVN5bmMoKTtUKG4sZS5kdHlwZSx0KSxvLnRoZW4oZnVuY3Rpb24obyl7dmFyIGE9XCJcIjtudWxsIT1vLmdldEV4dHJhUHJvZmlsZUluZm8mJihhPW8uZ2V0RXh0cmFQcm9maWxlSW5mbygpKSxyLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKHQsZSxuLG8ua2VybmVsTXMsYSl9KX0pLG59LHR9KCksZXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5sb2dLZXJuZWxQcm9maWxlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9RShyK1wibXNcIiw5KSxpPUUodCwyNSkscz1lLnJhbmssdT1lLnNpemUsbD1FKGUuc2hhcGUudG9TdHJpbmcoKSwxNCk7Y29uc29sZS5sb2coXCIlY1wiK2krXCJcXHQlY1wiK2ErXCJcXHQlY1wiK3MrXCJEIFwiK2wrXCJcXHQlY1wiK3UrXCJcXHQlY1wiK28sXCJmb250LXdlaWdodDpib2xkXCIsXCJjb2xvcjpyZWRcIixcImNvbG9yOmJsdWVcIixcImNvbG9yOiBvcmFuZ2VcIixcImNvbG9yOiBncmVlblwiKX0sdH0oKSxudD0yMCxydD0zLG90PTc7ZnVuY3Rpb24gYXQodCxlLG4scil7dmFyIG89VihlKSxhPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXkoZSksYT1yW3IubGVuZ3RoLTFdLGk9bmV3IEFycmF5KGEpLmZpbGwoMCkscz1lLmxlbmd0aCx1PVwiY29tcGxleDY0XCI9PT1uP3V0KHQpOnQ7aWYocz4xKWZvcih2YXIgbD0wO2w8by9hO2wrKylmb3IodmFyIGM9bCphLGg9MDtoPGE7aCsrKWlbaF09TWF0aC5tYXgoaVtoXSxpdCh1W2MraF0sMCxuKS5sZW5ndGgpO3JldHVybiBpfSh0LGUsbixvKSxpPWUubGVuZ3RoLHM9ZnVuY3Rpb24gdChlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9ITApO3ZhciBzPVwiY29tcGxleDY0XCI9PT1yPzI6MTt2YXIgdT1uWzBdO3ZhciBsPW4ubGVuZ3RoO2lmKDA9PT1sKXtpZihcImNvbXBsZXg2NFwiPT09cil7dmFyIGM9dXQoZSk7cmV0dXJuW2l0KGNbMF0sMCxyKV19cmV0dXJuXCJib29sXCI9PT1yP1tzdChlWzBdKV06W2VbMF0udG9TdHJpbmcoKV19aWYoMT09PWwpe2lmKHU+bnQpe3ZhciBoPXJ0KnMscD1BcnJheS5mcm9tKGUuc2xpY2UoMCxoKSksZj1BcnJheS5mcm9tKGUuc2xpY2UodS1ydCpzLHUpKTtyZXR1cm5cImNvbXBsZXg2NFwiPT09ciYmKHA9dXQocCksZj11dChmKSksW1wiW1wiK3AubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGl0KHQsYVtlXSxyKX0pLmpvaW4oXCIsIFwiKStcIiwgLi4uLCBcIitmLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBpdCh0LGFbdS1ydCtlXSxyKX0pLmpvaW4oXCIsIFwiKStcIl1cIl19dmFyIGQ9XCJjb21wbGV4NjRcIj09PXI/dXQoZSk6QXJyYXkuZnJvbShlKTtyZXR1cm5bXCJbXCIrZC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gaXQodCxhW2VdLHIpfSkuam9pbihcIiwgXCIpK1wiXVwiXX12YXIgdj1uLnNsaWNlKDEpO3ZhciBtPW8uc2xpY2UoMSk7dmFyIGc9b1swXSpzO3ZhciB5PVtdO2lmKHU+bnQpe2Zvcih2YXIgeD0wO3g8cnQ7eCsrKXt2YXIgdz14KmcsYj13K2c7eS5wdXNoLmFwcGx5KHksdChlLnNsaWNlKHcsYiksdixyLG0sYSwhMSkpfXkucHVzaChcIi4uLlwiKTtmb3IodmFyIHg9dS1ydDt4PHU7eCsrKXt2YXIgdz14KmcsYj13K2c7eS5wdXNoLmFwcGx5KHksdChlLnNsaWNlKHcsYiksdixyLG0sYSx4PT09dS0xKSl9fWVsc2UgZm9yKHZhciB4PTA7eDx1O3grKyl7dmFyIHc9eCpnLGI9dytnO3kucHVzaC5hcHBseSh5LHQoZS5zbGljZSh3LGIpLHYscixtLGEseD09PXUtMSkpfXZhciBDPTI9PT1sP1wiLFwiOlwiXCI7eVswXT1cIltcIit5WzBdK0M7Zm9yKHZhciB4PTE7eDx5Lmxlbmd0aC0xO3grKyl5W3hdPVwiIFwiK3lbeF0rQzt2YXIgRT1cIixcXG5cIjtmb3IodmFyIHg9Mjt4PGw7eCsrKUUrPVwiXFxuXCI7eVt5Lmxlbmd0aC0xXT1cIiBcIit5W3kubGVuZ3RoLTFdK1wiXVwiKyhpP1wiXCI6RSk7cmV0dXJuIHl9KHQsZSxuLG8sYSksdT1bXCJUZW5zb3JcIl07cmV0dXJuIHImJih1LnB1c2goXCIgIGR0eXBlOiBcIituKSx1LnB1c2goXCIgIHJhbms6IFwiK2kpLHUucHVzaChcIiAgc2hhcGU6IFtcIitlK1wiXVwiKSx1LnB1c2goXCIgIHZhbHVlczpcIikpLHUucHVzaChzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cIiAgICBcIit0fSkuam9pbihcIlxcblwiKSksdS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIGl0KHQsZSxuKXtyZXR1cm4gRShBcnJheS5pc0FycmF5KHQpP3BhcnNlRmxvYXQodFswXS50b0ZpeGVkKG90KSkrXCIgKyBcIitwYXJzZUZsb2F0KHRbMV0udG9GaXhlZChvdCkpK1wialwiOkIodCk/XCInXCIrdCtcIidcIjpcImJvb2xcIj09PW4/c3QodCk6cGFyc2VGbG9hdCh0LnRvRml4ZWQob3QpKS50b1N0cmluZygpLGUpfWZ1bmN0aW9uIHN0KHQpe3JldHVybiAwPT09dD9cImZhbHNlXCI6XCJ0cnVlXCJ9ZnVuY3Rpb24gdXQodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rPTIpZS5wdXNoKFt0W25dLHRbbisxXV0pO3JldHVybiBlfXZhciBsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3ZhciByPXRoaXM7aWYodGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9dC5zbGljZSgpLHRoaXMuc2l6ZT15KHQpLG51bGwhPW4pe3ZhciBvPW4ubGVuZ3RoO2Qobz09PXRoaXMuc2l6ZSxmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIHZhbHVlcyAnXCIrbytcIicgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgaW5mZXJyZWQgYnkgdGhlIHNoYXBlICdcIityLnNpemUrXCInLlwifSl9aWYoXCJjb21wbGV4NjRcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiY29tcGxleDY0IGR0eXBlIFRlbnNvckJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjcmVhdGUgYSBUZW5zb3JCdWZmZXIgZm9yIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMgc2VwYXJhdGVseSBhbmQgY2FsbCB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnZhbHVlcz1ufHxBKGUsdGhpcy5zaXplKSx0aGlzLnN0cmlkZXM9Vih0KX1yZXR1cm4gdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLG49W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTswPT09bi5sZW5ndGgmJihuPVswXSksZChuLmxlbmd0aD09PXRoaXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiVGhlIG51bWJlciBvZiBwcm92aWRlZCBjb29yZGluYXRlcyAoXCIrbi5sZW5ndGgrXCIpIG11c3QgbWF0Y2ggdGhlIHJhbmsgKFwiK2UucmFuaytcIilcIn0pO3ZhciBvPXRoaXMubG9jVG9JbmRleChuKTt0aGlzLnZhbHVlc1tvXT10fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07MD09PXQubGVuZ3RoJiYodD1bMF0pO2Zvcih2YXIgbj0wLHI9MCxvPXQ7cjxvLmxlbmd0aDtyKyspe3ZhciBhPW9bcl07aWYoYTwwfHxhPj10aGlzLnNoYXBlW25dKXt2YXIgaT1cIlJlcXVlc3RlZCBvdXQgb2YgcmFuZ2UgZWxlbWVudCBhdCBcIit0K1wiLiAgIEJ1ZmZlciBzaGFwZT1cIit0aGlzLnNoYXBlO3Rocm93IG5ldyBFcnJvcihpKX1uKyt9Zm9yKHZhciBzPXRbdC5sZW5ndGgtMV0sdT0wO3U8dC5sZW5ndGgtMTsrK3Upcys9dGhpcy5zdHJpZGVzW3VdKnRbdV07cmV0dXJuIHRoaXMudmFsdWVzW3NdfSx0LnByb3RvdHlwZS5sb2NUb0luZGV4PWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLnJhbmspcmV0dXJuIDA7aWYoMT09PXRoaXMucmFuaylyZXR1cm4gdFswXTtmb3IodmFyIGU9dFt0Lmxlbmd0aC0xXSxuPTA7bjx0Lmxlbmd0aC0xOysrbillKz10aGlzLnN0cmlkZXNbbl0qdFtuXTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuaW5kZXhUb0xvYz1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5yYW5rKXJldHVybltdO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuW3RdO2Zvcih2YXIgZT1uZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpLG49MDtuPGUubGVuZ3RoLTE7KytuKWVbbl09TWF0aC5mbG9vcih0L3RoaXMuc3RyaWRlc1tuXSksdC09ZVtuXSp0aGlzLnN0cmlkZXNbbl07cmV0dXJuIGVbZS5sZW5ndGgtMV09dCxlfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyYW5rXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS50b1RlbnNvcj1mdW5jdGlvbigpe3JldHVybiBmdC5tYWtlKHRoaXMuc2hhcGUse3ZhbHVlczp0aGlzLnZhbHVlc30sdGhpcy5kdHlwZSl9LHR9KCksY3Q9bnVsbCxodD1udWxsLHB0PW51bGw7dmFyIGZ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyLG8pe3RoaXMua2VwdD0hMSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMSx0aGlzLnNoYXBlPXQuc2xpY2UoKSx0aGlzLmR0eXBlPWV8fFwiZmxvYXQzMlwiLHRoaXMuc2l6ZT15KHQpLHRoaXMuc3RyaWRlcz1WKHQpLHRoaXMuZGF0YUlkPW51bGwhPXI/cjp7fSx0aGlzLmlkPWN0KCkubmV4dFRlbnNvcklkKCksdGhpcy5yYW5rVHlwZT10aGlzLnJhbms8NT90aGlzLnJhbmsudG9TdHJpbmcoKTpcImhpZ2hlclwiLGN0KCkucmVnaXN0ZXJUZW5zb3IodGhpcyxvKSxudWxsIT1uJiZjdCgpLndyaXRlKHRoaXMuZGF0YUlkLG4pfXJldHVybiB0Lm1ha2U9ZnVuY3Rpb24oZSxuLHIsbyl7cmV0dXJuIG5ldyB0KGUscixuLnZhbHVlcyxuLmRhdGFJZCxvKX0sdC5wcm90b3R5cGUuZmxhdHRlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMuYXMxRCgpfSx0LnByb3RvdHlwZS5hc1NjYWxhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGQoMT09PXRoaXMuc2l6ZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC5cIn0pLHRoaXMucmVzaGFwZShbXSl9LHQucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pfSx0LnByb3RvdHlwZS5hczJEPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGVdKX0sdC5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbl0pfSx0LnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG4scl0pfSx0LnByb3RvdHlwZS5hczVEPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbixyLG9dKX0sdC5wcm90b3R5cGUuYXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNhc3QodGhpcyx0KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksWzIsaHQuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0KV19fSl9KX0sdC5wcm90b3R5cGUuYnVmZmVyU3luYz1mdW5jdGlvbigpe3JldHVybiBodC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHRoaXMuZGF0YVN5bmMoKSl9LHQucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksWzIscSh0aGlzLnNoYXBlLHQpXX19KX0pfSx0LnByb3RvdHlwZS5hcnJheVN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gcSh0aGlzLnNoYXBlLHRoaXMuZGF0YVN5bmMoKSl9LHQucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFsyLGN0KCkucmVhZCh0aGlzLmRhdGFJZCldfSl9KX0sdC5wcm90b3R5cGUuZGF0YVN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjdCgpLnJlYWRTeW5jKHRoaXMuZGF0YUlkKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuaXNEaXNwb3NlZHx8KGN0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlzRGlzcG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEaXNwb3NlZEludGVybmFsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS50b0Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiZmxvYXQzMlwiKX0sdC5wcm90b3R5cGUudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUudG9Cb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiYm9vbFwiKX0sdC5wcm90b3R5cGUucHJpbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxodC5wcmludCh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJlc2hhcGUodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaGFwZUFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZSh0LnNoYXBlKX0sdC5wcm90b3R5cGUuZXhwYW5kRGltcz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksaHQuZXhwYW5kRGltcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLGh0LmN1bXN1bSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc3F1ZWV6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcXVlZXplKHRoaXMsdCl9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY2xvbmUodGhpcyl9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQub25lSG90KHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLGF0KHRoaXMuZGF0YVN5bmMoKSx0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdCl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudGlsZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5nYXRoZXIodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tYXRNdWw9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWF0TXVsKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5kb3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZG90KHRoaXMsdCl9LHQucHJvdG90eXBlLm5vcm09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD1cImV1Y2xpZGVhblwiKSx2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ub3JtKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNsaWNlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yZXZlcnNlKHRoaXMsdCl9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGUgaW5zdGFuY2VvZiB0JiYoZT1bZV0pLGh0LmNvbmNhdChbdGhpc10uY29uY2F0KGUpLG4pfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwbGl0KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3RhY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksaHQuc3RhY2soW3RoaXMsdF0sZSl9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLGh0LnVuc3RhY2sodGhpcyx0KX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLGh0LnBhZCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1uJiYobj0uMDAxKSxwdChcInRmLmJhdGNoTm9ybWFsaXphdGlvbigpIGlzIGdvaW5nIGF3YXkuIFVzZSB0Zi5iYXRjaE5vcm0oKSBpbnN0ZWFkLCBhbmQgbm90ZSB0aGUgcG9zaXRpb25hbCBhcmd1bWVudCBjaGFuZ2Ugb2Ygc2NhbGUsIG9mZnNldCwgYW5kIHZhcmlhbmNlRXBzaWxvblwiKSx0aGlzLmJhdGNoTm9ybSh0LGUsbyxyLG4pfSx0LnByb3RvdHlwZS5iYXRjaE5vcm09ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09byYmKG89LjAwMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5iYXRjaE5vcm0odGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWxsKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFueSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmxvZ1N1bUV4cD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dTdW1FeHAodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3VtKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5wcm9kKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWVhbj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tZWFuKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1pbih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tYXgodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXJnTWluKHRoaXMsdCl9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hcmdNYXgodGhpcyx0KX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jYXN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hZGQodGhpcyx0KX0sdC5wcm90b3R5cGUuYWRkU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFkZFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hdGFuMih0aGlzLHQpfSx0LnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3ViKHRoaXMsdCl9LHQucHJvdG90eXBlLnN1YlN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zdWJTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnBvdyh0aGlzLHQpfSx0LnByb3RvdHlwZS5wb3dTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucG93U3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tdWwodGhpcyx0KX0sdC5wcm90b3R5cGUubXVsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm11bFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5kaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZGl2KHRoaXMsdCl9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmZsb29yRGl2KHRoaXMsdCl9LHQucHJvdG90eXBlLmRpdlN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5kaXZTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5taW5pbXVtKHRoaXMsdCl9LHQucHJvdG90eXBlLm1pbmltdW1TdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWluaW11bVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1heGltdW0odGhpcyx0KX0sdC5wcm90b3R5cGUubWF4aW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tYXhpbXVtU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tb2QodGhpcyx0KX0sdC5wcm90b3R5cGUubW9kU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1vZFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcXVhcmVkRGlmZmVyZW5jZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudHJhbnNwb3NlKHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm5vdEVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm5vdEVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubGVzcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lmxlc3NTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lmxlc3NFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubGVzc0VxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZ3JlYXRlcih0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmdyZWF0ZXJTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmdyZWF0ZXJFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZ3JlYXRlckVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9naWNhbEFuZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9naWNhbE9yKHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dpY2FsTm90KHRoaXMpfSx0LnByb3RvdHlwZS5sb2dpY2FsWG9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ2ljYWxYb3IodGhpcyx0KX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC53aGVyZSh0LHRoaXMsZSl9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm5lZyh0aGlzKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNlaWwodGhpcyl9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZmxvb3IodGhpcyl9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zaWduKHRoaXMpfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmlzTmFOKHRoaXMpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmlzSW5mKHRoaXMpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmlzRmluaXRlKHRoaXMpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5leHAodGhpcyl9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZXhwbTEodGhpcyl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZyh0aGlzKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2cxcCh0aGlzKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNxdWFyZSh0aGlzKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJlY2lwcm9jYWwodGhpcyl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFicyh0aGlzKX0sdC5wcm90b3R5cGUuY2xpcEJ5VmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jbGlwQnlWYWx1ZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5lbHUodGhpcyl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5sZWFreVJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4yKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxlYWt5UmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5wcmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2lnbW9pZCh0aGlzKX0sdC5wcm90b3R5cGUubG9nU2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ1NpZ21vaWQodGhpcyl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc29mdHBsdXModGhpcyl9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lnplcm9zTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5vbmVzTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2luKHRoaXMpfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jb3ModGhpcyl9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnRhbih0aGlzKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFzaW4odGhpcyl9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hY29zKHRoaXMpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXRhbih0aGlzKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNpbmgodGhpcyl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jb3NoKHRoaXMpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hc2luaCh0aGlzKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hY29zaCh0aGlzKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hdGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZXJmKHRoaXMpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJvdW5kKHRoaXMpfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnN0ZXAodGhpcyx0KX0sdC5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc29mdG1heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dTb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dTb2Z0bWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmltYWdlLnJlc2l6ZUJpbGluZWFyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLmNvbnYxZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTldDXCIpLHZvaWQgMD09PW8mJihvPTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY29udjFkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2U9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jb252MmRUcmFuc3Bvc2UodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZGVwdGh3aXNlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5zZXBhcmFibGVDb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1vJiYobz1bMSwxXSksdm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2VwYXJhYmxlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmF2Z1Bvb2wodGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tYXhQb29sKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT10JiYodD01KSx2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0uNSksaHQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24odGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUucG9vbD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnBvb2wodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS52YXJpYWJsZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGR0LnZhcmlhYmxlKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC51bnNvcnRlZFNlZ21lbnRTdW0odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmJhdGNoVG9TcGFjZU5EKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGFjZVRvQmF0Y2hORCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MSksdm9pZCAwPT09ZSYmKGU9ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudG9wayh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnN0cmlkZWRTbGljZSh0aGlzLHQsZSxuLHIsbyxhLGkscyl9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmRlcHRoVG9TcGFjZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwZWN0cmFsLmZmdCh0aGlzKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwZWN0cmFsLmlmZnQodGhpcyl9LHQucHJvdG90eXBlLnJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGVjdHJhbC5yZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5pcmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwZWN0cmFsLmlyZmZ0KHRoaXMpfSx0fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShmdCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmbnVsbCE9dC5kYXRhSWQmJm51bGwhPXQuc2hhcGUmJm51bGwhPXQuZHR5cGV9fSk7dmFyIGR0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIpe3ZvaWQgMD09PW4mJihuPSEwKTt2YXIgbz10LmNhbGwodGhpcyxlLnNoYXBlLGUuZHR5cGUsbnVsbCxlLmRhdGFJZCl8fHRoaXM7by50cmFpbmFibGU9bixvLm5hbWU9cixudWxsPT1vLm5hbWUmJihvLm5hbWU9Y3QoKS5uZXh0VmFyaWFibGVJZCgpLnRvU3RyaW5nKCkpO3RyeXtjdCgpLnJlZ2lzdGVyVmFyaWFibGUobyl9Y2F0Y2godCl7dGhyb3cgY3QoKS5kaXNwb3NlVGVuc29yKG8pLHR9cmV0dXJuIG99cmV0dXJuIGUobix0KSxuLnZhcmlhYmxlPWZ1bmN0aW9uKHQsZSxyLG8pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksbnVsbCE9byYmbyE9PXQuZHR5cGUmJih0PXQuYXNUeXBlKG8pKSxuZXcgbih0LGUscil9LG4ucHJvdG90eXBlLmFzc2lnbj1mdW5jdGlvbih0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJkdHlwZSBvZiB0aGUgbmV3IHZhbHVlIChcIit0LmR0eXBlK1wiKSBhbmQgcHJldmlvdXMgdmFsdWUgKFwiK3RoaXMuZHR5cGUrXCIpIG11c3QgbWF0Y2hcIik7aWYoIXgodC5zaGFwZSx0aGlzLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBvZiB0aGUgbmV3IHZhbHVlIChcIit0LnNoYXBlK1wiKSBhbmQgcHJldmlvdXMgdmFsdWUgKFwiK3RoaXMuc2hhcGUrXCIpIG11c3QgbWF0Y2hcIik7Y3QoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuZGF0YUlkPXQuZGF0YUlkLGN0KCkucmVnaXN0ZXJUZW5zb3IodGhpcyl9LG59KGZ0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZHQsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0JiZudWxsIT10LmFzc2lnbiYmdC5hc3NpZ24gaW5zdGFuY2VvZiBGdW5jdGlvbn19KTt2YXIgdnQsbXQsZ3QseXQseHQsd3Q9ZHQudmFyaWFibGU7IWZ1bmN0aW9uKHQpe3QuUjA9XCJSMFwiLHQuUjE9XCJSMVwiLHQuUjI9XCJSMlwiLHQuUjM9XCJSM1wiLHQuUjQ9XCJSNFwiLHQuUjU9XCJSNVwiLHQuUjY9XCJSNlwifSh2dHx8KHZ0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJpbnQzMlwiLHQuYm9vbD1cImludDMyXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0obXR8fChtdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJib29sXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oZ3R8fChndD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiZmxvYXQzMlwiLHQuYm9vbD1cImZsb2F0MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifSh5dHx8KHl0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiY29tcGxleDY0XCIsdC5pbnQzMj1cImNvbXBsZXg2NFwiLHQuYm9vbD1cImNvbXBsZXg2NFwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KHh0fHwoeHQ9e30pKTt2YXIgYnQ9e2Zsb2F0MzI6eXQsaW50MzI6bXQsYm9vbDpndCxjb21wbGV4NjQ6eHR9O2Z1bmN0aW9uIEN0KHQsZSl7aWYoXCJzdHJpbmdcIj09PXR8fFwic3RyaW5nXCI9PT1lKXtpZihcInN0cmluZ1wiPT09dCYmXCJzdHJpbmdcIj09PWUpcmV0dXJuXCJzdHJpbmdcIjt0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVwY2FzdCBcIit0K1wiIHdpdGggXCIrZSl9cmV0dXJuIGJ0W3RdW2VdfWZ1bmN0aW9uIEV0KHQpe3JldHVybiBDdCh0LFwiaW50MzJcIil9ZnVuY3Rpb24gUnQodCxlKXtpZih0LmR0eXBlPT09ZS5kdHlwZSlyZXR1cm5bdCxlXTt2YXIgbj1DdCh0LmR0eXBlLGUuZHR5cGUpO3JldHVyblt0LmNhc3QobiksZS5jYXN0KG4pXX1mdW5jdGlvbiBTdCh0LGUpe2QodC5kdHlwZT09PWUuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZXMgb2YgdGhlIGZpcnN0KFwiK3QuZHR5cGUrXCIpIGFuZCBzZWNvbmQoXCIrZS5kdHlwZStcIikgaW5wdXQgbXVzdCBtYXRjaFwifSl9ZnVuY3Rpb24gTnQodCl7dmFyIGU9W107cmV0dXJuIGZ1bmN0aW9uIHQoZSxuLHIpe2lmKG51bGw9PWUpcmV0dXJuO2lmKGUgaW5zdGFuY2VvZiBmdClyZXR1cm4gdm9pZCBuLnB1c2goZSk7aWYobz1lLCFBcnJheS5pc0FycmF5KG8pJiZcIm9iamVjdFwiIT10eXBlb2YgbylyZXR1cm47dmFyIG87dmFyIGE9ZTtmb3IodmFyIGkgaW4gYSl7dmFyIHM9YVtpXTtyLmhhcyhzKXx8KHIuYWRkKHMpLHQocyxuLHIpKX19KHQsZSxuZXcgU2V0KSxlfXZhciBrdCxJdD1PYmplY3QuZnJlZXplKHttYWtlVHlwZXNNYXRjaDpSdCxhc3NlcnRUeXBlc01hdGNoOlN0LGlzVGVuc29ySW5MaXN0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspaWYoZVtuXS5pZD09PXQuaWQpcmV0dXJuITA7cmV0dXJuITF9LGdldFRlbnNvcnNJbkNvbnRhaW5lcjpOdH0pLEF0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcz17fSx0aGlzLm5leHRUYXBlTm9kZUlkPTAsdGhpcy5udW1CeXRlcz0wLHRoaXMubnVtVGVuc29ycz0wLHRoaXMubnVtU3RyaW5nVGVuc29ycz0wLHRoaXMubnVtRGF0YUJ1ZmZlcnM9MCx0aGlzLmdyYWRpZW50RGVwdGg9MCx0aGlzLmtlcm5lbERlcHRoPTAsdGhpcy5zY29wZVN0YWNrPVtdLHRoaXMubmV4dFNjb3BlSWQ9MCx0aGlzLnRlbnNvckluZm89bmV3IFdlYWtNYXAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsfX1yZXR1cm4gdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3RdLmRpc3Bvc2UoKX0sdH0oKSxUdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5FTlY9dCx0aGlzLnJlZ2lzdHJ5PXt9LHRoaXMucmVnaXN0cnlGYWN0b3J5PXt9LHRoaXMuc3RhdGU9bmV3IEF0fXJldHVybiB0LnByb3RvdHlwZS5yZWFkeT1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpcmV0dXJuWzIsdGhpcy5wZW5kaW5nQmFja2VuZEluaXQudGhlbihmdW5jdGlvbigpe30pXTtpZihudWxsIT10aGlzLmJhY2tlbmRJbnN0YW5jZSlyZXR1cm5bMl07dD10aGlzLmdldFNvcnRlZEJhY2tlbmRzKCksZT0wLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGU8dC5sZW5ndGg/KG49dFtlXSxbNCx0aGlzLmluaXRpYWxpemVCYWNrZW5kKG4pLnN1Y2Nlc3NdKTpbMyw0XTtjYXNlIDI6aWYoci5zZW50KCkpcmV0dXJuIHRoaXMuc2V0QmFja2VuZChuKSxbMl07ci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gZSsrLFszLDFdO2Nhc2UgNDp0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBmYWlsZWQuXCIpfX0pfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJhY2tlbmRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCAnXCIrdGhpcy5iYWNrZW5kTmFtZStcIicgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc1wiKTtpZihudWxsPT10aGlzLmJhY2tlbmRJbnN0YW5jZSl7dmFyIHQ9dGhpcy5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0KCksZT10Lm5hbWU7aWYodC5hc3luY0luaXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGhpZ2hlc3QgcHJpb3JpdHkgYmFja2VuZCAnXCIrZStcIicgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc1wiKTt0aGlzLnNldEJhY2tlbmQoZSl9cmV0dXJuIHRoaXMuYmFja2VuZEluc3RhbmNlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmJhY2tlbmROYW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSl9LHQucHJvdG90eXBlLmZpbmRCYWNrZW5kPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5KSl7aWYoISh0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSlyZXR1cm4gbnVsbDtpZih0aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpLmFzeW5jSW5pdClyZXR1cm4gbnVsbH1yZXR1cm4gdGhpcy5yZWdpc3RyeVt0XX0sdC5wcm90b3R5cGUuZmluZEJhY2tlbmRGYWN0b3J5PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5P3RoaXMucmVnaXN0cnlGYWN0b3J5W3RdLmZhY3Rvcnk6bnVsbH0sdC5wcm90b3R5cGUucmVnaXN0ZXJCYWNrZW5kPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT8oY29uc29sZS53YXJuKHQrXCIgYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLiBSZXVzaW5nIGV4aXN0aW5nIGJhY2tlbmQgZmFjdG9yeS5cIiksITEpOih0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XT17ZmFjdG9yeTplLHByaW9yaXR5Om59LCEwKX0sdC5wcm90b3R5cGUuc2V0QmFja2VuZD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHI7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdKXRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgbmFtZSAnXCIrdCtcIicgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO3JldHVybiB0aGlzLmJhY2tlbmROYW1lPXQsbnVsbCE9dGhpcy5yZWdpc3RyeVt0XT9bMyw0XToodGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCxlPXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCksbj1lLnN1Y2Nlc3MsZS5hc3luY0luaXQ/WzQsbl06WzMsMl0pO2Nhc2UgMTpyZXR1cm4gcj1vLnNlbnQoKSxbMywzXTtjYXNlIDI6cj1uLG8ubGFiZWw9MztjYXNlIDM6aWYoIXIpcmV0dXJuWzIsITFdO28ubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIHRoaXMuYmFja2VuZEluc3RhbmNlPXRoaXMucmVnaXN0cnlbdF0sdGhpcy5wcm9maWxlcj1uZXcgdHQodGhpcy5iYWNrZW5kSW5zdGFuY2UpLFsyLCEwXX19KX0pfSx0LnByb3RvdHlwZS5pbml0aWFsaXplQmFja2VuZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49RHQucmVnaXN0cnlGYWN0b3J5W3RdO2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgYmFja2VuZCBcIit0K1wiLCBubyByZWdpc3RyYXRpb24gZm91bmQuXCIpO3RyeXt2YXIgcj1uLmZhY3RvcnkoKTtpZihQcm9taXNlLnJlc29sdmUocik9PT1yKXt2YXIgbz1yLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIGUucmVnaXN0cnlbdF09bixlLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLCEwfSkuY2F0Y2goZnVuY3Rpb24obil7cmV0dXJuIGUucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsY29uc29sZS53YXJuKFwiSW5pdGlhbGl6YXRpb24gb2YgYmFja2VuZCBcIit0K1wiIGZhaWxlZFwiKSxjb25zb2xlLndhcm4obi5zdGFja3x8bi5tZXNzYWdlKSwhMX0pO3JldHVybiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1vLHtzdWNjZXNzOm8sYXN5bmNJbml0OiEwfX1yZXR1cm4gdGhpcy5yZWdpc3RyeVt0XT1yLHtzdWNjZXNzOiEwLGFzeW5jSW5pdDohMX19Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUud2FybihcIkluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgXCIrdCtcIiBmYWlsZWRcIiksY29uc29sZS53YXJuKGUuc3RhY2t8fGUubWVzc2FnZSkse3N1Y2Nlc3M6ITEsYXN5bmNJbml0OiExfX19LHQucHJvdG90eXBlLnJlbW92ZUJhY2tlbmQ9ZnVuY3Rpb24odCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSl0aHJvdyBuZXcgRXJyb3IodCtcIiBiYWNrZW5kIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTt0IGluIHRoaXMucmVnaXN0cnkmJih0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XSksZGVsZXRlIHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdfSx0LnByb3RvdHlwZS5nZXRTb3J0ZWRCYWNrZW5kcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoMD09PU9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS5cIik7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5zb3J0KGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQucmVnaXN0cnlGYWN0b3J5W25dLnByaW9yaXR5LXQucmVnaXN0cnlGYWN0b3J5W2VdLnByaW9yaXR5fSl9LHQucHJvdG90eXBlLmluaXRpYWxpemVCYWNrZW5kc0FuZFJldHVybkJlc3Q9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXSxyPXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQobiksbz1yLnN1Y2Nlc3MsYT1yLmFzeW5jSW5pdDtpZihhfHxvKXJldHVybntuYW1lOm4sYXN5bmNJbml0OmF9fXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGFueSBiYWNrZW5kcywgYWxsIGJhY2tlbmQgaW5pdGlhbGl6YXRpb25zIGZhaWxlZC5cIil9LHQucHJvdG90eXBlLm1vdmVEYXRhPWZ1bmN0aW9uKHQpe3RoaXMud3JpdGUodCx0aGlzLnJlYWRTeW5jKHQpKX0sdC5wcm90b3R5cGUudGlkeT1mdW5jdGlvbih0LGUpe3ZhciBuLHI9dGhpcyxvPW51bGw7aWYobnVsbD09ZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKVwiKTtlPXR9ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCYmISh0IGluc3RhbmNlb2YgU3RyaW5nKSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgMm5kIGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7bz10fXJldHVybiB0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiByLnN0YXJ0U2NvcGUobyl9LGZ1bmN0aW9uKCl7cmV0dXJuIHIuZW5kU2NvcGUobil9LGZ1bmN0aW9uKCl7cmV0dXJuKG49ZSgpKWluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxufSl9LHQucHJvdG90eXBlLnNjb3BlZFJ1bj1mdW5jdGlvbih0LGUsbil7dCgpO3RyeXt2YXIgcj1uKCk7cmV0dXJuIGUoKSxyfWNhdGNoKHQpe3Rocm93IGUoKSx0fX0sdC5wcm90b3R5cGUubmV4dFRlbnNvcklkPWZ1bmN0aW9uKCl7cmV0dXJuIHQubmV4dFRlbnNvcklkKyt9LHQucHJvdG90eXBlLm5leHRWYXJpYWJsZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIHQubmV4dFZhcmlhYmxlSWQrK30sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24odCl7dmFyIGU9ZnQubWFrZSh0LnNoYXBlLHtkYXRhSWQ6dC5kYXRhSWR9LHQuZHR5cGUpO3JldHVybiB0aGlzLmFkZFRhcGVOb2RlKFt0XSxlLGZ1bmN0aW9uKHQpe3JldHVyblt0LnRvRmxvYXQoKV19KSxlfSx0LnByb3RvdHlwZS5ydW5LZXJuZWw9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89dGhpcyxhPVtdLGk9dGhpcy5pc1RhcGVPbigpLHM9bnVsbCE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZT90aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWU6XCJcIix1PWZ1bmN0aW9uKHQpe2kmJihhPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmtlZXAoby5jbG9uZSh0KSl9KSl9LGw9dGhpcy5zdGF0ZS5udW1CeXRlcyxjPXRoaXMuc3RhdGUubnVtVGVuc29ycztpZih0aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBvLnN0YXRlLmtlcm5lbERlcHRoKyt9LGZ1bmN0aW9uKCl7cmV0dXJuIG8uc3RhdGUua2VybmVsRGVwdGgtLX0sZnVuY3Rpb24oKXtyPW8uRU5WLmdldEJvb2woXCJERUJVR1wiKT9vLnByb2ZpbGVyLnByb2ZpbGVLZXJuZWwocyxmdW5jdGlvbigpe3JldHVybiB0KG8uYmFja2VuZCx1KX0pOnQoby5iYWNrZW5kLHUpfSksaSl7dmFyIGg9e2lkOnRoaXMuc3RhdGUubmV4dFRhcGVOb2RlSWQrKyxuYW1lOnMsaW5wdXRzOmUsb3V0cHV0czpBcnJheS5pc0FycmF5KHIpP3I6W3JdLHNhdmVkOmF9O251bGwhPW4mJihoLmdyYWRpZW50PWZ1bmN0aW9uKHQpe3JldHVybiBuKHQsYSl9KSx0aGlzLnN0YXRlLmFjdGl2ZVRhcGUucHVzaChoKX1yZXR1cm4gdGhpcy5zdGF0ZS5wcm9maWxpbmcmJnRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe25hbWU6cyxieXRlc0FkZGVkOnRoaXMuc3RhdGUubnVtQnl0ZXMtbCx0b3RhbEJ5dGVzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1CeXRlcyx0ZW5zb3JzQWRkZWQ6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLWMsdG90YWxUZW5zb3JzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLGlucHV0U2hhcGVzOk9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XS5zaGFwZX0pLG91dHB1dFNoYXBlOkFycmF5LmlzQXJyYXkocik/ci5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KTpyLnNoYXBlfSkscn0sdC5wcm90b3R5cGUucmVnaXN0ZXJUZW5zb3I9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKT90aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudDowO2lmKHRoaXMuc3RhdGUubnVtVGVuc29ycysrLFwic3RyaW5nXCI9PT10LmR0eXBlJiZ0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMrKywwPT09bil7dGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycysrO3ZhciByPTA7XCJjb21wbGV4NjRcIiE9PXQuZHR5cGUmJlwic3RyaW5nXCIhPT10LmR0eXBlJiYocj10LnNpemUqTSh0LmR0eXBlKSksdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLnNldCh0LmRhdGFJZCx7YmFja2VuZDpudWxsIT1lP2U6dGhpcy5iYWNrZW5kLGR0eXBlOnQuZHR5cGUsc2hhcGU6dC5zaGFwZSxieXRlczpyLHJlZkNvdW50OjB9KSx0aGlzLnN0YXRlLm51bUJ5dGVzKz1yLG51bGwhPWU/ZS5yZWdpc3Rlcih0LmRhdGFJZCx0LnNoYXBlLHQuZHR5cGUpOnRoaXMuYmFja2VuZC5yZWdpc3Rlcih0LmRhdGFJZCx0LnNoYXBlLHQuZHR5cGUpfXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50KyssdCBpbnN0YW5jZW9mIGR0fHx0aGlzLnRyYWNrKHQpfSx0LnByb3RvdHlwZS5yZWdpc3RlclZhcmlhYmxlPWZ1bmN0aW9uKHQpe2lmKG51bGwhPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdKXRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHdpdGggbmFtZSBcIit0Lm5hbWUrXCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTt0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXT10fSx0LnByb3RvdHlwZS5kaXNwb3NlVGVuc29yPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpKXt0aGlzLnN0YXRlLm51bVRlbnNvcnMtLSxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzLS07dmFyIGU9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCk7ZS5yZWZDb3VudDw9MT8oXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUmJih0aGlzLnN0YXRlLm51bUJ5dGVzLT1lLmJ5dGVzKSx0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLS0sZS5iYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSx0aGlzLnN0YXRlLnRlbnNvckluZm8uZGVsZXRlKHQuZGF0YUlkKSk6dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQtLX19LHQucHJvdG90eXBlLmRpc3Bvc2VWYXJpYWJsZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzKXt2YXIgZT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5kaXNwb3NlVGVuc29yKGUpLGRlbGV0ZSB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF19fSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJhY2tlbmQubWVtb3J5KCk7cmV0dXJuIHQubnVtVGVuc29ycz10aGlzLnN0YXRlLm51bVRlbnNvcnMsdC5udW1EYXRhQnVmZmVycz10aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLHQubnVtQnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcyx0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnM+MCYmKHQudW5yZWxpYWJsZT0hMCxudWxsPT10LnJlYXNvbnMmJih0LnJlYXNvbnM9W10pLHQucmVhc29ucy5wdXNoKFwiTWVtb3J5IHVzYWdlIGJ5IHN0cmluZyB0ZW5zb3JzIGlzIGFwcHJveGltYXRlICgyIGJ5dGVzIHBlciBjaGFyYWN0ZXIpXCIpKSx0fSx0LnByb3RvdHlwZS5wcm9maWxlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5zdGF0ZS5wcm9maWxpbmc9ITAsZT10aGlzLnN0YXRlLm51bUJ5dGVzLG49dGhpcy5zdGF0ZS5udW1UZW5zb3JzLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzPVtdLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5yZXN1bHQ9dCgpLHRoaXMuc3RhdGUucHJvZmlsaW5nPSExLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5wZWFrQnl0ZXM9TWF0aC5tYXguYXBwbHkoTWF0aCx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudG90YWxCeXRlc1NuYXBzaG90fSkpLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdCeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLWUsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld1RlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLW4sWzIsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlXX0pfSl9LHQucHJvdG90eXBlLmlzVGFwZU9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aD4wJiYwPT09dGhpcy5zdGF0ZS5rZXJuZWxEZXB0aH0sdC5wcm90b3R5cGUuYWRkVGFwZU5vZGU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXt9O3QuZm9yRWFjaChmdW5jdGlvbih0LGUpe3JbZV09dH0pO3ZhciBvPXtpZDp0aGlzLnN0YXRlLm5leHRUYXBlTm9kZUlkKyssbmFtZTp0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWUsaW5wdXRzOnIsb3V0cHV0czpbZV0sZ3JhZGllbnQ6ZnVuY3Rpb24odCl7dmFyIGU9bih0KSxyPXt9O3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24odCxlKXtyW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIHR9fSkscn19O3RoaXMuc3RhdGUuYWN0aXZlVGFwZS5wdXNoKG8pfSx0LnByb3RvdHlwZS5rZWVwPWZ1bmN0aW9uKHQpe3JldHVybiB0LmtlcHQ9ITAsdH0sdC5wcm90b3R5cGUuc3RhcnRUYXBlPWZ1bmN0aW9uKCl7MD09PXRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aCYmKHRoaXMuc3RhdGUuYWN0aXZlVGFwZT1bXSksdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoKyt9LHQucHJvdG90eXBlLmVuZFRhcGU9ZnVuY3Rpb24oKXt0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgtLX0sdC5wcm90b3R5cGUuc3RhcnRTY29wZT1mdW5jdGlvbih0KXt2YXIgZT17dHJhY2s6W10sbmFtZTpcInVubmFtZWQgc2NvcGVcIixpZDp0aGlzLnN0YXRlLm5leHRTY29wZUlkKyt9O3QmJihlLm5hbWU9dCksdGhpcy5zdGF0ZS5zY29wZVN0YWNrLnB1c2goZSksdGhpcy5zdGF0ZS5hY3RpdmVTY29wZT1lfSx0LnByb3RvdHlwZS5lbmRTY29wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcyxuPU50KHQpLHI9bmV3IFNldChuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZH0pKSxvPTA7bzx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDtvKyspe3ZhciBhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2tbb107YS5rZXB0fHxyLmhhcyhhLmlkKXx8YS5kaXNwb3NlKCl9dmFyIGk9dGhpcy5zdGF0ZS5zY29wZVN0YWNrLnBvcCgpO3RoaXMuc3RhdGUuYWN0aXZlU2NvcGU9MD09PXRoaXMuc3RhdGUuc2NvcGVTdGFjay5sZW5ndGg/bnVsbDp0aGlzLnN0YXRlLnNjb3BlU3RhY2tbdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aC0xXSxuLmZvckVhY2goZnVuY3Rpb24odCl7dC5rZXB0fHx0LnNjb3BlSWQhPT1pLmlkfHxlLnRyYWNrKHQpfSl9LHQucHJvdG90eXBlLmdyYWRpZW50cz1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzO2lmKHZvaWQgMD09PXImJihyPSExKSxkKGUubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cImdyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuXCJ9KSxudWxsIT1uJiZcImZsb2F0MzJcIiE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHkgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnXCIrbi5kdHlwZStcIidcIik7dmFyIGE9dGhpcy5zY29wZWRSdW4oZnVuY3Rpb24oKXtyZXR1cm4gby5zdGFydFRhcGUoKX0sZnVuY3Rpb24oKXtyZXR1cm4gby5lbmRUYXBlKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIG8udGlkeShcImZvcndhcmRcIix0KX0pO2QoYSBpbnN0YW5jZW9mIGZ0LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgcmVzdWx0IHkgcmV0dXJuZWQgYnkgZigpIG11c3QgYmUgYSB0ZW5zb3IuXCJ9KTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXt9LG89e30sYT0wO2E8ZS5sZW5ndGg7YSsrKXJbZVthXS5pZF09ITA7Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIGk9KGQ9dFthXSkuaW5wdXRzO2Zvcih2YXIgcyBpbiBpKXtmb3IodmFyIHU9aVtzXSxsPSExLGM9MDtjPGUubGVuZ3RoO2MrKylpZihyW3UuaWRdKXtkLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gclt0LmlkXT0hMH0pLGw9ITAsb1tkLmlkXT0hMDticmVha31pZihsKWJyZWFrfX12YXIgaD17fTtoW24uaWRdPSEwO3ZhciBwPXt9O2ZvcihhPXQubGVuZ3RoLTE7YT49MDthLS0pZm9yKGk9KGQ9dFthXSkuaW5wdXRzLGM9MDtjPGQub3V0cHV0cy5sZW5ndGg7YysrKWlmKGhbZC5vdXRwdXRzW2NdLmlkXSl7Zm9yKHZhciBzIGluIGkpaFtpW3NdLmlkXT0hMCxwW2QuaWRdPSEwO2JyZWFrfXZhciBmPVtdO2ZvcihhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBkO2lmKG9bKGQ9dFthXSkuaWRdJiZwW2QuaWRdKXt2YXIgdj17fTtmb3IodmFyIHMgaW4gZC5pbnB1dHMpe3ZhciBtPWQuaW5wdXRzW3NdO3JbbS5pZF0mJih2W3NdPW0pfXZhciBnPU9iamVjdC5hc3NpZ24oe30sZCk7Zy5pbnB1dHM9dixnLm91dHB1dHM9ZC5vdXRwdXRzLGYucHVzaChnKX19cmV0dXJuIGZ9KHRoaXMuc3RhdGUuYWN0aXZlVGFwZSxlLGEpO2lmKCFyJiYwPT09aS5sZW5ndGgmJmUubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdCB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIik7cmV0dXJuIHRoaXMudGlkeShcImJhY2t3YXJkXCIsZnVuY3Rpb24oKXt2YXIgdCxyLHM9e307c1thLmlkXT1udWxsPT1uPyh0PWEuc2hhcGUscj1IKHkodCksXCJmbG9hdDMyXCIpLGZ0Lm1ha2UodCx7dmFsdWVzOnJ9KSk6bixmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPWZ1bmN0aW9uKHIpe3ZhciBvPWVbcl0sYT1bXTtpZihvLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj10W2UuaWRdO2lmKG51bGwhPW4pYS5wdXNoKG4pO2Vsc2V7dmFyIHI9ZnQubWFrZShlLnNoYXBlLHt2YWx1ZXM6JChlLnNpemUsZS5kdHlwZSl9LGUuZHR5cGUpO2EucHVzaChyKX19KSxudWxsPT1vLmdyYWRpZW50KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50OiBncmFkaWVudCBmdW5jdGlvbiBub3QgZm91bmQgZm9yIFwiK28ubmFtZStcIi5cIik7dmFyIGk9by5ncmFkaWVudCgxPT09by5vdXRwdXRzLmxlbmd0aD9hWzBdOmEpLHM9ZnVuY3Rpb24oZSl7aWYoIShlIGluIGkpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWNrcHJvcCB0aHJvdWdoIGlucHV0IFwiK2UrXCIuIEF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiK09iamVjdC5rZXlzKGkpK1wiLlwiKTt2YXIgcj1uKGZ1bmN0aW9uKCl7cmV0dXJuIGlbZV0oKX0pO2lmKFwiZmxvYXQzMlwiIT09ci5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrby5uYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgXCIrZStcIiBtdXN0IGhhdmUgJ2Zsb2F0MzInIGR0eXBlLCBidXQgaGFzICdcIityLmR0eXBlK1wiJ1wiKTt2YXIgYT1vLmlucHV0c1tlXTtpZigheChyLnNoYXBlLGEuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIGdyYWRpZW50IGZvciBvcCBcIitvLm5hbWUrXCIuIFRoZSBncmFkaWVudCBvZiBpbnB1dCAnXCIrZStcIicgaGFzIHNoYXBlICdcIityLnNoYXBlK1wiJywgd2hpY2ggZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCAnXCIrYS5zaGFwZStcIidcIik7aWYobnVsbD09dFthLmlkXSl0W2EuaWRdPXI7ZWxzZXt2YXIgcz10W2EuaWRdO3RbYS5pZF09cy5hZGQocikscy5kaXNwb3NlKCl9fTtmb3IodmFyIHUgaW4gby5pbnB1dHMpcyh1KX0sbz1lLmxlbmd0aC0xO28+PTA7by0tKXIobyl9KHMsaSxmdW5jdGlvbih0KXtyZXR1cm4gby50aWR5KHQpfSk7dmFyIHU9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHNbdC5pZF19KTtyZXR1cm4gMD09PW8uc3RhdGUuZ3JhZGllbnREZXB0aCYmKG8uc3RhdGUuYWN0aXZlVGFwZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0LnNhdmVkKXQuc2F2ZWRbZV0uZGlzcG9zZSgpfSksby5zdGF0ZS5hY3RpdmVUYXBlPW51bGwpLHt2YWx1ZTphLGdyYWRzOnV9fSl9LHQucHJvdG90eXBlLmN1c3RvbUdyYWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24uXCJ9KSxmdW5jdGlvbigpe2Zvcih2YXIgbixyPVtdLG89MDtvPGFyZ3VtZW50cy5sZW5ndGg7bysrKXJbb109YXJndW1lbnRzW29dO2Qoci5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0fSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpKHgxLCB4MiwuLi4pIG11c3QgYWxsIGJlIHRlbnNvcnNcIn0pO3ZhciBhPXt9O3JldHVybiByLmZvckVhY2goZnVuY3Rpb24odCxlKXthW2VdPXR9KSxlLnJ1bktlcm5lbChmdW5jdGlvbihlLG8pe3JldHVybiBkKChuPXQuYXBwbHkodm9pZCAwLHIuY29uY2F0KFtvXSkpKS52YWx1ZSBpbnN0YW5jZW9mIGZ0LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai52YWx1ZWAgaXMgYSB0ZW5zb3JcIn0pLGQoVShuLmdyYWRGdW5jKSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uXCJ9KSxuLnZhbHVlfSxhLGZ1bmN0aW9uKHQsZSl7dmFyIG89bi5ncmFkRnVuYyh0LGUpLGE9QXJyYXkuaXNBcnJheShvKT9vOltvXTtkKGEubGVuZ3RoPT09ci5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2FtZSBudW1iZXIgb2YgdGVuc29ycyBhcyBpbnB1dHMgcGFzc2VkIHRvIGYoLi4uKS5cIn0pLGQoYS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0fSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2Ygb25seSB0ZW5zb3JzLlwifSk7dmFyIGk9e307cmV0dXJuIGEuZm9yRWFjaChmdW5jdGlvbih0LGUpe2lbZV09ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxpfSl9fSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCk7aWYoXCJzdHJpbmdcIj09PW4uZHR5cGUpe3ZhciByPUYoZSk7dGhpcy5zdGF0ZS5udW1CeXRlcys9ci1uLmJ5dGVzLG4uYnl0ZXM9cn10aGlzLmJhY2tlbmQhPT1uLmJhY2tlbmQmJihuLmJhY2tlbmQuZGlzcG9zZURhdGEodCksbi5iYWNrZW5kPXRoaXMuYmFja2VuZCx0aGlzLmJhY2tlbmQucmVnaXN0ZXIodCxuLnNoYXBlLG4uZHR5cGUpKSx0aGlzLmJhY2tlbmQud3JpdGUodCxlKX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkU3luYyh0KX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWQodCl9LHQucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmZyb21QaXhlbHModCxlKX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT1qKCksWzQsdGhpcy5iYWNrZW5kLnRpbWUodCldO2Nhc2UgMTpyZXR1cm4obj1yLnNlbnQoKSkud2FsbE1zPWooKS1lLFsyLG5dfX0pfSl9LHQucHJvdG90eXBlLnRyYWNrPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlJiYodC5zY29wZUlkPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUuaWQsdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5wdXNoKHQpKSx0fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWdpc3RlcmVkVmFyaWFibGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5zdGF0ZS5kaXNwb3NlKCksdGhpcy5FTlYucmVzZXQoKSx0aGlzLnN0YXRlPW5ldyBBdCx0aGlzLnJlZ2lzdHJ5KXRoaXMucmVnaXN0cnlbdF0uZGlzcG9zZSgpLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W3RdO3RoaXMuYmFja2VuZE5hbWU9bnVsbCx0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsfSx0Lm5leHRUZW5zb3JJZD0wLHQubmV4dFZhcmlhYmxlSWQ9MCx0fSgpO3ZhciBEdD1mdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKCl7aWYobnVsbD09a3Qpe3ZhciB0PXZvaWQgMDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXQ9d2luZG93O2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCl0PWdsb2JhbDtlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwcm9jZXNzKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTt0PXByb2Nlc3N9a3Q9dH1yZXR1cm4ga3R9KCk7aWYobnVsbD09dC5fdGZlbmdpbmUpe3ZhciBlPW5ldyBpKHQpO3QuX3RmZW5naW5lPW5ldyBUdChlKX1yZXR1cm4gdSh0Ll90ZmVuZ2luZS5FTlYpLGN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuX3RmZW5naW5lfSx0Ll90ZmVuZ2luZX0oKTtmdW5jdGlvbiBPdCgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3d9YS5yZWdpc3RlckZsYWcoXCJERUJVR1wiLGZ1bmN0aW9uKCl7cmV0dXJuITF9LGZ1bmN0aW9uKHQpe3QmJmNvbnNvbGUud2FybihcIkRlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsIGJlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiBUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS5cIil9KSxhLnJlZ2lzdGVyRmxhZyhcIklTX0JST1dTRVJcIixmdW5jdGlvbigpe3JldHVybiBPdCgpfSksYS5yZWdpc3RlckZsYWcoXCJJU19OT0RFXCIsZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy52ZXJzaW9ucyYmdm9pZCAwIT09cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSksYS5yZWdpc3RlckZsYWcoXCJJU19DSFJPTUVcIixmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmL0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvcil9KSxhLnJlZ2lzdGVyRmxhZyhcIlBST0RcIixmdW5jdGlvbigpe3JldHVybiExfSksYS5yZWdpc3RlckZsYWcoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIsZnVuY3Rpb24oKXtyZXR1cm4hYS5nZXRCb29sKFwiUFJPRFwiKX0pLGEucmVnaXN0ZXJGbGFnKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLGZ1bmN0aW9uKCl7cmV0dXJuITB9KSxhLnJlZ2lzdGVyRmxhZyhcIklTX1RFU1RcIixmdW5jdGlvbigpe3JldHVybiExfSk7dmFyIF90PXt9LE10PXthbHBoYTohMSxhbnRpYWxpYXM6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxkZXB0aDohMSxzdGVuY2lsOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITB9O2Z1bmN0aW9uIEZ0KHQpe3QgaW4gX3R8fChfdFt0XT1mdW5jdGlvbih0KXtpZigxIT09dCYmMiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBXZWJHTCByZW5kZXJpbmcgY29udGV4dCwgV2ViR0wgaXMgZGlzYWJsZWQuXCIpO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aWYoZS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxkZWxldGUgX3RbdF19LCExKSwxPT09dClyZXR1cm4gZS5nZXRDb250ZXh0KFwid2ViZ2xcIixNdCl8fGUuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLE10KTtyZXR1cm4gZS5nZXRDb250ZXh0KFwid2ViZ2wyXCIsTXQpfSh0KSk7dmFyIGU9X3RbdF07cmV0dXJuIGUuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgX3RbdF0sRnQodCkpOihlLmRpc2FibGUoZS5ERVBUSF9URVNUKSxlLmRpc2FibGUoZS5TVEVOQ0lMX1RFU1QpLGUuZGlzYWJsZShlLkJMRU5EKSxlLmRpc2FibGUoZS5ESVRIRVIpLGUuZGlzYWJsZShlLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLGUuZGlzYWJsZShlLlNBTVBMRV9DT1ZFUkFHRSksZS5lbmFibGUoZS5TQ0lTU09SX1RFU1QpLGUuZW5hYmxlKGUuQ1VMTF9GQUNFKSxlLmN1bGxGYWNlKGUuQkFDSyksX3RbdF0pfWZ1bmN0aW9uIEJ0KHQsZSxuKXt2YXIgcj1uKCk7cmV0dXJuIGUmJmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RXJyb3IoKTtpZihlIT09dC5OT19FUlJPUil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBFcnJvcjogXCIrVXQodCxlKSl9KHQpLHJ9dmFyIFB0PTUuOTZlLTgsTHQ9NjU1MDQ7ZnVuY3Rpb24gV3QodCl7cmV0dXJuISEoYS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKXx8MD09PXR8fFB0PE1hdGguYWJzKHQpJiZNYXRoLmFicyh0KTxMdCl9ZnVuY3Rpb24gVXQodCxlKXtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVyblwiTk9fRVJST1JcIjtjYXNlIHQuSU5WQUxJRF9FTlVNOnJldHVyblwiSU5WQUxJRF9FTlVNXCI7Y2FzZSB0LklOVkFMSURfVkFMVUU6cmV0dXJuXCJJTlZBTElEX1ZBTFVFXCI7Y2FzZSB0LklOVkFMSURfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9PUEVSQVRJT05cIjtjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046cmV0dXJuXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiO2Nhc2UgdC5PVVRfT0ZfTUVNT1JZOnJldHVyblwiT1VUX09GX01FTU9SWVwiO2Nhc2UgdC5DT05URVhUX0xPU1RfV0VCR0w6cmV0dXJuXCJDT05URVhUX0xPU1RfV0VCR0xcIjtkZWZhdWx0OnJldHVyblwiVW5rbm93biBlcnJvciBjb2RlIFwiK2V9fWZ1bmN0aW9uIHp0KHQsZSxuKXtyZXR1cm4gaGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2V0RXh0ZW5zaW9uKG4pfSwnRXh0ZW5zaW9uIFwiJytuKydcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKX1mdW5jdGlvbiBWdCh0LGUsbil7dmFyIHI9aGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlU2hhZGVyKHQuVkVSVEVYX1NIQURFUil9LFwiVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuXCIpO2lmKEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY29tcGlsZVNoYWRlcihyKX0pLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuXCIpO3JldHVybiByfWZ1bmN0aW9uIEd0KHQsZSxuKXt2YXIgcj1oZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVTaGFkZXIodC5GUkFHTUVOVF9TSEFERVIpfSxcIlVuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuXCIpO2lmKEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY29tcGlsZVNoYWRlcihyKX0pLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBmdW5jdGlvbih0LGUpe3ZhciBuPSR0LmV4ZWMoZSk7aWYobnVsbD09bilyZXR1cm4gY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIrZSksdm9pZCBjb25zb2xlLmxvZyh0KTtmb3IodmFyIHI9K25bMV0sbz10LnNwbGl0KFwiXFxuXCIpLGE9by5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGgrMixpPW8ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIEUoKGUrMSkudG9TdHJpbmcoKSxhKSt0fSkscz0wLHU9MDt1PGkubGVuZ3RoO3UrKylzPU1hdGgubWF4KGlbdV0ubGVuZ3RoLHMpO3ZhciBsPWkuc2xpY2UoMCxyLTEpLGM9aS5zbGljZShyLTEsciksaD1pLnNsaWNlKHIpO2NvbnNvbGUubG9nKGwuam9pbihcIlxcblwiKSksY29uc29sZS5sb2coZS5zcGxpdChcIlxcblwiKVswXSksY29uc29sZS5sb2coXCIlYyBcIitFKGNbMF0scyksXCJib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3XCIpLGNvbnNvbGUubG9nKGguam9pbihcIlxcblwiKSl9KG4sdC5nZXRTaGFkZXJJbmZvTG9nKHIpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuXCIpO3JldHVybiByfXZhciBxdCxIdCwkdD0vRVJST1I6IFswLTldKzooWzAtOV0rKTovZztmdW5jdGlvbiBqdCh0LGUpe3JldHVybiBoZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVQcm9ncmFtKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uXCIpfWZ1bmN0aW9uIEt0KHQsZSxuKXtpZihCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5saW5rUHJvZ3JhbShuKX0pLCExPT09dC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdC5MSU5LX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRQcm9ncmFtSW5mb0xvZyhuKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlwiKX1mdW5jdGlvbiBYdCh0LGUsbil7aWYoQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudmFsaWRhdGVQcm9ncmFtKG4pfSksITE9PT10LmdldFByb2dyYW1QYXJhbWV0ZXIobix0LlZBTElEQVRFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRQcm9ncmFtSW5mb0xvZyhuKSksbmV3IEVycm9yKFwiU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuXCIpfWZ1bmN0aW9uIFl0KHQsZSxuKXt2YXIgcj1oZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVCdWZmZXIoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLHIpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LkFSUkFZX0JVRkZFUixuLHQuU1RBVElDX0RSQVcpfSkscn1mdW5jdGlvbiBRdCh0LGUsbil7dmFyIHI9aGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlQnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLHIpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyl9KSxyfWZ1bmN0aW9uIEp0KCl7cmV0dXJuIDI9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/MTo0fWZ1bmN0aW9uIFp0KHQsZSl7cmV0dXJuIGhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVRleHR1cmUoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS5cIil9ZnVuY3Rpb24gdGUodCxlKXt2YXIgbj1hLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYodDw9MHx8ZTw9MCl7dmFyIHI9XCJbXCIrdCtcInhcIitlK1wiXVwiO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBpcyBpbnZhbGlkLlwiKX1pZih0Pm58fGU+bil7cj1cIltcIit0K1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSBcIisoXCJbXCIrbitcInhcIituK1wiXVwiKStcIi5cIil9fWZ1bmN0aW9uIGVlKHQsZSl7cmV0dXJuIGhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUZyYW1lYnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLlwiKX1mdW5jdGlvbiBuZSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1PXQuZ2V0QXR0cmliTG9jYXRpb24obixyKTtyZXR1cm4tMSE9PXUmJihCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG8pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudmVydGV4QXR0cmliUG9pbnRlcih1LGEsdC5GTE9BVCwhMSxpLHMpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodSl9KSwhMCl9ZnVuY3Rpb24gcmUodCxlLG4scil7cGUodCxyKSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArcil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KX1mdW5jdGlvbiBvZSh0LGUsbixyKXtyZXR1cm4gaGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2V0VW5pZm9ybUxvY2F0aW9uKG4scil9LCd1bmlmb3JtIFwiJytyKydcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpfWZ1bmN0aW9uIGFlKHQsZSxuKXtyZXR1cm4gdC5nZXRVbmlmb3JtTG9jYXRpb24oZSxuKX1mdW5jdGlvbiBpZSh0LGUsbixyLG8sYSl7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHJlKHQsZSxyLGEpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudW5pZm9ybTFpKG8sYSl9KX1mdW5jdGlvbiBzZSh0LGUsbixyKXtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixyKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbiwwKX0pfWZ1bmN0aW9uIHVlKHQsZSxuKXtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbnVsbCwwKX0pfWZ1bmN0aW9uIGxlKHQpe3ZhciBlPXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0LkZSQU1FQlVGRkVSKTtpZihlIT09dC5GUkFNRUJVRkZFUl9DT01QTEVURSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiBcIitjZSh0LGUpKX1mdW5jdGlvbiBjZSh0LGUpe3N3aXRjaChlKXtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIjtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOnJldHVyblwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOnJldHVyblwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIjtkZWZhdWx0OnJldHVyblwidW5rbm93biBlcnJvciBcIitlfX1mdW5jdGlvbiBoZSh0LGUsbixyKXt2YXIgbz1CdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gbigpfSk7aWYobnVsbD09byl0aHJvdyBuZXcgRXJyb3Iocik7cmV0dXJuIG99ZnVuY3Rpb24gcGUodCxlKXt2YXIgbj10Lk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTLTEscj1lK3QuVEVYVFVSRTA7aWYocjx0LlRFWFRVUkUwfHxyPm4pdGhyb3cgbmV3IEVycm9yKFwidGV4dHVyZVVuaXQgbXVzdCBiZSBpbiBcIisoXCJbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkVcIituK1wiXVwiKStcIi5cIil9ZnVuY3Rpb24gZmUodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MikseSh0LnNsaWNlKDAsdC5sZW5ndGgtZSkpfWZ1bmN0aW9uIGRlKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcIkNhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS5cIik7cmV0dXJuW3QubGVuZ3RoPjE/dFt0Lmxlbmd0aC0yXToxLHRbdC5sZW5ndGgtMV1dfWZ1bmN0aW9uIHZlKHQsZSl7dmFyIG47dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPWEuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZihlJiYocio9MiwxPT09KHQ9dC5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gbj49dC5sZW5ndGgtMj9wKHRbbl0pOnRbbl19KSkubGVuZ3RoJiYodD1bMix0WzBdXSkpLDIhPT10Lmxlbmd0aCl7dmFyIG89ayh0KTt0PW8ubmV3U2hhcGV9dmFyIGk9eSh0KTtpZih0Lmxlbmd0aDw9MSYmaTw9cilyZXR1cm5bMSxpXTtpZigyPT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV08PXIpcmV0dXJuIHQ7aWYoMz09PXQubGVuZ3RoJiZ0WzBdKnRbMV08PXImJnRbMl08PXIpcmV0dXJuW3RbMF0qdFsxXSx0WzJdXTtpZigzPT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV0qdFsyXTw9cilyZXR1cm5bdFswXSx0WzFdKnRbMl1dO2lmKDQ9PT10Lmxlbmd0aCYmdFswXSp0WzFdKnRbMl08PXImJnRbM108PXIpcmV0dXJuW3RbMF0qdFsxXSp0WzJdLHRbM11dO2lmKDQ9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXSp0WzJdKnRbM108PXIpcmV0dXJuW3RbMF0sdFsxXSp0WzJdKnRbM11dO2lmKGUpe3ZhciBzPWZlKHQpLHU9MixsPTI7cmV0dXJuIHQubGVuZ3RoJiYodT0obj1kZSh0KSlbMF0sbD1uWzFdKSxDKGk9cyoodS8yKSoobC8yKSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiAyKnR9KX1yZXR1cm4gQyhpKX1mdW5jdGlvbiBtZSh0KXtyZXR1cm4gdCUyPT0wfWZ1bmN0aW9uIGdlKHQsZSl7aWYoeCh0PXQuc2xpY2UoLTIpLGU9ZS5zbGljZSgtMikpKXJldHVybiEwO2lmKCF0Lmxlbmd0aHx8IWUubGVuZ3RoKXJldHVybiEwO2lmKDA9PT10WzBdfHwwPT09dFsxXXx8MD09PWVbMF18fDA9PT1lWzFdKXJldHVybiEwO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpe3ZhciBuPXQuc2xpY2UoLTEpWzBdLHI9ZS5zbGljZSgtMSlbMF07aWYobj09PXIpcmV0dXJuITA7aWYobWUobikmJm1lKHIpJiYoMT09PXRbMF18fDE9PT1lWzBdKSlyZXR1cm4hMH1yZXR1cm4gdFsxXT09PWVbMV0mJm1lKHRbMF0pJiZtZShlWzBdKX1mdW5jdGlvbiB5ZSh0KXtpZihudWxsPT1xdCl7dmFyIGU9RnQodCk7cXQ9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9TSVpFKX1yZXR1cm4gcXR9ZnVuY3Rpb24geGUodCl7aWYobnVsbD09SHQpe3ZhciBlPUZ0KHQpO0h0PWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpfXJldHVybiBNYXRoLm1pbigxNixIdCl9ZnVuY3Rpb24gd2UodCl7aWYoMD09PXQpcmV0dXJuIDA7dmFyIGU9RnQodCk7cmV0dXJuIGJlKGUsXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpJiYyPT09dD8yOmJlKGUsXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIik/MTowfWZ1bmN0aW9uIGJlKHQsZSl7cmV0dXJuIG51bGwhPXQuZ2V0RXh0ZW5zaW9uKGUpfWZ1bmN0aW9uIENlKHQpe3RyeXtpZihudWxsIT1GdCh0KSlyZXR1cm4hMH1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4hMX1mdW5jdGlvbiBFZSh0KXtpZigwPT09dClyZXR1cm4hMTt2YXIgZT1GdCh0KTtpZigxPT09dCl7aWYoIWJlKGUsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSlyZXR1cm4hMX1lbHNlIGlmKCFiZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gU2UoZSx0KX1mdW5jdGlvbiBSZSh0KXtpZigwPT09dClyZXR1cm4hMTt2YXIgZT1GdCh0KTtpZigxPT09dCl7aWYoIWJlKGUsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSlyZXR1cm4hMTtpZighYmUoZSxcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMX1lbHNlIGlmKCFiZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gU2UoZSx0KX1mdW5jdGlvbiBTZSh0LGUpe3ZhciBuPXQuY3JlYXRlRnJhbWVidWZmZXIoKSxyPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELHIpO3ZhciBvPTI9PT1lP3QuUkdCQTMyRjp0LlJHQkE7dC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLG8sMSwxLDAsdC5SR0JBLHQuRkxPQVQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixuKSx0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsciwwKTt2YXIgYT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShyKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKG4pLGF9ZnVuY3Rpb24gTmUodCl7cmV0dXJuIDI9PT10JiZudWxsIT1GdCh0KS5mZW5jZVN5bmN9dmFyIGtlPU9iamVjdC5mcmVlemUoe2NhbGxBbmRDaGVjazpCdCxjYW5CZVJlcHJlc2VudGVkOld0LGdldFdlYkdMRXJyb3JNZXNzYWdlOlV0LGdldEV4dGVuc2lvbk9yVGhyb3c6enQsY3JlYXRlVmVydGV4U2hhZGVyOlZ0LGNyZWF0ZUZyYWdtZW50U2hhZGVyOkd0LGNyZWF0ZVByb2dyYW06anQsbGlua1Byb2dyYW06S3QsdmFsaWRhdGVQcm9ncmFtOlh0LGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjpZdCxjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjpRdCxnZXROdW1DaGFubmVsczpKdCxjcmVhdGVUZXh0dXJlOlp0LHZhbGlkYXRlVGV4dHVyZVNpemU6dGUsY3JlYXRlRnJhbWVidWZmZXI6ZWUsYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTpuZSxiaW5kVGV4dHVyZVVuaXQ6cmUsdW5iaW5kVGV4dHVyZVVuaXQ6ZnVuY3Rpb24odCxlLG4pe3BlKHQsbiksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYWN0aXZlVGV4dHVyZSh0LlRFWFRVUkUwK24pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSl9LGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93Om9lLGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb246YWUsYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcjppZSxiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjpmdW5jdGlvbih0LGUpe0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudmlld3BvcnQoMCwwLHQuY2FudmFzLndpZHRoLHQuY2FudmFzLmhlaWdodCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5zY2lzc29yKDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSl9LGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyOnNlLHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcjp1ZSx2YWxpZGF0ZUZyYW1lYnVmZmVyOmxlLGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlOmNlLGdldEJhdGNoRGltOmZlLGdldFJvd3NDb2xzOmRlLGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU6dmUsaXNSZXNoYXBlRnJlZTpnZSxnZXQgTUFYX1RFWFRVUkVfU0laRSgpe3JldHVybiBxdH0sZ2V0IE1BWF9URVhUVVJFU19JTl9TSEFERVIoKXtyZXR1cm4gSHR9LGdldFdlYkdMTWF4VGV4dHVyZVNpemU6eWUsZ2V0TWF4VGV4dHVyZXNJblNoYWRlcjp4ZSxnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb246d2UsaXNXZWJHTFZlcnNpb25FbmFibGVkOkNlLGlzUmVuZGVyVG9GbG9hdFRleHR1cmVFbmFibGVkOkVlLGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkOlJlLGlzV2ViR0xGZW5jZUVuYWJsZWQ6TmV9KTtmdW5jdGlvbiBJZSgpe2Euc2V0KFwiUFJPRFwiLCEwKX1mdW5jdGlvbiBBZSgpe2Euc2V0KFwiREVCVUdcIiwhMCl9ZnVuY3Rpb24gVGUoKXthLnNldChcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIiwhMSksY29uc29sZS53YXJuKFwiVGVuc29yRmxvdy5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyBoYXZlIGJlZW4gZGlzYWJsZWQuXCIpfWZ1bmN0aW9uIERlKHQpe2EuZ2V0Qm9vbChcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIikmJmNvbnNvbGUud2Fybih0K1wiIFlvdSBjYW4gZGlzYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5ncyB3aXRoIHRmLmRpc2FibGVEZXByZWNhdGlvbldhcm5pbmdzKCkuXCIpfWZ1bmN0aW9uIE9lKCl7RHQuZGlzcG9zZVZhcmlhYmxlcygpfWZ1bmN0aW9uIF9lKCl7cmV0dXJuIER0Lm1lbW9yeSgpfWZ1bmN0aW9uIE1lKHQpe3JldHVybiBEdC5wcm9maWxlKHQpfWZ1bmN0aW9uIEZlKHQsZSl7cmV0dXJuIER0LnRpZHkodCxlKX1mdW5jdGlvbiBCZSh0KXtOdCh0KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRpc3Bvc2UoKX0pfWZ1bmN0aW9uIFBlKHQpe3JldHVybiBEdC5rZWVwKHQpfWZ1bmN0aW9uIExlKHQpe3JldHVybiBEdC50aW1lKHQpfWZ1bmN0aW9uIFdlKHQpe3JldHVybiBEdC5zZXRCYWNrZW5kKHQpfWZ1bmN0aW9uIFVlKCl7cmV0dXJuIER0LnJlYWR5KCl9ZnVuY3Rpb24gemUoKXtyZXR1cm4gRHQuYmFja2VuZE5hbWV9ZnVuY3Rpb24gVmUodCl7RHQucmVtb3ZlQmFja2VuZCh0KX1mdW5jdGlvbiBHZSh0KXtyZXR1cm4gRHQuZmluZEJhY2tlbmQodCl9ZnVuY3Rpb24gcWUodCl7cmV0dXJuIER0LmZpbmRCYWNrZW5kRmFjdG9yeSh0KX1mdW5jdGlvbiBIZSh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLER0LnJlZ2lzdGVyQmFja2VuZCh0LGUsbil9ZnVuY3Rpb24gJGUoKXtyZXR1cm4gRHQuYmFja2VuZH1mdW5jdGlvbiBqZSgpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTthLmdldEJvb2woXCJJU19URVNUXCIpfHxjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSx0KX1mdW5jdGlvbiBLZSh0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMCk7dmFyIG89W107aWYocikobz1vLmNvbmNhdChlLnNsaWNlKDApKSkucHVzaCh0WzBdL24pLG89by5jb25jYXQodC5zbGljZSgxKSk7ZWxzZXtvPW8uY29uY2F0KHRbMF0pO2Zvcih2YXIgYT1lLmxlbmd0aCxpPTA7aTxhOysraSlvPW8uY29uY2F0KFt0W2krMV0vZVtpXSxlW2ldXSk7bz1vLmNvbmNhdCh0LnNsaWNlKGErMSkpfXJldHVybiBvfWZ1bmN0aW9uIFhlKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMCk7dmFyIHI9W107aWYobil7ci5wdXNoKGUpO2Zvcih2YXIgbz1lKzE7bzx0OysrbylvPD0yKmU/KHIucHVzaChvKSxyLnB1c2goby0oZSsxKSkpOnIucHVzaChvKX1lbHNle3ZhciBhPVtdLGk9W107Zm9yKG89MTtvPHQ7KytvKW8+PTIqZSsxfHxvJTI9PTE/aS5wdXNoKG8pOmEucHVzaChvKTtyLnB1c2guYXBwbHkocixhKSxyLnB1c2goMCksci5wdXNoLmFwcGx5KHIsaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gWWUodCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPVtdO3I/by5wdXNoKHRbMF0vbik6by5wdXNoKHRbMF0qbik7Zm9yKHZhciBhPTE7YTx0Lmxlbmd0aDsrK2EpYTw9ZS5sZW5ndGg/cj9vLnB1c2goZVthLTFdKnRbYV0pOm8ucHVzaCh0W2FdL2VbYS0xXSk6by5wdXNoKHRbYV0pO3JldHVybiBvfWZ1bmN0aW9uIFFlKHQsZSl7Zm9yKHZhciBuPVswXSxyPTA7cjxlOysrciluLnB1c2godFtyXVswXSk7cmV0dXJuIG59ZnVuY3Rpb24gSmUodCxlLG4pe2Zvcih2YXIgcj10LnNsaWNlKDAsMSksbz0wO288bjsrK28pci5wdXNoKHRbbysxXS1lW29dWzBdLWVbb11bMV0pO3JldHVybiByfWZ1bmN0aW9uIFplKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24paWYodFt0Lmxlbmd0aC1uLTFdIT09ZS0xLW4pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gdG4odCxlKXtmb3IodmFyIG49W10scj10Lmxlbmd0aCxvPTA7bzxyO28rKyktMT09PWUuaW5kZXhPZihvKSYmbi5wdXNoKHRbb10pO3JldHVybltuLGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSldfWZ1bmN0aW9uIGVuKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9dC5sZW5ndGgrZS5sZW5ndGgsbz1bXSxhPTAsaT0wLHM9MDtzPHI7cysrKS0xPT09bi5pbmRleE9mKHMpP28ucHVzaCh0W2ErK10pOm8ucHVzaChlW2krK10pO3JldHVybiBvfSh0LGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiAxfSksZSl9ZnVuY3Rpb24gbm4odCxlLG4pe2QoWmUoZSxuKSxmdW5jdGlvbigpe3JldHVybiB0K1wiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIEdvdCBheGVzIFwiK2UrXCIgYW5kIHJhbmstXCIrbitcIiBpbnB1dC5cIn0pfWZ1bmN0aW9uIHJuKHQsZSl7aWYoWmUodCxlKSlyZXR1cm4gbnVsbDtmb3IodmFyIG49W10scj0wO3I8ZTsrK3IpLTE9PT10LmluZGV4T2YocikmJm4ucHVzaChyKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBuLnB1c2godCl9KSxufWZ1bmN0aW9uIG9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0LGUpe3JldHVybltlLHRdfSkuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0WzFdLWVbMV19KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KX1mdW5jdGlvbiBhbih0LGUpe2Zvcih2YXIgbj1bXSxyPWUtdDtyPGU7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBzbih0LGUpe2Zvcih2YXIgbj10WzBdLnNsaWNlKCkscj0xO3I8dC5sZW5ndGg7cisrKW5bZV0rPXRbcl1bZV07cmV0dXJuIG59ZnVuY3Rpb24gdW4odCxlKXtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrdC5yYW5rK1wiLlwiKTtpZihlLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK2UuZHR5cGUrXCIuXCIpO2lmKGUuc2hhcGVbZS5yYW5rLTFdPnQucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBpbm5lcm1vc3QgZGltZW5zaW9uIGxlbmd0aCBtdXN0IGJlIDw9IHRlbnNvciByYW5rOyBzYXc6IFwiK2Uuc2hhcGVbZS5yYW5rLTFdK1wiIHZzLiBcIit0LnJhbmspO2lmKDA9PT10LnNpemUpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIG1vcmUgdGhhbiAwIGVudHJpZXMsIGJ1dCBpbnB1dCBpcyBlbXB0eS4gSW5wdXQgc2hhcGU6IFwiK3Quc2hhcGUrXCIuXCIpO2Zvcih2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPTEsYT0wO2E8bi5sZW5ndGgtMTsrK2Epbyo9blthXTt2YXIgaT10LnNoYXBlLHM9bi5zbGljZSgpO3MucG9wKCk7dmFyIHU9MTtmb3IoYT1yO2E8dC5yYW5rOysrYSl1Kj1pW2FdLHMucHVzaChpW2FdKTt2YXIgbD1WKHQuc2hhcGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC91fSkuY29uY2F0KFsxXSkuc2xpY2UoMCxyKTtyZXR1cm5bcyxvLHUsbF19YS5yZWdpc3RlckZsYWcoXCJIQVNfV0VCR0xcIixmdW5jdGlvbigpe3JldHVybiBhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik+MH0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfVkVSU0lPTlwiLGZ1bmN0aW9uKCl7cmV0dXJuIENlKDIpPzI6Q2UoMSk/MTowfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9CVUZGRVJfU1VQUE9SVEVEXCIsZnVuY3Rpb24oKXtyZXR1cm4gMj09PWEuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIixmdW5jdGlvbigpe3JldHVybiExfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0NMSVBcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlZcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19SRURVQ0VcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ09OVl9JTTJDT0xcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIsZnVuY3Rpb24oKXtyZXR1cm4geWUoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiLGZ1bmN0aW9uKCl7cmV0dXJuIHhlKGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIsZnVuY3Rpb24oKXt2YXIgdD1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7cmV0dXJuIDA9PT10PzA6d2UodCl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MCYmKHQ9bmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhLCEoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QodCl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QodC5zdWJzdHIoMCw0KSkpKTt2YXIgdH0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiLGZ1bmN0aW9uKCl7cmV0dXJuIEVlKGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIixmdW5jdGlvbigpe3JldHVybiBSZShhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiLGZ1bmN0aW9uKCl7cmV0dXJuIE5lKGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpPzQ6MH0pLHB0PURlO3ZhciBsbj0zMDtmdW5jdGlvbiBjbih0KXtyZXR1cm4gdDw9bG4/dDp6KHQsTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKX1mdW5jdGlvbiBobih0LGUsbil7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgdXBkYXRlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK3QucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZHR5cGUgb2YgJ2luZGljZXMnIHNob3VsZCBiZSBpbnQzMiwgYnV0IGdvdCBkdHlwZTogXCIrZS5kdHlwZSk7aWYobi5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogXCIrbik7aWYoMD09PW4ubGVuZ3RoKXtpZigwPT09ZS5zaXplKXRocm93IG5ldyBFcnJvcihcIkluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6IFwiK2Uuc2hhcGUpO2lmKDA9PT10LnNpemUpdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gdXBkYXRlcyBzaGFwZTogXCIrdC5zaGFwZSl9IWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1lLnJhbms+MT9lLnNoYXBlW2UucmFuay0xXToxLG89ZS5yYW5rPjE/ZS5yYW5rLTE6MSxhPVwiTXVzdCBoYXZlIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gKyBzaGFwZVtzbGljZURpbTpdLCBnb3QgdXBkYXRlcy5zaGFwZTogXCIrbi5zaGFwZStcIiwgaW5kaWNlcy5zaGFwZTogXCIrZS5zaGFwZStcIiwgc2hhcGU6IFwiK3QrXCIsIHNsaWNlRGltOiBcIityK1wiLCBhbmQgYmF0Y2hEaW06IFwiK28rXCIuXCI7aWYobi5yYW5rPG8pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlLnJhbmsgPCBcIitvK1wiLiBcIik7aWYodC5sZW5ndGg8cisobi5yYW5rLW8pKXRocm93IG5ldyBFcnJvcihhK1wiIE91dHB1dCBzaGFwZSBsZW5ndGggPCBcIisocisobi5yYW5rLW8pKSk7aWYobi5yYW5rIT09byt0Lmxlbmd0aC1yKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rICE9IFwiKyhvK3QubGVuZ3RoLXIpKTtmb3IodmFyIGk9MDtpPG87KytpKWlmKG4uc2hhcGVbaV0hPT1lLnNoYXBlW2ldKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZXMuc2hhcGVbXCIraStcIl0gKFwiK24uc2hhcGVbaV0rXCIpICE9IGluZGljZXMuc2hhcGVbXCIraStcIl0gKFwiK2Uuc2hhcGVbaV0rXCIpLlwiKTtmb3IoaT0wO2k8bi5yYW5rLW87KytpKWlmKG4uc2hhcGVbaStvXSE9PXRbaStyXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiKyhpK28pK1wiXSAoXCIrbi5zaGFwZVtpK29dK1wiKSAhPSBzaGFwZVtcIisoaStvKStcIl0gKFwiK3RbaStvXStcIilcIil9KG4sZSx0KX1mdW5jdGlvbiBwbih0LGUsbil7Zm9yKHZhciByPWUucmFuaz4xP2Uuc2hhcGVbZS5yYW5rLTFdOjEsbz1uLmxlbmd0aCxhPTEsaT1yO2k8bzsrK2kpYSo9bltpXTt2YXIgcz1yPDE/MTpyO3JldHVybntzbGljZVJhbms6cixudW1VcGRhdGVzOmUuc2l6ZS9zLHNsaWNlU2l6ZTphLHN0cmlkZXM6VihuLnNsaWNlKDAscikpLmNvbmNhdChbMV0pLG91dHB1dFNpemU6eShuKX19ZnVuY3Rpb24gZm4odCxlLG4scixvLGEsaSxzLHUpe2lmKHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHZvaWQgMD09PXUmJih1PTApLDAhPT1pKXRocm93IG5ldyBFcnJvcihcImVsbGlwc2lzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwibmV3IGF4aXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIGw9W10sYz1bXSxoPVtdLHA9MDtwPHQubGVuZ3RoO3ArKylsW3BdPWRuKG8sZSxyLHQscCksY1twXT12bihhLG4scix0LHApLHUmMTw8cCYmKGNbcF09bFtwXSsxLGgucHVzaChwKSk7dmFyIGY9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKDApO3JldHVybiBmPWYubWFwKGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsbz1yW2VdfHwxLGE9bFtlXTshKG8+MD9hPj1jW2VdOmE8PWNbZV0pO2ErPW8pbis9MTtyZXR1cm4gbn0pLFtsLGYsaF19ZnVuY3Rpb24gZG4odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NSU5fU0FGRV9JTlRFR0VSOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPWgoMCxhLHMtMSl9ZnVuY3Rpb24gdm4odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NQVhfU0FGRV9JTlRFR0VSOk51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPWk+MD9oKDAsYSxzKTpoKC0xLGEscy0xKX1mdW5jdGlvbiBtbih0LGUsbil7Zm9yKHZhciByPW4ubGVuZ3RoLG89MDtvPG4ubGVuZ3RoO28rKylpZihuW29dPjEpe3I9bzticmVha31mb3Iobz1yKzE7bzxuLmxlbmd0aDtvKyspaWYoZVtvXT4wfHxuW29dIT09dFtvXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBnbih0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aD4wP3RbdC5sZW5ndGgtMV06MSxyPTA7cjx0Lmxlbmd0aC0xO3IrKyluKz10W3JdKmVbcl07cmV0dXJuIG59ZnVuY3Rpb24geW4odCl7dmFyIGU9dDtpZihfKHQpKXJldHVyblt0Lmxlbmd0aF07aWYoIUFycmF5LmlzQXJyYXkodCkpcmV0dXJuW107Zm9yKHZhciBuPVtdO0FycmF5LmlzQXJyYXkoZSl8fF8oZSk7KW4ucHVzaChlLmxlbmd0aCksZT1lWzBdO3JldHVybiBBcnJheS5pc0FycmF5KHQpJiZhLmdldEJvb2woXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIpJiZmdW5jdGlvbiB0KGUsbixyKXtyPXJ8fFtdO2lmKCFBcnJheS5pc0FycmF5KGUpJiYhXyhlKSlyZXR1cm4gdm9pZCBkKDA9PT1uLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIGlzIGEgcHJpbWl0aXZlLCBidXQgc2hvdWxkIGJlIGFuIGFycmF5L1R5cGVkQXJyYXkgb2YgXCIrblswXStcIiBlbGVtZW50c1wifSk7ZChuLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGJlIGEgcHJpbWl0aXZlLCBidXQgaXMgYW4gYXJyYXkgb2YgXCIrZS5sZW5ndGgrXCIgZWxlbWVudHNcIn0pO2QoZS5sZW5ndGg9PT1uWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gc2hvdWxkIGhhdmUgXCIrblswXStcIiBlbGVtZW50cywgYnV0IGhhcyBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSk7dmFyIG89bi5zbGljZSgxKTtmb3IodmFyIGE9MDthPGUubGVuZ3RoOysrYSl0KGVbYV0sbyxyLmNvbmNhdChhKSl9KHQsbixbXSksbn1mdW5jdGlvbiB4bih0LGUsbixyKXtpZihudWxsIT10JiYoXCJudW1lcmljXCIhPT10JiZ0IT09ZXx8XCJudW1lcmljXCI9PT10JiZcInN0cmluZ1wiPT09ZSkpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK24rXCInIHBhc3NlZCB0byAnXCIrcitcIicgbXVzdCBiZSBcIit0K1wiIHRlbnNvciwgYnV0IGdvdCBcIitlK1wiIHRlbnNvclwiKX1mdW5jdGlvbiB3bih0LGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1cIm51bWVyaWNcIiksdCBpbnN0YW5jZW9mIGZ0KXJldHVybiB4bihyLHQuZHR5cGUsZSxuKSx0O3ZhciBvPVcodCk7aWYoXCJzdHJpbmdcIiE9PW8mJltcImJvb2xcIixcImludDMyXCIsXCJmbG9hdDMyXCJdLmluZGV4T2Yocik+PTAmJihvPXIpLHhuKHIsbyxlLG4pLG51bGw9PXR8fCFfKHQpJiYhQXJyYXkuaXNBcnJheSh0KSYmXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiYm9vbGVhblwiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpe3ZhciBpPW51bGw9PXQ/XCJudWxsXCI6dC5jb25zdHJ1Y3Rvci5uYW1lO3Rocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdcIitlK1wiJyBwYXNzZWQgdG8gJ1wiK24rXCInIG11c3QgYmUgYSBUZW5zb3Igb3IgVGVuc29yTGlrZSwgYnV0IGdvdCAnXCIraStcIidcIil9dmFyIHM9eW4odCk7Xyh0KXx8QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKTt2YXIgdT1cInN0cmluZ1wiIT09bz9HKHQsbyxhLmdldEJvb2woXCJERUJVR1wiKSk6Zyh0KTtyZXR1cm4gZnQubWFrZShzLHt2YWx1ZXM6dX0sbyl9ZnVuY3Rpb24gYm4odCxlLG4scil7aWYodm9pZCAwPT09ciYmKHI9XCJudW1lcmljXCIpLCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IFwiK2UrXCIgcGFzc2VkIHRvIFwiK24rXCIgbXVzdCBiZSBhIGBUZW5zb3JbXWAgb3IgYFRlbnNvckxpa2VbXWBcIik7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQscil7cmV0dXJuIHduKHQsZStcIltcIityK1wiXVwiLG4pfSxyKX1mdW5jdGlvbiBDbih0KXtyZXR1cm4gZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pLGZ1bmN0aW9uKGUsbil7dmFyIHI9d24oZSxcInhcIixcInRmLmdyYWRcIixudWxsKSxvPW51bGwhPW4/d24obixcImR5XCIsXCJ0Zi5ncmFkXCIpOm51bGw7cmV0dXJuIER0LnRpZHkoZnVuY3Rpb24oKXt2YXIgZT1EdC5ncmFkaWVudHMoZnVuY3Rpb24oKXtyZXR1cm4gdChyKX0sW3JdLG8pLG49ZS52YWx1ZSxhPWUuZ3JhZHM7cmV0dXJuIG51bGwhPW8mJnYobi5zaGFwZSxvLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKHgpXCIpLEluKGEpLGFbMF19KX19ZnVuY3Rpb24gRW4odCl7cmV0dXJuIGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSksZnVuY3Rpb24oZSxuKXtkKEFycmF5LmlzQXJyYXkoZSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiBncmFkcyhmKShhcmdzKSBtdXN0IGJlIGFuIGFycmF5IG9mIGBUZW5zb3JgcyBvciBgVGVuc29yTGlrZWBzXCJ9KTt2YXIgcj1ibihlLFwiYXJnc1wiLFwidGYuZ3JhZHNcIixudWxsKSxvPW51bGwhPW4/d24obixcImR5XCIsXCJ0Zi5ncmFkc1wiKTpudWxsO3JldHVybiBEdC50aWR5KGZ1bmN0aW9uKCl7dmFyIGU9RHQuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodm9pZCAwLHIpfSxyLG8pLG49ZS52YWx1ZSxhPWUuZ3JhZHM7cmV0dXJuIG51bGwhPW8mJnYobi5zaGFwZSxvLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLEluKGEpLGF9KX19ZnVuY3Rpb24gUm4odCl7cmV0dXJuIGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pLGZ1bmN0aW9uKGUsbil7ZChlIGluc3RhbmNlb2YgZnQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB4IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvclwifSksZChudWxsPT1ufHxuIGluc3RhbmNlb2YgZnQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCJ9KTt2YXIgcj1EdC5ncmFkaWVudHMoZnVuY3Rpb24oKXtyZXR1cm4gdChlKX0sW2VdLG4pLG89ci5ncmFkcyxhPXIudmFsdWU7cmV0dXJuIEluKG8pLHtncmFkOm9bMF0sdmFsdWU6YX19fWZ1bmN0aW9uIFNuKHQpe3JldHVybiBkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSksZnVuY3Rpb24oZSxuKXtkKEFycmF5LmlzQXJyYXkoZSkmJmUuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmdH0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzKSBtdXN0IGJlIGFycmF5IG9mIHRlbnNvcnNcIn0pLGQobnVsbD09bnx8biBpbnN0YW5jZW9mIGZ0LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncywgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pO3ZhciByPUR0LmdyYWRpZW50cyhmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KHZvaWQgMCxlKX0sZSxuKTtyZXR1cm4gbnVsbCE9biYmdihyLnZhbHVlLnNoYXBlLG4uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxJbihyLmdyYWRzKSxyfX1mdW5jdGlvbiBObih0LGUpe2lmKGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSxkKG51bGw9PWV8fEFycmF5LmlzQXJyYXkoZSkmJmUuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBkdH0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgdmFyTGlzdCBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KSBtdXN0IGJlIGFuIGFycmF5IG9mIHZhcmlhYmxlc1wifSksbnVsbD09ZSlmb3IodmFyIG4gaW4gZT1bXSxEdC5yZWdpc3RlcmVkVmFyaWFibGVzKWUucHVzaChEdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dKTt2YXIgcj1lLmxlbmd0aDtkKChlPWUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYWluYWJsZX0pKS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwidmFyaWFibGVHcmFkcygpIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbnB1dCB2YXJpYWJsZXMgdG8gYmUgdHJhaW5hYmxlLCBidXQgbm9uZSBvZiB0aGUgXCIrcitcIiB2YXJpYWJsZXMgaXMgdHJhaW5hYmxlLlwifSk7dmFyIG89RHQuZ3JhZGllbnRzKHQsZSxudWxsLCEwKSxhPW8udmFsdWUsaT1vLmdyYWRzO2QoaS5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSksZnVuY3Rpb24oKXtyZXR1cm5cIkNhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgdmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuXCJ9KSxkKDA9PT1hLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgcmV0dXJuIGEgc2NhbGFyLCBidXQgaXQgcmV0dXJuZWQgYSByYW5rLVwiK2EucmFuaytcIiB0ZW5zb3JcIn0pO3ZhciBzPXt9O3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24odCxlKXtudWxsIT1pW2VdJiYoc1t0Lm5hbWVdPWlbZV0pfSkse3ZhbHVlOmEsZ3JhZHM6c319ZnVuY3Rpb24ga24odCl7cmV0dXJuIER0LmN1c3RvbUdyYWQodCl9ZnVuY3Rpb24gSW4odCl7aWYodC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9KS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0XFxuICAgIHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKX1mdW5jdGlvbiBBbih0KXt2YXIgZT1PYmplY3Qua2V5cyh0KTtpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggXCIrZS5sZW5ndGgrXCIga2V5cy5cIik7dmFyIG49ZVswXSxyPXRbbl07bi5lbmRzV2l0aChcIl9cIikmJihuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMSkpO3ZhciBvPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO0R0LnN0YXJ0U2NvcGUobik7dHJ5e3ZhciBvPXIuYXBwbHkodm9pZCAwLHQpO3JldHVybiBvIGluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxEdC5lbmRTY29wZShvKSxvfWNhdGNoKHQpe3Rocm93IER0LmVuZFNjb3BlKG51bGwpLHR9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJuYW1lXCIse3ZhbHVlOm4sY29uZmlndXJhYmxlOiEwfSksb312YXIgVG49QW4oe3NvZnRtYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LTEpO3ZhciBuPXduKHQsXCJsb2dpdHNcIixcInNvZnRtYXhcIik7aWYoLTE9PT1lJiYoZT1uLnJhbmstMSksZSE9PW4ucmFuay0xKXRocm93IEVycm9yKFwiU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rIFwiK24ucmFuaytcIiBhbmQgZGltIHdhcyBcIitlKTtyZXR1cm4ga24oZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZ1N1bUV4cChbZV0sITApLG89dC50b0Zsb2F0KCkuc3ViKHIpLmV4cCgpO3JldHVybiBuKFtvXSkse3ZhbHVlOm8sZ3JhZEZ1bmM6ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLG89dC5tdWwocik7cmV0dXJuIG8uc3ViKG8uc3VtKFtlXSwhMCkubXVsKHIpKX19fSkobil9fSksRG49QW4oe2xvZ1NvZnRtYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LTEpO3ZhciBuPXduKHQsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYoLTE9PT1lJiYoZT1uLnJhbmstMSksZSE9PW4ucmFuay0xKXRocm93IEVycm9yKFwiTG9nIFNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGF4aXMgd2FzIFwiK2UpO3JldHVybiBrbihmdW5jdGlvbih0LG4pe3ZhciByPXQubWF4KGUsITApLG89dC5zdWIociksYT1vLnRvRmxvYXQoKS5zdWIoby5leHAoKS5zdW0oZSwhMCkubG9nKCkpO3JldHVybiBuKFthXSkse3ZhbHVlOmEsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLmV4cCgpO3JldHVybiB0LnN1Yih0LnN1bShlLCEwKS5tdWwocikpfX19KShuKX19KTt2YXIgT249QW4oe2NvbXBsZXhfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInJlYWxcIixcImNvbXBsZXhcIikscj13bihlLFwiaW1hZ1wiLFwiY29tcGxleFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJyZWFsIGFuZCBpbWFnIHNoYXBlcywgXCIrbi5zaGFwZStcIiBhbmQgXCIrci5zaGFwZStcIiwgbXVzdCBtYXRjaCBpbiBjYWxsIHRvIHRmLmNvbXBsZXgoKS5cIiksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBsZXgobixyKX0seyRyZWFsOm4sJGltYWc6cn0pfX0pLF9uPUFuKHtyZWFsXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwiaW5wdXRcIixcInJlYWxcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFsKGUpfSx7JGlucHV0OmV9KX19KSxNbj1Bbih7aW1hZ186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcImlucHV0XCIsXCJpbWFnXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaW1hZyhlKX0seyRpbnB1dDplfSl9fSk7ZnVuY3Rpb24gRm4odCxlLG4pe2lmKG51bGw9PW4mJihuPVcodCkpLFwiY29tcGxleDY0XCI9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYSBjb21wbGV4NjQgdGVuc29yIGRpcmVjdGx5LiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO2lmKCFfKHQpJiYhQXJyYXkuaXNBcnJheSh0KSYmXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiYm9vbGVhblwiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGEgbnVtYmVyL2Jvb2xlYW4vc3RyaW5nIG9yIGFuIGFycmF5IG9mIG51bWJlcnMvYm9vbGVhbnMvc3RyaW5ncywgb3IgYSBUeXBlZEFycmF5XCIpO3ZhciByPXluKHQpO2lmKG51bGwhPWUpe0soZSk7dmFyIG89eShlKSxpPXkocik7ZChvPT09aSxmdW5jdGlvbigpe3JldHVyblwiQmFzZWQgb24gdGhlIHByb3ZpZGVkIHNoYXBlLCBbXCIrZStcIl0sIHRoZSB0ZW5zb3Igc2hvdWxkIGhhdmUgXCIrbytcIiB2YWx1ZXMgYnV0IGhhcyBcIitpfSk7Zm9yKHZhciBzPTA7czxyLmxlbmd0aDsrK3Mpe3ZhciB1PXJbc10sbD1zIT09ci5sZW5ndGgtMXx8dSE9PXkoZS5zbGljZShzKSk7ZChyW3NdPT09ZVtzXXx8IWwsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgKFwiK3IrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSAoXCIrZStcIikuIFwifSl9fXJldHVybiBfKHQpfHxBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLGU9ZXx8cix0PVwic3RyaW5nXCIhPT1uP0codCxuLGEuZ2V0Qm9vbChcIkRFQlVHXCIpKTpnKHQpLGZ0Lm1ha2UoZSx7dmFsdWVzOnR9LG4pfWZ1bmN0aW9uIEJuKHQsZSl7aWYoKF8odCl8fEFycmF5LmlzQXJyYXkodCkpJiZcImNvbXBsZXg2NFwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBhIG5ldyBTY2FsYXI6IHZhbHVlIG11c3QgYmUgYSBwcmltaXRpdmUgKG51bWJlcnxib29sZWFufHN0cmluZylcIik7cmV0dXJuIEZuKHQsW10sZSl9ZnVuY3Rpb24gUG4odCxlKXttKHQpO3ZhciBuPXluKHQpO2lmKDEhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IxZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gRm4odCxuLGUpfWZ1bmN0aW9uIExuKHQsZSxuKXtpZihtKHQpLG51bGwhPWUmJjIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7dmFyIHI9eW4odCk7aWYoMiE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIEZuKHQsZT1lfHxyLG4pfWZ1bmN0aW9uIFduKHQsZSxuKXtpZihtKHQpLG51bGwhPWUmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdGhyZWUgbnVtYmVyc1wiKTt2YXIgcj15bih0KTtpZigzIT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gRm4odCxlPWV8fHIsbil9ZnVuY3Rpb24gVW4odCxlLG4pe2lmKG0odCksbnVsbCE9ZSYmNCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmb3VyIG51bWJlcnNcIik7dmFyIHI9eW4odCk7aWYoNCE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gRm4odCxlPWV8fHIsbil9ZnVuY3Rpb24gem4odCxlLG4pe2lmKG0odCksbnVsbCE9ZSYmNSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7dmFyIHI9eW4odCk7aWYoNSE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBGbih0LGU9ZXx8cixuKX1mdW5jdGlvbiBWbih0LGUsbil7aWYobSh0KSxudWxsIT1lJiY2IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHNpeCBudW1iZXJzXCIpO3ZhciByPXluKHQpO2lmKDYhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBGbih0LGU9ZXx8cixuKX1mdW5jdGlvbiBHbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxcImNvbXBsZXg2NFwiPT09ZSl7dmFyIG49R24odCxcImZsb2F0MzJcIikscj1xbih0LFwiZmxvYXQzMlwiKTtyZXR1cm4gT24obixyKX12YXIgbz1IKHkodCksZSk7cmV0dXJuIGZ0Lm1ha2UodCx7dmFsdWVzOm99LGUpfWZ1bmN0aW9uIHFuKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLFwiY29tcGxleDY0XCI9PT1lKXt2YXIgbj1xbih0LFwiZmxvYXQzMlwiKSxyPXFuKHQsXCJmbG9hdDMyXCIpO3JldHVybiBPbihuLHIpfXZhciBvPSQoeSh0KSxlKTtyZXR1cm4gZnQubWFrZSh0LHt2YWx1ZXM6b30sZSl9ZnVuY3Rpb24gSG4odCxlLG4pe3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24ocil7cmV0dXJuIHIuZmlsbCh0LGUsbil9LHt9KX1mdW5jdGlvbiAkbih0LGUsbil7aWYobjw9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHZhbHVlcyBzaG91bGQgYmUgcG9zaXRpdmUuXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24ocil7cmV0dXJuIHIubGluc3BhY2UodCxlLG4pfSx7fSl9ZnVuY3Rpb24gam4odCxlLG4scil7aWYodm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgc3RlcCBvZiB6ZXJvXCIpO2lmKHQ9PT1lfHx0PGUmJm48MHx8ZTx0JiZuPjEpcmV0dXJuIHFuKFswXSxyKTt2YXIgbz0kKE1hdGguYWJzKE1hdGguY2VpbCgoZS10KS9uKSkscik7ZTx0JiYxPT09biYmKG49LTEpLG9bMF09dDtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStuO3JldHVybiBQbihvLHIpfXZhciBLbj1Bbih7b25lc0xpa2VfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJvbmVzTGlrZVwiKTtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl7dmFyIG49S24oX24oZSkpLHI9WG4oTW4oZSkpO3JldHVybiBPbihuLHIpfXJldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQub25lc0xpa2UoZSl9LHskeDplfSxudWxsKX19KSxYbj1Bbih7emVyb3NMaWtlXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiemVyb3NMaWtlXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuemVyb3NMaWtlKGUpfSx7JHg6ZX0sbnVsbCl9fSksWW49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZGF0YU1vdmVyPXQsdGhpcy5kYXRhPW5ldyBXZWFrTWFwfXJldHVybiB0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl8fHRoaXMuZGF0YU1vdmVyLm1vdmVEYXRhKHQpLHRoaXMuZGF0YS5nZXQodCl9LHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe3RoaXMuZGF0YS5zZXQodCxlKX0sdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpfSx0LnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5kZWxldGUodCl9LHR9KCksUW49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sdC5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0fSgpO2Z1bmN0aW9uIEpuKHQsZSxuKXtpZihcImNvbXBsZXg2NFwiPT09ZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpcmV0dXJuIHQuY2xvbmUoKTt2YXIgcj1xbih0LnNoYXBlKSxvPXQudG9GbG9hdCgpLGE9bi5jb21wbGV4KG8scik7cmV0dXJuIHIuZGlzcG9zZSgpLG8uZGlzcG9zZSgpLGF9aWYoIU8odC5kdHlwZSxlKSlyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHtkYXRhSWQ6dC5kYXRhSWR9LGUpO2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXt2YXIgaT1uLnJlYWwodCk7YT1pLmNhc3QoZSk7cmV0dXJuIGkuZGlzcG9zZSgpLGF9aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbi5pbnQodCk7aWYoXCJib29sXCI9PT1lKXt2YXIgcz1CbigwLHQuZHR5cGUpO2E9bi5ub3RFcXVhbCh0LHMpO3JldHVybiBzLmRpc3Bvc2UoKSxhfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIENhc3Q6IHVua25vd24gZHR5cGUgYXJndW1lbnQgKFwiK2UrXCIpXCIpfWZ1bmN0aW9uIFpuKHQsZSl7cmV0dXJuIGZ0Lm1ha2UoZSx7ZGF0YUlkOnQuZGF0YUlkfSx0LmR0eXBlKX1mdW5jdGlvbiB0cih0LGUsbil7dmFyIHI9KGUtdCkvKG4tMSksbz0kKG4sXCJmbG9hdDMyXCIpO29bMF09dDtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStyO3JldHVybiBQbihvLFwiZmxvYXQzMlwiKX1mdW5jdGlvbiBlcih0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHJlYWwgYW5kIGltYWcgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGhzLiByZWFsOlwiK3QubGVuZ3RoK1wiLCBpbWFnOiBcIitlLmxlbmd0aCtcIi5cIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkoMip0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cis9MiluW3JdPXRbci8yXSxuW3IrMV09ZVtyLzJdO3JldHVybiBufWZ1bmN0aW9uIG5yKHQsZSl7cmV0dXJue3JlYWw6dFsyKmVdLGltYWc6dFsyKmUrMV19fWZ1bmN0aW9uIHJyKHQsZSxuLHIpe3RbMipyXT1lLHRbMipyKzFdPW59ZnVuY3Rpb24gb3IodCxlLG4pe3ZhciByPShuPzI6LTIpKk1hdGguUEkqKHQvZSk7cmV0dXJue3JlYWw6TWF0aC5jb3MociksaW1hZzpNYXRoLnNpbihyKX19ZnVuY3Rpb24gYXIodCxlLG4scixvKXtmb3IodmFyIGE9QXJyYXkuZnJvbShlKS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm57c2NvcmU6dCxib3hJbmRleDplfX0pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5zY29yZT5vfSkuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiBlLnNjb3JlLXQuc2NvcmV9KSxpPVtdLHM9MDtzPGEubGVuZ3RoO3MrKyl7dmFyIHU9YVtzXSxsPXUuc2NvcmUsYz11LmJveEluZGV4O2lmKGw8bylicmVhaztmb3IodmFyIGg9ITEscD1pLmxlbmd0aC0xO3A+PTA7LS1wKXtpZihpcih0LGMsaVtwXSk+PXIpe2g9ITA7YnJlYWt9fWlmKCFoJiYoaS5wdXNoKGMpLGkubGVuZ3RoPj1uKSlicmVha31yZXR1cm4gUG4oaSxcImludDMyXCIpfWZ1bmN0aW9uIGlyKHQsZSxuKXt2YXIgcj10LnN1YmFycmF5KDQqZSw0KmUrNCksbz10LnN1YmFycmF5KDQqbiw0Km4rNCksYT1NYXRoLm1pbihyWzBdLHJbMl0pLGk9TWF0aC5taW4oclsxXSxyWzNdKSxzPU1hdGgubWF4KHJbMF0sclsyXSksdT1NYXRoLm1heChyWzFdLHJbM10pLGw9TWF0aC5taW4ob1swXSxvWzJdKSxjPU1hdGgubWluKG9bMV0sb1szXSksaD1NYXRoLm1heChvWzBdLG9bMl0pLHA9TWF0aC5tYXgob1sxXSxvWzNdKSxmPShzLWEpKih1LWkpLGQ9KGgtbCkqKHAtYyk7aWYoZjw9MHx8ZDw9MClyZXR1cm4gMDt2YXIgdj1NYXRoLm1heChhLGwpLG09TWF0aC5tYXgoaSxjKSxnPU1hdGgubWluKHMsaCkseT1NYXRoLm1pbih1LHApLHg9TWF0aC5tYXgoZy12LDApKk1hdGgubWF4KHktbSwwKTtyZXR1cm4geC8oZitkLXgpfWZ1bmN0aW9uIHNyKHQsZSxuKXt2YXIgcj1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLG89dC5zaGFwZS5zbGljZSgpO3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtvW25dPWU7dmFyIGE9dC5zbGljZShyLG8pO3JldHVybiByW25dKz1lLGF9KX1mdW5jdGlvbiB1cih0LGUsbixyLG8pe2Zvcih2YXIgYT1lW2UubGVuZ3RoLTFdLGk9W3QubGVuZ3RoL2EsYV0scz1pWzBdLHU9aVsxXSxsPUkobixzKnIpLGM9SShcImludDMyXCIscypyKSxoPTA7aDxzO2grKyl7Zm9yKHZhciBwPWgqdSxmPXQuc3ViYXJyYXkocCxwK3UpLGQ9W10sdj0wO3Y8Zi5sZW5ndGg7disrKWQucHVzaCh7dmFsdWU6Zlt2XSxpbmRleDp2fSk7ZC5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUudmFsdWUtdC52YWx1ZX0pO3ZhciBtPWgqcixnPWwuc3ViYXJyYXkobSxtK3IpLHk9Yy5zdWJhcnJheShtLG0rcik7Zm9yKHY9MDt2PHI7disrKWdbdl09ZFt2XS52YWx1ZSx5W3ZdPWRbdl0uaW5kZXh9dmFyIHg9ZS5zbGljZSgpO3JldHVybiB4W3gubGVuZ3RoLTFdPXIsW0ZuKGwseCxuKSxGbihjLHgsXCJpbnQzMlwiKV19dmFyIGxyPUFuKHtjb25jYXRfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksZCh0Lmxlbmd0aD49MSxmdW5jdGlvbigpe3JldHVyblwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIGNvbmNhdFwifSk7dmFyIG49Ym4odCxcInRlbnNvcnNcIixcImNvbmNhdFwiKTtlPU4oZSxuWzBdLnNoYXBlKVswXTt2YXIgcj1zbihuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLGUpO2lmKDA9PT15KHIpKXJldHVybiBGbihbXSxyKTtpZigxPT09KG49bi5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2l6ZT4wfSkpLmxlbmd0aClyZXR1cm4gblswXTt2YXIgbz1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pOyFmdW5jdGlvbih0LGUpe3ZhciBuPXRbMF0ubGVuZ3RoO3QuZm9yRWFjaChmdW5jdGlvbih0LGUpe2QodC5sZW5ndGg9PT1uLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogcmFuayBvZiB0ZW5zb3JzW1wiK2UrXCJdIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHJhbmsgb2YgdGhlIHJlc3QgKFwiK24rXCIpXCJ9KX0pLGQoZT49MCYmZTxuLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogYXhpcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgXCIrKG4tMSkrXCIuXCJ9KTt2YXIgcj10WzBdO3QuZm9yRWFjaChmdW5jdGlvbih0LG8pe2Zvcih2YXIgYT0wO2E8bjthKyspZChhPT09ZXx8dFthXT09PXJbYV0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiBTaGFwZSBvZiB0ZW5zb3JzW1wiK28rXCJdIChcIit0K1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIHJlc3QgKFwiK3IrXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIrbytcIi5cIn0pfSl9KG8sZSk7dmFyIGE9bjtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbmNhdChuLGUpfSxhLGZ1bmN0aW9uKHQpe3ZhciBuPW8ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0W2VdfSk7cmV0dXJuIGRyKHQsbixlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fSl9KX19KSxjcj1Bbih7Y29uY2F0MWRfOmZ1bmN0aW9uKHQpe3JldHVybiBscih0LDApfX0pLGhyPUFuKHtjb25jYXQyZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gbHIodCxlKX19KSxwcj1Bbih7Y29uY2F0M2RfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGxyKHQsZSl9fSksZnI9QW4oe2NvbmNhdDRkXzpmdW5jdGlvbih0LGUpe3JldHVybiBscih0LGUpfX0pLGRyPUFuKHtzcGxpdF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByLG89d24odCxcInhcIixcInNwbGl0XCIpO3JldHVybiBuPU4obixvLnNoYXBlKVswXSxcIm51bWJlclwiPT10eXBlb2YgZT8oZChvLnNoYXBlW25dJWU9PTAsZnVuY3Rpb24oKXtyZXR1cm5cIk51bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLlwifSkscj1uZXcgQXJyYXkoZSkuZmlsbChvLnNoYXBlW25dL2UpKTooZChvLnNoYXBlW25dPT09ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBzdW0gb2Ygc2l6ZXMgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgYXhpcyBkaW1lbnNpb24uXCJ9KSxyPWUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChvLHIsbil9LHskeDpvfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbHIodCxuKX19fSl9fSk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZjtmdW5jdGlvbiB2cih0LGUpe3JldHVybiB0KGU9e2V4cG9ydHM6e319LGUuZXhwb3J0cyksZS5leHBvcnRzfXZhciBtcj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGUsbj10aGlzLHI9KGU9NDAyMjg3MTE5NyxmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9LjAyNTE5NjAzMjgyNDE2OTM4KihlKz10LmNoYXJDb2RlQXQobikpO3ItPWU9cj4+PjAsZT0ocio9ZSk+Pj4wLGUrPTQyOTQ5NjcyOTYqKHItPWUpfXJldHVybiAyLjMyODMwNjQzNjUzODY5NjNlLTEwKihlPj4+MCl9KTtuLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD0yMDkxNjM5Km4uczArMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCpuLmM7cmV0dXJuIG4uczA9bi5zMSxuLnMxPW4uczIsbi5zMj10LShuLmM9MHx0KX0sbi5jPTEsbi5zMD1yKFwiIFwiKSxuLnMxPXIoXCIgXCIpLG4uczI9cihcIiBcIiksbi5zMC09cih0KSxuLnMwPDAmJihuLnMwKz0xKSxuLnMxLT1yKHQpLG4uczE8MCYmKG4uczErPTEpLG4uczItPXIodCksbi5zMjwwJiYobi5zMis9MSkscj1udWxsfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5jPXQuYyxlLnMwPXQuczAsZS5zMT10LnMxLGUuczI9dC5zMixlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1uLm5leHQ7cmV0dXJuIGkuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDk2NzI5NipuLm5leHQoKXwwfSxpLmRvdWJsZT1mdW5jdGlvbigpe3JldHVybiBpKCkrMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNiooMjA5NzE1MippKCl8MCl9LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLmFsZWE9YX0oMCx0LCExKX0pLGdyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54PDwxMTtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53Xj1lLnc+Pj4xOV50XnQ+Pj44fSx0PT09KDB8dCk/ZS54PXQ6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzY0O3IrKyllLnhePTB8bi5jaGFyQ29kZUF0KHIpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLnhvcjEyOD1hfSgwLHQsITEpfSkseXI9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng+Pj4yO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLnc9ZS52LChlLmQ9ZS5kKzM2MjQzN3wwKSsoZS52PWUudl5lLnY8PDRedF50PDwxKXwwfSxlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLnY9MCx0PT09KDB8dCk/ZS54PXQ6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzY0O3IrKyllLnhePTB8bi5jaGFyQ29kZUF0KHIpLHI9PW4ubGVuZ3RoJiYoZS5kPWUueDw8MTBeZS54Pj4+NCksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGUudj10LnYsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLnhvcndvdz1hfSgwLHQsITEpfSkseHI9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQsbixyPWUueCxvPWUuaTtyZXR1cm4gdD1yW29dLG49KHRePXQ+Pj43KV50PDwyNCxuXj0odD1yW28rMSY3XSledD4+PjEwLG5ePSh0PXJbbyszJjddKV50Pj4+MyxuXj0odD1yW28rNCY3XSledDw8Nyx0PXJbbys3JjddLG5ePSh0Xj10PDwxMyledDw8OSxyW29dPW4sZS5pPW8rMSY3LG59LGZ1bmN0aW9uKHQsZSl7dmFyIG4scj1bXTtpZihlPT09KDB8ZSkpclswXT1lO2Vsc2UgZm9yKGU9XCJcIitlLG49MDtuPGUubGVuZ3RoOysrbilyWzcmbl09cls3Jm5dPDwxNV5lLmNoYXJDb2RlQXQobikrcltuKzEmN108PDEzO2Zvcig7ci5sZW5ndGg8ODspci5wdXNoKDApO2ZvcihuPTA7bjw4JiYwPT09cltuXTsrK24pO2Zvcig4PT1uP3JbN109LTE6cltuXSx0Lng9cix0Lmk9MCxuPTI1NjtuPjA7LS1uKXQubmV4dCgpfShlLHQpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueC5zbGljZSgpLGUuaT10LmksZX1mdW5jdGlvbiBhKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoYS54JiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy54b3JzaGlmdDc9YX0oMCx0LCExKX0pLHdyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LG4scj1lLncsbz1lLlgsYT1lLmk7cmV0dXJuIGUudz1yPXIrMTY0MDUzMTUyN3wwLG49b1thKzM0JjEyN10sdD1vW2E9YSsxJjEyN10sbl49bjw8MTMsdF49dDw8MTcsbl49bj4+PjE1LHRePXQ+Pj4xMixuPW9bYV09bl50LGUuaT1hLG4rKHJecj4+PjE2KXwwfSxmdW5jdGlvbih0LGUpe3ZhciBuLHIsbyxhLGkscz1bXSx1PTEyODtmb3IoZT09PSgwfGUpPyhyPWUsZT1udWxsKTooZSs9XCJcXDBcIixyPTAsdT1NYXRoLm1heCh1LGUubGVuZ3RoKSksbz0wLGE9LTMyO2E8dTsrK2EpZSYmKHJePWUuY2hhckNvZGVBdCgoYSszMiklZS5sZW5ndGgpKSwwPT09YSYmKGk9cikscl49cjw8MTAscl49cj4+PjE1LHJePXI8PDQscl49cj4+PjEzLGE+PTAmJihpPWkrMTY0MDUzMTUyN3wwLG89MD09KG49c1sxMjcmYV1ePXIraSk/bysxOjApO2ZvcihvPj0xMjgmJihzWzEyNyYoZSYmZS5sZW5ndGh8fDApXT0tMSksbz0xMjcsYT01MTI7YT4wOy0tYSlyPXNbbyszNCYxMjddLG49c1tvPW8rMSYxMjddLHJePXI8PDEzLG5ePW48PDE3LHJePXI+Pj4xNSxuXj1uPj4+MTIsc1tvXT1yXm47dC53PWksdC5YPXMsdC5pPW99KGUsdCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmk9dC5pLGUudz10LncsZS5YPXQuWC5zbGljZSgpLGV9ZnVuY3Rpb24gYSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKGEuWCYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMueG9yNDA5Nj1hfSgwLHQsITEpfSksYnI9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUuYixuPWUuYyxyPWUuZCxvPWUuYTtyZXR1cm4gdD10PDwyNV50Pj4+N15uLG49bi1yfDAscj1yPDwyNF5yPj4+OF5vLG89by10fDAsZS5iPXQ9dDw8MjBedD4+PjEyXm4sZS5jPW49bi1yfDAsZS5kPXI8PDE2Xm4+Pj4xNl5vLGUuYT1vLXR8MH0sZS5hPTAsZS5iPTAsZS5jPS0xNjQwNTMxNTI3LGUuZD0xMzY3MTMwNTUxLHQ9PT1NYXRoLmZsb29yKHQpPyhlLmE9dC80Mjk0OTY3Mjk2fDAsZS5iPTB8dCk6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzIwO3IrKyllLmJePTB8bi5jaGFyQ29kZUF0KHIpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5hPXQuYSxlLmI9dC5iLGUuYz10LmMsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLnR5Y2hlaT1hfSgwLHQsITEpfSksQ3I9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUsbil7dmFyIHIsbz10aGlzLGE9MjU2LGk9NixzPVwicmFuZG9tXCIsdT1uLnBvdyhhLGkpLGw9bi5wb3coMiw1MiksYz0yKmwsaD1hLTE7ZnVuY3Rpb24gcCh0LGgscCl7dmFyIGc9W10seT12KGZ1bmN0aW9uIHQoZSxuKXt2YXIgcixvPVtdLGE9dHlwZW9mIGU7aWYobiYmXCJvYmplY3RcIj09YSlmb3IociBpbiBlKXRyeXtvLnB1c2godChlW3JdLG4tMSkpfWNhdGNoKHQpe31yZXR1cm4gby5sZW5ndGg/bzpcInN0cmluZ1wiPT1hP2U6ZStcIlxcMFwifSgoaD0xPT1oP3tlbnRyb3B5OiEwfTpofHx7fSkuZW50cm9weT9bdCxtKGUpXTpudWxsPT10P2Z1bmN0aW9uKCl7dHJ5e3ZhciB0O3JldHVybiByJiYodD1yLnJhbmRvbUJ5dGVzKT90PXQoYSk6KHQ9bmV3IFVpbnQ4QXJyYXkoYSksKG8uY3J5cHRvfHxvLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXModCkpLG0odCl9Y2F0Y2godCl7dmFyIG49by5uYXZpZ2F0b3IsaT1uJiZuLnBsdWdpbnM7cmV0dXJuWytuZXcgRGF0ZSxvLGksby5zY3JlZW4sbShlKV19fSgpOnQsMyksZykseD1uZXcgZihnKSx3PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXguZyhpKSxlPXUsbj0wO3Q8bDspdD0odCtuKSphLGUqPWEsbj14LmcoMSk7Zm9yKDt0Pj1jOyl0Lz0yLGUvPTIsbj4+Pj0xO3JldHVybih0K24pL2V9O3JldHVybiB3LmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8eC5nKDQpfSx3LnF1aWNrPWZ1bmN0aW9uKCl7cmV0dXJuIHguZyg0KS80Mjk0OTY3Mjk2fSx3LmRvdWJsZT13LHYobSh4LlMpLGUpLChoLnBhc3N8fHB8fGZ1bmN0aW9uKHQsZSxyLG8pe3JldHVybiBvJiYoby5TJiZkKG8seCksdC5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBkKHgse30pfSkscj8obltzXT10LGUpOnR9KSh3LHksXCJnbG9iYWxcImluIGg/aC5nbG9iYWw6dGhpcz09bixoLnN0YXRlKX1mdW5jdGlvbiBmKHQpe3ZhciBlLG49dC5sZW5ndGgscj10aGlzLG89MCxpPXIuaT1yLmo9MCxzPXIuUz1bXTtmb3Iobnx8KHQ9W24rK10pO288YTspc1tvXT1vKys7Zm9yKG89MDtvPGE7bysrKXNbb109c1tpPWgmaSt0W28lbl0rKGU9c1tvXSldLHNbaV09ZTsoci5nPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPTAsbz1yLmksaT1yLmoscz1yLlM7dC0tOyllPXNbbz1oJm8rMV0sbj1uKmErc1toJihzW29dPXNbaT1oJmkrZV0pKyhzW2ldPWUpXTtyZXR1cm4gci5pPW8sci5qPWksbn0pKGEpfWZ1bmN0aW9uIGQodCxlKXtyZXR1cm4gZS5pPXQuaSxlLmo9dC5qLGUuUz10LlMuc2xpY2UoKSxlfWZ1bmN0aW9uIHYodCxlKXtmb3IodmFyIG4scj10K1wiXCIsbz0wO288ci5sZW5ndGg7KWVbaCZvXT1oJihuXj0xOSplW2gmb10pK3IuY2hhckNvZGVBdChvKyspO3JldHVybiBtKGUpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCx0KX1pZihuW1wic2VlZFwiK3NdPXAsdihuLnJhbmRvbSgpLGUpLHQuZXhwb3J0cyl7dC5leHBvcnRzPXA7dHJ5e3I9cmVxdWlyZShcImNyeXB0b1wiKX1jYXRjaCh0KXt9fX0oW10sTWF0aCl9KTtDci5hbGVhPW1yLENyLnhvcjEyOD1ncixDci54b3J3b3c9eXIsQ3IueG9yc2hpZnQ3PXhyLENyLnhvcjQwOTY9d3IsQ3IudHljaGVpPWJyO3ZhciBFcj1Dci5hbGVhLFJyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyLG8pe3RoaXMubWVhbj10LHRoaXMuc3RkRGV2PWUsdGhpcy5kdHlwZT1uLHRoaXMubmV4dFZhbD1OYU4sdGhpcy50cnVuY2F0ZWQ9cix0aGlzLnRydW5jYXRlZCYmKHRoaXMudXBwZXI9dGhpcy5tZWFuKzIqdGhpcy5zdGREZXYsdGhpcy5sb3dlcj10aGlzLm1lYW4tMip0aGlzLnN0ZERldik7dmFyIGE9b3x8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmRvbT1FcihhLnRvU3RyaW5nKCkpfXJldHVybiB0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtpZighaXNOYU4odGhpcy5uZXh0VmFsKSl7dmFyIHQ9dGhpcy5uZXh0VmFsO3JldHVybiB0aGlzLm5leHRWYWw9TmFOLHR9Zm9yKHZhciBlLG4scj0hMTshcjspe3ZhciBvPXZvaWQgMCxhPXZvaWQgMCxpPXZvaWQgMDtkb3tpPShvPTIqdGhpcy5yYW5kb20oKS0xKSpvKyhhPTIqdGhpcy5yYW5kb20oKS0xKSphfXdoaWxlKGk+PTF8fDA9PT1pKTt2YXIgcz1NYXRoLnNxcnQoLTIqTWF0aC5sb2coaSkvaSk7ZT10aGlzLm1lYW4rdGhpcy5zdGREZXYqbypzLG49dGhpcy5tZWFuK3RoaXMuc3RkRGV2KmEqcyx0aGlzLnRydW5jYXRlZCYmIXRoaXMuaXNWYWxpZFRydW5jYXRlZChlKXx8KHI9ITApfXJldHVybiB0aGlzLnRydW5jYXRlZCYmIXRoaXMuaXNWYWxpZFRydW5jYXRlZChuKXx8KHRoaXMubmV4dFZhbD10aGlzLmNvbnZlcnRWYWx1ZShuKSksdGhpcy5jb252ZXJ0VmFsdWUoZSl9LHQucHJvdG90eXBlLmNvbnZlcnRWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dGhpcy5kdHlwZXx8XCJmbG9hdDMyXCI9PT10aGlzLmR0eXBlP3Q6TWF0aC5yb3VuZCh0KX0sdC5wcm90b3R5cGUuaXNWYWxpZFRydW5jYXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdDw9dGhpcy51cHBlciYmdD49dGhpcy5sb3dlcn0sdH0oKSxTcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scil7dm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09ciYmKHI9TWF0aC5yYW5kb20oKSk7dmFyIG89dGhpcztpZih0aGlzLmNhblJldHVybkZsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW8uZHR5cGV8fFwiZmxvYXQzMlwiPT09by5kdHlwZX0sdGhpcy5taW49dCx0aGlzLnJhbmdlPWUtdCx0aGlzLmR0eXBlPW4sIXRoaXMuY2FuUmV0dXJuRmxvYXQoKSYmdGhpcy5yYW5nZTw9MSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiK3QrXCIgLSBcIitlK1wiIDw9IDEgYW5kIGR0eXBlIGlzIG5vdCBmbG9hdFwiKTt0aGlzLnJhbmRvbT1FcihyLnRvU3RyaW5nKCkpfXJldHVybiB0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2FuUmV0dXJuRmxvYXQoKT90Ok1hdGgucm91bmQodCl9LHQucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnZlcnRWYWx1ZSh0aGlzLm1pbit0aGlzLnJhbmdlKnRoaXMucmFuZG9tKCkpfSx0fSgpO2Z1bmN0aW9uIE5yKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLGU9ZXx8XCJmbG9hdDMyXCIsSyh0KSxuZXcgbHQodCxlLG4pfWZ1bmN0aW9uIGtyKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITEpLGNvbnNvbGUubG9nKHQudG9TdHJpbmcoZSkpfXZhciBJcj1Bbih7YmF0Y2hUb1NwYWNlTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwiYmF0Y2hUb1NwYWNlTkRcIiksbz1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KTtyZXR1cm4gZChyLnJhbms+PTErZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHJhbmsgaXMgXCIrci5yYW5rK1wiIGJ1dCBzaG91bGQgYmUgPiB0aGFuIGJsb2NrU2hhcGUubGVuZ3RoIFwiK2UubGVuZ3RofSksZChuLmxlbmd0aD09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJjcm9wcy5sZW5ndGggaXMgXCIrbi5sZW5ndGgrXCIgYnV0IHNob3VsZCBiZSBlcXVhbCB0byBibG9ja1NoYXBlLmxlbmd0aCAgXCIrZS5sZW5ndGh9KSxkKHIuc2hhcGVbMF0lbz09MCxmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgdGVuc29yIGJhdGNoIGlzIFwiK3Iuc2hhcGVbMF0rXCIgYnV0IGlzIG5vdCBkaXZpc2libGUgYnkgdGhlIHByb2R1Y3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGJsb2NrU2hhcGUgXCIrZS5qb2luKFwiICogXCIpK1wiID09PSBcIitvfSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJhdGNoVG9TcGFjZU5EKHIsZSxuKX0seyR4OnJ9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnNwYWNlVG9CYXRjaE5EKGUsbil9fX0pfX0pLEFyPUFuKHtjYXN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJjYXN0XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2FzdChuLGUpfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvbmUoKX19fSl9fSksVHI9QW4oe2Nsb25lXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiY2xvbmVcIixudWxsKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiBmdC5tYWtlKGUuc2hhcGUse2RhdGFJZDplLmRhdGFJZH0sZS5kdHlwZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC50b0Zsb2F0KCl9fX0pfX0pLERyPUFuKHtjdW1zdW1fOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89d24odCxcInhcIixcImN1bXN1bVwiKSxhPXJuKFtlfD0wXSxvLnJhbmspLGk9bztudWxsIT1hJiYoaT1vLnRyYW5zcG9zZShhKSk7dmFyIHM9YW4oMSxvLnJhbmspWzBdLHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmN1bXN1bShpLHMsbixyKX0se3Blcm11dGVkWDppfSxmdW5jdGlvbih0KXtyZXR1cm57cGVybXV0ZWRYOmZ1bmN0aW9uKCl7cmV0dXJuIHQuY3Vtc3VtKGUsbiwhcil9fX0pO3JldHVybiBudWxsIT1hJiYodT11LnRyYW5zcG9zZShhKSksdX19KSxPcj1Bbih7ZGVwdGhUb1NwYWNlXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49XCJOSFdDXCIpO3ZhciByPXduKHQsXCJ4XCIsXCJkZXB0aFRvU3BhY2VcIiksbz1cIk5IV0NcIj09PW4/ci5zaGFwZVsxXTpyLnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1uP3Iuc2hhcGVbMl06ci5zaGFwZVszXSxpPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzNdOnIuc2hhcGVbMV07cmV0dXJuIGQobyplPj0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK28rXCIgYW5kIFwiK2UrXCIgIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgIFwiK3Iuc2hhcGV9KSxkKGEqZT49MCxmdW5jdGlvbigpe3JldHVyblwiTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IG92ZXJmbG93IHdoZW4gbXVsdGlwbHlpbmdcXG4gICAgICBcIithK1wiIGFuZCBcIitlK1wiIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgICAgICBcIityLnNoYXBlfSksZChpJShlKmUpPT0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJEaW1lbnNpb24gc2l6ZSBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgXCIrZSplK1wiIGJ1dCBpcyBcIitpK1wiIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZSBcIityLnNoYXBlfSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRoVG9TcGFjZShyLGUsbil9LHskeDpyfSl9fSksX3I9QW4oe2V4cGFuZERpbXNfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49d24odCxcInhcIixcImV4cGFuZERpbXNcIik7ZChlPD1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIn0pO3ZhciByPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gZTwwJiYoZCgtKG4ucmFuaysxKTw9ZSxmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbXCIrLShuLnJhbmsrMSkrXCIsIFwiK24ucmFuaytcIl1cIn0pLGU9bi5yYW5rK2UrMSksci5zcGxpY2UoZSwwLDEpLEhyKG4scil9fSksTXI9QW4oe2V5ZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpLG51bGw9PWUmJihlPXQpO2Zvcih2YXIgbz1OcihbdCxlXSxyKSxhPXQ8PWU/dDplLGk9MDtpPGE7KytpKW8uc2V0KDEsaSxpKTt2YXIgcz1vLnRvVGVuc29yKCkuYXMyRCh0LGUpO2lmKG51bGw9PW4pcmV0dXJuIHM7aWYoMT09PW4ubGVuZ3RoKXJldHVybiBYcihfcihzLDApLFtuWzBdLDEsMV0pO2lmKDI9PT1uLmxlbmd0aClyZXR1cm4gWHIoX3IoX3IocywwKSwwKSxbblswXSxuWzFdLDEsMV0pO2lmKDM9PT1uLmxlbmd0aClyZXR1cm4gWHIoX3IoX3IoX3IocywwKSwwKSwwKSxbblswXSxuWzFdLG5bMl0sMSwxXSk7dGhyb3cgbmV3IEVycm9yKFwiZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIGJhdGNoU2hhcGVzLCBidXQgcmVjZWl2ZWQgXCIrbi5sZW5ndGgrXCJELlwiKX19KSxGcj1Bbih7bXVsdGlub21pYWxfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbz13bih0LFwibG9naXRzXCIsXCJtdWx0aW5vbWlhbFwiKSxhPW8uc2l6ZSxpPW8ucmFuaztpZihhPDIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgXCIrYStcIi5cIik7aWYoaT4yKXRocm93IG5ldyBFcnJvcihcIlJhbmsgb2YgcHJvYmFiaWxpdGllcyBtdXN0IGJlIDEgb3IgMiwgYnV0IGlzIFwiK2kpO249bnx8TWF0aC5yYW5kb20oKTt2YXIgcz0xPT09aT9vLmFzMkQoMSwtMSk6byx1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5tdWx0aW5vbWlhbChzLHIsZSxuKX0se2xvZ2l0czJEOnN9KTtyZXR1cm4gMT09PWk/dS5hczFEKCk6dX19KSxCcj1Bbih7b25lSG90XzpmdW5jdGlvbih0LGUsbixyKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0wKSxlPDIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiK2UpO3ZhciBvPXduKHQsXCJpbmRpY2VzXCIsXCJvbmVIb3RcIixcImludDMyXCIpLGE9by5zaGFwZS5jb25jYXQoW2VdKTtyZXR1cm4gbz1vLmZsYXR0ZW4oKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQub25lSG90KG8sZSxuLHIpfSx7JGluZGljZXM6b30sZnVuY3Rpb24odCl7cmV0dXJueyRpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHFuKG8uc2hhcGUsXCJmbG9hdDMyXCIpfX19KS5yZXNoYXBlKGEpfX0pLFByPUFuKHtwYWRfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcj13bih0LFwieFwiLFwicGFkXCIpO2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwicGFkKHNjYWxhcikgaXMgbm90IGRlZmluZWQuIFBhc3Mgbm9uLXNjYWxhciB0byBwYWRcIik7dmFyIG89ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZChyLGUsbil9LHskeDpyfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zbGljZShvLHIuc2hhcGUpfX19KX19KSxMcj1Bbih7cGFkMWRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksZCgyPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyLlwifSksUHIodCxbZV0sbil9fSksV3I9QW4oe3BhZDJkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLGQoMj09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pLFByKHQsZSxuKX19KSxVcj1Bbih7cGFkM2RfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksZCgzPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSxQcih0LGUsbil9fSksenI9QW4oe3BhZDRkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLGQoND09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCYmMj09PWVbMl0ubGVuZ3RoJiYyPT09ZVszXS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSxQcih0LGUsbil9fSksVnI9QW4oe3JhbmRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj15KHQpLG89bnVsbDtpZihudWxsPT1ufHxcImZsb2F0MzJcIj09PW4pbz1uZXcgRmxvYXQzMkFycmF5KHIpO2Vsc2UgaWYoXCJpbnQzMlwiPT09bilvPW5ldyBJbnQzMkFycmF5KHIpO2Vsc2V7aWYoXCJib29sXCIhPT1uKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK24pO289bmV3IFVpbnQ4QXJyYXkocil9Zm9yKHZhciBhPTA7YTxyO2ErKylvW2FdPWUoKTtyZXR1cm4gZnQubWFrZSh0LHt2YWx1ZXM6b30sbil9fSksR3I9QW4oe3JhbmRvbU5vcm1hbF86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSxudWxsIT1yJiZcImJvb2xcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgUnIoZSxuLHIsITEsbyksaT1Ocih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pLHFyPUFuKHtyYW5kb21Vbmlmb3JtXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKTtmb3IodmFyIGE9TnIodCxyKSxpPW5ldyBTcihlLG4sbnVsbCxvKSxzPTA7czxhLnZhbHVlcy5sZW5ndGg7cysrKWEudmFsdWVzW3NdPWkubmV4dFZhbHVlKCk7cmV0dXJuIGEudG9UZW5zb3IoKX19KSxIcj1Bbih7cmVzaGFwZV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicmVzaGFwZVwiLG51bGwpO3JldHVybiBlPVMoZSxuLnNpemUpLGQobi5zaXplPT09eShlKSxmdW5jdGlvbigpe3JldHVyblwibmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIn0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNoYXBlKG4sZSl9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXNoYXBlKG4uc2hhcGUpfX19KX19KSwkcj1Bbih7c3BhY2VUb0JhdGNoTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwic3BhY2VUb0JhdGNoTkRcIik7cmV0dXJuIGQoci5yYW5rPj0xK2UubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCByYW5rIFwiK3IucmFuaytcIiBzaG91bGQgYmUgPiB0aGFuIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pLGQobi5sZW5ndGg9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwicGFkZGluZ3Muc2hhcGVbMF0gXCIrbi5sZW5ndGgrXCIgbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gXCIrZS5sZW5ndGh9KSxkKHIuc2hhcGUucmVkdWNlKGZ1bmN0aW9uKHQscixvKXtyZXR1cm4gbz4wJiZvPD1lLmxlbmd0aD90JiYocituW28tMV1bMF0rbltvLTFdWzFdKSVlW28tMV09PTA6dH0sITApLGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCBzcGF0aWFsIGRpbWVuc2lvbnMgXCIrci5zaGFwZS5zbGljZSgxKStcIiB3aXRoIHBhZGRpbmdzIFwiK24udG9TdHJpbmcoKStcIiBtdXN0IGJlIGRpdmlzaWJsZSBieSBibG9ja1NoYXBlcyBcIitlLnRvU3RyaW5nKCl9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQocixlLG4pfSx7JHg6cn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuYmF0Y2hUb1NwYWNlTkQoZSxuKX19fSl9fSksanI9QW4oe3NxdWVlemVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInNxdWVlemVcIik7cmV0dXJuIEhyKG4sayhuLnNoYXBlLGUpLm5ld1NoYXBlKX19KSxLcj1Bbih7c3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49Ym4odCxcInRlbnNvcnNcIixcInN0YWNrXCIpO2lmKGQobi5sZW5ndGg+PTEsZnVuY3Rpb24oKXtyZXR1cm5cIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5zdGFja1wifSksMT09PW4ubGVuZ3RoKXJldHVybiBuWzBdLmV4cGFuZERpbXMoZSk7dmFyIHI9blswXS5yYW5rLG89blswXS5zaGFwZSxhPW5bMF0uZHR5cGU7ZChlPD1yLGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCJ9KSxuLmZvckVhY2goZnVuY3Rpb24odCl7dihvLHQuc2hhcGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlc1wiKX0pLG4uZm9yRWFjaChmdW5jdGlvbih0KXtkKGE9PT10LmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlc1wifSl9KTt2YXIgaT1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5leHBhbmREaW1zKGUpfSk7cmV0dXJuIGxyKGksZSl9fSksWHI9QW4oe3RpbGVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInRpbGVcIik7cmV0dXJuIGQobi5yYW5rPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIituLnJhbmsrXCIgbXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIitlK1wiLlwifSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQscil7dmFyIG89dC50aWxlKG4sZSk7cmV0dXJuIHIoW25dKSxvfSx7JHg6bn0sZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3ZhciBuPVhuKHIpO2lmKDE9PT1yLnJhbmspZm9yKHZhciBvPTA7bzxlWzBdOysrbyluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXV0sW3Iuc2hhcGVbMF1dKSk7ZWxzZSBpZigyPT09ci5yYW5rKWZvcihvPTA7bzxlWzBdOysrbylmb3IodmFyIGE9MDthPGVbMV07KythKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXV0pKTtlbHNlIGlmKDM9PT1yLnJhbmspZm9yKG89MDtvPGVbMF07KytvKWZvcihhPTA7YTxlWzFdOysrYSlmb3IodmFyIGk9MDtpPGVbMl07KytpKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXSxpKnIuc2hhcGVbMl1dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXV0pKTtlbHNle2lmKDQhPT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIHRpbGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmFuay1cIityLnJhbmsrXCIgdGVuc29ycyB5ZXQuXCIpO2ZvcihvPTA7bzxlWzBdOysrbylmb3IoYT0wO2E8ZVsxXTsrK2EpZm9yKGk9MDtpPGVbMl07KytpKWZvcih2YXIgcz0wO3M8ZVszXTsrK3Mpbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXSxzKnIuc2hhcGVbM11dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSxyLnNoYXBlWzNdXSkpfXJldHVybiBufX19KX19KSxZcj1Bbih7dHJ1bmNhdGVkTm9ybWFsXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLG51bGwhPXImJlwiYm9vbFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrcik7Zm9yKHZhciBhPW5ldyBScihlLG4sciwhMCxvKSxpPU5yKHQscikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9fSksUXI9QW4oe3Vuc3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksZT1lfHwwO3ZhciBuPXduKHQsXCJ4XCIsXCJ1bnN0YWNrXCIpO3JldHVybiBkKGU+PS1uLnNoYXBlLmxlbmd0aCYmZTxuLnNoYXBlLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiQXhpcyA9IFwiK2UrXCIgaXMgbm90IGluIFstXCIrbi5zaGFwZS5sZW5ndGgrXCIsIFwiK24uc2hhcGUubGVuZ3RoK1wiKVwifSksZTwwJiYoZSs9bi5zaGFwZS5sZW5ndGgpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC51bnN0YWNrKG4sZSl9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gS3IodCxlKX19fSl9fSksSnI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGEsaSxzLHUsbCxjLGgscDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49d24odCxcInhcIixcInNldGRpZmYxZFwiKSxyPXduKGUsXCJ5XCIsXCJzZXRkaWZmMWRcIiksZChuLmR0eXBlPT09ci5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwieCBhbmQgeSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkdHlwZSwgYnV0IGdvdCB4IChcIituLmR0eXBlK1wiKSBhbmQgeSAoXCIrci5kdHlwZStcIikuXCJ9KSxkKDE9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInggc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB4IChcIituLnNoYXBlK1wiKS5cIn0pLGQoMT09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwieSBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHkgKFwiK3Iuc2hhcGUrXCIpLlwifSksWzQsbi5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gYT1vLnNlbnQoKSxbNCxyLmRhdGEoKV07Y2FzZSAyOmZvcihpPW8uc2VudCgpLHM9bmV3IFNldChpKSx1PTAsaD0wO2g8YS5sZW5ndGg7aCsrKXMuaGFzKGFbaF0pfHx1Kys7Zm9yKGw9bmV3IGx0KFt1XSxuLmR0eXBlKSxjPW5ldyBsdChbdV0sXCJpbnQzMlwiKSxoPTAscD0wO2g8YS5sZW5ndGg7aCsrKXMuaGFzKGFbaF0pfHwobC52YWx1ZXNbcF09YVtoXSxjLnZhbHVlc1twXT1oLHArKyk7cmV0dXJuWzIsW2wudG9UZW5zb3IoKSxjLnRvVGVuc29yKCldXX19KX0pfTtmdW5jdGlvbiBacih0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjxlLmxlbmd0aDtyKyspZVtyXSYmbi5wdXNoKHIpO3ZhciBvPU5yKHQsXCJpbnQzMlwiKSxhPU5yKFtuLmxlbmd0aCx0Lmxlbmd0aF0sXCJpbnQzMlwiKTtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1vLmluZGV4VG9Mb2MobltyXSkscz1yKnQubGVuZ3RoO2EudmFsdWVzLnNldChpLHMpfXJldHVybiBhLnRvVGVuc29yKCl9dmFyIHRvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy52YXJpYWJsZU5hbWVzPWUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pO3ZhciBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe24ucHVzaChcImZsb2F0IHZcIit0K1wiID0gZ2V0XCIrdCtcIkF0T3V0Q29vcmRzKCk7XCIpfSk7dmFyIHI9dGhpcy52YXJpYWJsZU5hbWVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbi5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IFwiK3IrXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxlbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KTt2YXIgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbih0KXtuLnB1c2goXCJ2ZWM0IHZcIit0K1wiID0gZ2V0XCIrdCtcIkF0T3V0Q29vcmRzKCk7XCIpfSk7dmFyIHI9dGhpcy52YXJpYWJsZU5hbWVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbi5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gXCIrcitcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLG5vPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgcj10LndpbmRvd1NpemUsbz10LmJhdGNoU2l6ZSxhPXQuaW5TaXplLGk9TWF0aC5jZWlsKGEvcik7bnx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIiksdGhpcy5vdXRwdXRTaGFwZT1bbyxpXTt2YXIgcz1cIm1heFwiPT09ZT9cIj5cIjpcIjxcIix1PW4/XCJpbk9mZnNldCArIGk7XCI6XCJyb3VuZChnZXRCZXN0SW5kaWNlc0EoYmF0Y2gsIGluT2Zmc2V0ICsgaSkpO1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIityK1wiO1xcblxcbiAgICAgICAgaW50IGJlc3RJbmRleCA9IGluT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gZ2V0QShiYXRjaCwgYmVzdEluZGV4KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiK3UrXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIitzK1wiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO2Z1bmN0aW9uIHJvKHQsZSl7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdCtcIi5cIitlfSl9ZnVuY3Rpb24gb28odCxlKXtyZXR1cm4gMT09PWU/W3RdOnJvKHQsZSl9ZnVuY3Rpb24gYW8odCxlKXtmb3IodmFyIG49dC5sZW5ndGgscj1bXSxvPTA7bzxuO28rKyl7dmFyIGE9bi0xLW8saT10W2FdfHwxOyhlW2UubGVuZ3RoLTEtb118fDEpPjEmJjE9PT1pJiZyLnVuc2hpZnQoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gaW8odCxlKXtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbz10W3QubGVuZ3RoLXItMV0sYT1lLmxlbmd0aC1yLTEsaT1lW2FdOyhudWxsPT1vfHwxPT09byYmaT4xKSYmbi51bnNoaWZ0KGEpfXJldHVybiBufWZ1bmN0aW9uIHNvKHQsZSl7Zm9yKHZhciBuPVtdLHI9TWF0aC5tYXgodC5sZW5ndGgsZS5sZW5ndGgpLG89MDtvPHI7bysrKXt2YXIgYT10W3QubGVuZ3RoLW8tMV07bnVsbD09YSYmKGE9MSk7dmFyIGk9ZVtlLmxlbmd0aC1vLTFdO2lmKG51bGw9PWkmJihpPTEpLDE9PT1hKW4udW5zaGlmdChpKTtlbHNlIGlmKDE9PT1pKW4udW5zaGlmdChhKTtlbHNle2lmKGEhPT1pKXRocm93IEVycm9yKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiLlwiKTtuLnVuc2hpZnQoYSl9fXJldHVybiBufWZ1bmN0aW9uIHVvKCl7dmFyIHQsZSxuLHIsbyxpLHMsdSxsLGM7cmV0dXJuIDI9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/KHQ9XCIjdmVyc2lvbiAzMDAgZXNcIixlPVwiaW5cIixuPVwib3V0XCIscj1cImluXCIsbz1cInRleHR1cmVcIixpPVwib3V0cHV0Q29sb3JcIixzPVwib3V0IHZlYzQgb3V0cHV0Q29sb3I7XCIsdT1cIlxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLiB8fCB2YWwgPCAwLiB8fCB2YWwgPT0gMC4pID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgIH1cXG4gICAgXCIsbD1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IElORklOSVRZID0gdWludEJpdHNUb0Zsb2F0KHVpbnQoMHg3ZjgwMDAwMCkpO1xcbiAgICBcIixjPVwiXFxuICAgICAgI2RlZmluZSByb3VuZCh2YWx1ZSkgbmV3Um91bmQodmFsdWUpXFxuICAgICAgaW50IG5ld1JvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGl2ZWM0IG5ld1JvdW5kKHZlYzQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xcbiAgICAgIH1cXG4gICAgXCIpOih0PVwiXCIsZT1cImF0dHJpYnV0ZVwiLG49XCJ2YXJ5aW5nXCIscj1cInZhcnlpbmdcIixvPVwidGV4dHVyZTJEXCIsaT1cImdsX0ZyYWdDb2xvclwiLHM9XCJcIix1PVwiXFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDEuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XFxuICAgICAgfVxcbiAgICBcIixsPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBJTkZJTklUWTtcXG5cXG4gICAgICBib29sIGlzaW5mKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGFicyh2YWwpID09IElORklOSVRZO1xcbiAgICAgIH1cXG4gICAgICBidmVjNCBpc2luZih2ZWM0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGVxdWFsKGFicyh2YWwpLCB2ZWM0KElORklOSVRZKSk7XFxuICAgICAgfVxcbiAgICBcIixjPVwiXFxuICAgICAgaW50IHJvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGl2ZWM0IHJvdW5kKHZlYzQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xcbiAgICAgIH1cXG4gICAgXCIpLHt2ZXJzaW9uOnQsYXR0cmlidXRlOmUsdmFyeWluZ1ZzOm4sdmFyeWluZ0ZzOnIsdGV4dHVyZTJEOm8sb3V0cHV0OmksZGVmaW5lT3V0cHV0OnMsZGVmaW5lU3BlY2lhbE5hTjp1LGRlZmluZVNwZWNpYWxJbmY6bCxkZWZpbmVSb3VuZDpjfX1mdW5jdGlvbiBsbyh0LGUsbil7dm9pZCAwPT09biYmKG49XCJpbmRleFwiKTt2YXIgcj1WKGUpO3JldHVybiByLm1hcChmdW5jdGlvbihlLG8pe3JldHVyblwiaW50IFwiK3Rbb10rXCIgPSBcIituK1wiIC8gXCIrZStcIjsgXCIrKG89PT1yLmxlbmd0aC0xP1wiaW50IFwiK3RbbysxXStcIiA9IFwiK24rXCIgLSBcIit0W29dK1wiICogXCIrZTpcImluZGV4IC09IFwiK3Rbb10rXCIgKiBcIitlKStcIjtcIn0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gY28odCl7cmV0dXJuIDE9PT10Lmxlbmd0aD9cIlwiK3RbMF06XCJ2ZWNcIit0Lmxlbmd0aCtcIihcIit0LmpvaW4oXCIsXCIpK1wiKVwifWZ1bmN0aW9uIGhvKHQsZSxuLHIpe3ZhciBvPVtdO3QuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT15KHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7dC5zaGFwZUluZm8uaXNVbmlmb3JtP28ucHVzaChcInVuaWZvcm0gZmxvYXQgXCIrdC5uYW1lKyhlPjE/XCJbXCIrZStcIl1cIjpcIlwiKStcIjtcIik6KG8ucHVzaChcInVuaWZvcm0gc2FtcGxlcjJEIFwiK3QubmFtZStcIjtcIiksby5wdXNoKFwidW5pZm9ybSBpbnQgb2Zmc2V0XCIrdC5uYW1lK1wiO1wiKSl9KTt2YXIgYSxpLHM9by5qb2luKFwiXFxuXCIpLHU9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9XCJcIjtyKz1uP2ZvKHQpOnBvKHQpO3ZhciBvPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxhPWUubG9naWNhbFNoYXBlO28ubGVuZ3RoPD1hLmxlbmd0aCYmKHIrPW4/ZnVuY3Rpb24odCxlKXt2YXIgbixyPXQubmFtZSxvPXIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxhPVwiZ2V0XCIrbytcIkF0T3V0Q29vcmRzXCIsaT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLHM9ZS5sb2dpY2FsU2hhcGUubGVuZ3RoLHU9YW8odC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGUubG9naWNhbFNoYXBlKSxsPWJvKHMpLGM9cy1pLGg9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtuPTA9PT1pP1wiXCI6czwyJiZ1Lmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6dS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJjb29yZHMuXCIraFt0K2NdK1wiID0gMDtcIn0pLmpvaW4oXCJcXG5cIik7dmFyIHA9XCJcIjtwPXM8MiYmaT4wP1wiY29vcmRzXCI6dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiY29vcmRzLlwiK2hbZStjXX0pLmpvaW4oXCIsIFwiKTt2YXIgZj1cInJldHVybiBvdXRwdXRWYWx1ZTtcIixkPTE9PT15KHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSksdj0xPT09eShlLmxvZ2ljYWxTaGFwZSk7aWYoMSE9PWl8fGR8fHYpe2lmKGQmJiF2KWY9MT09PXM/XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XFxuICAgICAgXCI6XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgIFwiO2Vsc2UgaWYodS5sZW5ndGgpe3ZhciBtPWktMixnPWktMTt1LmluZGV4T2YobSk+LTEmJnUuaW5kZXhPZihnKT4tMT9mPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI6dS5pbmRleE9mKG0pPi0xP2Y9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCBvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55KTtcIjp1LmluZGV4T2YoZyk+LTEmJihmPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnp6KTtcIil9fWVsc2UgZj1cIlxcbiAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgIFwiO3JldHVyblwiXFxuICAgIHZlYzQgXCIrYStcIigpIHtcXG4gICAgICBcIitsK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiK24rXCJcXG4gICAgICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0XCIrbytcIihcIitwK1wiKTtcXG4gICAgICBcIitmK1wiXFxuICAgIH1cXG4gIFwifSh0LGUpOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5uYW1lLHI9bi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89XCJnZXRcIityK1wiQXRPdXRDb29yZHNcIixhPWUudGV4U2hhcGUsaT10LnNoYXBlSW5mby50ZXhTaGFwZSxzPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgsdT1lLmxvZ2ljYWxTaGFwZS5sZW5ndGg7aWYoIXQuc2hhcGVJbmZvLmlzVW5pZm9ybSYmcz09PXUmJm51bGw9PXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQmJngoaSxhKSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK28rXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCByZXN1bHRVVik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgbCxjPWJvKHUpLGg9YW8odC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGUubG9naWNhbFNoYXBlKSxwPXUtcyxmPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07bD0wPT09cz9cIlwiOnU8MiYmaC5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmgubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiY29vcmRzLlwiK2ZbdCtwXStcIiA9IDA7XCJ9KS5qb2luKFwiXFxuXCIpO3ZhciBkPVwiXCI7ZD11PDImJnM+MD9cImNvb3Jkc1wiOnQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvb3Jkcy5cIitmW2UrcF19KS5qb2luKFwiLCBcIik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICBcIitjK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiK2wrXCJcXG4gICAgICByZXR1cm4gZ2V0XCIrcitcIihcIitkK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSkpO3JldHVybiByfSh0LGUscil9KS5qb2luKFwiXFxuXCIpLGw9ZS50ZXhTaGFwZSxjPXVvKCksaD1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgIHJldHVybiBcIit0LnRleHR1cmUyRCtcIih0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgIH1cXG4gIFwifShjKSxwPWZ1bmN0aW9uKHQpe3JldHVybiB0LnZlcnNpb24rXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xcbiAgICBcIit0LnZhcnlpbmdGcytcIiB2ZWMyIHJlc3VsdFVWO1xcbiAgICBcIit0LmRlZmluZU91dHB1dCtcIlxcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgICBzdHJ1Y3QgaXZlYzVcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICB9O1xcblxcbiAgICBzdHJ1Y3QgaXZlYzZcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICAgIGludCB2O1xcbiAgICB9O1xcblxcbiAgICB1bmlmb3JtIGZsb2F0IE5BTjtcXG4gICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICBcIit0LmRlZmluZVNwZWNpYWxOYU4rXCJcXG4gICAgYnZlYzQgaXNuYW5fY3VzdG9tKHZlYzQgdmFsKSB7XFxuICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuKHZhbC54KSwgaXNuYW4odmFsLnkpLCBpc25hbih2YWwueiksIGlzbmFuKHZhbC53KSk7XFxuICAgIH1cXG5cXG4gICAgXCIrdC5kZWZpbmVTcGVjaWFsSW5mK1wiXFxuICAgIFwiK3QuZGVmaW5lUm91bmQrXCJcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBpbnQgaWRpdihpbnQgYSwgaW50IGIsIGZsb2F0IHNpZ24pIHtcXG4gICAgICBpbnQgcmVzID0gYSAvIGI7XFxuICAgICAgaW50IG1vZCA9IGltb2QoYSwgYik7XFxuICAgICAgaWYgKHNpZ24gPCAwLiAmJiBtb2QgIT0gMCkge1xcbiAgICAgICAgcmVzIC09IDE7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiByZXM7XFxuICAgIH1cXG5cXG4gICAgLy9CYXNlZCBvbiB0aGUgd29yayBvZiBEYXZlIEhvc2tpbnNcXG4gICAgLy9odHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNGRqU1JXXFxuICAgICNkZWZpbmUgSEFTSFNDQUxFMSA0NDMuODk3NVxcbiAgICBmbG9hdCByYW5kb20oZmxvYXQgc2VlZCl7XFxuICAgICAgdmVjMiBwID0gcmVzdWx0VVYgKiBzZWVkO1xcbiAgICAgIHZlYzMgcDMgID0gZnJhY3QodmVjMyhwLnh5eCkgKiBIQVNIU0NBTEUxKTtcXG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl6eCArIDE5LjE5KTtcXG4gICAgICByZXR1cm4gZnJhY3QoKHAzLnggKyBwMy55KSAqIHAzLnopO1xcbiAgICB9XFxuXFxuICAgIFwiK3ZvK1wiXFxuICAgIFwiK21vK1wiXFxuICAgIFwiK2dvK1wiXFxuICBcIn0oYyk7cmV0dXJuIGUuaXNQYWNrZWQ/KGE9ZnVuY3Rpb24odCxlKXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXTtpZigxPT09blswXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi54ICogXCIrblsxXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1uWzFdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnkgKiBcIituWzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwifSgwLGUpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildO2lmKHgodCxlKSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPU1hdGguY2VpbCh0WzFdLzIpO3JldHVyblwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgMzpyZXR1cm4gbj10LHI9ZSxvPVtNYXRoLmNlaWwoclswXS8yKSxNYXRoLmNlaWwoclsxXS8yKV0sYT1NYXRoLmNlaWwoblsyXS8yKSxpPWEqTWF0aC5jZWlsKG5bMV0vMiksXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitvWzBdK1wiLCBcIitvWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK29bMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitpK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitpK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK2ErXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrYStcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgXCI7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXSxyPU1hdGguY2VpbCh0W3QubGVuZ3RoLTFdLzIpLG89cipNYXRoLmNlaWwodFt0Lmxlbmd0aC0yXS8yKSxhPW8saT1cIlwiLHM9XCJiLCByLCBjXCIsdT0yO3U8dC5sZW5ndGgtMTt1KyspYSo9dFt0Lmxlbmd0aC11LTFdLGk9XCJcXG4gICAgICBpbnQgYlwiK3UrXCIgPSBpbmRleCAvIFwiK2ErXCI7XFxuICAgICAgaW5kZXggLT0gYlwiK3UrXCIgKiBcIithK1wiO1xcbiAgICBcIitpLHM9XCJiXCIrdStcIiwgXCIrcztyZXR1cm5cIlxcbiAgICBpdmVjXCIrdC5sZW5ndGgrXCIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK2krXCJcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIrbytcIjtcXG4gICAgICBpbmRleCAtPSBiICogXCIrbytcIjtcXG5cXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIityK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK3IrXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlY1wiK3QubGVuZ3RoK1wiKFwiK3MrXCIpO1xcbiAgICB9XFxuICBcIn0odCxlKX12YXIgbixyLG8sYSxpfShlLmxvZ2ljYWxTaGFwZSxsKSxpPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgXCIrdC5vdXRwdXQrXCIgPSB2YWw7XFxuICAgIH1cXG4gIFwifShjKSk6KGE9ZnVuY3Rpb24odCxlKXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoMT09PWVbMF0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogXCIrZVsxXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1lWzFdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiK2VbMF0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgfVxcbiAgXCJ9KDAsZSk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0LGUpe2lmKHgodCxlKSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PXRbMV0pcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PXRbMF0pcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIit0WzFdK1wiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIrdFsxXStcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgMzpyZXR1cm4gbj1lLHI9bG8oW1wiclwiLFwiY1wiLFwiZFwiXSx0KSxcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrcitcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7Y2FzZSA0OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWxvKFtcInJcIixcImNcIixcImRcIixcImQyXCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIituK1wiXFxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSA1OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWxvKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrZVswXStcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK2VbMV0rXCIpKTtcXG5cXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIrbitcIlxcblxcbiAgICAgIGl2ZWM1IG91dFNoYXBlID0gaXZlYzUociwgYywgZCwgZDIsIGQzKTtcXG4gICAgICByZXR1cm4gb3V0U2hhcGU7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgNjpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1sbyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIixcImQ0XCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM2IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIituK1wiXFxuXFxuICAgICAgaXZlYzYgcmVzdWx0ID0gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IodC5sZW5ndGgrXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9dmFyIG4scn0oZS5sb2dpY2FsU2hhcGUsbCksaT1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICBcIit0Lm91dHB1dCtcIiA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgfVxcbiAgXCJ9KGMpKSxyJiYocCs9eW8pLFtwLGgsaSxzLGEsdSxuXS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHBvKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiZmxvYXQgXCIrbitcIigpIHtyZXR1cm4gXCIrZStcIjt9XCI7dmFyIHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1yWzBdLGE9clsxXTtpZigxPT09byYmMT09PWEpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBpPXQuc2hhcGVJbmZvLnRleFNoYXBlLHM9aVswXSx1PWlbMV0sbD14byhlKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIituK1wiKCkge1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3MrXCIsIFwiK3UrXCIsIFwiK2wrXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSk7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgcj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPXJbMF0sYT1yWzFdO2lmKDE9PT1hJiYxPT09bylyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9eG8oZSk7aWYoMT09PWEpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXggKyBcIitpK1wiKSArIDAuNSkgLyBcIitvK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PW8pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4ICsgXCIraStcIikgKyAwLjUpIC8gXCIrYStcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitvK1wiLCBcIithK1wiLCBpbmRleCArIFwiK2krXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZTtpZihudWxsIT1vJiZ4KGUsbykpe3ZhciBhPW9bMF0saT1vWzFdO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIitpK1wiLjAsIFwiK2ErXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn12YXIgcz1rKGUpLHU9cy5uZXdTaGFwZSxsPXMua2VwdERpbXMsYz11O2lmKGMubGVuZ3RoPGUubGVuZ3RoKXt2YXIgaD1Dbyh0LGMpO3JldHVyblwiXFxuICAgICAgXCIrcG8oaCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcInJvd1wiLFwiY29sXCJdLGwpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKSk7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIHA9b1swXSxmPW9bMV0sZD14byhuKTtpZigxPT09ZilyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBcIitkK1wiKSwgdmVjMyhcIitlWzFdK1wiLCAxLCAxKSk7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gXCIrcCtcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO2lmKDE9PT1wKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiK2QrXCIpLCB2ZWMzKFwiK2VbMV0rXCIsIDEsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gXCIrZitcIi4wLCAwLjUpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7cmV0dXJuXCJcXG4gIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2VbMV0rXCIgKyBjb2wgKyBcIitkK1wiO1xcbiAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitwK1wiLCBcIitmK1wiLCBpbmRleCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gIH1cXG5cIn0odCk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbMV0qZVsyXSxhPWVbMl0saT1rKGUpLHM9aS5uZXdTaGFwZSx1PWkua2VwdERpbXMsbD1zO2lmKGwubGVuZ3RoPGUubGVuZ3RoKXt2YXIgYz1Dbyh0LGwpO3JldHVyblwiXFxuICAgICAgICBcIitwbyhjKStcIlxcbiAgICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCJdLHUpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrbytcIiwgXCIrYStcIiwgMSkpKTtcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgaD10LnNoYXBlSW5mby50ZXhTaGFwZSxwPWhbMF0sZj1oWzFdLGQ9dC5zaGFwZUluZm8uZmxhdE9mZnNldDtpZihmPT09byYmbnVsbD09ZClyZXR1cm5cIlxcbiAgICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjMihjb2wsIGRlcHRoKSwgdmVjMihcIithK1wiLCAxKSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZitcIi4wLCBcIitwK1wiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7aWYoZj09PWEmJm51bGw9PWQpcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKFwiK2VbMV0rXCIsIDEpKTtcXG4gICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgpO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK2YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO3ZhciB2PXhvKG4pO3JldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK28rXCIgKyBjb2wgKiBcIithK1wiICsgZGVwdGggKyBcIit2K1wiO1xcbiAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcCtcIiwgXCIrZitcIiwgaW5kZXgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gIFwifSh0KTtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVszXSxhPWVbMl0qbyxpPWVbMV0qYSxzPWsoZSksdT1zLm5ld1NoYXBlLGw9cy5rZXB0RGltcztpZih1Lmxlbmd0aDxlLmxlbmd0aCl7dmFyIGM9Q28odCx1KTtyZXR1cm5cIlxcbiAgICAgIFwiK3BvKGMpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCJdLGwpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIDEpKSk7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGg9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxwPXQuc2hhcGVJbmZvLnRleFNoYXBlLGY9cFswXSxkPXBbMV07aWYoZD09PWkmJm51bGw9PWgpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XFxuICAgICAgICBmbG9hdCB0ZXhDID1cXG4gICAgICAgICAgICBkb3QodmVjMyhjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICB2ZWMzKFwiK2ErXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2QrXCIuMCwgXCIrZitcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKGQ9PT1vJiZudWxsPT1oKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiK2VbMV0qZVsyXStcIiwgXCIrZVsyXStcIiwgMSkpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoMik7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK2QrXCIuMCwgXCIrZitcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciB2PXhvKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2krXCIgKyBjb2wgKiBcIithK1wiICtcXG4gICAgICAgICAgZGVwdGggKiBcIitvK1wiICsgZGVwdGgyO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2YrXCIsIFwiK2QrXCIsIGluZGV4ICsgXCIrditcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSA1OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbNF0sYT1lWzNdKm8saT1lWzJdKmEscz1lWzFdKmksdT1rKGUpLGw9dS5uZXdTaGFwZSxjPXUua2VwdERpbXM7aWYobC5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBoPUNvKHQsbCk7cmV0dXJuXCJcXG4gICAgICBcIitwbyhoKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCJdLGMpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrcytcIiwgXCIraStcIiwgXCIrYStcIiwgXCIrbytcIikpICtcXG4gICAgICAgICAgZGVwdGgzO1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBwPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQsZj10LnNoYXBlSW5mby50ZXhTaGFwZSxkPWZbMF0sdj1mWzFdO2lmKHY9PT1zJiZudWxsPT1wKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIit2K1wiLjAsIFwiK2QrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZih2PT09byYmbnVsbD09cClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXStcIixcXG4gICAgICAgICAgICAgICBcIitlWzJdKmVbM10rXCIsIFwiK2VbM10rXCIsIDEpKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgzO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIit2K1wiLjAsIFwiK2QrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgbT14byhuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitzK1wiICsgY29sICogXCIraStcIiArIGRlcHRoICogXCIrYStcIiArXFxuICAgICAgICAgIGRlcHRoMiAqIFwiK28rXCIgKyBkZXB0aDMgKyBcIittK1wiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2QrXCIsIFwiK3YrXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDY6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ayhlKSxhPW8ubmV3U2hhcGUsaT1vLmtlcHREaW1zO2lmKGEubGVuZ3RoPGUubGVuZ3RoKXt2YXIgcz1Dbyh0LGEpO3JldHVyblwiXFxuICAgICAgXCIrcG8ocykrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSxpKStcIik7XFxuICAgICAgfVxcbiAgICBcIn12YXIgdT1lWzVdLGw9ZVs0XSp1LGM9ZVszXSpsLGg9ZVsyXSpjLHA9ZVsxXSpoO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrcCtcIiwgXCIraCtcIiwgXCIrYytcIiwgXCIrbCtcIikpICtcXG4gICAgICAgICAgZG90KFxcbiAgICAgICAgICAgIHZlYzIoZGVwdGgzLCBkZXB0aDQpLFxcbiAgICAgICAgICAgIHZlYzIoXCIrdStcIiwgMSkpKTtcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgZj10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LGQ9dC5zaGFwZUluZm8udGV4U2hhcGUsdj1kWzBdLG09ZFsxXTtpZihtPT09cCYmbnVsbD09ZilyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICB2ZWM0KFwiK2grXCIsIFwiK2MrXCIsIFwiK2wrXCIsIFwiK3UrXCIpKSArXFxuICAgICAgICAgICAgICAgZmxvYXQoZGVwdGg0KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK20rXCIuMCwgXCIrditcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKG09PT11JiZudWxsPT1mKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2VbMV0qZVsyXSplWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVsyXSplWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbNF0rXCIpKSArIGZsb2F0KGRlcHRoMyk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoNDtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrbStcIi4wLCBcIit2K1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGc9eG8obik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitwK1wiICsgY29sICogXCIraCtcIiArIGRlcHRoICogXCIrYytcIiArXFxuICAgICAgICAgIGRlcHRoMiAqIFwiK2wrXCIgKyBkZXB0aDMgKiBcIit1K1wiICsgZGVwdGg0ICsgXCIrZytcIjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIit2K1wiLCBcIittK1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoZS5sZW5ndGgrXCItRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX19ZnVuY3Rpb24gZm8odCl7dmFyIGUsbixyO3N3aXRjaCh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkscj11bygpLFwiXFxuICAgIHZlYzQgXCIrbitcIigpIHtcXG4gICAgICByZXR1cm4gXCIrci50ZXh0dXJlMkQrXCIoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXSxhPXVvKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAgIFwiK29bMF0rXCIsIFwiK29bMV0rXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gXCIrYS50ZXh0dXJlMkQrXCIoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlLGE9b1swXSxpPW9bMV0scz11bygpO2lmKG51bGwhPW8mJngoZSxvKSlyZXR1cm5cIlxcbiAgICAgIHZlYzQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIraStcIi4wLCBcIithK1wiLjApO1xcblxcbiAgICAgICAgcmV0dXJuIFwiK3MudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciB1PVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV0sbD1NYXRoLmNlaWwoZVsxXS8yKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRChcIitsK1wiLCBcIit1WzBdK1wiLCBcIit1WzFdK1wiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIFwiK3MudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZSxhPVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV07aWYoMT09PWVbMF0pe3ZhciBpPWUuc2xpY2UoMSkscz1Dbyh0LGkpO3JldHVyblwiXFxuICAgICAgICBcIitmbyhzKStcIlxcbiAgICAgICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcImJcIixcInJvd1wiLFwiY29sXCJdLFsxLDJdKStcIik7XFxuICAgICAgICB9XFxuICAgICAgXCJ9dmFyIHU9YVswXSxsPWFbMV0sYz1NYXRoLmNlaWwoZVsyXS8yKSxoPWMqTWF0aC5jZWlsKGVbMV0vMikscD11bygpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcXG4gICAgICAgIFwiK3UrXCIsIFwiK2wrXCIsIFwiK2grXCIsIFwiK2MrXCIsIGIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gXCIrcC50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPWUubGVuZ3RoLHI9dC5uYW1lLG89XCJnZXRcIityLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksYT10LnNoYXBlSW5mby50ZXhTaGFwZSxpPVtNYXRoLmNlaWwoYVswXS8yKSxNYXRoLmNlaWwoYVsxXS8yKV0scz1pWzBdLHU9aVsxXSxsPU1hdGguY2VpbChlW24tMV0vMiksYz1sKk1hdGguY2VpbChlW24tMl0vMiksaD1cImludCBiLCBpbnQgcm93LCBpbnQgY29sXCIscD1cImIgKiBcIitjK1wiICsgKHJvdyAvIDIpICogXCIrbCtcIiArIChjb2wgLyAyKVwiLGY9MjtmPG4tMTtmKyspaD1cImludCBiXCIrZitcIiwgXCIraCxjKj1lW24tZi0xXSxwPVwiYlwiK2YrXCIgKiBcIitjK1wiICsgXCIrcDt2YXIgZD11bygpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbytcIihcIitoK1wiKSB7XFxuICAgICAgaW50IGluZGV4ID0gXCIrcCtcIjtcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gXCIrdStcIjtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIFwiK3UrXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrdStcIiwgXCIrcytcIik7XFxuICAgICAgcmV0dXJuIFwiK2QudGV4dHVyZTJEK1wiKFwiK3IrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpfX12YXIgdm89XCJcXG52ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcbnZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLG1vPVwiXFxudmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgdGV4TnVtUixcXG4gIGludCB0ZXhOdW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixnbz1cIlxcbnZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxcbiAgICBpbnQgdGV4ZWxzSW5CYXRjaCwgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IGIsXFxuICAgIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIseW89XCJcXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICB9XFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICBmbG9hdCBtb2RDb29yZCA9IG1vZChmbG9hdChkaW0pLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZCA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZztcXG4gIH1cXG5cIjtmdW5jdGlvbiB4byh0KXtyZXR1cm5cIm9mZnNldFwiK3R9ZnVuY3Rpb24gd28odCl7dmFyIGU9dC5uYW1lLG49eSh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3JldHVybiBuPDI/XCJyZXR1cm4gXCIrZStcIjtcIjpcIlxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK24rXCI7IGkrKykge1xcbiAgICAgIGlmIChpID09IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gXCIrZStcIltpXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwifWZ1bmN0aW9uIGJvKHQpe2lmKHQ8PTEpcmV0dXJuXCJpbnRcIjtpZigyPT09dClyZXR1cm5cIml2ZWMyXCI7aWYoMz09PXQpcmV0dXJuXCJpdmVjM1wiO2lmKDQ9PT10KXJldHVyblwiaXZlYzRcIjtpZig1PT09dClyZXR1cm5cIml2ZWM1XCI7aWYoNj09PXQpcmV0dXJuXCJpdmVjNlwiO3Rocm93IEVycm9yKFwiR1BVIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9ZnVuY3Rpb24gQ28odCxlKXt2YXIgbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKTtyZXR1cm4gbi5zaGFwZUluZm8ubG9naWNhbFNoYXBlPWUsbn1mdW5jdGlvbiBFbyh0LGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pLmpvaW4oXCIsIFwiKX12YXIgUm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsZCh0Lmxlbmd0aD4yLGZ1bmN0aW9uKCl7cmV0dXJuXCJQYWNrZWQgYXJnXCIrKG4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSkrXCIgc3VwcG9ydHMgb25seSBpbnB1dHMgd2l0aCByYW5rIGFib3ZlIDIuXCJ9KTt2YXIgbz10W3QubGVuZ3RoLTFdLGE9TWF0aC5jZWlsKG8vZSk7dGhpcy5vdXRwdXRTaGFwZT10LnNsaWNlKDAsLTEpLGE+MSYmdGhpcy5vdXRwdXRTaGFwZS5wdXNoKGEpLHJ8fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpO3ZhciBpLHMsdT10aGlzLm91dHB1dFNoYXBlLGw9dS5sZW5ndGgsYz1ibyhsKSxoPW9vKFwiY29vcmRzXCIsbCk7aWYoMT09PWEpe3ZhciBwPWJvKHM9bCsxKTtpPVwiXFxuICAgICAgICBcIitwK1wiIHNvdXJjZUxvY1IgPSBcIitwK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgICsrXCIraFtsLTFdK1wiO1xcbiAgICAgICAgXCIrcCtcIiBzb3VyY2VMb2NHID0gXCIrcCtcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICArK1wiK2hbbC0yXStcIjtcXG4gICAgICAgIFwiK3ArXCIgc291cmNlTG9jQSA9IFwiK3ArXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgLS1cIitoW2wtMV0rXCI7XFxuICAgICAgICBcIitwK1wiIHNvdXJjZUxvY0IgPSBcIitwK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgIC0tXCIraFtsLTJdK1wiO1wifWVsc2Ugcz1sLGk9XCJcXG4gICAgICAgIFwiK2MrXCIgc291cmNlTG9jUiA9IGNvb3JkcztcXG4gICAgICAgICsrXCIraFtsLTFdK1wiO1xcbiAgICAgICAgXCIrYytcIiBzb3VyY2VMb2NHID0gY29vcmRzO1xcbiAgICAgICAgKytcIitoW2wtMl0rXCI7XFxuICAgICAgICBcIitjK1wiIHNvdXJjZUxvY0EgPSBjb29yZHM7XFxuICAgICAgICAtLVwiK2hbbC0xXStcIjtcXG4gICAgICAgIFwiK2MrXCIgc291cmNlTG9jQiA9IGNvb3JkcztcXG4gICAgICAgIC0tXCIraFtsLTJdK1wiO1wiO3ZhciBmPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxzKSx2PVwiLlwiK2Zbcy0xXSxtPWYubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiaW50IFwiK3R9KSxnPW9vKFwic291cmNlTG9jUlwiLHMtMSkuY29uY2F0KFwiaW5JZHguclwiKSx5PW9vKFwic291cmNlTG9jR1wiLHMtMSkuY29uY2F0KFwiaW5JZHguZ1wiKSx4PW9vKFwic291cmNlTG9jQlwiLHMtMSkuY29uY2F0KFwiaW5JZHguYlwiKSx3PW9vKFwic291cmNlTG9jQVwiLHMtMSkuY29uY2F0KFwiaW5JZHguYVwiKSxiPVwibWF4XCI9PT1uP1wiZ3JlYXRlclRoYW5cIjpcImxlc3NUaGFuXCIsQz1yP1wiXCI6XCJcXG4gICAgICAgICAgaW5JZHggPSByb3VuZCh2ZWM0KGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrZy5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit5LmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3guam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrdy5qb2luKCkrXCIpKSk7XCIsRT1cInZlYzQoXFxuICAgICAgICAgICAgZ2V0QUNoYW5uZWwoXCIrZy5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbChcIit5LmpvaW4oKStcIikgOiAwLixcXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QUNoYW5uZWwoXCIreC5qb2luKCkrXCIpIDogMC4sXFxuICAgICAgICAgICAgaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIrdy5qb2luKCkrXCIpIDogMC4pXCIsUj1yP1wiXCI6XCJcXG4gICAgICBmbG9hdCBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK20uam9pbigpK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRCZXN0SW5kaWNlc0EoXCIrZi5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZi5zbGljZSgtMikuam9pbigpK1wiKSk7XFxuICAgICAgfVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBnZXRBQ2hhbm5lbChcIittLmpvaW4oKStcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShcIitmLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZi5zbGljZSgtMikuam9pbigpK1wiKSk7XFxuICAgICAgfVxcbiAgICAgIFwiK1IrXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitjK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gXCIraFtsLTFdK1wiIDwgXCIrKHVbbC0xXS0xKStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IFwiK2hbbC0yXStcIiA8IFwiKyh1W2wtMl0tMSkrXCI7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBpdmVjNCBzcmNJZHggPSBpdmVjNChzb3VyY2VMb2NSXCIrditcIiwgc291cmNlTG9jR1wiK3YrXCIsXFxuICAgICAgICAgIHNvdXJjZUxvY0JcIit2K1wiLCBzb3VyY2VMb2NBXCIrditcIikgKiBcIitlK1wiO1xcbiAgICAgICAgaXZlYzQgaW5JZHggPSBzcmNJZHg7XFxuICAgICAgICB2ZWM0IGJlc3RJbmRleCA9IHZlYzQoaW5JZHgpO1xcbiAgICAgICAgdmVjNCBiZXN0VmFsdWUgPSBcIitFK1wiO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitlK1wiOyBpKyspIHtcXG4gICAgICAgICAgaW5JZHggPSBzcmNJZHg7XFxuICAgICAgICAgIFwiK0MrXCJcXG4gICAgICAgICAgdmVjNCBjYW5kaWRhdGUgPSBcIitFK1wiO1xcbiAgICAgICAgICBidmVjNCBuYW4gPSBpc25hbihjYW5kaWRhdGUpO1xcbiAgICAgICAgICBidmVjNCByZXBsYWNlID0gYnZlYzQoXFxuICAgICAgICAgICAgdmVjNChcIitiK1wiKGNhbmRpZGF0ZSwgYmVzdFZhbHVlKSkgKiAodmVjNCgxLjApIC0gdmVjNChuYW4pKSk7XFxuXFxuICAgICAgICAgIGJlc3RWYWx1ZSA9IHZlYzQocmVwbGFjZS54ICA/IGNhbmRpZGF0ZS54IDogYmVzdFZhbHVlLngsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS55ICA/IGNhbmRpZGF0ZS55IDogYmVzdFZhbHVlLnksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS56ICA/IGNhbmRpZGF0ZS56IDogYmVzdFZhbHVlLnosXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS53ICA/IGNhbmRpZGF0ZS53IDogYmVzdFZhbHVlLncpO1xcbiAgICAgICAgICBiZXN0SW5kZXggPSBtaXgoYmVzdEluZGV4LCB2ZWM0KGluSWR4KSwgdmVjNChyZXBsYWNlKSk7XFxuICAgICAgICAgIHNyY0lkeCsrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGJlc3RJbmRleCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksU289ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPXQuZGlsYXRpb25IZWlnaHQsaT10LmRpbGF0aW9uV2lkdGgscz10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD1zLTEtdC5wYWRJbmZvLnRvcCxjPXUtMS10LnBhZEluZm8ubGVmdCxoPTEvKGUqbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitsK1wiLCBcIitjK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIraCtcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrcytcIjtcXG4gICAgICAgICAgICB3UiArPSBcIithK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd0MrPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLE5vPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxzbyh0LGUpLHNvKHQsbik7dmFyIGk9XCIwLjBcIjtudWxsIT1yJiYoc28odCxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcIm9mZnNldFwiKSxpPVwiZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKVwiKTt2YXIgcz1cIjEuMFwiO251bGwhPW8mJihzbyh0LG8pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwic2NhbGVcIikscz1cImdldFNjYWxlQXRPdXRDb29yZHMoKVwiKSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIraStcIjtcXG4gICAgICAgIGZsb2F0IHNjYWxlID0gXCIrcytcIjtcXG4gICAgICAgIGZsb2F0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyBmbG9hdChcIithK1wiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoZG90KHZlYzMoeCwgLW1lYW4sIG9mZnNldCksIHZlYzMoaW52LCBpbnYsIDEpKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksa289ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEpe3RoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxzbyh0LGUpLHNvKHQsbik7dmFyIGk9XCJ2ZWM0KDAuMClcIjtudWxsIT1yJiYoc28odCxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcIm9mZnNldFwiKSxpPVwiZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKVwiKTt2YXIgcz1cInZlYzQoMS4wKVwiO251bGwhPW8mJihzbyh0LG8pLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwic2NhbGVcIikscz1cImdldFNjYWxlQXRPdXRDb29yZHMoKVwiKSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgb2Zmc2V0ID0gXCIraStcIjtcXG4gICAgICAgIHZlYzQgc2NhbGUgPSBcIitzK1wiO1xcblxcbiAgICAgICAgdmVjNCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyB2ZWM0KFwiK2ErXCIpKTtcXG5cXG4gICAgICAgIHNldE91dHB1dCgoeCAtIG1lYW4pICogaW52ICsgb2Zmc2V0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxJbz1cInJldHVybiBhcmVhbCAqIGJyZWFsIC0gYWltYWcgKiBiaW1hZztcIixBbz1cInJldHVybiBhcmVhbCAqIGJpbWFnICsgYWltYWcgKiBicmVhbDtcIixUbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFSZWFsXCIsXCJBSW1hZ1wiLFwiQlJlYWxcIixcIkJJbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9c28oZSxuKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BDb21wbGV4KFxcbiAgICAgICAgICBmbG9hdCBhcmVhbCwgZmxvYXQgYWltYWcsIGZsb2F0IGJyZWFsLCBmbG9hdCBiaW1hZykge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhcmVhbCA9IGdldEFSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGFpbWFnID0gZ2V0QUltYWdBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYnJlYWwgPSBnZXRCUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiaW1hZyA9IGdldEJJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcENvbXBsZXgoYXJlYWwsIGFpbWFnLCBicmVhbCwgYmltYWcpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxEbz1cInJldHVybiBhICsgYjtcIixPbz1cInJldHVybiBhIC0gYjtcIixfbz1cInJldHVybiBhICogYjtcIixNbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5vdXRwdXRTaGFwZT1zbyhlLG4pLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcGVyYXRpb24oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxGbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXNvKGUsbik7dmFyIG89dGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgsYT1cIlwiO2lmKHIpaWYoMD09PW98fDE9PT15KHRoaXMub3V0cHV0U2hhcGUpKWE9XCJcXG4gICAgICAgICAgcmVzdWx0LnkgPSAwLjtcXG4gICAgICAgICAgcmVzdWx0LnogPSAwLjtcXG4gICAgICAgICAgcmVzdWx0LncgPSAwLjtcXG4gICAgICAgIFwiO2Vsc2UgaWYoYT1cIlxcbiAgICAgICAgICBcIitibyhvKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiLDE9PT1vKWErPVwiXFxuICAgICAgICAgICAgcmVzdWx0LnkgPSAoY29vcmRzICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVswXStcIiA/IDAuIDogcmVzdWx0Lnk7XFxuICAgICAgICAgICAgcmVzdWx0LnogPSAwLjtcXG4gICAgICAgICAgICByZXN1bHQudyA9IDAuO1xcbiAgICAgICAgICBcIjtlbHNle3ZhciBpPW9vKFwiY29vcmRzXCIsbyk7YSs9XCJcXG4gICAgICAgICAgICBib29sIG5leHRSb3dPdXRPZkJvdW5kcyA9XFxuICAgICAgICAgICAgICAoXCIraVtvLTJdK1wiICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVtvLTJdK1wiO1xcbiAgICAgICAgICAgIGJvb2wgbmV4dENvbE91dE9mQm91bmRzID1cXG4gICAgICAgICAgICAgIChcIitpW28tMV0rXCIgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlW28tMV0rXCI7XFxuICAgICAgICAgICAgcmVzdWx0LnkgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQuejtcXG4gICAgICAgICAgICByZXN1bHQudyA9IG5leHRDb2xPdXRPZkJvdW5kcyB8fCBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC53O1xcbiAgICAgICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdmVjNCBiaW5hcnlPcGVyYXRpb24odmVjNCBhLCB2ZWM0IGIpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gYmluYXJ5T3BlcmF0aW9uKGEsIGIpO1xcbiAgICAgICAgXCIrYStcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksQm89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBtaW47XFxuICAgICAgdW5pZm9ybSBmbG9hdCBtYXg7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc25hbih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBtaW4sIG1heCkpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbyl7bnVsbD09bi5taW5Mb2MmJihuLm1pbkxvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1pblwiKSxuLm1heExvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1heFwiKSksci5nbC51bmlmb3JtMWYobi5taW5Mb2MsdCksci5nbC51bmlmb3JtMWYobi5tYXhMb2MsZSl9fSx0fSgpLFBvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGlmIChhbnkoaXNuYW4odmFsdWUpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIHZlYzQobWluKSwgdmVjNChtYXgpKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24ocixvKXtudWxsPT1uLm1pbkxvYyYmKG4ubWluTG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWluXCIpLG4ubWF4TG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWF4XCIpKSxyLmdsLnVuaWZvcm0xZihuLm1pbkxvYyx0KSxyLmdsLnVuaWZvcm0xZihuLm1heExvYyxlKX19LHR9KCksTG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCByZSA9IGFicyhnZXRSZWFsQXRPdXRDb29yZHMoKSk7XFxuICAgICAgICBmbG9hdCBpbSA9IGFicyhnZXRJbWFnQXRPdXRDb29yZHMoKSk7XFxuICAgICAgICBmbG9hdCBteCA9IG1heChyZSwgaW0pO1xcblxcbiAgICAgICAgLy8gc2FkbHkgdGhlIGxlbmd0aCBmdW5jdGlvbiBpbiBnbHNsIGlzIG5vdCB1bmRlcmZsb3ctc2FmZVxcbiAgICAgICAgLy8gKGF0IGxlYXN0IG5vdCBvbiBJbnRlbCBHUFVzKS4gU28gdGhlIHNhZmUgc29sdXRpb24gaXNcXG4gICAgICAgIC8vIHRvIGVuc3VyZSB1bmRlcmZsb3ctc2FmZXR5IGluIGFsbCBjYXNlcy5cXG4gICAgICAgIHNldE91dHB1dChcXG4gICAgICAgICAgbXggPT0gMC4wID8gMC4wIDogbXggKiBsZW5ndGgodmVjMigxLCBtaW4ocmUsIGltKS9teCkpXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFdvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1zbih0LDEpLHRoaXMudmFyaWFibGVOYW1lcz10Lm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KTt2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgtMSk7ZVswXT10WzBdWzFdO2Zvcih2YXIgbj0xO248ZS5sZW5ndGg7bisrKWVbbl09ZVtuLTFdK3Rbbl1bMV07dmFyIHI9W1wiaWYgKHlDIDwgXCIrZVswXStcIikgc2V0T3V0cHV0KGdldFQwKHlSLCB5QykpO1wiXTtmb3Iobj0xO248ZS5sZW5ndGg7bisrKXt2YXIgbz1lW24tMV07ci5wdXNoKFwiZWxzZSBpZiAoeUMgPCBcIitlW25dK1wiKSBzZXRPdXRwdXQoZ2V0VFwiK24rXCIoeVIsIHlDLVwiK28rXCIpKTtcIil9dmFyIGE9ZS5sZW5ndGgsaT1lW2UubGVuZ3RoLTFdO3IucHVzaChcImVsc2Ugc2V0T3V0cHV0KGdldFRcIithK1wiKHlSLCB5Qy1cIitpK1wiKSk7XCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB5UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XFxuXFxuICAgICAgICBcIityLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFVvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXNuKHQsZSk7dmFyIG49dGhpcy5vdXRwdXRTaGFwZSxyPW4ubGVuZ3RoLG89Ym8ociksYT1vbyhcImNvb3Jkc1wiLHIpLGk9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHIpO3RoaXMudmFyaWFibGVOYW1lcz10Lm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KTt2YXIgcz1uZXcgQXJyYXkodC5sZW5ndGgtMSk7c1swXT10WzBdW2VdO2Zvcih2YXIgdT0xO3U8cy5sZW5ndGg7dSsrKXNbdV09c1t1LTFdK3RbdV1bZV07dmFyIGw9aVtlXSxjPVwidmVjMihcIitpLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsaD1pLmpvaW4oKSxwPVwiaWYgKFwiK2wrXCIgPCBcIitzWzBdK1wiKVxcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRUMChcIitoK1wiKSwgXCIrYytcIik7XCI7Zm9yKHU9MTt1PHMubGVuZ3RoO3UrKyl7dmFyIGY9c1t1LTFdO3ArPVwiXFxuICAgICAgICBlbHNlIGlmIChcIitsK1wiIDwgXCIrc1t1XStcIikge1xcbiAgICAgICAgICBcIitsK1wiIC09IFwiK2YrXCI7XFxuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldFRcIit1K1wiKFwiK2grXCIpLCBcIitjK1wiKTtcXG4gICAgICAgIH1cIn12YXIgZD1zLmxlbmd0aDtwKz1cIlxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIFwiK2wrXCIgLT0gXCIrc1tzLmxlbmd0aC0xXStcIjtcXG4gICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0VFwiK2QrXCIoXCIraCtcIiksIFwiK2MrXCIpO1xcbiAgICAgICAgfVwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBnZXRWYWx1ZShcIitpLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImludCBcIit0fSkrXCIpIHtcXG4gICAgICAgIFwiK3ArXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZShcIithK1wiKSwgMC4sIDAuLCAwLik7XFxuICAgICAgICBpZiAoKytcIithW3ItMV0rXCIgPCBcIituW3ItMV0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgrK1wiK2Fbci0yXStcIiA8IFwiK25bci0yXStcIikge1xcbiAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKFwiK2Fbci0yXStcIiA8IFwiK25bci0yXStcIiAmJlxcbiAgICAgICAgICAgIC0tXCIrYVtyLTFdK1wiIDwgXCIrbltyLTFdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSx6bz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK2UrXCIgLSBcIityK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrbitcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxWbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9ZS0xLXQucGFkSW5mby50b3AsaT1uLTEtdC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIithK1wiLCBcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIrdC5vdXRDaGFubmVscytcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxHbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlRGVwdGgsbj10LnN0cmlkZUhlaWdodCxyPXQuc3RyaWRlV2lkdGgsbz10LnBhZEluZm8uZnJvbnQsYT10LnBhZEluZm8udG9wLGk9dC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdGID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueTtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8IFwiK3Qub3V0RGVwdGgrXCI7IHlGKyspIHtcXG4gICAgICAgICAgICBpbnQgeEYgPSB3RiArIHlGICogXCIrZStcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIituK1wiIC0gXCIrYStcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIityK1wiIC0gXCIraStcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeUYsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhGLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCkscW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVyRGVwdGgsbj10LmZpbHRlckhlaWdodCxyPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9ZS0xLXQucGFkSW5mby5mcm9udCx1PW4tMS10LnBhZEluZm8udG9wLGw9ci0xLXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrcytcIiwgXCIrdStcIiwgXCIrbCtcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy51O1xcblxcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlGQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2UrXCI7IHdGKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlGID0gZmxvYXQoZHlGQ29ybmVyICsgd0YpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlGIDwgMC4wIHx8IGR5RiA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlGKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlGID0gaW50KGR5Rik7XFxuXFxuICAgICAgICAgIGludCB3RlBlcm0gPSBcIitlK1wiIC0gMSAtIHdGO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbitcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2ErXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrbitcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrcitcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIraStcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrcitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIit0Lm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod0ZQZXJtLCB3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksSG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIrYStcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK24rXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksJG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPWUtMS10LnBhZEluZm8udG9wLGk9bi0xLXQucGFkSW5mby5sZWZ0LHM9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIithK1wiLCBcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2UrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrZStcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK24rXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIituK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgY2hhbm5lbE11bFxcbiAgICAgICAgICAgIGZvciAoaW50IGRtID0gMDsgZG0gPCBcIitzK1wiOyBkbSsrKSB7XFxuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqIFwiK3MrXCIgKyBkbTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZG0pO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksam89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBlPXQucGFkSW5mby50b3Asbj10LnBhZEluZm8ubGVmdCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPXQuZGlsYXRpb25IZWlnaHQsaT10LmRpbGF0aW9uV2lkdGgscz10LmZpbHRlckhlaWdodCx1PXQuZmlsdGVyV2lkdGgsbD00Kk1hdGguZmxvb3IodC5pbkNoYW5uZWxzLzQpLGM9dC5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIityK1wiLCBcIitvK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrZStcIiwgXCIrbitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitzK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIithK1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitpK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2wrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiKygxPT09YykrXCIpIHtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiKSAqXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiLCBkMik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWMpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWMpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiICsgMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxLbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIGU9dC5wYWRJbmZvLmZyb250LG49dC5wYWRJbmZvLnRvcCxyPXQucGFkSW5mby5sZWZ0LG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25EZXB0aCx1PXQuZGlsYXRpb25IZWlnaHQsbD10LmRpbGF0aW9uV2lkdGgsYz10LmZpbHRlckRlcHRoLGg9dC5maWx0ZXJIZWlnaHQscD10LmZpbHRlcldpZHRoLGY9NCpNYXRoLmZsb29yKHQuaW5DaGFubmVscy80KSxkPXQuaW5DaGFubmVscyU0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoXCIrbytcIiwgXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK2UrXCIsIFwiK24rXCIsIFwiK3IrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGl2ZWMzIHhGUkNDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCA/LCBkMSkgd2l0aCB3KDosIDosIDosIGQxLCBkMikgdG8gZ2V0XFxuICAgICAgICAvLyB5KHlGLCB5UiwgeUMsIGQyKS4gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsXFxuICAgICAgICAvLyB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCBcIitjK1wiOyB3RisrKSB7XFxuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiOyB3UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK3UrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3ArXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitsK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIrZitcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChcIisoMT09PWQpK1wiKSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiLCBkMik7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiICsgMSlcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIiArIDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxYbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIGU9dC5pbkhlaWdodCxuPXQuaW5XaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25IZWlnaHQsdT10LmRpbGF0aW9uV2lkdGgsbD10LmZpbHRlckhlaWdodCxjPXQuZmlsdGVyV2lkdGgsaD10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIityK1wiLCBcIitvK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyIC8gXCIraCtcIjtcXG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqIFwiK2grXCI7XFxuXFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2wrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrZStcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitjK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK3UrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIituK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxZbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7Zm9yKHZhciBlPXQuaW5IZWlnaHQsbj10LmluV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uSGVpZ2h0LHU9dC5kaWxhdGlvbldpZHRoLGw9dC5maWx0ZXJIZWlnaHQsYz10LmZpbHRlcldpZHRoLGg9YyxmPVwiaW50IHhSOyBpbnQgeEM7IGludCB4Q09mZnNldDtcIixkPTA7ZDxsO2QrKylmb3IodmFyIHY9MDt2PGM7disrKWYrPVwiXFxuICAgICAgICAgIHZlYzQgeFRleGVsUlwiK2QrXCJDXCIrMip2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgIHZlYzQgd1JcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB4UlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1wiO2ZvcihkPTA7ZDxsO2QrKylmb3IodmFyIG09MDttPGg7bSsrKXtpZihmKz1cIlxcbiAgICAgICAgICB4UiA9IHhSQ29ybmVyICsgXCIrZCpzK1wiO1xcbiAgICAgICAgICB4QyA9IHhDQ29ybmVyICsgXCIrKHY9MiptKSp1K1wiO1xcbiAgICAgICAgXCIsMT09PWkpe2lmKHY8YyYmKGYrPW8lMj09MT9cIlxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiYgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiYgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB2ZWM0IHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMCwgMCwgeFRleGVsUlwiK2QrXCJDXCIrditcIi54eSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmIHhDID49IDAgJiYgeEMgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrditcIiA9IHhUZXhlbFJcIitkK1wiQ1wiK3YrXCI7XFxuICAgICAgICAgICAgICBcIix2KzE8Yykpe3ZhciBnPW8lMj09MD9wKHUpOnU7dSUyPT0wJiZvJTI9PTF8fHUlMiE9MCYmbyUyIT0xPyhmKz1cIlxcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitvJTIrXCIgKyBcIitnK1wiO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiLHU+MSYmKGYrPVwiXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIFwiKSxmKz1cIlxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIisodisxKStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnp3LCB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIi54eSk7XFxuICAgICAgICAgICAgICAgIFwiKTpmKz1cIlxcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitnK1wiO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiKyh2KzEpK1wiID0geFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCI7XFxuICAgICAgICAgICAgICAgIFwifX1lbHNlIHY8YyYmKGYrPVwiXFxuICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIikge1xcbiAgICAgICAgICAgIFwiLG8lMj09MT8oZis9XCJcXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBcIitpK1wiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYoeEMgKyAxID49IDAgJiYgeEMgKyAxIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDICsgMSwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIuencsIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiLnp3KTtcXG4gICAgICAgICAgICAgIFwiLHYrMTxjJiYoZis9XCJcXG4gICAgICAgICAgICAgICAgICB2ZWM0IGZpbmFsID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgKyBcIitpK1wiO1xcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBmaW5hbCA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrKHYrMSkrXCIgPSB2ZWM0KHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiLnh5LCBmaW5hbC54eSk7XFxuICAgICAgICAgICAgICAgIFwiKSk6KGYrPVwiXFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIraStcIjtcXG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIueHksIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiLnh5KTtcXG4gICAgICAgICAgICAgIFwiLHYrMTxjJiYoZis9XCJcXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrKHYrMSkrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIi56dywgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIuencpO1xcbiAgICAgICAgICAgICAgICBcIikpLGYrPVwifVwiKTt2PGMmJihmKz1cIlxcbiAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFcoXCIrZCtcIiwgXCIrditcIiwgZDEsIHEpO1xcbiAgICAgICAgICAgIHdSXCIrZCtcIkNcIit2K1wiID0gdmVjNCh3VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnh6LCB3VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnh6KTtcXG4gICAgICAgICAgXCIsdisxPGMmJihmKz1cIlxcbiAgICAgICAgICAgICAgdmVjNCB3VGV4ZWxSXCIrZCtcIkNcIisodisxKStcIiA9IGdldFcoXCIrZCtcIiwgXCIrKHYrMSkrXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICAgIHdSXCIrZCtcIkNcIisodisxKStcIiA9XFxuICAgICAgICAgICAgICAgIHZlYzQod1RleGVsUlwiK2QrXCJDXCIrKHYrMSkrXCIueHosIHdUZXhlbFJcIitkK1wiQ1wiKyh2KzEpK1wiLnh6KTtcIikpfWZvcihkPTA7ZDxsO2QrKylmb3Iodj0wO3Y8Yzt2KyspZis9XCJyZXN1bHQgKz0geFJcIitkK1wiQ1wiK3YrXCIgKiB3UlwiK2QrXCJDXCIrditcIjtcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIityK1wiLCBcIitvK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuXFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyO1xcbiAgICAgICAgaW50IHEgPSAwO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBcIitmK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxRbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJJbWFnZVwiLFwiQm94ZXNcIixcIkJveEluZFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBhPXRbMF0saT10WzFdLHM9dFsyXSx1PXRbM10sbD1lWzBdLGM9blswXSxoPW5bMV07dGhpcy5vdXRwdXRTaGFwZT1bbCxjLGgsdV07dmFyIHA9XCJiaWxpbmVhclwiPT09cj8xOjAsZj1baS0xK1wiLjBcIixzLTErXCIuMFwiXSxkPWZbMF0sdj1mWzFdLG09Yz4xP1tcIlwiKyhpLTEpLyhjLTEpLFwiKHkyLXkxKSAqIGhlaWdodF9yYXRpb1wiLFwieTEqXCIrZCtcIiArIGZsb2F0KHkpKihoZWlnaHRfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeTEreTIpICogXCIrZF0sZz1tWzBdLHk9bVsxXSx4PW1bMl0sdz1oPjE/W1wiXCIrKHMtMSkvKGgtMSksXCIoeDIteDEpICogd2lkdGhfcmF0aW9cIixcIngxKlwiK3YrXCIgKyBmbG9hdCh4KSood2lkdGhfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeDEreDIpICogXCIrdl0sYj13WzBdLEM9d1sxXSxFPXdbMl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGhlaWdodF9yYXRpbyA9IGZsb2F0KFwiK2crXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IHdpZHRoX3JhdGlvID0gZmxvYXQoXCIrYitcIik7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IHggPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIC8vIGdldCBib3ggdmFsc1xcbiAgICAgICAgZmxvYXQgeTEgPSBnZXRCb3hlcyhiLDApO1xcbiAgICAgICAgZmxvYXQgeDEgPSBnZXRCb3hlcyhiLDEpO1xcbiAgICAgICAgZmxvYXQgeTIgPSBnZXRCb3hlcyhiLDIpO1xcbiAgICAgICAgZmxvYXQgeDIgPSBnZXRCb3hlcyhiLDMpO1xcblxcbiAgICAgICAgLy8gZ2V0IGltYWdlIGluIGJhdGNoIGluZGV4XFxuICAgICAgICBpbnQgYkluZCA9IHJvdW5kKGdldEJveEluZChiKSk7XFxuICAgICAgICBpZihiSW5kIDwgMCB8fCBiSW5kID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gXCIreStcIjtcXG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gXCIrQytcIjtcXG5cXG4gICAgICAgIGZsb2F0IGluX3kgPSBcIit4K1wiO1xcbiAgICAgICAgaWYoIGluX3kgPCAwLjAgfHwgaW5feSA+IFwiK2QrXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IGluX3ggPSBcIitFK1wiO1xcbiAgICAgICAgaWYoIGluX3ggPCAwLjAgfHwgaW5feCA+IFwiK3YrXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB2ZWMyKGluX3gsaW5feSk7XFxuICAgICAgICBpZihcIitwK1wiID09IDEpIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yQ1IgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhDUik7XFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuXFxuICAgICAgICAgIHZlYzIgZnJhY0NSID0gc291cmNlRnJhY0luZGV4Q1IgLSB2ZWMyKHNvdXJjZUZsb29yQ1IpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjQ1IueTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcXG4gICAgICAgICAgICBzb3VyY2VGcmFjSW5kZXhDUiArIHZlYzIoMC41LDAuNSkpKTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRJbWFnZShiLCBzb3VyY2VOZWFyZXN0Q1IueSwgc291cmNlTmVhcmVzdENSLngsIGQpO1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEpvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9dC5sZW5ndGgsbz10W3QubGVuZ3RoLTFdLGE9bj9cIjxcIjpcIj5cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaW50IGdldEluZGV4KGludCBpKSB7XFxuICAgICAgICBcIisobj9cInJldHVybiBcIitvK1wiIC1pIC0gMTtcIjpcInJldHVybiBpO1wiKStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitibyhyKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBlbmQgPSBcIitabyhyLFwiY29vcmRzXCIpK1wiO1xcbiAgICAgICAgZmxvYXQgdmFsID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IFwiK28rXCIgLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZ2V0SW5kZXgoaSk7XFxuICAgICAgICAgIGlmIChpZHggXCIrYStcIiBlbmQpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaWR4ID09IGVuZCAmJiBcIitlK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXCIrWm8ocixcImNvb3Jkc1wiKStcIiA9IGlkeDtcXG4gICAgICAgICAgdmFsICs9IGdldFgoXCIrZnVuY3Rpb24odCxlKXtpZigxPT09dClyZXR1cm5cIlwiK2U7aWYoMj09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55XCI7aWYoMz09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnpcIjtpZig0PT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnksIFwiK2UrXCIueiwgXCIrZStcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfShyLFwiY29vcmRzXCIpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO2Z1bmN0aW9uIFpvKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJcIitlO2lmKDI9PT10KXJldHVybiBlK1wiLnlcIjtpZigzPT09dClyZXR1cm4gZStcIi56XCI7aWYoND09PXQpcmV0dXJuIGUrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgdGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLmJsb2NrU2l6ZT1lLHRoaXMuZGF0YUZvcm1hdD1uLHRoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgIGludCBoID0gXCIrdGhpcy5nZXRIZWlnaHRDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCB3ID0gXCIrdGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IGQgPSBcIit0aGlzLmdldERlcHRoQ29vcmRTdHJpbmcoKStcIjtcXG5cXG4gICAgICBpbnQgaW5faCA9IGggLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgXCIrZStcIik7XFxuICAgICAgaW50IGluX3cgPSB3IC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X3cgPSBpbW9kKHcsIFwiK2UrXCIpO1xcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqIFwiK2UrXCIgKyBvZmZzZXRfdykgKlxcbiAgICAgICAgXCIrdGhpcy5nZXRPdXRwdXREZXB0aFNpemUoKStcIjtcXG4gICAgICBpbnQgaW5fZCA9IGQgKyBvZmZzZXRfZDtcXG5cXG4gICAgICBmbG9hdCByZXN1bHQgPSBcIit0aGlzLmdldElucHV0U2FtcGxpbmdTdHJpbmcoKStcIjtcXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEhlaWdodENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMV1cIjpcImNvb3Jkc1syXVwifSx0LnByb3RvdHlwZS5nZXRXaWR0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMl1cIjpcImNvb3Jkc1szXVwifSx0LnByb3RvdHlwZS5nZXREZXB0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbM11cIjpcImNvb3Jkc1sxXVwifSx0LnByb3RvdHlwZS5nZXRPdXRwdXREZXB0aFNpemU9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD90aGlzLm91dHB1dFNoYXBlWzNdOnRoaXMub3V0cHV0U2hhcGVbMV19LHQucHJvdG90eXBlLmdldElucHV0U2FtcGxpbmdTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImdldFgoYiwgaW5faCwgaW5fdywgaW5fZClcIjpcImdldFgoYiwgaW5fZCwgaW5faCwgaW5fdylcIn0sdH0oKSxlYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgZT11bygpO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcXG4gICAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgICBsb3dwIHZlYzQgZW5jb2RlX2Zsb2F0KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICAgIGlmIChpc25hbih2KSkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XFxuXFxuICAgICAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcXG4gICAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgICAgbSAtPSBjWzJdIC8gMTI4LjA7XFxuICAgICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcXG5cXG4gICAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XFxuICAgICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgICByZXR1cm4gYyAvIDI1NS4wO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBcIitlLm91dHB1dCtcIiA9IGVuY29kZV9mbG9hdCh4KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxuYT1cInJldHVybiByZWFsICogZXhwUiAtIGltYWcgKiBleHBJO1wiLHJhPVwicmV0dXJuIHJlYWwgKiBleHBJICsgaW1hZyAqIGV4cFI7XCIsb2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdO3ZhciByPWVbMV07dGhpcy5vdXRwdXRTaGFwZT1lO3ZhciBvPW4/XCIyLjAgKiBcIitNYXRoLlBJOlwiLTIuMCAqIFwiK01hdGguUEksYT1uP3IrXCIuMFwiOlwiMS4wXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGV4cG9uZW50TXVsdGlwbGllciA9IFwiK28rXCI7XFxuXFxuICAgICAgZmxvYXQgdW5hcnlPcENvbXBsZXgoZmxvYXQgcmVhbCwgZmxvYXQgZXhwUiwgZmxvYXQgaW1hZywgZmxvYXQgZXhwSSkge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBtdWxNYXRERlQoaW50IGJhdGNoLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4UmF0aW8gPSBmbG9hdChpbmRleCkgLyBmbG9hdChcIityK1wiKTtcXG4gICAgICAgIGZsb2F0IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyA9XFxuICAgICAgICAgICAgZXhwb25lbnRNdWx0aXBsaWVyICogaW5kZXhSYXRpbztcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcitcIjsgaSsrKSB7XFxuICAgICAgICAgIC8vIHggPSAoLTJ8MiAqIFBJIC8gTikgKiBpbmRleCAqIGk7XFxuICAgICAgICAgIGZsb2F0IHggPSBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gKiBmbG9hdChpKTtcXG4gICAgICAgICAgZmxvYXQgZXhwUiA9IGNvcyh4KTtcXG4gICAgICAgICAgZmxvYXQgZXhwSSA9IHNpbih4KTtcXG4gICAgICAgICAgZmxvYXQgcmVhbCA9IGdldFJlYWwoYmF0Y2gsIGkpO1xcbiAgICAgICAgICBmbG9hdCBpbWFnID0gZ2V0SW1hZyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIHJlc3VsdCArPVxcbiAgICAgICAgICAgICAgdW5hcnlPcENvbXBsZXgocmVhbCwgZXhwUiwgaW1hZywgZXhwSSkgLyBcIithK1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQobXVsTWF0REZUKGNvb3Jkc1swXSwgY29vcmRzWzFdKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksYWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgdmFsdWU7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgLy8gSW5wdXQgY2FuIGJlIG9idGFpbmVkIGZyb20gdW5pZm9ybSB2YWx1ZS5cXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS52YWx1ZUxvYyYmKGUudmFsdWVMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJ2YWx1ZVwiKSksbi5nbC51bmlmb3JtMWYoZS52YWx1ZUxvYyx0KX19LHR9KCksaWE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIGU9dW8oKSxuPXRbMF0scj10WzFdO3RoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB0ZXhDID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrcitcIi4wLCBcIituK1wiLjApO1xcblxcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSBcIitlLnRleHR1cmUyRCtcIihBLCB1dik7XFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHNhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiaW5kaWNlc1wiXTt2YXIgcj10LnNsaWNlKCk7cltuXT1lLHRoaXMub3V0cHV0U2hhcGU9cix0aGlzLnJhbms9ci5sZW5ndGg7dmFyIG89Ym8odGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IEVycm9yKFwiR2F0aGVyIGZvciByYW5rIFwiK24rXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PW4pcmV0dXJuXCJpbnQoZ2V0SW5kaWNlcyhyZXNSQykpXCI7Zm9yKHZhciByPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0sbz1bXSxhPTA7YTx0Lmxlbmd0aDthKyspYT09PWU/by5wdXNoKFwiaW50KGdldEluZGljZXMoXCIrclthXStcIikpXCIpOm8ucHVzaChcIlwiK3JbYV0pO3JldHVybiBvLmpvaW4oKX0odCxuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO3ZhciB1YSxsYSxjYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy5zbGljZURpbT10LHRoaXMuc3RyaWRlcz1lLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9bjt2YXIgcj1ibyhlLmxlbmd0aCksbz1ibyhuLmxlbmd0aCksYT10aGlzLnNsaWNlRGltPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcitcIiBzdHJpZGVzID0gXCIrcitcIihcIit0aGlzLnN0cmlkZXMrXCIpO1xcbiAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGZsYXR0ZW5JbmRleCA9IDA7XFxuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdGhpcy5zbGljZURpbStcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHNbMF0sIGopKTtcXG4gICAgICAgICAgICBmbGF0dGVuSW5kZXggKz0gaW5kZXggKiBcIithK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKGZsYXR0ZW5JbmRleCwgY29vcmRzWzFdKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpO2Z1bmN0aW9uIGhhKHQsZSl7cmV0dXJuW2UsdF19ZnVuY3Rpb24gcGEodCxlKXtyZXR1cm4gdCplfWZ1bmN0aW9uIGZhKHQsZSxuKXt2YXIgcj1mdW5jdGlvbih0LGUpe2lmKHQlZSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZFNpemUgKFwiK3QrXCIpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcIitlKTtyZXR1cm4gdC9lfSh0Lmxlbmd0aCxuKTtpZihlLmxlbmd0aDxyKXRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiK2UubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK3IpO2Zvcih2YXIgbz0wLGE9MDthPHQubGVuZ3RoO2ErPW4pZVtvKytdPXRbYV19ZnVuY3Rpb24gZGEodCxlKXtyZXR1cm5bTWF0aC5tYXgoMSxNYXRoLmNlaWwoZS8yKSksTWF0aC5tYXgoMSxNYXRoLmNlaWwodC8yKSldfWZ1bmN0aW9uIHZhKHQsZSl7dmFyIG49ZGEodCxlKTtyZXR1cm4gblswXSpuWzFdKjR9ZnVuY3Rpb24gbWEodCxlLG4scixvKXt2YXIgYT1uKnI7aWYoby5sZW5ndGg8YSl0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIitvLmxlbmd0aCtcIikgbXVzdCBiZSA+PSBcIithKTtmb3IodmFyIGk9ciUyPT0xLHM9biUyPT0xLHU9TWF0aC5mbG9vcihyLzIpLGw9TWF0aC5mbG9vcihuLzIpLGM9TWF0aC5jZWlsKHIvMiksaD1jKk1hdGguY2VpbChuLzIpLGY9cChuKSpwKHIpLGQ9MDtkPGU7ZCsrKXtmb3IodmFyIHY9ZCpuKnIsbT1kKmYsZz1pPzQ6MCx5PXIrKGk/MTowKSx4PW0sdz12LGI9dityLEM9MDtDPGw7KytDKXtmb3IodmFyIEU9MDtFPHU7KytFKW9bdysrXT10W3grK10sb1t3KytdPXRbeCsrXSxvW2IrK109dFt4KytdLG9bYisrXT10W3grK107eCs9Zyx3Kz15LGIrPXl9aWYoaSl7eD1tKzQqKGMtMSk7dmFyIFI9dityLTE7Zm9yKGc9NCpjLHk9MipyLEM9MDtDPGw7KytDKW9bUl09dFt4XSxvW1Ircl09dFt4KzJdLHgrPWcsUis9eX1pZihzKXtmb3IoeD1tKzQqKGgtYyksUj12KyhuLTEpKnIsRT0wO0U8dTsrK0Upb1tSKytdPXRbeCsrXSxvW1IrK109dFt4KytdLHgrPTI7aSYmKG9bdituKnItMV09dFt4XSl9fXJldHVybiBvfWZ1bmN0aW9uIGdhKHQsZSl7dmFyIG49dW8oKTtyZXR1cm4gVnQodCxlLG4udmVyc2lvbitcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIFwiK24uYXR0cmlidXRlK1wiIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBcIituLmF0dHJpYnV0ZStcIiB2ZWMyIHV2O1xcbiAgICBcIituLnZhcnlpbmdWcytcIiB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiKX1mdW5jdGlvbiB5YSh0LGUpe3JldHVybiBZdCh0LGUsbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pKX1mdW5jdGlvbiB4YSh0LGUpe3JldHVybiBRdCh0LGUsbmV3IFVpbnQxNkFycmF5KFswLDEsMiwyLDEsM10pKX1mdW5jdGlvbiB3YSh0LGUpe3ZhciBuLHIsbyxpLHMsdSxsLGMsaD10O3JldHVybiAyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyhuPWguUjMyRixyPWguUjE2RixvPWguUkdCQTE2RixpPWguUkdCQTMyRixzPWguUkVELHU9NCxsPTEsYz1oLkhBTEZfRkxPQVQpOihuPXQuUkdCQSxyPXQuUkdCQSxvPXQuUkdCQSxpPWguUkdCQSxzPXQuUkdCQSx1PTQsbD00LGM9bnVsbCE9ZT9lLkhBTEZfRkxPQVRfT0VTOm51bGwpLHtpbnRlcm5hbEZvcm1hdEZsb2F0Om4saW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ6cixpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdDpvLGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ6aSx0ZXh0dXJlRm9ybWF0RmxvYXQ6cyxkb3dubG9hZFRleHR1cmVGb3JtYXQ6dC5SR0JBLGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHM6dSxkZWZhdWx0TnVtQ2hhbm5lbHM6bCx0ZXh0dXJlVHlwZUhhbGZGbG9hdDpjfX1mdW5jdGlvbiBiYSh0LGUsbixyLG8sYSxpKXt0ZShuLHIpO3ZhciBzPVp0KHQsZSksdT10LlRFWFRVUkVfMkQ7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHUscyl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfUyx0LkNMQU1QX1RPX0VER0UpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9XUkFQX1QsdC5DTEFNUF9UT19FREdFKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfTUlOX0ZJTFRFUix0Lk5FQVJFU1QpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9NQUdfRklMVEVSLHQuTkVBUkVTVCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHUsMCxvLG4sciwwLGEsaSxudWxsKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pLHN9ZnVuY3Rpb24gQ2EodCxlLG4scixvKXt2YXIgYT1oYShuLHIpO3JldHVybiBiYSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRGbG9hdCxvLnRleHR1cmVGb3JtYXRGbG9hdCx0LkZMT0FUKX1mdW5jdGlvbiBFYSh0LGUsbixyLG8pe3ZhciBhPWhhKG4scik7cmV0dXJuIGJhKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCxvLnRleHR1cmVGb3JtYXRGbG9hdCxvLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiBSYSh0LGUsbixyLG8pe3ZhciBhPWhhKG4scik7cmV0dXJuIGJhKHQsZSxhWzBdLGFbMV0sdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUpfWZ1bmN0aW9uIFNhKHQsZSxuLHIsbyl7dmFyIGE9ZGEobixyKTtyZXR1cm4gYmEodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQsdC5SR0JBLHQuRkxPQVQpfWZ1bmN0aW9uIE5hKHQsZSxuLHIsbyl7dmFyIGE9ZGEobixyKTtyZXR1cm4gYmEodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0LHQuUkdCQSxvLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiBrYSh0LGUsbixyKXtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixyKX0pLG5lKHQsZSxuLFwiY2xpcFNwYWNlUG9zXCIsciwzLDIwLDApJiZuZSh0LGUsbixcInV2XCIsciwyLDIwLDEyKX1mdW5jdGlvbiBJYSh0LGUsbixyKXtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLHQuUkdCQSx0LlJHQkEsdC5VTlNJR05FRF9CWVRFLHIpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSl9ZnVuY3Rpb24gQWEodCxlLG4scixvLGEsaSl7dGUocixvKSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhTdWJJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLDAsMCxyLG8saSx0LkZMT0FULGEpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSl9ZnVuY3Rpb24gVGEodCxlLG4scixvLGEsaSxzKXt2YXIgdSxsPWhhKHIsbyksYz1sWzBdLGg9bFsxXSxwPXIqbzsxPT09cy5kZWZhdWx0TnVtQ2hhbm5lbHMmJnA9PT1hLmxlbmd0aD91PWE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPXBhKHQubGVuZ3RoLG4pO2lmKGUubGVuZ3RoPHIpdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRBcnJheSBsZW5ndGggKFwiK2UubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK3IpO2Zvcih2YXIgbz0wLGE9MDthPHQubGVuZ3RoOysrYSllW29dPXRbYV0sbys9bn0oYSx1PW5ldyBGbG9hdDMyQXJyYXkocCppKSxpKSxBYSh0LGUsbixjLGgsdSxzLnRleHR1cmVGb3JtYXRGbG9hdCl9ZnVuY3Rpb24gRGEodCxlLG4scixvLGEsaSxzLHUsbCl7dmFyIGM9ZGEoaSxzKSxoPWNbMF0sZj1jWzFdLGQ9bmV3IEZsb2F0MzJBcnJheSh2YShpLHMpKTshZnVuY3Rpb24odCxlLG4scixvKXtmb3IodmFyIGE9ciUyPT0xLGk9biUyPT0xLHM9TWF0aC5mbG9vcihyLzIpLHU9TWF0aC5mbG9vcihuLzIpLGw9TWF0aC5jZWlsKHIvMiksYz1sKk1hdGguY2VpbChuLzIpLGg9cChuKSpwKHIpLGY9MDtmPGU7ZisrKXtmb3IodmFyIGQ9ZipuKnIsdj1mKmgsbT1hPzQ6MCxnPXIseT12LHg9MDt4PHU7Kyt4KXtmb3IodmFyIHc9Mip4KnIsYj0wO2I8czsrK2Ipe3ZhciBDPWQrdysyKmI7b1t5XT10W0NdLG9beSsxXT10W0MrMV0sb1t5KzJdPXRbQytnXSxvW3krM109dFtDK2crMV0seSs9NH15Kz1tfWlmKGEpe0M9ZCtyLTEseT12KzQqKGwtMSk7dmFyIEU9MipyO2ZvcihtPTQqbCx4PTA7eDx1OysreClvW3ldPXRbQ10sb1t5KzJdPXRbQytyXSxDKz1FLHkrPW19aWYoaSl7Zm9yKEM9ZCsobi0xKSpyLHk9dis0KihjLWwpLGI9MDtiPHM7KytiKW9beSsrXT10W0MrK10sb1t5KytdPXRbQysrXSx5Kz0yO2EmJmkmJihvW3YraC00XT10W0NdKX19fSh1LHIsbyxhLGQpLEFhKHQsZSxuLGgsZixkLHQuUkdCQSl9ZnVuY3Rpb24gT2EodCxlLG4scixvKXt2YXIgYT10LmNyZWF0ZUJ1ZmZlcigpO0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixhKX0pO3ZhciBpPTQqcGEobipyLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyk7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5QSVhFTF9QQUNLX0JVRkZFUixpLHQuU1RSRUFNX1JFQUQpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAscixuLHQuUkdCQSx0LkZMT0FULDApfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpfSksYX1mdW5jdGlvbiBfYSh0LGUsbixyLG8pe3ZhciBhPXQsaT1uZXcgRmxvYXQzMkFycmF5KHBhKG4qcixvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpKTthLmJpbmRCdWZmZXIoYS5QSVhFTF9QQUNLX0JVRkZFUixlKSxhLmdldEJ1ZmZlclN1YkRhdGEoYS5QSVhFTF9QQUNLX0JVRkZFUiwwLGkpLGEuYmluZEJ1ZmZlcihhLlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpO3ZhciBzPW5ldyBGbG9hdDMyQXJyYXkobipyKTtyZXR1cm4gZmEoaSxzLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyksc31mdW5jdGlvbiBNYSh0LGUsbixyLG8pe3ZhciBhPWhhKG4sciksaT1hWzBdLHM9YVsxXSx1PW5ldyBGbG9hdDMyQXJyYXkocGEobipyLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscykpO0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLGkscyxvLmRvd25sb2FkVGV4dHVyZUZvcm1hdCx0LkZMT0FULHUpfSk7dmFyIGw9bmV3IEZsb2F0MzJBcnJheShuKnIpO3JldHVybiBmYSh1LGwsby5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSxsfWZ1bmN0aW9uIEZhKHQsZSxuLHIsbyl7dmFyIGE9aGEobixyKSxpPWFbMF0scz1hWzFdLHU9bmV3IFVpbnQ4QXJyYXkocGEobipyLDQpKTtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAsaSxzLG8uZG93bmxvYWRUZXh0dXJlRm9ybWF0LHQuVU5TSUdORURfQllURSx1KX0pLG5ldyBGbG9hdDMyQXJyYXkodS5idWZmZXIpfWZ1bmN0aW9uIEJhKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9dCxsPW5ldyBGbG9hdDMyQXJyYXkodmEoYSxpKSk7dS5iaW5kQnVmZmVyKHUuUElYRUxfUEFDS19CVUZGRVIsZSksdS5nZXRCdWZmZXJTdWJEYXRhKHUuUElYRUxfUEFDS19CVUZGRVIsMCxsKSx1LmJpbmRCdWZmZXIodS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKTt2YXIgYz1uZXcgRmxvYXQzMkFycmF5KHkoW24scixvXSkpO3JldHVybiBtYShsLG4scixvLGMpLGN9ZnVuY3Rpb24gUGEodCxlLG4scixvLGEsaSxzKXt2YXIgdT1kYShhLGkpLGw9dVswXSxjPXVbMV0saD1uZXcgRmxvYXQzMkFycmF5KHZhKGEsaSkpO0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLGwsYyx0LlJHQkEsdC5GTE9BVCxoKX0pO3ZhciBwPW5ldyBGbG9hdDMyQXJyYXkoeShbbixyLG9dKSk7cmV0dXJuIG1hKGgsbixyLG8scCl9IWZ1bmN0aW9uKHQpe3RbdC5SRU5ERVI9MF09XCJSRU5ERVJcIix0W3QuVVBMT0FEPTFdPVwiVVBMT0FEXCIsdFt0LlBJWEVMUz0yXT1cIlBJWEVMU1wiLHRbdC5ET1dOTE9BRD0zXT1cIkRPV05MT0FEXCJ9KHVhfHwodWE9e30pKSxmdW5jdGlvbih0KXt0W3QuVU5QQUNLRURfRkxPQVQxNj0wXT1cIlVOUEFDS0VEX0ZMT0FUMTZcIix0W3QuVU5QQUNLRURfRkxPQVQzMj0xXT1cIlVOUEFDS0VEX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFPTJdPVwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCIsdFt0LlBBQ0tFRF8yWDJfRkxPQVQzMj0zXT1cIlBBQ0tFRF8yWDJfRkxPQVQzMlwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMTY9NF09XCJQQUNLRURfMlgyX0ZMT0FUMTZcIn0obGF8fChsYT17fSkpO3ZhciBMYT1PYmplY3QuZnJlZXplKHtjcmVhdGVWZXJ0ZXhTaGFkZXI6Z2EsY3JlYXRlVmVydGV4QnVmZmVyOnlhLGNyZWF0ZUluZGV4QnVmZmVyOnhhLGdldFRleHR1cmVDb25maWc6d2EsY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6Q2EsY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6RWEsY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6UmEsY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTpTYSxjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTpOYSxiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXM6a2EsdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlOklhLHVwbG9hZE1hdHJpeFRvVGV4dHVyZTpUYSx1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmU6RGEsY3JlYXRlQnVmZmVyRnJvbU91dHB1dFRleHR1cmU6T2EsZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcjpfYSxkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTpNYSxkb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTpGYSxkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI6QmEsZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZTpQYX0pLFdhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLm91dHB1dFRleHR1cmU9bnVsbCx0aGlzLnByb2dyYW09bnVsbCx0aGlzLmRpc3Bvc2VkPSExLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdO3ZhciBlPWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtudWxsIT10Pyh0aGlzLmdsPXQsZnVuY3Rpb24odCxlKXtfdFt0XT1lfShlLHQpKTp0aGlzLmdsPUZ0KGUpLDE9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpLHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSxhLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpfHwodGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSkpOnRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj16dCh0aGlzLmdsLHRoaXMuZGVidWcsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMudmVydGV4QnVmZmVyPXlhKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy5pbmRleEJ1ZmZlcj14YSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMuZnJhbWVidWZmZXI9ZWUodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLnRleHR1cmVDb25maWc9d2EodGhpcy5nbCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkZWJ1Z1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiREVCVUdcIil9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuZGlzcG9zZWQpe251bGwhPXRoaXMucHJvZ3JhbSYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZVByb2dyYW0gYmVmb3JlIGRpc3Bvc2luZy5cIiksbnVsbCE9dGhpcy5vdXRwdXRUZXh0dXJlJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4IHRleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgbWF0cml4IHRleHR1cmUgd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlTWF0cml4VGV4dHVyZSBiZWZvcmUgZGlzcG9zaW5nLlwiKTt2YXIgZT10aGlzLmdsO0J0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmZpbmlzaCgpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCl9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWxldGVGcmFtZWJ1ZmZlcih0LmZyYW1lYnVmZmVyKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbnVsbCl9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbnVsbCl9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWxldGVCdWZmZXIodC5pbmRleEJ1ZmZlcil9KSx0aGlzLmRpc3Bvc2VkPSEwfX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRWEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFJhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlPWZ1bmN0aW9uKHQsZSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxJYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlKX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxOYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxTYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRlbGV0ZU1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMub3V0cHV0VGV4dHVyZT09PXQmJih1ZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5vdXRwdXRUZXh0dXJlPW51bGwpLEJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVRleHR1cmUodCl9KX0sdC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9UZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIG89SnQoKTtyZXR1cm4gVGEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSxuLHIsbyx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmU9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRGEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSxuLHIsbyxhLGksdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCxmdW5jdGlvbigpe3JldHVybiBNYShyLmdsLHIuZGVidWcsZSxuLHIudGV4dHVyZUNvbmZpZyl9KX0sdC5wcm90b3R5cGUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCxmdW5jdGlvbigpe3JldHVybiBGYShyLmdsLHIuZGVidWcsZSxuLHIudGV4dHVyZUNvbmZpZyl9KX0sdC5wcm90b3R5cGUuZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gQmEodGhpcy5nbCx0LGUsbixyLG8sYSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gX2EodGhpcy5nbCx0LGUsbix0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIHI9T2EodGhpcy5nbCx0aGlzLmRlYnVnLGUsbix0aGlzLnRleHR1cmVDb25maWcpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCkscn0sdC5wcm90b3R5cGUuY3JlYXRlQW5kV2FpdEZvckZlbmNlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtyZXR1cm4gdGhpcy5wb2xsRmVuY2UodCl9LHQucHJvdG90eXBlLmNyZWF0ZUZlbmNlPWZ1bmN0aW9uKHQpe3ZhciBlLG4scj10aGlzO2lmKGEuZ2V0Qm9vbChcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIpKXt2YXIgbz10LGk9by5mZW5jZVN5bmMoby5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTt0LmZsdXNoKCksbj1mdW5jdGlvbigpe3ZhciB0PW8uY2xpZW50V2FpdFN5bmMoaSwwLDApO3JldHVybiB0PT09by5BTFJFQURZX1NJR05BTEVEfHx0PT09by5DT05ESVRJT05fU0FUSVNGSUVEfSxlPWl9ZWxzZSBhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/KGU9dGhpcy5iZWdpblF1ZXJ5KCksdGhpcy5lbmRRdWVyeSgpLG49ZnVuY3Rpb24oKXtyZXR1cm4gci5pc1F1ZXJ5QXZhaWxhYmxlKGUsYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KTpuPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3JldHVybntxdWVyeTplLGlzRmVuY2VQYXNzZWQ6bn19LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCxmdW5jdGlvbigpe3JldHVybiBQYShpLmdsLGkuZGVidWcsZSxuLHIsbyxhLGkudGV4dHVyZUNvbmZpZyl9KX0sdC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbT1mdW5jdGlvbih0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciBlPXRoaXMuZ2wsbj1HdChlLHRoaXMuZGVidWcsdCkscj1nYShlLHRoaXMuZGVidWcpLG89anQoZSx0aGlzLmRlYnVnKTtyZXR1cm4gQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG8scil9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobyxuKX0pLEt0KGUsdGhpcy5kZWJ1ZyxvKSx0aGlzLmRlYnVnJiZYdChlLHRoaXMuZGVidWcsbyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kfHwodGhpcy5zZXRQcm9ncmFtKG8pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZD1rYShlLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtLHRoaXMudmVydGV4QnVmZmVyKSksb30sdC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdD09PXRoaXMucHJvZ3JhbSYmKHRoaXMucHJvZ3JhbT1udWxsKSxudWxsIT10JiZCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC5kZWxldGVQcm9ncmFtKHQpfSl9LHQucHJvdG90eXBlLnNldFByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucHJvZ3JhbT10LG51bGwhPXRoaXMucHJvZ3JhbSYmdGhpcy5kZWJ1ZyYmWHQodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSksQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wudXNlUHJvZ3JhbSh0KX0pfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb249ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxuP29lKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpOmFlKHRoaXMuZ2wsdCxlKX0sdC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBuLmdsLmdldEF0dHJpYkxvY2F0aW9uKHQsZSl9KX0sdC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZSl9LHQucHJvdG90eXBlLnNldElucHV0TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnRocm93SWZOb1Byb2dyYW0oKSxpZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtLHQsZSxuKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKHQsbixlKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj1kYShlLG4pLG89clswXSxhPXJbMV07dGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKHQsbyxhKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb249ZnVuY3Rpb24odCxlLG4scil7dGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihuLHQscixlKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb249ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwic2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUuZGVidWdWYWxpZGF0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMucHJvZ3JhbSYmWHQodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSksbGUodGhpcy5nbCl9LHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtPWZ1bmN0aW9uKCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnRocm93SWZOb1Byb2dyYW0oKTt2YXIgdD10aGlzLmdsO3RoaXMuZGVidWcmJnRoaXMuZGVidWdWYWxpZGF0ZSgpLEJ0KHQsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiB0LmRyYXdFbGVtZW50cyh0LlRSSUFOR0xFUyw2LHQuVU5TSUdORURfU0hPUlQsMCl9KX0sdC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiB0LmdsLmZpbmlzaCgpfSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24mJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj16dCh0aGlzLmdsLHRoaXMuZGVidWcsMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik/XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCI6XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIikpLHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9ufSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpfSx0LnByb3RvdHlwZS5iZWdpblF1ZXJ5PWZ1bmN0aW9uKCl7aWYoMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciB0PXRoaXMuZ2wsZT10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxuPXQuY3JlYXRlUXVlcnkoKTtyZXR1cm4gdC5iZWdpblF1ZXJ5KGUuVElNRV9FTEFQU0VEX0VYVCxuKSxufXZhciByPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpLG89ci5jcmVhdGVRdWVyeUVYVCgpO3JldHVybiByLmJlZ2luUXVlcnlFWFQoci5USU1FX0VMQVBTRURfRVhULG8pLG99LHQucHJvdG90eXBlLmVuZFF1ZXJ5PWZ1bmN0aW9uKCl7aWYoMiE9PWEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciB0PXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3QuZW5kUXVlcnlFWFQodC5USU1FX0VMQVBTRURfRVhUKX1lbHNle3ZhciBlPXRoaXMuZ2wsbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtlLmVuZFF1ZXJ5KG4uVElNRV9FTEFQU0VEX0VYVCl9fSx0LnByb3RvdHlwZS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LFIoZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXNwb3NlZHx8ZS5pc1F1ZXJ5QXZhaWxhYmxlKHQsYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbMix0aGlzLmdldFF1ZXJ5VGltZSh0LGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpXX19KX0pfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWU9ZnVuY3Rpb24odCxlKXtpZigwPT09ZSlyZXR1cm4gbnVsbDtpZigyPT09ZSl7dmFyIG49dGhpcy5nbDtyZXR1cm4gbi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKS8xZTZ9dmFyIHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7cmV0dXJuIHIuZ2V0UXVlcnlPYmplY3RFWFQodCxyLlFVRVJZX1JFU1VMVF9FWFQpLzFlNn0sdC5wcm90b3R5cGUuaXNRdWVyeUF2YWlsYWJsZT1mdW5jdGlvbih0LGUpe2lmKDA9PT1lKXJldHVybiEwO2lmKDI9PT1lKXt2YXIgbj10aGlzLmdsLHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksbz1uLmdldFF1ZXJ5UGFyYW1ldGVyKHQsbi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSksbyYmIXRoaXMuZGlzam9pbnR9bz0ocj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSkuZ2V0UXVlcnlPYmplY3RFWFQodCxyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoci5HUFVfRElTSk9JTlRfRVhUKSksbyYmIXRoaXMuZGlzam9pbnR9LHQucHJvdG90eXBlLnBvbGxGZW5jZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuKXtlLmFkZEl0ZW1Ub1BvbGwoZnVuY3Rpb24oKXtyZXR1cm4gdC5pc0ZlbmNlUGFzc2VkKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pfSl9LHQucHJvdG90eXBlLnBvbGxJdGVtcz1mdW5jdGlvbigpe2Zvcih2YXIgdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoOysrZSl7dmFyIG49dFtlXSgpO2lmKCFuKWJyZWFrfXJldHVybiBlLTF9KHRoaXMuaXRlbXNUb1BvbGwubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRG9uZUZufSkpLGU9MDtlPD10OysrZSl7KDAsdGhpcy5pdGVtc1RvUG9sbFtlXS5yZXNvbHZlRm4pKCl9dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKHQrMSl9LHQucHJvdG90eXBlLmFkZEl0ZW1Ub1BvbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3RoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46dCxyZXNvbHZlRm46ZX0pLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPjF8fFIoZnVuY3Rpb24oKXtyZXR1cm4gbi5wb2xsSXRlbXMoKSwwPT09bi5pdGVtc1RvUG9sbC5sZW5ndGh9KX0sdC5wcm90b3R5cGUuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksc2UodGhpcy5nbCx0aGlzLmRlYnVnLHQsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmbGUodGhpcy5nbCl9LHQucHJvdG90eXBlLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5vdXRwdXRUZXh0dXJlPyhzZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5vdXRwdXRUZXh0dXJlLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJmxlKHRoaXMuZ2wpKTp1ZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5mcmFtZWJ1ZmZlcil9LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyPWZ1bmN0aW9uKHQsZSl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIG49ZSgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCksbn0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcj1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj10aGlzLmdsO3NlKHIsdGhpcy5kZWJ1Zyx0LHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJmxlKHIpLHRoaXMub3V0cHV0VGV4dHVyZT10LEJ0KHIsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiByLnZpZXdwb3J0KDAsMCxlLG4pfSksQnQocix0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIHIuc2Npc3NvcigwLDAsZSxuKX0pfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIG8uZ2wuc2Npc3Nvcih0LGUsbixyKX0pfSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmRpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LlwiKX0sdC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbT1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucHJvZ3JhbSl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX0sdH0oKTtmdW5jdGlvbiBVYSh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIrdC5sZW5ndGgrXCIgaW5wdXRzLCBidXQgd2FzIGV4ZWN1dGVkIHdpdGggXCIrZS5sZW5ndGgrXCIgaW5wdXRzXCIpO3QuZm9yRWFjaChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9naWNhbFNoYXBlLG89ZVtuXSxhPW8uc2hhcGU7aWYoIXgocixhKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGVzIFwiK3IrXCIgYW5kIFwiK2ErXCIgbXVzdCBtYXRjaFwiKTtpZighdC5pc1VuaWZvcm18fCFvLmlzVW5pZm9ybSl7dmFyIGk9dC50ZXhTaGFwZSxzPW8uaXNVbmlmb3JtP251bGw6by50ZXhEYXRhLnRleFNoYXBlO2lmKCF4KGkscykpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHRleHR1cmUgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIraStcIiBhbmQgXCIrcytcIiBtdXN0IG1hdGNoXCIpfX0pfXZhciB6YT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPW4uZmlsdGVyV2lkdGgsbz1uLmluQ2hhbm5lbHMsYT1uLnN0cmlkZVdpZHRoLGk9bi5zdHJpZGVIZWlnaHQscz1uLnBhZEluZm8sdT1uLm91dFdpZHRoLGw9bi5kaWxhdGlvbldpZHRoLGM9bi5kaWxhdGlvbkhlaWdodCxoPXMubGVmdCxwPXMudG9wLGY9bypyLGQ9dW8oKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG5cXG4gICAgICAgIGZvcihpbnQgcm93PTA7IHJvdzw9MTsgcm93KyspIHtcXG4gICAgICAgICAgZm9yKGludCBjb2w9MDsgY29sPD0xOyBjb2wrKykge1xcbiAgICAgICAgICAgIGludCBibG9ja0luZGV4ID0gcmMueSArIGNvbDtcXG4gICAgICAgICAgICBpbnQgcG9zID0gcmMueCArIHJvdztcXG5cXG4gICAgICAgICAgICBpZihibG9ja0luZGV4ID49IFwiK3RbMV0rXCIgfHwgcG9zID49IFwiK3RbMF0rXCIpIGNvbnRpbnVlO1xcblxcbiAgICAgICAgICAgIGludCBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoXCIrdStcIikpICogXCIraStcIiAtIFwiK3ArXCI7XFxuICAgICAgICAgICAgaW50IGQwID0gb2Zmc2V0WSArIFwiK2MrXCIgKiAocG9zIC8gXCIrZitcIik7XFxuXFxuICAgICAgICAgICAgaWYoZDAgPj0gXCIrZVswXStcIiB8fCBkMCA8IDApIGNvbnRpbnVlO1xcblxcbiAgICAgICAgICAgIGludCBvZmZzZXRYID0gaW50KG1vZChmbG9hdChibG9ja0luZGV4KSwgXCIrdStcIi4pICogXCIrYStcIi4gLSBcIitoK1wiLik7XFxuICAgICAgICAgICAgaW50IGQxID0gb2Zmc2V0WCArIFwiK2wrXCIgKiAoaW50KG1vZChmbG9hdChwb3MpLCBcIitmK1wiLikgLyBcIitvK1wiLikpO1xcblxcbiAgICAgICAgICAgIGlmKGQxID49IFwiK2VbMV0rXCIgfHwgZDEgPCAwKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZDEsIGludChtb2QoZmxvYXQocG9zKSwgXCIrbytcIi4pKSk7XFxuICAgICAgICAgICAgcmVzdWx0W3JvdyAqIDIgKyBjb2xdID0gZ2V0Q2hhbm5lbChnZXRBKGQwLCBpbnQoaW5uZXJEaW1zLngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrZC5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn19KCksVmE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBhLGk9ZSxzPXRbM10tMTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHU9XCJmbG9hdChcIituK1wiKSArIGZsb2F0KFwiK3IrXCIpICogc3VtXCI7YT0uNT09PW8/XCJpbnZlcnNlc3FydChcIit1K1wiKVwiOjE9PT1vP1wiMS4wLyhcIit1K1wiKVwiOlwiZXhwKGxvZyhcIit1K1wiKSAqIGZsb2F0KC1cIitvK1wiKSk7XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WChiLCByLCBjLCBkKTtcXG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGogPSAtXCIraStcIjsgaiA8PSBcIitpK1wiOyBqKyspIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGQgKyBqO1xcbiAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9ICBcIitzK1wiKSB7XFxuICAgICAgICAgICAgZmxvYXQgeiA9IGdldFgoYiwgciwgYywgaWR4KTtcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHZhbCA9IHggKiBcIithK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksR2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5wdXRJbWFnZVwiLFwib3V0cHV0SW1hZ2VcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMuZGVwdGg9dFszXSx0aGlzLmRlcHRoUmFkaXVzPWUsdGhpcy5iaWFzPW4sdGhpcy5hbHBoYT1yLHRoaXMuYmV0YT1vLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGQgPSAwOyBkIDwgXCIrdGhpcy5kZXB0aCtcIjsgKytkKSB7XFxuICAgICAgICAgIGludCBkZXB0aEJlZ2luID0gaW50KG1heCgwLjAsIGZsb2F0KGQgLSBcIitlK1wiKSkpO1xcbiAgICAgICAgICBpbnQgZGVwdGhFbmQgPSBpbnQobWluKGZsb2F0KFwiK3RoaXMuZGVwdGgrXCIpLFxcbiAgICAgICAgICAgICAgZmxvYXQoZCArIFwiK2UrXCIgKyAxKSkpO1xcblxcbiAgICAgICAgICBjb25zdCBpbnQgTUlOX0RFUFRIX0JFR0lOID0gMDtcXG4gICAgICAgICAgY29uc3QgaW50IE1BWF9ERVBUSF9FTkQgPSBcIit0aGlzLmRlcHRoK1wiO1xcblxcbiAgICAgICAgICBmbG9hdCBub3JtID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKSB7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKSB7XFxuICAgICAgICAgICAgICBub3JtICs9IGdldElucHV0SW1hZ2UoYiwgciwgYywgaykgKiBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBub3JtID0gZmxvYXQoXCIrcitcIikgKiBub3JtICsgZmxvYXQoXCIrbitcIik7XFxuXFxuICAgICAgICAgIGZvcihpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsrayl7XFxuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKXtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5aSA9IC0yLjAgKiBmbG9hdChcIityK1wiKVxcbiAgICAgICAgICAgICAgICAqIGZsb2F0KFwiK28rXCIpXFxuICAgICAgICAgICAgICAgICogZ2V0SW5wdXRJbWFnZShiICxyICxjLCBrKSAqIGdldE91dHB1dEltYWdlKGIsIHIsIGMsIGQpXFxuICAgICAgICAgICAgICAgIC8gbm9ybTtcXG4gICAgICAgICAgICAgIGlmIChrID09IGQpIHtcXG4gICAgICAgICAgICAgICAgZHlpICs9IHBvdyhub3JtLCAtMS4wICogXCIrbytcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoayA9PSBjb29yZHNbM10pIHtcXG4gICAgICAgICAgICAgICAgZHlpICo9IGdldER5KGIsIHIsIGMsIGQpO1xcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZHlpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxxYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITA7dmFyIGEsaT1lLHM9dFszXS0xO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgdT1cImZsb2F0KFwiK24rXCIpICsgZmxvYXQoXCIrcitcIikgKiBzdW1cIjthPS41PT09bz9cImludmVyc2VzcXJ0KFwiK3UrXCIpXCI6MT09PW8/XCIxLjAvKFwiK3UrXCIpXCI6XCJleHAobG9nKFwiK3UrXCIpICogZmxvYXQoLVwiK28rXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHIgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBjID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gZCA8IFwiK3RoaXMub3V0cHV0U2hhcGVbM10rXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVsyXStcIjtcXG5cXG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLik7XFxuICAgICAgICB2ZWM0IHhGcmFnQXRPdXRwdXRDb29yZHMgPSBnZXRYKGIsIHIsIGMsIGQpO1xcblxcbiAgICAgICAgdmVjNCB4QXRPdXRwdXRDb29yZHMgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCkpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCArIDEpKSA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzICwgdmVjMihjICsgMSwgZCkpIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMgKyAxLCBkICsgMSkpIDogMC4wXFxuICAgICAgICApO1xcblxcbiAgICAgICAgaW50IGZpcnN0Q2hhbm5lbCA9IGQgLSBcIitpK1wiO1xcbiAgICAgICAgdmVjMiBjYWNoZSA9IHZlYzIoMC4pO1xcbiAgICAgICAgaWYoZmlyc3RDaGFubmVsID49IDApe1xcbiAgICAgICAgICB2ZWM0IGZpcnN0Q2hhbm5lbEZyYWcgPSBnZXRYKGIsIHIsIGMsIGZpcnN0Q2hhbm5lbCk7XFxuICAgICAgICAgIGNhY2hlLnggPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYywgZmlyc3RDaGFubmVsKSk7XFxuICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XFxuICAgICAgICAgICAgICBjYWNoZS55ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMgKyAxLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpdmVjMiBkZXB0aCA9IGl2ZWMyKGQsIGQgKyAxKTtcXG4gICAgICAgIGZvciAoaW50IGogPSAtIFwiK2krXCI7IGogPD0gXCIraStcIjsgaisrKSB7XFxuICAgICAgICAgIGl2ZWMyIGlkeCA9IGRlcHRoICsgajtcXG4gICAgICAgICAgYnZlYzIgYWJvdmVMb3dlckJvdW5kID0gZ3JlYXRlclRoYW5FcXVhbChpZHgsIGl2ZWMyKDApKTtcXG4gICAgICAgICAgYnZlYzIgYmVsb3dVcHBlckJvdW5kID0gbGVzc1RoYW5FcXVhbChpZHgsIGl2ZWMyKFwiK3MrXCIpKTtcXG5cXG4gICAgICAgICAgYm9vbCBkZXB0aEluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueCAmJiBiZWxvd1VwcGVyQm91bmQueDtcXG4gICAgICAgICAgYm9vbCBkZXB0aFBsdXNPbmVJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnkgJiYgYmVsb3dVcHBlckJvdW5kLnk7XFxuXFxuICAgICAgICAgIGlmKGRlcHRoSW5SYW5nZSB8fCBkZXB0aFBsdXNPbmVJblJhbmdlKXtcXG4gICAgICAgICAgICB2ZWM0IHogPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICB2ZWM0IHhGcmFnQXRDdXJyZW50RGVwdGg7XFxuICAgICAgICAgICAgei54eiA9IGNhY2hlLnh5O1xcbiAgICAgICAgICAgIGlmKGRlcHRoUGx1c09uZUluUmFuZ2UgJiYgaGFzTmV4dENvbCl7XFxuICAgICAgICAgICAgICB4RnJhZ0F0Q3VycmVudERlcHRoID0gaWR4LnkgIT0gZCA/XFxuICAgICAgICAgICAgICAgIGdldFgoYiwgciwgYywgaWR4LnkpIDogeEZyYWdBdE91dHB1dENvb3JkcztcXG4gICAgICAgICAgICAgIHoueSA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjLCBpZHgueSkpO1xcbiAgICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XFxuICAgICAgICAgICAgICAgIHoudyA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjICsgMSwgaWR4LnkpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2FjaGUueHkgPSB6Lnl3O1xcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB4QXRPdXRwdXRDb29yZHMgKiBcIithK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksSGE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJtYXhQb3NcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5kaWxhdGlvbkhlaWdodCxvPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGE9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxpPW8tMS10LnBhZEluZm8udG9wLHM9YS0xLXQucGFkSW5mby5sZWZ0LHU9byphLTE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitvK1wiO1xcbiAgICAgICAgICB3UiArPSBcIityK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2UrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2ErXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIituK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG4gICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIit1K1wiIC0gaW50KGdldE1heFBvcyhiLCBpZHlSLCBpZHlDLCBkKSk7XFxuXFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqIFwiK2ErXCIgKyB3QztcXG4gICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSwkYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09YSYmKGE9bnVsbCksdGhpcy52YXJpYWJsZU5hbWVzPVtcIm1hdHJpeEFcIixcIm1hdHJpeEJcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1lO3ZhciBpPW4/dFsxXTp0WzJdLHM9TWF0aC5jZWlsKGkvMiksdT1uP1wiaSAqIDIsIHJjLnlcIjpcInJjLnksIGkgKiAyXCIsbD1yP1wicmMueiwgaSAqIDJcIjpcImkgKiAyLCByYy56XCIsYz1uP1tcImEueHh5eVwiLFwiYS56end3XCJdOltcImEueHh6elwiLFwiYS55eXd3XCJdLGg9cj9bXCJiLnh6eHpcIixcImIueXd5d1wiXTpbXCJiLnh5eHlcIixcImIuend6d1wiXSxwPVwiXCIsZj1cIlwiO2EmJihwPVwidmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgXCIrYStcIlxcbiAgICAgIH1cIixmPVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgZD1vP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7byYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitwK1wiXFxuXFxuICAgICAgY29uc3QgZmxvYXQgc2hhcmVkRGltZW5zaW9uID0gXCIrcytcIi4wO1xcblxcbiAgICAgIHZlYzQgZG90MngyQVJvd0JDb2woaXZlYzMgcmMpIHtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcytcIjsgaSsrKSB7XFxuICAgICAgICAgIHZlYzQgYSA9IGdldE1hdHJpeEEocmMueCwgXCIrdStcIik7XFxuICAgICAgICAgIHZlYzQgYiA9IGdldE1hdHJpeEIocmMueCwgXCIrbCtcIik7XFxuXFxuICAgICAgICAgIHJlc3VsdCArPSAoXCIrY1swXStcIiAqIFwiK2hbMF0rXCIpICsgKFwiK2NbMV0rXCIgKiBcIitoWzFdK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdDJ4MkFSb3dCQ29sKHJjKTtcXG5cXG4gICAgICAgIFwiK2QrXCJcXG5cXG4gICAgICAgIFwiK2YrXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGphPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInByb2JzXCJdLHRoaXMub3V0cHV0U2hhcGU9W3Qsbl0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgc2VlZDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG5cXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XFxuICAgICAgICBmbG9hdCBjZGYgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiKyhlLTEpK1wiOyBpKyspIHtcXG4gICAgICAgICAgY2RmICs9IGdldFByb2JzKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrKGUtMSkrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnNlZWRMb2MmJihlLnNlZWRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb24ocixcInNlZWRcIikpLG4uZ2wudW5pZm9ybTFmKGUuc2VlZExvYyx0KX19LHR9KCksS2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCxlXSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiK3IrXCIpLCBmbG9hdChcIituK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksWGE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5pc1BhY2tTaGFkZXI9ITAsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciBlPXQubGVuZ3RoO2lmKDA9PT1lKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZlYzQoZ2V0QSgpLCAwLiwgMC4sIDAuKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgbj1vbyhcInJjXCIsZSkscj1ibyhlKSxvPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09dClyZXR1cm5cInJjID4gXCIrZVswXTtmb3IodmFyIHI9XCJcIixvPXQtMjtvPHQ7bysrKXIrPW5bb10rXCIgPj0gXCIrZVtvXSxvPHQtMSYmKHIrPVwifHxcIik7cmV0dXJuIHJ9KGUsdCxuKSxhPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKDE9PT10KXJldHVyblwiXCI7dmFyIG89ci5zbGljZSgtMik7cmV0dXJuXCJcXG4gICAgaW50IHIgPSBcIitvWzBdK1wiO1xcbiAgICBpbnQgYyA9IFwiK29bMV0rXCI7XFxuICAgIGludCBycDEgPSByICsgMTtcXG4gICAgaW50IGNwMSA9IGMgKyAxO1xcblxcbiAgICBib29sIGNFZGdlID0gY3AxID49IFwiK2UrXCI7XFxuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gXCIrbitcIjtcXG4gIFwifShlLHRbdC5sZW5ndGgtMV0sdFt0Lmxlbmd0aC0yXSxuKSxpPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZW5ndGgscj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjw9MTtyKyspZm9yKHZhciBvPTA7bzw9MTtvKyspe2Zvcih2YXIgYT0oMD09PXI/XCJyXCI6XCJycDFcIikrXCIsIFwiKygwPT09bz9cImNcIjpcImNwMVwiKSxpPTI7aTx0O2krKylhPWVbZS5sZW5ndGgtMS1pXStcIixcIithO24ucHVzaChhKX1yZXR1cm4gbn0obixlKTtyZXR1cm4gMT09PW4/XCJnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gXCIrdFswXStcIiA/IDAuIDogZ2V0QShyYyArIDEpLFxcbiAgICAgICAgICAgIDAsIDBcIjpcImdldEEoXCIrclswXStcIiksXFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKFwiK3JbMV0rXCIpLFxcbiAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QShcIityWzJdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoXCIrclszXStcIilcIn0odCxuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK3IrXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoXCIrbytcIikge1xcbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KDApKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBcIithK1wiXFxuXFxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoXCIraStcIikpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCJ9fX0oKTt2YXIgWWE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dK2VbMV19KTt2YXIgcj10Lmxlbmd0aCxvPWJvKHIpLGE9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KS5qb2luKFwiLFwiKSxpPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXX0pLmpvaW4oXCIsXCIpLHM9W1wiY29vcmRzWzBdXCIsXCJjb29yZHNbMV1cIixcImNvb3Jkc1syXVwiLFwiY29vcmRzWzNdXCJdLnNsaWNlKDAscik7dGhpcy51c2VyQ29kZT0xIT09cj9cIlxcbiAgICAgIFwiK28rXCIgc3RhcnQgPSBcIitvK1wiKFwiK2ErXCIpO1xcbiAgICAgIFwiK28rXCIgZW5kID0gXCIrbytcIihcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChhbnkobGVzc1RoYW4ob3V0Qywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChvdXRDLCBlbmQpKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK3MrXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiOlwiXFxuICAgICAgICBpbnQgc3RhcnQgPSBcIithK1wiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK2krXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNldE91dHB1dChnZXRYKG91dEMgLSBzdGFydCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpLFFhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXStlWzFdfSk7Zm9yKHZhciByPXQubGVuZ3RoLG89Ym8ociksYT1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLmpvaW4oXCIsXCIpLGk9ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dfSkuam9pbihcIixcIikscz1vbyhcInJjXCIsciksdT1vbyhcInNvdXJjZVwiLHIpLGw9c1tyLTFdK1wiIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtyLTFdLGM9MT09PXI/XCJzb3VyY2VcIjpcInZlYzIoXCIrdS5zbGljZSgtMikuam9pbigpK1wiKVwiLGg9W28rXCIgcmMgPSBvdXRwdXRMb2M7XCIsc1tyLTFdK1wiICs9IDE7XFxuICAgICAgIGlmKFwiK2wrXCIpIHtcXG4gICAgICBcIiwxPT09cj9cIlwiOlwifVxcbiAgICAgICByYyA9IG91dHB1dExvYztcXG4gICAgICAgXCIrc1tyLTJdK1wiICs9IDE7XFxuICAgICAgIGlmKFwiK3Nbci0yXStcIiA8IFwiK3RoaXMub3V0cHV0U2hhcGVbci0yXStcIikge1wiLDE9PT1yP1wiXCI6XCIgIFwiK3Nbci0xXStcIiArPSAxO1xcbiAgICAgICAgIGlmKFwiK2wrXCIpIHtcIl0scD0xPT09cj9cInJjIDwgc3RhcnQgfHwgcmMgPj0gZW5kXCI6XCJhbnkobGVzc1RoYW4ocmMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwocmMsIGVuZCkpXCIsZj1cIlwiLGQ9MCx2PTE9PT1yPzI6NDtkPHY7ZCsrKWYrPVwiXFxuICAgICAgICBcIitoW2RdK1wiXFxuICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICByZXN1bHRbXCIrZCtcIl0gPSBmbG9hdChcIituK1wiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK28rXCIgc291cmNlID0gcmMgLSBzdGFydDtcXG4gICAgICAgICAgcmVzdWx0W1wiK2QrXCJdID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3Uuam9pbigpK1wiKSwgXCIrYytcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7Zis9MT09PXI/XCJ9IFwiOlwifX1cIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgXCIrbytcIiBzdGFydCA9IFwiK28rXCIoXCIrYStcIik7XFxuICAgICAgY29uc3QgXCIrbytcIiBlbmQgPSBcIitvK1wiKFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgb3V0cHV0TG9jID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgXCIrZitcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksSmE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLFwiYXZnXCI9PT1lJiZuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLlwiKTt2YXIgcj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVIZWlnaHQsYT10LnN0cmlkZVdpZHRoLGk9dC5kaWxhdGlvbkhlaWdodCxzPXQuZGlsYXRpb25XaWR0aCx1PXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGw9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPXQucGFkSW5mby50b3AsaD10LnBhZEluZm8ubGVmdDt0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIHA9XCJhdmdcIj09PWUsZj1cIjAuMFwiO2lmKHB8fChmPVwiLTEuMCAvIDFlLTIwXCIpLG4pdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2MrXCIsIFwiK2grXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIitpK1wiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbCtcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIrcytcIikge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3UiAqIFwiK2wrXCIgKyB3QztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7ZWxzZXt2YXIgZD1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wiYXZnXCI9PT1lJiYoZD1cImF2Z1ZhbHVlIC8gY291bnRcIik7dmFyIHY9NCpNYXRoLmZsb29yKHIvNCksbT1yJTQsZz1cIlxcbiAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBtYXgodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK28rXCIsIFwiK2ErXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitjK1wiLCBcIitoK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIrZitcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgeFIsIGludCB4QywgaW50IGQpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY291bnQgKz0gMS4wO1xcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitmK1wiKTtcXG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcbiAgICAgICAgY291bnQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICB3UiArPSBcIitpK1wiKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit2K1wiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDMgKiBcIitzK1wiLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIrditcIjtcXG4gICAgICAgICAgaWYgKFwiKygxPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK2QrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9fX0oKSxaYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBuPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG89dC5pblNpemUsYT1NYXRoLmNlaWwoby9uKTt0aGlzLm91dHB1dFNoYXBlPVtyLGFdO3ZhciBpPVwiMC4wXCIscz1cIlwiO1wicHJvZFwiPT09ZT9pPVwiMS4wXCI6XCJtaW5cIj09PWU/KGk9XCIxLjAgLyAxZS0yMFwiLHM9XCJtaW5cIik6XCJtYXhcIj09PWUmJihpPVwiLTEuMCAvIDFlLTIwXCIscz1cIm1heFwiKTt2YXIgdT1lK1wiKFwiK2UrXCIoXCIrZStcIihtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKVwiO1wic3VtXCI9PT1lP3U9XCJzdW1WYWx1ZVwiOlwicHJvZFwiPT09ZT91PVwicHJvZFZhbHVlXCI6XCJhbGxcIj09PWU/dT1cImFsbFZhbHVlXCI6XCJhbnlcIj09PWUmJih1PVwiYW55VmFsdWVcIik7dmFyIGw9NCpNYXRoLmZsb29yKG4vNCksYz1uJTQsaD1cIlxcbiAgICAgIGlmIChcIisoXCJzdW1cIj09PWUpK1wiKSB7XFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiKyhcInByb2RcIj09PWUpK1wiKSB7XFxuICAgICAgICB2ZWMyIHRtcCA9IHZlYzIodmFsdWVzWzBdLCB2YWx1ZXNbMV0pICogdmVjMih2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XFxuICAgICAgICBwcm9kVmFsdWUgKj0gdG1wWzBdICogdG1wWzFdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiK3MrXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIixwPVwidmVjNFwiO1wiYWxsXCI9PT1lPyhpPVwiMS4wXCIsaD1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQWxsVmFsdWUgPSBhbGwodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPSBmbG9hdChyZWR1Y2VkQWxsVmFsdWUpO1xcbiAgICAgICAgYWxsVmFsdWUgPSBmbG9hdChhbGxWYWx1ZSA+PSAxLjAgJiYgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLHA9XCJidmVjNFwiKTpcImFueVwiPT09ZSYmKGk9XCIwLjBcIixoPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbnlWYWx1ZSA9IGFueSh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbnlWYWx1ZSk7XFxuICAgICAgICBhbnlWYWx1ZSA9IGZsb2F0KGFueVZhbHVlID49IDEuMCB8fCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID49IDEuMCk7XFxuICAgICAgXCIscD1cImJ2ZWM0XCIpO3ZhciBmPVwiXCI7byVuPjAmJihmPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIraStcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2YrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiK24rXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIitpK1wiKTtcXG4gICAgICAgIGZsb2F0IHByb2RWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcbiAgICAgICAgZmxvYXQgYWxsVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBhbnlWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbCtcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgXCIrcCtcIiB2YWx1ZXMgPSBcIitwK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIitsK1wiO1xcbiAgICAgICAgaWYgKFwiKygxPT09YykrXCIpIHtcXG4gICAgICAgICAgXCIrcCtcIiB2YWx1ZXMgPSBcIitwK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWMpK1wiKSB7XFxuICAgICAgICAgIFwiK3ArXCIgdmFsdWVzID0gXCIrcCtcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09YykrXCIpIHtcXG4gICAgICAgICAgXCIrcCtcIiB2YWx1ZXMgPSBcIitwK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIrdStcIik7XFxuICAgICAgfVxcbiAgICBcIn19KCksdGk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7Zm9yKHZhciBuPVwiXCIscj0wO3I8NDtyKyspe3ZhciBvPVwidGhpc1JDID0gcmM7XCI7ciUyPT0xJiYobys9XCJ0aGlzUkMueiArPSAxO1wiKSxyPjEmJihvKz1cInRoaXNSQy55ICs9IDE7XCIpLG4rPVwiXFxuICAgICAgICBcIitvK1wiXFxuICAgICAgICBcIisocj4wP1wiaWYodGhpc1JDLnkgPCByb3dzICYmIHRoaXNSQy56IDwgY29scyl7XCI6XCJcIikrXCJcXG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleCh0aGlzUkMpO1xcblxcbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbnB1dFJDSW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbXCIrcitcIl0gPVxcbiAgICAgICAgICAgIGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5wdXRSQ0lubmVyRGltcyk7XFxuICAgICAgICBcIisocj4wP1wifVwiOlwiXCIpK1wiXFxuICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICBcIitsbyhbXCJyXCIsXCJjXCIsXCJkXCJdLGUpK1wiXFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcXG4gICAgICBcIitmdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0RmxhdEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICAgIHJldHVybiByb3VuZChcIitmdW5jdGlvbih0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVmVjdG9ycyB0byBiZSBkb3R0ZWQgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGggLWdvdCBcIit0Lmxlbmd0aCtcIiBhbmQgXCIrZS5sZW5ndGgpO2Zvcih2YXIgbj1bXSxyPU1hdGguZmxvb3IodC5sZW5ndGgvNCksbz10Lmxlbmd0aCU0LGE9MDthPHI7YSsrKXt2YXIgaT10LnNsaWNlKDQqYSw0KmErNCkscz1lLnNsaWNlKDQqYSw0KmErNCk7bi5wdXNoKGNvKGkpK1wiLCBcIitjbyhzKSl9cmV0dXJuIDAhPT1vJiYoaT10LnNsaWNlKDQqcikscz1lLnNsaWNlKDQqciksMT09PWkubGVuZ3RoJiYoaT1pLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImZsb2F0KFwiK3QrXCIpXCJ9KSxzPXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiZmxvYXQoXCIrdCtcIilcIn0pKSxuLnB1c2goY28oaSkrXCIsIFwiK2NvKHMpKSksbi5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cImRvdChcIit0K1wiKVwifSkuam9pbihcIitcIil9KFtcImNvb3Jkcy54XCIsXCJjb29yZHMueVwiLFwiY29vcmRzLnpcIl0sVih0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9TdHJpbmcoKX0pLmNvbmNhdChbXCIxLlwiXSkpK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBpdmVjMyB0aGlzUkM7XFxuICAgICAgICBpbnQgcm93cyA9IFwiK3RbMV0rXCI7XFxuICAgICAgICBpbnQgY29scyA9IFwiK3RbMl0rXCI7XFxuXFxuICAgICAgICBcIituK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKTt2YXIgZWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZS5zaGFwZTt2YXIgcj1lLnNoYXBlLG89clsxXSxhPXJbMl0saT10LnNoYXBlLHM9aVsxXSx1PWlbMl0sbD1bbiYmcz4xP28tMTpvLG4mJnU+MT9hLTE6YV0sYz1bbiYmcz4xP3MtMTpzLG4mJnU+MT91LTE6dV0saD1sWzBdL2NbMF0scD1sWzFdL2NbMV0sZj0xL2gsZD0xL3Asdj0yKk1hdGguY2VpbChmKSsyLG09MipNYXRoLmNlaWwoZCkrMjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIitwK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoXCIrZitcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuXFxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KFwiK3YrXCIpO1xcbiAgICAgICAgY29uc3QgaW50IHdpbldpZHRoID0gaW50KFwiK20rXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBkeFIgPSBmbG9hdChkeVIpICogaGVpZ2h0U2NhbGU7XFxuICAgICAgICAgICAgaW50IHRvcER4UkluZGV4ID0gaW50KGZsb29yKGR4UikpO1xcbiAgICAgICAgICAgIGludCBib3R0b21EeFJJbmRleCA9IGludChtaW4oY2VpbChkeFIpLCBcIisoby0xKStcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhSTGVycCA9IGR4UiAtIGZsb2F0KHRvcER4UkluZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhSTGVycCA9IDEuMCAtIGR4UkxlcnA7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhDID0gZmxvYXQoZHlDKSAqIHdpZHRoU2NhbGU7XFxuICAgICAgICAgICAgaW50IGxlZnREeENJbmRleCA9IGludChmbG9vcihkeEMpKTtcXG4gICAgICAgICAgICBpbnQgcmlnaHREeENJbmRleCA9IGludChtaW4oY2VpbChkeEMpLCBcIisoYS0xKStcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhDTGVycCA9IGR4QyAtIGZsb2F0KGxlZnREeENJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BMZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPVxcbiAgICAgICAgICAgICAgICBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcFJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21MZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxuaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGw9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIit1WzBdL2xbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vbFsxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK2ErXCIuMCwgXCIraStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxyaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGw9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMzIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMzKFxcbiAgICAgICAgICBcIit1WzBdL2xbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vbFsxXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9sWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMzIGlucHV0U2hhcGVSQyA9IHZlYzMoXCIrYStcIi4wLCBcIitpK1wiLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK2krXCIuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCBiLCBpbnQgciwgaW50IGMsIGludCBkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKGIsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlcyBmb3IgbmV4dCBjb2x1bW4gaW4geVJDLnouXFxuICAgICAgICBpdmVjMyB5UkMgPSBjb29yZHMueXp6ICsgaXZlYzMoMCwgMCwgMSk7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzMgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMzKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMyBzb3VyY2VGbG9vclJDID0gaXZlYzMoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzMgc291cmNlQ2VpbFJDID0gaXZlYzMoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuICAgICAgICBcXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrKHMtMSkrXCI7IFxcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gY29vcmRzLnogPCBcIisobi0xKStcIjtcXG5cXG4gICAgICAgIC8vIEluIHBhcmFsbGVsLCBjb25zdHJ1Y3QgZm91ciBjb3JuZXJzIGZvciBhbGwgZm91ciBjb21wb25lbnRzIGluXFxuICAgICAgICAvLyBwYWNrZWQgMngyIGNlbGwuXFxuICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWMzIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMyhzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBmcmFjUkMueXl6eik7XFxuICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgZnJhY1JDLnl5enopO1xcbiAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgZnJhY1JDLngpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxvaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbz1yWzFdLGE9clsyXSxpPXQuc2hhcGUscz1pWzFdLHU9aVsyXSxsPVtuJiZzPjE/by0xOm8sbiYmdT4xP2EtMTphXSxjPVtuJiZzPjE/cy0xOnMsbiYmdT4xP3UtMTp1XSxoPWxbMF0vY1swXSxwPWxbMV0vY1sxXSxmPTEvaCxkPTEvcCx2PTIqTWF0aC5jZWlsKGYpKzIsbT0yKk1hdGguY2VpbChkKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitmK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrditcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoZmxvb3Ioc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChmbG9vcihzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSkpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY1JvdyA9XFxuICAgICAgICAgICAgICBmbG9hdChcIitsWzBdK1wiKSAqXFxuICAgICAgICAgICAgICAgIChmbG9hdChkeVIpIC8gZmxvYXQoXCIrY1swXStcIikpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNDb2wgPVxcbiAgICAgICAgICAgICAgICBmbG9hdChcIitsWzFdK1wiKSAqXFxuICAgICAgICAgICAgICAgICAgKGZsb2F0KGR5QykgLyBmbG9hdChcIitjWzFdK1wiKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RSb3cgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrbytcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrbitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNSb3cpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNSb3cpKSkpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Q29sID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiK2ErXCIpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK24rXCIgPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjQ29sKSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjQ29sKSkpKTtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSBzb3VyY2VOZWFyZXN0Um93ICYmIGMgPT0gc291cmNlTmVhcmVzdENvbCkge1xcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxhaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBvPXRbMF0sYT10WzFdLGk9dFsyXSxzPXRbM107dGhpcy5vdXRwdXRTaGFwZT1bbyxlLG4sc107dmFyIHU9W3ImJmU+MT9hLTE6YSxyJiZuPjE/aS0xOmldLGw9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGM9cj9cIjAuNVwiOlwiMC4wXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vbFswXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9sWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBmbG9vcihzb3VyY2VGcmFjSW5kZXhSQyArIFwiK2MrXCIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEEoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksaWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiK24rXCIgdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKHRoaXMub3V0cHV0U2hhcGU9dCwxIT09bil7dmFyIHI9dC5tYXAoZnVuY3Rpb24obixyKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuLTEhPT1lLmluZGV4T2YobikmJjEhPT10W25dP3Rbbl0rXCIgLSBjb29yZHNbXCIrbitcIl0gLSAxXCI6XCJjb29yZHNbXCIrbitcIl1cIn0ocil9KS5qb2luKFwiLFwiKSxvPWJvKG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrcitcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9ZWxzZSB0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBjb29yZCA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIit0WzBdK1wiIC0gY29vcmQgLSAxKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpLHNpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITA7dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIituK1wiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9b28oXCJyY1wiLG4pLG89cltuLTFdK1wiICsgMSA8IFwiK3RoaXMub3V0cHV0U2hhcGVbbi0xXSxhPXJbbi0yXStcIiArIDEgPCBcIit0aGlzLm91dHB1dFNoYXBlW24tMl0saT1ibyhuKTtmdW5jdGlvbiBzKG4pe3ZhciByPXQubWFwKGZ1bmN0aW9uKHIsbyl7cmV0dXJuIGZ1bmN0aW9uKG4scil7cmV0dXJuLTEhPT1lLmluZGV4T2YobikmJjEhPT10W25dP3Rbbl0rXCIgLSBcIityW25dK1wiIC0gMVwiOlwiXCIrcltuXX0obyxuKX0pO3JldHVyblwiZ2V0Q2hhbm5lbChnZXRYKFwiK3Iuam9pbihcIixcIikrXCIpLCB2ZWMyKFwiK3Iuc2xpY2UoLTIpLmpvaW4oXCIsXCIpK1wiKSlcIn10aGlzLnVzZXJDb2RlPTE9PT1uP1wiXFxuICAgICAgICB2b2lkIG1haW4oKXtcXG4gICAgICAgICAgaW50IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSByYyAtIDEpLFxcbiAgICAgICAgICAgIFwiK3RbMF0rXCIgLSByYyAtIDEpO1xcbiAgICAgICAgICBpZihcIitvK1wiKXtcXG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSAocmMgICsgMSkgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrdFswXStcIiAtIChyYyAgKyAxKSAtIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiOlwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK2krXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgcmVzdWx0LnIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gcyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgaWYoXCIrbytcIil7XFxuICAgICAgICAgICAgcmVzdWx0LmcgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTFdPVwiKFwiK3Rbbi0xXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZihcIithK1wiKSB7XFxuICAgICAgICAgICAgcmVzdWx0LmIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTJdPVwiKFwiK3Rbbi0yXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgICByZXN1bHQuYSA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMV09XCIoXCIrdFtuLTFdK1wiICsgMSlcIix0W24tMl09XCIoXCIrdFtuLTJdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgXCJ9fSgpLHVpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPSEwKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1widXBkYXRlc1wiLFwiaW5kaWNlc1wiLFwiZGVmYXVsdFZhbHVlXCJdLHRoaXMub3V0cHV0U2hhcGU9YTt2YXIgcz1ibyhvLmxlbmd0aCksdT1ibyhhLmxlbmd0aCksbD1cIlwiOzE9PT1uP2w9XCJpXCI6Mj09PW4mJihsPVwiaSwgalwiKTt2YXIgYz1cImdldEluZGljZXMoXCIrbCtcIilcIixoPVwiXCI7MT09PXI/aD1cImlcIjoyPT09ciYmKGg9XCJpLCBjb29yZHNbMV1cIik7dmFyIHA9XCJnZXRVcGRhdGVzKFwiK2grXCIpXCIsZj1lPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcytcIiBzdHJpZGVzID0gXCIrcytcIihcIitvK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrdStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBib29sIGZvdW5kID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrdCtcIjsgaSsrKSB7XFxuICAgICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gMDtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2UrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoXCIrYytcIik7XFxuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqIFwiK2YrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChmbGF0dGVuZWRJbmRleCA9PSBjb29yZHNbMF0pIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBcIitwK1wiO1xcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQobWl4KGdldERlZmF1bHRWYWx1ZSgpLCBzdW0sIGZsb2F0KGZvdW5kKSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKSxsaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO3ZhciBuPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG89dC5pblNpemUsYT10Lm51bVNlZ21lbnRzLGk9YSpNYXRoLmNlaWwoby9uKTt0aGlzLm91dHB1dFNoYXBlPVtyLGldO3ZhciBzPTQqTWF0aC5mbG9vcihuLzQpLHU9biU0LGw9XCJcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIHNlZ0ZpbHRlcik7XFxuICAgIFwiLGM9XCJcIjtvJW4+MCYmKGM9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIik7dmFyIGg9XCJcIjtvJW4+MCYmKGg9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gLTEuMDtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2MrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XFxuICAgICAgICBcIitoK1wiXFxuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudElkcyhpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXFxuICAgICAgICAgIFwiK2ErXCIpKSAqIGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgIGludCBjdXJyZW50U2VnID0gaW50KG1vZChmbG9hdChvdXRJZHgpLCBmbG9hdChcIithK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK3MrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoc3VtVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGNpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvO2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJjXCIsXCJhXCIsXCJiXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSxuPjQpdGhyb3cgRXJyb3IoXCJXaGVyZSBmb3IgcmFuayBcIituK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1uKW89XCJyZXNSQ1wiLHI9XCJyZXNSQ1wiO2Vsc2V7Zm9yKHZhciBhPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0saT1bXSxzPVtdLHU9MDt1PGUubGVuZ3RoO3UrKylzLnB1c2goXCJcIithW3VdKSx1PHQmJmkucHVzaChcIlwiK2FbdV0pO3I9aS5qb2luKCksbz1zLmpvaW4oKX12YXIgbD1ibyhuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbCtcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgY1ZhbCA9IGdldEMoXCIrcitcIik7XFxuICAgICAgICBpZiAoY1ZhbCA+PSAxLjApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrbytcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEIoXCIrbytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGhpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGUsbj1ibyh0aGlzLnJhbmspLHI9XCJ1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1wiLG89ZnVuY3Rpb24odCl7aWYoMT09PXQpcmV0dXJuXCJzb3VyY2VMb2NcIjtpZih0PD02KXJldHVybiBwaS5zbGljZSgwLHQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cInNvdXJjZUxvYy5cIit0fSkuam9pbihcIixcIik7dGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9KHRoaXMucmFuayk7ZT1cIlxcbiAgICAgICAgXCIrbitcIiBzb3VyY2VMb2M7XFxuICAgICAgICBcIituK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIrdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cInNvdXJjZUxvYy5cIitwaVtlXStcIiA9IHN0YXJ0W1wiK2UrXCJdICsgY29vcmRzLlwiK3BpW2VdK1wiO1wifSkuam9pbihcIlxcblwiKStcIlxcbiAgICAgIFwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIityK1wiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIitvK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodC5sZW5ndGghPT10aGlzLnJhbmspdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIrdGhpcy5yYW5rK1wiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2Ygc3RhcnQgKFwiK3QubGVuZ3RoK1wiKVwiKTtyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnN0YXJ0TG9jJiYoZS5zdGFydExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInN0YXJ0XCIpLG51bGw9PWUuc3RhcnRMb2MpfHxuLmdsLnVuaWZvcm0xaXYoZS5zdGFydExvYyx0KX19LHR9KCkscGk9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTt2YXIgZmk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMucmFuaz10Lmxlbmd0aDt2YXIgZT1ibyh0aGlzLnJhbmspLG49b28oXCJjb29yZHNcIix0aGlzLnJhbmspLHI9b28oXCJzb3VyY2VMb2NcIix0aGlzLnJhbmspLG89MT09PXRoaXMucmFuaz9cInNvdXJjZUxvY1wiOlwidmVjMihcIityLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsYT1cImdldENoYW5uZWwoZ2V0U291cmNlKFwiK3Iuam9pbigpK1wiKSwgXCIrbytcIilcIixpPVwiXFxuICAgICAgcmVzdWx0LnggPSBcIithK1wiO1xcbiAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTFdK1wiIDwgXCIrdFt0aGlzLnJhbmstMV0rXCIpIHtcXG4gICAgICAgICsrXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgICByZXN1bHQueSA9IFwiK2ErXCI7XFxuICAgICAgICAtLVwiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIH1cXG4gICAgXCIscz0xPT09dGhpcy5yYW5rP1wiXCI6XCJcXG4gICAgICAtLVwiK25bdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTJdK1wiIDwgXCIrdFt0aGlzLnJhbmstMl0rXCIpIHtcXG4gICAgICAgICsrXCIrclt0aGlzLnJhbmstMl0rXCI7XFxuICAgICAgICByZXN1bHQueiA9IFwiK2ErXCI7XFxuICAgICAgICBpZiAoKytcIituW3RoaXMucmFuay0xXStcIiA8IFwiK3RbdGhpcy5yYW5rLTFdK1wiKSB7XFxuICAgICAgICAgICsrXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgICAgIHJlc3VsdC53ID0gXCIrYStcIjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiLHU9dGhpcy5yYW5rPD00P1wic291cmNlTG9jID0gY29vcmRzICtcXG4gICAgICAgICAgICBcIitlK1wiKFwiK3QubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzdGFydFtcIitlK1wiXVwifSkuam9pbigpK1wiKTtcIjp0Lm1hcChmdW5jdGlvbih0LGUpe3JldHVybiByW2VdK1wiID0gXCIrbltlXStcIiArIHN0YXJ0W1wiK2UrXCJdO1wifSkuam9pbihcIlxcblwiKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBpbnQgc3RhcnRbXCIrdGhpcy5yYW5rK1wiXTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitlK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIrZStcIiBzb3VyY2VMb2M7XFxuICAgICAgICBcIit1K1wiIFxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIFwiK3MrXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIit0Lmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8bi5nbC51bmlmb3JtMWl2KGUuc3RhcnRMb2MsdCl9fSx0fSgpLGRpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBvPW4uZmlsdGVyKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1yLmluZGV4T2YoZSl9KTt0aGlzLm91dHB1dFNoYXBlPW87dmFyIGE9bi5sZW5ndGgsaT1ibyhuLmxlbmd0aCkscz1ibyhvLmxlbmd0aCksdT1cIlwiO2lmKDE9PT1hKXU9XCJjb29yZHMgKiBzdHJpZGVzICsgYmVnaW5cIjtlbHNle3ZhciBsPTA7dT1uLm1hcChmdW5jdGlvbih0LGUpe3JldHVybi0xPT09ci5pbmRleE9mKGUpPyhsKyssMT09PW8ubGVuZ3RoP1wiY29vcmRzICogc3RyaWRlc1tcIitlK1wiXSArIGJlZ2luW1wiK2UrXCJdXCI6XCJjb29yZHNbXCIrKGwtMSkrXCJdICogc3RyaWRlc1tcIitlK1wiXSArIGJlZ2luW1wiK2UrXCJdXCIpOlwiYmVnaW5bXCIrZStcIl1cIn0pLmpvaW4oXCIsXCIpfXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitpK1wiIGJlZ2luID0gXCIraStcIihcIit0K1wiKTtcXG4gICAgICBcIitpK1wiIHN0cmlkZXMgPSBcIitpK1wiKFwiK2UrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK3MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIit1K1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksdmk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZ3BncHU9dCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTAsdGhpcy5mcmVlVGV4dHVyZXM9e30sdGhpcy5sb2dFbmFibGVkPSExLHRoaXMudXNlZFRleHR1cmVzPXt9fXJldHVybiB0LnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz1taShlLG4pLGE9Z2kodCxvLG4pO2lmKGEgaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1thXT1bXSksYSBpbiB0aGlzLnVzZWRUZXh0dXJlc3x8KHRoaXMudXNlZFRleHR1cmVzW2FdPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1thXS5sZW5ndGg+MCl7dGhpcy5udW1GcmVlVGV4dHVyZXMtLSx0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCk7dmFyIGk9dGhpcy5mcmVlVGV4dHVyZXNbYV0uc2hpZnQoKTtyZXR1cm4gdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChpKSxpfXJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMubG9nKCksbz09PWxhLlBBQ0tFRF8yWDJfRkxPQVQzMj9yPXRoaXMuZ3BncHUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1sYS5QQUNLRURfMlgyX0ZMT0FUMTY/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PWxhLlVOUEFDS0VEX0ZMT0FUMzI/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PWxhLlVOUEFDS0VEX0ZMT0FUMTY/cj10aGlzLmdwZ3B1LmNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PWxhLlBBQ0tFRF80WDFfVU5TSUdORURfQllURSYmKHI9dGhpcy5ncGdwdS5jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pKSx0aGlzLnVzZWRUZXh0dXJlc1thXS5wdXNoKHIpLHJ9LHQucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXt2YXIgbz1naShlLG1pKG4scikscik7byBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW29dPVtdKSx0aGlzLmZyZWVUZXh0dXJlc1tvXS5wdXNoKHQpLHRoaXMubnVtRnJlZVRleHR1cmVzKyssdGhpcy5udW1Vc2VkVGV4dHVyZXMtLTt2YXIgYT10aGlzLnVzZWRUZXh0dXJlc1tvXSxpPWEuaW5kZXhPZih0KTtpZihpPDApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbGVhc2UgYSB0ZXh0dXJlIHRoYXQgd2FzIG5ldmVyIHByb3ZpZGVkIGJ5IHRoaXMgdGV4dHVyZSBtYW5hZ2VyXCIpO2Euc3BsaWNlKGksMSksdGhpcy5sb2coKX19LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe2lmKHRoaXMubG9nRW5hYmxlZCl7dmFyIHQ9dGhpcy5udW1GcmVlVGV4dHVyZXMrdGhpcy5udW1Vc2VkVGV4dHVyZXM7Y29uc29sZS5sb2coXCJGcmVlL1VzZWRcIix0aGlzLm51bUZyZWVUZXh0dXJlcytcIiAvIFwiK3RoaXMubnVtVXNlZFRleHR1cmVzLFwiKFwiK3QrXCIpXCIpfX0sdC5wcm90b3R5cGUuZ2V0TnVtVXNlZFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzfSx0LnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXN9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKG51bGwhPXRoaXMuZnJlZVRleHR1cmVzKXtmb3IodmFyIGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpdGhpcy5mcmVlVGV4dHVyZXNbZV0uZm9yRWFjaChmdW5jdGlvbihlKXt0LmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KTtmb3IodmFyIGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpdGhpcy51c2VkVGV4dHVyZXNbZV0uZm9yRWFjaChmdW5jdGlvbihlKXt0LmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZSl9KTt0aGlzLmZyZWVUZXh0dXJlcz1udWxsLHRoaXMudXNlZFRleHR1cmVzPW51bGwsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wfX0sdH0oKTtmdW5jdGlvbiBtaSh0LGUpe2lmKHQ9PT11YS5VUExPQUQpcmV0dXJuIGU/bGEuUEFDS0VEXzJYMl9GTE9BVDMyOmxhLlVOUEFDS0VEX0ZMT0FUMzI7aWYodD09PXVhLlJFTkRFUnx8bnVsbD09dClyZXR1cm4gZT9hLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpP2xhLlBBQ0tFRF8yWDJfRkxPQVQzMjpsYS5QQUNLRURfMlgyX0ZMT0FUMTY6YS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT9sYS5VTlBBQ0tFRF9GTE9BVDMyOmxhLlVOUEFDS0VEX0ZMT0FUMTY7aWYodD09PXVhLkRPV05MT0FEfHx0PT09dWEuUElYRUxTKXJldHVybiBsYS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBsb2dpY2FsIHRleHR1cmUgdHlwZSBcIit0KX1mdW5jdGlvbiBnaSh0LGUsbil7cmV0dXJuIHRbMF0rXCJfXCIrdFsxXStcIl9cIitlK1wiX1wiK259dmFyIHlpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtyXSplW3JdO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7dmFyIG89Ym8odGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU+NSl0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09ZSlyZXR1cm5cImltb2QocmVzUkMsIFwiK3RbMF0rXCIpXCI7Zm9yKHZhciBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIl0scj1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspci5wdXNoKFwiaW1vZChcIituW29dK1wiLCBcIit0W29dK1wiKVwiKTtyZXR1cm4gci5qb2luKCl9KHQpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7dmFyIHhpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO3ZhciBvPWJvKHRoaXMucmFuayksYT1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPjYpdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiLFwicmVzUkMudlwiXSxyPW5ldyBBcnJheShlKSxvPTA7bzx0Lmxlbmd0aDtvKyspclt0W29dXT1uW29dO3JldHVybiByLmpvaW4oKX0oZSk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgfVxcbiAgICBcIn19KCk7dmFyIHdpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITA7Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTtpZih0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoLHRoaXMucmFuaz42KXRocm93IEVycm9yKFwiUGFja2VkIHRyYW5zcG9zZSBmb3IgcmFuayBcIit0aGlzLnJhbmsrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO3ZhciBvPWJvKHRoaXMucmFuayksYT1ybyhcInJjXCIsdGhpcy5yYW5rKSxpPW5ldyBBcnJheSh0aGlzLnJhbmspO2ZvcihyPTA7cjxlLmxlbmd0aDtyKyspaVtlW3JdXT1hW3JdO3ZhciBzPVwidmVjMihcIitpLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsdT1cIisrXCIrYVt0aGlzLnJhbmstMV0rXCIgPCBcIituW3RoaXMucmFuay0xXSxsPVwiZ2V0Q2hhbm5lbChnZXRBKFwiK2kuam9pbigpK1wiKSwgXCIrcytcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICByZXN1bHRbMF0gPSBcIitsK1wiO1xcbiAgICAgIGlmKFwiK3UrXCIpIHtcXG4gICAgICAgIHJlc3VsdFsxXSA9IFwiK2wrXCI7XFxuICAgICAgfVxcbiAgICAgIC0tXCIrYVt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgaWYoKytcIithW3RoaXMucmFuay0yXStcIiA8IFwiK25bdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICByZXN1bHRbMl0gPSBcIitsK1wiO1xcbiAgICAgICAgaWYoXCIrdStcIikge1xcbiAgICAgICAgICByZXN1bHRbM10gPSBcIitsK1wiO1xcbiAgICAgICAgfVxcbiAgICAgIH0gIFxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICAgIFwifX0oKSxiaT0xLjc1ODA5OTM0MDg0NzM3NjgsQ2k9MS4wNTA3MDA5ODczNTU0ODA1LEVpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxSaT1cImlmIChpc25hbih4KSkgcmV0dXJuIHg7XCIsU2k9XCJyZXR1cm4geDtcIixOaT1SaStcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCIsa2k9XCJcXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cXG4gIC8vIHNlZTogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcXG4gIGZsb2F0IHNjYWxlQWxwaGEgPSBcIitiaStcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIrQ2krXCI7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjt2YXIgSWk9XCJyZXR1cm4gZXhwKHgpO1wiLEFpPVJpK1wiXFxuICByZXR1cm4gc2luKHgpO1xcblwiLFRpPVJpK1wiXFxuICByZXR1cm4gY29zKHgpO1xcblwiLERpPVJpK1wiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIixPaT1SaStcIlxcbiAgaWYgKHggPCAxLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMS4wKSk7XCIsX2k9UmkrXCJcXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtcIixNaT1cInJldHVybiB4O1wiLEZpPVwiXFxuICB2ZWM0IHJlc3VsdCA9IHggKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XFxuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xcblxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLEJpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2ZWM0IHVuYXJ5T3BlcmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFBpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgZT10Lmxlbmd0aCxuPW9vKFwicmNcIixlKSxyPWJvKGUpLG89ZnVuY3Rpb24odCxlKXtpZigxPT09dClyZXR1cm5cInJjXCI7Zm9yKHZhciBuPVwiXCIscj0wO3I8dDtyKyspbis9ZVtyXSxyPHQtMSYmKG4rPVwiLFwiKTtyZXR1cm4gbn0oZSxuKSxhPW4uc2xpY2UoLTIpLGk9ZTw9MT9cInJjXCI6XCJ2ZWMyKFwiK2Euam9pbihcIixcIikrXCIpXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK3IrXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKFwiK28rXCIpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KGdldENoYW5uZWwocGFja2VkSW5wdXQsIFwiK2krXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxMaT17fTt2YXIgV2k9NjAwO3ZhciBVaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5ncGdwdT10LHRoaXMucGVuZGluZ1JlYWQ9bmV3IFdlYWtNYXAsdGhpcy5wZW5kaW5nRGlzcG9zYWw9bmV3IFdlYWtTZXQsdGhpcy5kYXRhUmVmQ291bnQ9bmV3IFdlYWtNYXAsdGhpcy5udW1CeXRlc0luR1BVPTAsdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsdGhpcy53YXJuZWRBYm91dE1lbW9yeT0hMSx0aGlzLmRpc3Bvc2VkPSExLCFhLmdldEJvb2woXCJIQVNfV0VCR0xcIikpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtpZihudWxsPT10KXt2YXIgZT1GdChhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpO3RoaXMuYmluYXJ5Q2FjaGU9KG49YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKWluIExpP0xpW25dOihMaVtuXT17fSxMaVtuXSksdGhpcy5ncGdwdT1uZXcgV2EoZSksdGhpcy5jYW52YXM9ZS5jYW52YXMsdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSEwfWVsc2UgdGhpcy5iaW5hcnlDYWNoZT17fSx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITEsdGhpcy5jYW52YXM9dC5nbC5jYW52YXM7dmFyIG47dGhpcy50ZXh0dXJlTWFuYWdlcj1uZXcgdmkodGhpcy5ncGdwdSksdGhpcy5udW1NQkJlZm9yZVdhcm5pbmc9bnVsbD09YS5nbG9iYWwuc2NyZWVuPzEwMjQ6YS5nbG9iYWwuc2NyZWVuLmhlaWdodCphLmdsb2JhbC5zY3JlZW4ud2lkdGgqd2luZG93LmRldmljZVBpeGVsUmF0aW8qV2kvMTAyNC8xMDI0LHRoaXMudGV4RGF0YT1uZXcgWW4oRHQpfXJldHVybiB0LnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbih0LGUsbil7aWYodGhpcy50ZXhEYXRhLmhhcyh0KSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dGhpcy50ZXhEYXRhLnNldCh0LHtzaGFwZTplLGR0eXBlOm59KX0sdC5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbih0LGUpe2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7dmFyIG49W3QuaGVpZ2h0LHQud2lkdGhdLHI9W3QuaGVpZ2h0LHQud2lkdGgsZV07aWYoYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl7aWYoISh0IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudHx8dCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8dCBpbnN0YW5jZW9mIEltYWdlRGF0YSkpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBtdXN0IGJlIGVpdGhlciBhbiBIVE1MVmlkZW9FbGVtZW50LCBIVE1MSW1hZ2VFbGVtZW50LCBIVE1MQ2FudmFzRWxlbWVudCBvciBJbWFnZURhdGEsIGJ1dCB3YXMgXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKTtpZih0IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCl7aWYobnVsbD09dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0KXtpZihcImNvbXBsZXRlXCIhPT1kb2N1bWVudC5yZWFkeVN0YXRlKXRocm93IG5ldyBFcnJvcihcIlRoZSBET00gaXMgbm90IHJlYWR5IHlldC4gUGxlYXNlIGNhbGwgdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgb25jZSB0aGUgRE9NIGlzIHJlYWR5LiBPbmUgd2F5IHRvIGRvIHRoYXQgaXMgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgRE9NQ29udGVudExvYWRlZGAgb24gdGhlIGRvY3VtZW50IG9iamVjdFwiKTt0aGlzLmZyb21QaXhlbHMyRENvbnRleHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIil9dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy53aWR0aD10LndpZHRoLHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMuaGVpZ2h0PXQuaGVpZ2h0LHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UodCwwLDAsdC53aWR0aCx0LmhlaWdodCksdD10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzfX12YXIgbz10aGlzLm1ha2VUZW5zb3JIYW5kbGUobixcImludDMyXCIpO3RoaXMudGV4RGF0YS5nZXQoby5kYXRhSWQpLnVzYWdlPXVhLlBJWEVMUyx0aGlzLmdwZ3B1LnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdldFRleHR1cmUoby5kYXRhSWQpLHQpO3ZhciBpPW5ldyBpYShyKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihpLFtvXSk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEoby5kYXRhSWQpLHN9LHQucHJvdG90eXBlLm1ha2VUZW5zb3JIYW5kbGU9ZnVuY3Rpb24odCxlKXt2YXIgbj17fTtyZXR1cm4gdGhpcy5yZWdpc3RlcihuLHQsZSkse2RhdGFJZDpuLHNoYXBlOnQsZHR5cGU6ZX19LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJNYXRoQmFja2VuZFdlYkdMLndyaXRlKCk6IHZhbHVlcyBjYW4gbm90IGJlIG51bGxcIik7aWYoYS5nZXRCb29sKFwiREVCVUdcIikpZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07aWYoIVd0KHIpKXRocm93IEVycm9yKFwiVGhlIHZhbHVlIFwiK3IrXCIgY2Fubm90IGJlIHJlcHJlc2VudGVkIG9uIHRoaXMgZGV2aWNlLlwiKX12YXIgbz10aGlzLnRleERhdGEuZ2V0KHQpO2lmKFwiY29tcGxleDY0XCI9PT1vLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnJlbGVhc2VHUFVEYXRhKHQpLG8udXNhZ2U9dWEuVVBMT0FELG8udmFsdWVzPWV9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCksbj1lLnZhbHVlcyxyPWUuZHR5cGUsbz1lLmNvbXBsZXhUZW5zb3JzLGE9ZS5zbGljZSxpPWUuc2hhcGU7aWYobnVsbCE9YSl7dmFyIHM9bmV3IEVpKGksXCJyZXR1cm4geDtcIiksdT10aGlzLmNvbXBpbGVBbmRSdW4ocyxbe2RhdGFJZDp0LHNoYXBlOmksZHR5cGU6cn1dKSxsPXRoaXMucmVhZFN5bmModS5kYXRhSWQpO3JldHVybiB1LmRpc3Bvc2UoKSxsfWlmKG51bGwhPW4pcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCk7aWYoXCJzdHJpbmdcIj09PXIpcmV0dXJuIG47dmFyIGMsaCxwPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzOyhwJiYoYz1wZXJmb3JtYW5jZS5ub3coKSksXCJjb21wbGV4NjRcIj09PXIpP2g9ZXIoby5yZWFsLmRhdGFTeW5jKCksby5pbWFnLmRhdGFTeW5jKCkpOmg9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KTtyZXR1cm4gcCYmKHRoaXMuZG93bmxvYWRXYWl0TXMrPXBlcmZvcm1hbmNlLm5vdygpLWMpLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCxoKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsaSxzLHUsbCxjLGgscCxmLGQsdixtLGcseCx3LGIsQyxFLFIsUyxOLGssSSxBLFQsRDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpcmV0dXJuIHI9dGhpcy5wZW5kaW5nUmVhZC5nZXQodCksWzIsbmV3IFByb21pc2UoZnVuY3Rpb24odCl7cmV0dXJuIHIucHVzaCh0KX0pXTtpZihpPXRoaXMudGV4RGF0YS5nZXQodCkscz1pLnRleHR1cmUsdT1pLnZhbHVlcyxsPWkudGV4U2hhcGUsYz1pLmlzUGFja2VkLGg9aS5zaGFwZSxwPWkuc2xpY2UsZj1pLmR0eXBlLGQ9aS5jb21wbGV4VGVuc29ycyxudWxsIT1wKXJldHVybiB2PW5ldyBFaShoLFwicmV0dXJuIHg7XCIpLG09dGhpcy5jb21waWxlQW5kUnVuKHYsW3tkYXRhSWQ6dCxzaGFwZTpoLGR0eXBlOmZ9XSksZz10aGlzLnJlYWQobS5kYXRhSWQpLG0uZGlzcG9zZSgpLFsyLGddO2lmKG51bGwhPXUpcmV0dXJuWzIsdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KV07aWYodGhpcy5wZW5kaW5nUmVhZC5zZXQodCxbXSksIWEuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikmJjI9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yLmRhdGEoKSB3aXRoIFdFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQ9ZmFsc2UgYW5kIFdFQkdMX1ZFUlNJT049MiBub3QgeWV0IHN1cHBvcnRlZC5cIik7cmV0dXJuIHg9bnVsbCxcImNvbXBsZXg2NFwiPT09Zj9bMywyXToodz1sWzFdLGI9bFswXSxjJiYoZT1kYShsWzBdLGxbMV0pLHc9ZVswXSxiPWVbMV0pLGEuZ2V0KFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiKSYmKHg9dGhpcy5ncGdwdS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZShzLGIsdykpLFs0LHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldKTtjYXNlIDE6by5zZW50KCksby5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5cImNvbXBsZXg2NFwiIT09Zj9bMyw0XTpbNCxQcm9taXNlLmFsbChbZC5yZWFsLmRhdGEoKSxkLmltYWcuZGF0YSgpXSldO2Nhc2UgMzpyZXR1cm4gRT1vLnNlbnQoKSxSPUVbMF0sUz1FWzFdLEM9ZXIoUixTKSxbMyw1XTtjYXNlIDQ6bnVsbD09eD9DPXRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUodCk6KE49eShoKSxjPyhrPWZlKGgpLEk9MSxBPTEsaC5sZW5ndGgmJihuPWRlKGgpLEk9blswXSxBPW5bMV0pLEM9dGhpcy5ncGdwdS5kb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXIoeCxrLEksQSxsWzBdLGxbMV0pLnN1YmFycmF5KDAsTikpOkM9dGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHgsbFswXSxsWzFdKS5zdWJhcnJheSgwLE4pKSxvLmxhYmVsPTU7Y2FzZSA1OnJldHVybiBUPXRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCxDKSxEPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpLHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKHQpLEQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdChUKX0pLHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSYmKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZSh0KSx0aGlzLmRpc3Bvc2VEYXRhKHQpKSxbMixUXX19KX0pfSx0LnByb3RvdHlwZS5nZXRWYWx1ZXNGcm9tVGV4dHVyZT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMscj10aGlzLnRleERhdGEuZ2V0KHQpLG89ci5zaGFwZSxpPXIuZHR5cGUscz1yLnRleHR1cmUsdT1yLnRleFNoYXBlLGw9eShvKTtpZihhLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpKXtpZih0aGlzLnRleERhdGEuZ2V0KHQpLmlzUGFja2VkKXt2YXIgYz1mZShvKSxoPTEscD0xO3JldHVybiBvLmxlbmd0aCYmKGg9KGU9ZGUobykpWzBdLHA9ZVsxXSksdGhpcy5ncGdwdS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlKHMsYyxoLHAsdVswXSx1WzFdKS5zdWJhcnJheSgwLGwpfXJldHVybiB0aGlzLmdwZ3B1LmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHMsdVswXSx1WzFdKS5zdWJhcnJheSgwLGwpfXZhciBmPXRoaXMubWFrZVRlbnNvckhhbmRsZShvLFwiZmxvYXQzMlwiKTtmLnNpemU9eShvKSx0aGlzLnRleERhdGEuZ2V0KGYuZGF0YUlkKS51c2FnZT11YS5ET1dOTE9BRDt2YXIgZD1GZShmdW5jdGlvbigpe3ZhciBlPW5ldyBlYShvKTtyZXR1cm4gbi5jb21waWxlQW5kUnVuKGUsW3tzaGFwZTpvLGR0eXBlOmksZGF0YUlkOnR9XSxmLG51bGwpfSksdj10aGlzLnRleERhdGEuZ2V0KGQuZGF0YUlkKSxtPXRoaXMuZ3BncHUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUodi50ZXh0dXJlLHYudGV4U2hhcGVbMF0sdi50ZXhTaGFwZVsxXSkuc3ViYXJyYXkoMCxsKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShmLmRhdGFJZCksbX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsYSxpLHMsdTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcy5hY3RpdmVUaW1lcnMsbj1bXSxyPSExLG51bGw9PXRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPyh0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1uLHI9ITApOnRoaXMuYWN0aXZlVGltZXJzLnB1c2gobiksdGhpcy5hY3RpdmVUaW1lcnM9bix0KCksYT1nKHRoaXMuYWN0aXZlVGltZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5xdWVyeX0pKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSxpPWcodGhpcy5hY3RpdmVUaW1lcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSksdGhpcy5hY3RpdmVUaW1lcnM9ZSxyJiYodGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bnVsbCksWzQsUHJvbWlzZS5hbGwoYSldO2Nhc2UgMTpyZXR1cm4gcz1vLnNlbnQoKSx1PXt1cGxvYWRXYWl0TXM6dGhpcy51cGxvYWRXYWl0TXMsZG93bmxvYWRXYWl0TXM6dGhpcy5kb3dubG9hZFdhaXRNcyxrZXJuZWxNczpmKHMpLGdldEV4dHJhUHJvZmlsZUluZm86ZnVuY3Rpb24oKXtyZXR1cm4gcy5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm57bmFtZTppW2VdLG1zOnR9fSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWUrXCI6IFwiK3QubXN9KS5qb2luKFwiLCBcIil9LHdhbGxNczpudWxsfSx0aGlzLnVwbG9hZFdhaXRNcz0wLHRoaXMuZG93bmxvYWRXYWl0TXM9MCxbMix1XX19KX0pfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMSxudW1CeXRlc0luR1BVOnRoaXMubnVtQnl0ZXNJbkdQVX19LHQucHJvdG90eXBlLnN0YXJ0VGltZXI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wP3RoaXMuZ3BncHUuYmVnaW5RdWVyeSgpOntzdGFydE1zOnBlcmZvcm1hbmNlLm5vdygpLGVuZE1zOm51bGx9fSx0LnByb3RvdHlwZS5lbmRUaW1lcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wPyh0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCksdCk6KHQuZW5kTXM9cGVyZm9ybWFuY2Uubm93KCksdCl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiBhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/WzIsdGhpcy5ncGdwdS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpXTpbMiwoZT10KS5lbmRNcy1lLnN0YXJ0TXNdfSl9KX0sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7aWYoIXRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSlpZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSl0aGlzLnBlbmRpbmdEaXNwb3NhbC5hZGQodCk7ZWxzZSBpZih0aGlzLnRleERhdGEuaGFzKHQpKXt0aGlzLnJlbGVhc2VHUFVEYXRhKHQpO3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCkuY29tcGxleFRlbnNvcnM7bnVsbCE9ZSYmKGUucmVhbC5kaXNwb3NlKCksZS5pbWFnLmRpc3Bvc2UoKSksdGhpcy50ZXhEYXRhLmRlbGV0ZSh0KX19LHQucHJvdG90eXBlLnJlbGVhc2VHUFVEYXRhPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCksbj1lLnRleHR1cmUscj1lLmR0eXBlLG89ZS50ZXhTaGFwZSxhPWUudXNhZ2UsaT1lLmlzUGFja2VkLHM9ZS5zbGljZSx1PXMmJnMub3JpZ0RhdGFJZHx8dCxsPXRoaXMuZGF0YVJlZkNvdW50LmdldCh1KTtsPjE/dGhpcy5kYXRhUmVmQ291bnQuc2V0KHUsbC0xKToodGhpcy5kYXRhUmVmQ291bnQuZGVsZXRlKHUpLG51bGwhPW4mJih0aGlzLm51bUJ5dGVzSW5HUFUtPXRoaXMuY29tcHV0ZUJ5dGVzKG8sciksdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShuLG8sYSxpKSkpO3ZhciBjPXRoaXMudGV4RGF0YS5nZXQodCk7Yy50ZXh0dXJlPW51bGwsYy50ZXhTaGFwZT1udWxsLGMuaXNQYWNrZWQ9ITEsYy5zbGljZT1udWxsfSx0LnByb3RvdHlwZS5nZXRUZXh0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVwbG9hZFRvR1BVKHQpLHRoaXMudGV4RGF0YS5nZXQodCkudGV4dHVyZX0sdC5wcm90b3R5cGUuZ2V0Q1BVQmFja2VuZD1mdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9DUFVfRk9SV0FSRFwiKT8obnVsbD09dGhpcy5jcHVCYWNrZW5kJiYodGhpcy5jcHVCYWNrZW5kPUR0LmZpbmRCYWNrZW5kKFwiY3B1XCIpKSx0aGlzLmNwdUJhY2tlbmQpOm51bGx9LHQucHJvdG90eXBlLnNob3VsZEV4ZWN1dGVPbkNQVT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEyOCksbnVsbCE9dGhpcy5nZXRDUFVCYWNrZW5kKCkmJnQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PW4udGV4RGF0YS5nZXQodC5kYXRhSWQpLnRleHR1cmUmJnQuc2l6ZTxlfSl9LHQucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdwZ3B1fSx0LnByb3RvdHlwZS5nZXRDYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXN9LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm1ha2VPdXRwdXRBcnJheSh0LnNoYXBlLFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpEdC5rZWVwKHQuY2xvbmUoKSksaW1hZzpEdC5rZWVwKGUuY2xvbmUoKSl9LG59LHQucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuY2xvbmUoKX0sdC5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMuaW1hZy5jbG9uZSgpfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnNsaWNlKHQsZSxuKTt2YXIgcj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5pc1BhY2tlZCxvPW1uKHQuc2hhcGUsZSxuKTtpZihyfHwhbyl7dmFyIGk9YS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBmaShuKTpuZXcgaGkobikscz1pLmdldEN1c3RvbVNldHVwRnVuYyhlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3RdLG51bGwscyl9cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodC5kYXRhSWQpLHRoaXMuc2hhbGxvd1NsaWNlKHQsZSxuKX0sdC5wcm90b3R5cGUuc2hhbGxvd1NsaWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxvPWZ0Lm1ha2Uobix7fSx0LmR0eXBlLHRoaXMpLGE9dGhpcy50ZXhEYXRhLmdldChvLmRhdGFJZCk7T2JqZWN0LmFzc2lnbihhLHIpLGEuc2hhcGU9bixhLmR0eXBlPXQuZHR5cGU7dmFyIGk9Z24oZSx0LnN0cmlkZXMpO3Iuc2xpY2UmJihpKz1yLnNsaWNlLmZsYXRPZmZzZXQpLGEuc2xpY2U9e2ZsYXRPZmZzZXQ6aSxvcmlnRGF0YUlkOnIuc2xpY2UmJnIuc2xpY2Uub3JpZ0RhdGFJZHx8dC5kYXRhSWR9O3ZhciBzPXRoaXMuZGF0YVJlZkNvdW50LmdldChhLnNsaWNlLm9yaWdEYXRhSWQpfHwxO3JldHVybiB0aGlzLmRhdGFSZWZDb3VudC5zZXQoYS5zbGljZS5vcmlnRGF0YUlkLHMrMSksb30sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3RyaWRlZFNsaWNlKHQsZSxuLHIsbyxhLGkscyx1KTt2YXIgbD1mbih0LnNoYXBlLGUsbixyLG8sYSxpLHMsdSksYz1sWzBdLGg9bFsxXSxwPWxbMl0sZj1oLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybi0xPT09cC5pbmRleE9mKGUpfSk7aWYoZi5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dH0pKXJldHVybiBGbihbXSxmKTt2YXIgZD1uZXcgZGkoYyxyLGgscCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihkLFt0XSl9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IHNpKHQuc2hhcGUsZSk6bmV3IGlpKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKHQpKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuY29uY2F0KHQsZSk7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmEuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiKSl7dmFyIG49TWF0aC5mbG9vcih0Lmxlbmd0aC8yKSxyPXRoaXMuY29uY2F0KHQuc2xpY2UoMCxuKSxlKSxvPXRoaXMuY29uY2F0KHQuc2xpY2UobiksZSk7cmV0dXJuIHRoaXMuY29uY2F0KFtyLG9dLGUpfWlmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKSYmdFswXS5yYW5rPjEpe3ZhciBpPW5ldyBVbyh0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSx0KX12YXIgcz1zbih0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLGUpLHU9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXMyRCgtMSx5KHQuc2hhcGUuc2xpY2UoZSkpKX0pLGw9bmV3IFdvKHUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obCx1KS5yZXNoYXBlKHMpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gLXg7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxhPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLGk9bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0scz10LnNoYXBlWzBdO2lmKCgxPT09b3x8MT09PWEpJiZpPjFlMyl7biYmKHQ9dC50cmFuc3Bvc2UoWzAsMiwxXSkpLHImJihlPWUudHJhbnNwb3NlKFswLDIsMV0pKTt2YXIgdT0xPT09YT90OnQuYXMzRChzLGksMSksbD0xPT09YT8yOjEsYz0xPT09YT9lLmFzM0QocywxLGkpOmU7cmV0dXJuIHRoaXMubXVsdGlwbHkodSxjKS5zdW0obCwhMCl9dmFyIGg9Q3QodC5kdHlwZSxlLmR0eXBlKSxwPW5ldyAkYSh0LnNoYXBlLFtzLG8sYV0sbixyKSxmPXRoaXMubWFrZVBhY2tlZFRlbnNvcihwLm91dHB1dFNoYXBlLGgpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocCxbdCxlXSxmKX0sdC5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0scz1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSx1PXQuc2hhcGVbMF0sbD1DdCh0LmR0eXBlLGUuZHR5cGUpLGM9bmV3ICRhKHQuc2hhcGUsW3UsaSxzXSxuLHIsISFvLGE/ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksXCJsaW5lYXJcIj09PXQpcmV0dXJuIGU/TWk6U2k7aWYoXCJyZWx1XCI9PT10KXJldHVybiBlP0ZpOk5pO3Rocm93IG5ldyBFcnJvcihcIkFjdGl2YXRpb24gXCIrdCtcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBXZWJHTCBiYWNrZW5kLlwiKX0oYSwhMCk6bnVsbCksaD10aGlzLm1ha2VQYWNrZWRUZW5zb3IoYy5vdXRwdXRTaGFwZSxsKSxwPVt0LGVdO3JldHVybiBvJiZwLnB1c2gobyksdGhpcy5jb21waWxlQW5kUnVuKGMscCxoKX0sdC5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxvPW5ldyBUbyhJbyx0LnNoYXBlLGUuc2hhcGUpLGk9bmV3IFRvKEFvLHQuc2hhcGUsZS5zaGFwZSkscz1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZShlLHIuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZShlLHIuY29tcGxleFRlbnNvcnMuaW1hZyldLHU9dGhpcy5jb21waWxlQW5kUnVuKG8scyksbD10aGlzLmNvbXBpbGVBbmRSdW4oaSxzKSxjPXRoaXMuY29tcGxleCh1LGwpO3JldHVybiB1LmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxjfWlmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm11bHRpcGx5KHQsZSk7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsX28sdC5kdHlwZSk7dmFyIGg9bmV3IE1vKF9vLHQuc2hhcGUsZS5zaGFwZSkscD10aGlzLm1ha2VPdXRwdXRBcnJheShoLm91dHB1dFNoYXBlLHQuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxbdCxlXSxwKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxpKXt2YXIgcz1bdCxlLG5dLHU9bnVsbDtudWxsIT1pJiYodT1pLnNoYXBlLHMucHVzaChpKSk7dmFyIGw9bnVsbDtpZihudWxsIT1vJiYobD1vLnNoYXBlLHMucHVzaChvKSksYS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpKXt2YXIgYz1uZXcga28odC5zaGFwZSxlLnNoYXBlLG4uc2hhcGUsdSxsLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYyxzKX12YXIgaD1uZXcgTm8odC5zaGFwZSxlLnNoYXBlLG4uc2hhcGUsdSxsLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxzKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBpPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKT9uZXcgcWEodC5zaGFwZSxlLG4scixvKTpuZXcgVmEodC5zaGFwZSxlLG4scixvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3RdKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcz1uZXcgR2EoZS5zaGFwZSxyLG8sYSxpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsW2Usbix0XSl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeWkodC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IFFhKHQuc2hhcGUsZSxuKTpuZXcgWWEodC5zaGFwZSxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQudHJhbnNwb3NlKHQsZSk7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyB3aSh0LnNoYXBlLGUpOm5ldyB4aSh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmdhdGhlcih0LGUsbik7dmFyIHI9bmV3IHNhKHQuc2hhcGUsZS5zaXplLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXtkKHQucmFuazw9NCxmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIn0pO3ZhciByPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pLG89S2UodC5zaGFwZSxlLHIpLGE9WGUoby5sZW5ndGgsZS5sZW5ndGgpLGk9WWUodC5zaGFwZSxlLHIpLHM9UWUobixlLmxlbmd0aCksdT1KZShpLG4sZS5sZW5ndGgpO3JldHVybiB0LnJlc2hhcGUobykudHJhbnNwb3NlKGEpLnJlc2hhcGUoaSkuc2xpY2Uocyx1KX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe2QodC5yYW5rPD00LGZ1bmN0aW9uKCl7cmV0dXJuXCJzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwifSk7dmFyIHI9ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLG4pO2Zvcih2YXIgYT0xK2UubGVuZ3RoO2E8dC5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9dC5wYWQobykscz1LZShpLnNoYXBlLGUsciwhMSksdT1YZShzLmxlbmd0aCxlLmxlbmd0aCwhMSksbD1ZZShpLnNoYXBlLGUsciwhMSk7cmV0dXJuIGkucmVzaGFwZShzKS50cmFuc3Bvc2UodSkucmVzaGFwZShsKX0sdC5wcm90b3R5cGUucmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXSxhPWNuKG8pLGk9bmV3IFphKHt3aW5kb3dTaXplOmEsaW5TaXplOm8sYmF0Y2hTaXplOnJ9LGUpLHM9aS5vdXRwdXRTaGFwZSx1PXNbMF0sbD1zWzFdLGM9dGhpcy5tYWtlT3V0cHV0QXJyYXkoW3UsbF0sbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFt0XSxjKSwxPT09Yy5zaGFwZVsxXT9jOnRoaXMucmVkdWNlKGMsZSxuKX0sdC5wcm90b3R5cGUuYXJnUmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1udWxsKTt2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXTtudWxsIT1uJiYocj1uLnNoYXBlWzBdLG89bi5zaGFwZVsxXSk7dmFyIGE9Y24obyksaT1uZXcgbm8oe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6cn0sZSxudWxsPT1uKSxzPWkub3V0cHV0U2hhcGUsdT1zWzBdLGw9c1sxXSxjPXRoaXMubWFrZU91dHB1dEFycmF5KFt1LGxdLFwiaW50MzJcIiksaD1bdF07cmV0dXJuIG51bGwhPW4mJmgucHVzaChuKSx0aGlzLmNvbXBpbGVBbmRSdW4oaSxoLGMpLDE9PT1jLnNoYXBlWzFdP2M6dGhpcy5hcmdSZWR1Y2UodCxlLGMpfSx0LnByb3RvdHlwZS5hcmdSZWR1Y2VQYWNrZWQ9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPW51bGwhPW4/bi5zaGFwZTp0LnNoYXBlLG89Y24ocltyLmxlbmd0aC0xXSksYT1uZXcgUm8ocixvLGUsbnVsbD09biksaT10aGlzLm1ha2VQYWNrZWRUZW5zb3IoYS5vdXRwdXRTaGFwZSxcImludDMyXCIpLHM9bnVsbD09bj9bdF06W3Qsbl07cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLHMsaSksaS5yYW5rPT09dC5yYW5rP3RoaXMuYXJnUmVkdWNlUGFja2VkKHQsZSxpKTppfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtubihcInN1bVwiLGUsdC5yYW5rKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyksaT1FdCh0LmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInN1bVwiLGkpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucHJvZCh0LGUpO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKSxpPUV0KHQuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShhLFwicHJvZFwiLGkpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7dmFyIHI9MCxvPXJuKFtyXSx0LnJhbmspLGE9dDtudWxsIT1vJiYoYT10LnRyYW5zcG9zZShvKSxyPWFuKDEsdC5yYW5rKVswXSk7dmFyIGk9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1bXSxvPXQubGVuZ3RoLGE9MDthPG87YSsrKWEhPT1lP3IucHVzaCh0W2FdKTpyLnB1c2gobik7cmV0dXJuIHJ9KGEuc2hhcGUscixuKSxzPXkoW2Euc2hhcGVbcl1dKSx1PWEuYXMyRCgtMSxzKSxsPUV0KHQuZHR5cGUpLGM9dGhpcy5zZWdPcENvbXB1dGUodSxcInVuc29ydGVkU2VnbWVudFN1bVwiLGUsbCxuKS5yZXNoYXBlKGkpO3JldHVybiBudWxsIT1vJiYoYz1jLnRyYW5zcG9zZShvbihvKSkpLGN9LHQucHJvdG90eXBlLnNlZ09wQ29tcHV0ZT1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXQuc2hhcGVbMF0saT10LnNoYXBlWzFdLHM9ZnVuY3Rpb24odCxlKXt2YXIgbixyPSExO2Zvcih0PD1sbj8obj10LHI9ITApOm49eih0LE1hdGguZmxvb3IoTWF0aC5zcXJ0KHQpKSk7IXI7KW4+ZXx8bj09PXQ/cj0hMDpuPXoodCxuKzEpO3JldHVybiBufShpLG8pLHU9bmV3IGxpKHt3aW5kb3dTaXplOnMsaW5TaXplOmksYmF0Y2hTaXplOmEsbnVtU2VnbWVudHM6b30sZSksbD11Lm91dHB1dFNoYXBlLGM9bFswXSxoPWxbMV0scD10aGlzLm1ha2VPdXRwdXRBcnJheShbYyxoXSxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHUsW3Qsbl0scCkscC5zaGFwZVsxXT09PW8/cDoobj1qbigwLG8pLnRpbGUoW2kvc10pLHRoaXMuc2VnT3BDb21wdXRlKHAsZSxuLHIsbykpfSx0LnByb3RvdHlwZS5hcmdNaW5NYXhSZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtlXTtpZihubihcImFyZ1wiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxyLHQucmFuayksIWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfUkVEVUNFXCIpfHx0LnJhbms8PTIpe3ZhciBvPXRuKHQuc2hhcGUsciksaT1vWzBdLHM9eShvWzFdKSx1PXQuYXMyRCgtMSxzKTtyZXR1cm4gdGhpcy5hcmdSZWR1Y2UodSxuKS5yZXNoYXBlKGkpfXJldHVybiB0aGlzLmFyZ1JlZHVjZVBhY2tlZCh0LG4pfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWluXCIpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWF4XCIpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYoZSE9PXQucmFuay0xKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGN1bXN1bSBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKHQucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7dmFyIG89bmV3IEpvKHQuc2hhcGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA9PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChub3RFcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhICE9IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5sZXNzKHQsZSk7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPCBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobGVzc1RoYW5FcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhIDw9IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5ncmVhdGVyKHQsZSk7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPiBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhID49IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoISh4ID49IDEuMCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICpcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wICYmIGIgPj0gMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIG1pbihcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICtcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpLFxcbiAgICB2ZWM0KDEuMCkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgfHwgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGNpKHQucmFuayxlLnNoYXBlLGUucmFuayksbz10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLEN0KGUuZHR5cGUsbi5kdHlwZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlLG5dLG8pfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXtqZShcInRmLndoZXJlKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi53aGVyZUFzeW5jKCkgaW5zdGVhZFwiKTt2YXIgZT10LmRhdGFTeW5jKCk7cmV0dXJuIFpyKHQuc2hhcGUsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB1cih0LmRhdGFTeW5jKCksdC5zaGFwZSx0LmR0eXBlLGUpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtubihcIm1pblwiLGUsdC5yYW5rKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtaW5cIixhLmR0eXBlKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWluaW11bSh0LGUpO3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWluKGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIG1pbihhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IHJlc3VsdCA9IG1vZChhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGVxdWFsKGIsIHZlYzQoMC4wKSkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcImlmIChiID09IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBtb2QoYSwgYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4KHQsZSk7bm4oXCJtYXhcIixlLHQucmFuayk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwibWF4XCIsYS5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1heGltdW0odCxlKTt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1heChhLCBiKSk7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBtYXgoYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtubihcImFsbFwiLGUsdC5yYW5rKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJhbGxcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtubihcImFueVwiLGUsdC5yYW5rKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJhbnlcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwicmV0dXJuIChhIC0gYikgKiAoYSAtIGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwicmV0dXJuIChhIC0gYikgKiAoYSAtIGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpe3JldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgLy8gdmVjNCBvbmUgPSB2ZWM0KGVxdWFsKGEsIGIpKTtcXG4gIC8vIHJldHVybiBvbmUgKyAodmVjNCgxLjApIC0gb25lKSAqIGEgLyBiO1xcbiAgdmVjNCByZXN1bHQgPSBhIC8gYjtcXG4gIGlmKGIueCA9PSAwLjApIHtcXG4gICAgcmVzdWx0LnggPSBOQU47XFxuICB9IGVsc2UgaWYoYS54ID09IGIueCkge1xcbiAgICByZXN1bHQueCA9IDEuO1xcbiAgfVxcbiAgaWYoYi55ID09IDAuMCkge1xcbiAgICByZXN1bHQueSA9IE5BTjtcXG4gIH0gZWxzZSBpZihhLnkgPT0gYi55KSB7XFxuICAgIHJlc3VsdC55ID0gMS47XFxuICB9XFxuICBpZihiLnogPT0gMC4wKSB7XFxuICAgIHJlc3VsdC56ID0gTkFOO1xcbiAgfSBlbHNlIGlmKGEueiA9PSBiLnopIHtcXG4gICAgcmVzdWx0LnogPSAxLjtcXG4gIH1cXG4gIGlmKGIudyA9PSAwLjApIHtcXG4gICAgcmVzdWx0LncgPSBOQU47XFxuICB9IGVsc2UgaWYoYS53ID09IGIudykge1xcbiAgICByZXN1bHQudyA9IDEuO1xcbiAgfVxcbiAgXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLFwiZmxvYXQzMlwiLCEwKX12YXIgbj1uZXcgTW8oXCJcXG5pZiAoYiA9PSAwLjApIHtcXG4gIHJldHVybiBOQU47XFxufSBcXG5pZiAoYSA9PSBiKSB7XFxuICByZXR1cm4gMS4wO1xcbn07XFxucmV0dXJuIGEgLyBiO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiZmxvYXQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIGl2ZWM0IGlhID0gcm91bmQoYSk7XFxuICBpdmVjNCBpYiA9IHJvdW5kKGIpO1xcbiAgYnZlYzQgY29uZCA9IG5vdEVxdWFsKGliLCBpdmVjNCgwKSk7XFxuICBpdmVjNCByZXN1bHQgPSBpdmVjNCgwKTtcXG4gIHZlYzQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcblxcbiAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXFxuICBpZiAoY29uZFswXSkge1xcbiAgICByZXN1bHRbMF0gPSBpZGl2KGlhWzBdLCBpYlswXSwgc1swXSk7XFxuICB9XFxuICBpZiAoY29uZFsxXSkge1xcbiAgICByZXN1bHRbMV0gPSBpZGl2KGlhWzFdLCBpYlsxXSwgc1sxXSk7XFxuICB9XFxuICBpZiAoY29uZFsyXSkge1xcbiAgICByZXN1bHRbMl0gPSBpZGl2KGlhWzJdLCBpYlsyXSwgc1syXSk7XFxuICB9XFxuICBpZiAoY29uZFszXSkge1xcbiAgICByZXN1bHRbM10gPSBpZGl2KGlhWzNdLCBpYlszXSwgc1szXSk7XFxuICB9XFxuICByZXR1cm4gdmVjNChyZXN1bHQpO1xcblwiLFwiaW50MzJcIik7dmFyIG49bmV3IE1vKFwiXFxuICBmbG9hdCBzID0gc2lnbihhKSAqIHNpZ24oYik7XFxuICBpbnQgaWEgPSByb3VuZChhKTtcXG4gIGludCBpYiA9IHJvdW5kKGIpO1xcbiAgaWYgKGliICE9IDApIHtcXG4gICAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXFxuICAgIHJldHVybiBmbG9hdChpZGl2KGlhLCBpYiwgcykpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG5cIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImludDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcCh0LGUsRG8pO2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmFkZCh0LGUpO3ZhciBuPUN0KHQuZHR5cGUsZS5kdHlwZSk7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsRG8sbik7dmFyIHI9bmV3IE1vKERvLHQuc2hhcGUsZS5zaGFwZSksbz10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSxvKX0sdC5wcm90b3R5cGUucGFja2VkQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMSk7dmFyIGE9bmV3IEZvKG4sdC5zaGFwZSxlLnNoYXBlLG8pLGk9dGhpcy5tYWtlUGFja2VkVGVuc29yKGEub3V0cHV0U2hhcGUscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0LGVdLGkpfSx0LnByb3RvdHlwZS5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMsbz10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxhPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLGk9W1tvLmNvbXBsZXhUZW5zb3JzLnJlYWwsYS5jb21wbGV4VGVuc29ycy5yZWFsXSxbby5jb21wbGV4VGVuc29ycy5pbWFnLGEuY29tcGxleFRlbnNvcnMuaW1hZ11dLm1hcChmdW5jdGlvbihvKXt2YXIgYT1vWzBdLGk9b1sxXSxzPXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxhKSx1PXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxpKSxsPW5ldyBNbyhuLHQuc2hhcGUsZS5zaGFwZSksYz1yLm1ha2VPdXRwdXRBcnJheShsLm91dHB1dFNoYXBlLEN0KGEuZHR5cGUsaS5kdHlwZSkpO3JldHVybiByLmNvbXBpbGVBbmRSdW4obCxbcyx1XSxjKX0pLHM9aVswXSx1PWlbMV0sbD10aGlzLmNvbXBsZXgocyx1KTtyZXR1cm4gcy5kaXNwb3NlKCksdS5kaXNwb3NlKCksbH0sdC5wcm90b3R5cGUubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGU9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZGF0YUlkOmUuZGF0YUlkLGR0eXBlOmUuZHR5cGUsc2hhcGU6dC5zaGFwZX19LHQucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmEuZ2V0KFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiKSl7dmFyIGU9TWF0aC5mbG9vcih0Lmxlbmd0aC8yKSxuPXRoaXMuYWRkTih0LnNsaWNlKDAsZSkpLHI9dGhpcy5hZGROKHQuc2xpY2UoZSkpO3JldHVybiB0aGlzLmFkZE4oW24scl0pfXZhciBvPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmR0eXBlfSkucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIEN0KHQsZSl9KSxpPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkscz1hLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpLHU9cz9uZXcgZW8odFswXS5zaGFwZSxpKTpuZXcgdG8odFswXS5zaGFwZSxpKSxsPXM/dGhpcy5tYWtlUGFja2VkVGVuc29yKHUub3V0cHV0U2hhcGUsbyk6dGhpcy5tYWtlT3V0cHV0QXJyYXkodS5vdXRwdXRTaGFwZSxvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHUsdCxsKX0sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSYmXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIHRoaXMuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wKHQsZSxPbyk7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3VidHJhY3QodCxlKTt2YXIgbj1DdCh0LmR0eXBlLGUuZHR5cGUpO2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLE9vLHQuZHR5cGUpO3ZhciByPW5ldyBNbyhPbyx0LnNoYXBlLGUuc2hhcGUpLG89dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sbyl9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikscj1uP25ldyBGbyhcIlxcbiAgLy8gaXNNb2RSb3VuZDEgaGFzIDEgZm9yIGNvbXBvbmVudHMgd2l0aCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMSwgMCBvdGhlcndpc2UuXFxuICB2ZWM0IGlzTW9kUm91bmQxID0gdmVjNChlcXVhbChyb3VuZChtb2QoYiwgMi4wKSksIGl2ZWM0KDEpKSk7XFxuICB2ZWM0IG11bHRpcGxpZXIgPSBzaWduKGEpICogaXNNb2RSb3VuZDEgKyAodmVjNCgxLjApIC0gaXNNb2RSb3VuZDEpO1xcbiAgdmVjNCByZXN1bHQgPSBtdWx0aXBsaWVyICogcG93KGFicyhhKSwgYik7XFxuXFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuMCkpKSAqIHZlYzQobGVzc1RoYW4oZmxvb3IoYiksIGIpKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJcXG5pZihhIDwgMC4wICYmIGZsb29yKGIpIDwgYil7XFxuICByZXR1cm4gTkFOO1xcbn1cXG5yZXR1cm4gKHJvdW5kKG1vZChiLCAyLjApKSAhPSAxKSA/XFxuICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSksbz1DdCh0LmR0eXBlLGUuZHR5cGUpLGk9bj90aGlzLm1ha2VQYWNrZWRUZW5zb3Ioci5vdXRwdXRTaGFwZSxvKTp0aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSxpKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBjZWlsKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvb3IoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICBpZiAoaXNuYW4oeCkpIHsgcmV0dXJuIDAuMDsgfVxcbiAgcmV0dXJuIHNpZ24oeCk7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9hdChpc25hbih4KSk7XCIpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxuKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaXNpbmYoeCkpO1wiKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KGUub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sbil9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KCFpc25hbih4KSAmJiAhaXNpbmYoeCkpO1wiKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KGUub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sbil9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICAvLyBPcGVuR0wgRVMgZG9lcyBub3Qgc3VwcG9ydCByb3VuZCBmdW5jdGlvbi5cXG4gIC8vIFRoZSBhbGdvcml0aG0gaXMgYmFzZWQgb24gYmFua2VyJ3Mgcm91bmRpbmcuXFxuICBmbG9hdCBiYXNlID0gZmxvb3IoeCk7XFxuICBpZiAoKHggLSBiYXNlKSA8IDAuNSkge1xcbiAgICByZXR1cm4gZmxvb3IoeCk7XFxuICB9IGVsc2UgaWYgKCh4IC0gYmFzZSkgPiAwLjUpIHtcXG4gICAgcmV0dXJuIGNlaWwoeCk7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAobW9kKGJhc2UsIDIuMCkgPT0gMC4wKSB7XFxuICAgICAgcmV0dXJuIGJhc2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJhc2UgKyAxLjA7XFxuICAgIH1cXG4gIH1cXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1hLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBCaSh0LnNoYXBlLElpKTpuZXcgRWkodC5zaGFwZSxJaSksdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZXhwKHgpIC0gMS4wO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IEJpKHQuc2hhcGUsXCJcXG4gIHZlYzQgcmVzdWx0ID0gbG9nKHgpO1xcbiAgdmVjNCBpc05hTiA9IHZlYzQobGVzc1RoYW4oeCwgdmVjNCgwLjApKSk7XFxuICByZXN1bHQuciA9IGlzTmFOLnIgPT0gMS4wID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPT0gMS4wID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPT0gMS4wID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPT0gMS4wID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiKTpuZXcgRWkodC5zaGFwZSxcImlmICh4IDwgMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4KTtcIiksdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gbG9nKDEuMCArIHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBzcXJ0KHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnJzcXJ0KHQpO3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGludmVyc2VzcXJ0KHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIHggKiB4O1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiAxLjAgLyB4O1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1hLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBCaSh0LnNoYXBlLEZpKTpuZXcgRWkodC5zaGFwZSxOaSksdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJyZXR1cm4gKGEgPCAwLikgPyBiICogYSA6IGE7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IGJHVEVaZXJvID0gdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGJHVEVaZXJvICogYSkgKyAoKHZlYzQoMS4wKSAtIGJHVEVaZXJvKSAqIChhICogKGIgKyB2ZWM0KDEuMCkpKSk7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJyZXR1cm4gKGIgPj0gMS4wKSA/IGEgOiBhICogKGIgKyAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxraSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9hdChpbnQoeCkpO1wiKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KGUub3V0cHV0U2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLG4pfSx0LnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPShyPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQ0xJUFwiKT9uZXcgUG8odC5zaGFwZSk6bmV3IEJvKHQuc2hhcGUpKS5nZXRDdXN0b21TZXR1cEZ1bmMoZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLG51bGwsbyl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBhYnMoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG49bmV3IExvKHQuc2hhcGUpLHI9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxlLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxlLmNvbXBsZXhUZW5zb3JzLmltYWcpXTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4scil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGVwc2lsb24gPSAxLjE5MjA5Mjg5NTUwNzgxMjVlLTc7XFxuICBmbG9hdCB0aHJlc2hvbGQgPSBsb2coZXBzaWxvbikgKyAyLjA7XFxuXFxuICBib29sIHRvb19sYXJnZSA9IHggPiAtdGhyZXNob2xkO1xcbiAgYm9vbCB0b29fc21hbGwgPSB4IDwgdGhyZXNob2xkO1xcblxcbiAgZmxvYXQgcmVzdWx0O1xcbiAgZmxvYXQgZXhwX3ggPSBleHAoeCk7XFxuXFxuICBpZiAodG9vX2xhcmdlKXtcXG4gICAgcmVzdWx0ID0geDtcXG4gIH1cXG4gIGVsc2UgaWYgKHRvb19zbWFsbCl7XFxuICAgIHJlc3VsdCA9IGV4cF94O1xcbiAgfVxcbiAgZWxzZXtcXG4gICAgcmVzdWx0ID0gbG9nKGV4cF94ICsgMS4wKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsQWkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsVGkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gdGFuKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBhc2luKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBhY29zKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxEaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgcmVzdWx0ID0gYXRhbihhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIGF0YW4oYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMS4wKSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxPaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLF9pKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLCdcXG4gIC8vIEVycm9yIGZ1bmN0aW9uIGlzIGNhbGN1bGF0ZWQgYXBwcm94aW1hdGVseSB3aXRoIGVsZW1lbnRhcnkgZnVuY3Rpb24uXFxuICAvLyBTZWUgXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXCIsIEFicmFtb3dpdHogYW5kIFN0ZWd1bi5cXG4gIGZsb2F0IHAgPSAwLjMyNzU5MTE7XFxuICBmbG9hdCBhMSA9IDAuMjU0ODI5NTkyO1xcbiAgZmxvYXQgYTIgPSAtMC4yODQ0OTY3MzY7XFxuICBmbG9hdCBhMyA9IDEuNDIxNDEzNzQxO1xcbiAgZmxvYXQgYTQgPSAtMS40NTMxNTIwMjc7XFxuICBmbG9hdCBhNSA9IDEuMDYxNDA1NDI5O1xcblxcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XFxuICByZXR1cm4gMS4wIC0gKCgoKChhNSp0ICsgYTQpKnQpICsgYTMpKnQgKyBhMikqdCArIGExKSp0KmV4cCgteCp4KTtcXG4nKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBFaSh0LnNoYXBlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxSaStcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiK3QrXCIpO1xcbiAgXCJ9KGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sdC5wcm90b3R5cGUuY29udjJkQnlNYXRNdWw9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQuc2hhcGUsbz10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxpPW4uaW5DaGFubmVscyxzPXJbMF0qclsxXSpyWzJdLHU9bi5vdXRDaGFubmVscyxsPSgxPT09c3x8MT09PXUpJiZpPjFlMyxjPXJbMl0lMiE9MCYmISFvLmlzUGFja2VkO2lmKGx8fCFhLmdldEJvb2woXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpfHwhYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKXx8IWMpe3ZhciBoPXRoaXMucmVzaGFwZSh0LFsxLHJbMF0qclsxXSpyWzJdLG4uaW5DaGFubmVsc10pLHA9dGhpcy5yZXNoYXBlKGUsWzEsbi5pbkNoYW5uZWxzLG4ub3V0Q2hhbm5lbHNdKTtyZXR1cm4gdGhpcy5yZXNoYXBlKHRoaXMuYmF0Y2hNYXRNdWwoaCxwLCExLCExKSxuLm91dFNoYXBlKX12YXIgZj1mdC5tYWtlKFsxLHJbMF0qclsxXSooclsyXSsxKSxuLmluQ2hhbm5lbHNdLHtkYXRhSWQ6dC5kYXRhSWR9LHQuZHR5cGUsdGhpcyksdj1vLnNoYXBlO28uc2hhcGU9by5zaGFwZS5zbGljZSgpLG8uc2hhcGVbby5zaGFwZS5sZW5ndGgtMl0rKyxkKGdlKG8uc2hhcGUsZi5zaGFwZSksZnVuY3Rpb24oKXtyZXR1cm5cInBhY2tlZCByZXNoYXBlIFwiK28uc2hhcGUrXCIgdG8gXCIrZi5zaGFwZStcIiBpc24ndCBmcmVlXCJ9KTt2YXIgbT10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pLGc9dGhpcy5iYXRjaE1hdE11bChmLG0sITEsITEpLHk9dGhpcy50ZXhEYXRhLmdldChnLmRhdGFJZCk7cmV0dXJuIGQoeS5pc1BhY2tlZCxmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hNYXRNdWwgcmVzdWx0IGlzIGV4cGVjdGVkIHRvIGJlIHBhY2tlZFwifSksby5zaGFwZT12LHkuc2hhcGU9bi5vdXRTaGFwZSxmdC5tYWtlKG4ub3V0U2hhcGUse2RhdGFJZDpnLmRhdGFJZH0sZy5kdHlwZSx0aGlzKX0sdC5wcm90b3R5cGUuY29udjJkV2l0aEltMlJvdz1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5maWx0ZXJXaWR0aCxvPW4uZmlsdGVySGVpZ2h0LGE9bi5pbkNoYW5uZWxzLGk9bi5vdXRXaWR0aCxzPW4ub3V0SGVpZ2h0LHU9cipvKmEsbD1zKmksYz1bdSxsXSxoPXQuc3F1ZWV6ZShbMF0pLHA9ZS5yZXNoYXBlKFsxLHUsLTFdKSxmPW5ldyB6YShjLGguc2hhcGUsbiksZD10aGlzLmNvbXBpbGVBbmRSdW4oZixbaF0pLnJlc2hhcGUoWzEsY1swXSxjWzFdXSksdj1uZXcgJGEoZC5zaGFwZSxbMSxsLG4ub3V0Q2hhbm5lbHNdLCEwLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHYsW2QscF0pLnJlc2hhcGUoWzEscyxpLG4ub3V0Q2hhbm5lbHNdKX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09bi5maWx0ZXJIZWlnaHQmJjE9PT1uLmZpbHRlcldpZHRoJiYxPT09bi5kaWxhdGlvbkhlaWdodCYmMT09PW4uZGlsYXRpb25XaWR0aCYmMT09PW4uc3RyaWRlSGVpZ2h0JiYxPT09bi5zdHJpZGVXaWR0aCYmKFwiU0FNRVwiPT09bi5wYWRJbmZvLnR5cGV8fFwiVkFMSURcIj09PW4ucGFkSW5mby50eXBlKSlyZXR1cm4gdGhpcy5jb252MmRCeU1hdE11bCh0LGUsbik7aWYoYS5nZXRCb29sKFwiV0VCR0xfQ09OVl9JTTJDT0xcIikmJjE9PT10LnNoYXBlWzBdKXJldHVybiB0aGlzLmNvbnYyZFdpdGhJbTJSb3codCxlLG4pO3ZhciByPW5ldyBqbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFZvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IHpvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7dmFyIHI7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmbi5zdHJpZGVXaWR0aDw9MiYmbi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHM9PTE/KHI9bmV3IFlvKG4pLHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLHRoaXMubWFrZVBhY2tlZFRlbnNvcihuLm91dFNoYXBlLHQuZHR5cGUpKSk6KHI9bmV3IFhvKG4pLHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKSl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgJG8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgSG8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgS28obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBxbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBHbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEphKGUsXCJtYXhcIiwhMSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLHQuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0scil9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSmEoZSxcImF2Z1wiLCExKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJmbG9hdDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0scil9LHQucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgSmEocixcIm1heFwiLCEwKSxhPXRoaXMuY29tcGlsZUFuZFJ1bihvLFtlXSksaT1uZXcgSGEocikscz10aGlzLm1ha2VPdXRwdXRBcnJheShpLm91dHB1dFNoYXBlLGUuZHR5cGUpLHU9dGhpcy5jb21waWxlQW5kUnVuKGksW3QsYV0scyk7cmV0dXJuIGEuZGlzcG9zZSgpLHV9LHQucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFNvKG4pLG89dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxlLmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdLG8pfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEpuKHQsZSx0aGlzKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlW2VdLHI9bmV3IEFycmF5KHQucmFuay0xKSxvPTAsYT0wO2E8dC5yYW5rO2ErKylhIT09ZSYmKHJbbysrXT10LnNoYXBlW2FdKTt2YXIgaT1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLHM9dC5zaGFwZS5zbGljZSgpO3NbZV09MTt2YXIgdT1uZXcgQXJyYXkobik7Zm9yKGE9MDthPHUubGVuZ3RoO2ErKylpW2VdPWEsdVthXT10aGlzLnNsaWNlKHQsaSxzKS5yZXNoYXBlKHIpO3JldHVybiB1fSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCk7cmV0dXJuIW4uaXNQYWNrZWR8fGdlKHQuc2hhcGUsZSl8fG51bGwhPT1uLnRleHR1cmUmJmdlKG4uc2hhcGUsZSk/Wm4odCxlKTp0aGlzLnBhY2tlZFJlc2hhcGUodCxlKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89YS5nZXRCb29sKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIpP25ldyByaSh0LnNoYXBlLGUsbixyKTpuZXcgbmkodC5zaGFwZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBlaSh0LGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgYWkodC5zaGFwZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgb2kodCxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lP3Q6VG4odCksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPW5ldyBqYShhLGksbiksdT10aGlzLm1ha2VPdXRwdXRBcnJheShzLm91dHB1dFNoYXBlLFwiaW50MzJcIiksbD1zLmdldEN1c3RvbVNldHVwRnVuYyhyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsW29dLHUsbCl9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgS2EodC5zaXplLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gamUoXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIiksYXIodC5kYXRhU3luYygpLGUuZGF0YVN5bmMoKSxuLHIsbyl9LHQucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW5ldyBRbyh0LnNoYXBlLGUuc2hhcGUscixvLGEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxlLG5dKX0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXtkKGU+MSxmdW5jdGlvbigpe3JldHVyblwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZX0pO3ZhciByPXQuc2hhcGVbMF0sbz1cIk5IV0NcIj09PW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1uP3Quc2hhcGVbMl06dC5zaGFwZVszXSxpPVwiTkhXQ1wiPT09bj90LnNoYXBlWzNdOnQuc2hhcGVbMV0scz1vKmUsdT1hKmUsbD1pLyhlKmUpLGM9bmV3IHRhKFwiTkhXQ1wiPT09bj9bcixzLHUsbF06W3IsbCxzLHVdLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihjLFt0XSl9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gc3IodCxlLG4pfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXBuKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsbD1bdS9pLGldLGM9dC5yZXNoYXBlKFthLG9dKSxoPWUucmVzaGFwZShbYSxpXSk7aWYoMD09PXUpcmV0dXJuIFpuKEZuKFtdKSxuKTt2YXIgcD1CbigwKSxmPW5ldyB1aShhLG8sYy5yYW5rLGgucmFuayxzLGwpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZixbaCxjLHBdKS5yZXNoYXBlKG4pfSx0LnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXBuKDAsdCxuKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zdHJpZGVzLHU9by5vdXRwdXRTaXplLGw9bmV3IHVpKGksYSx0LnJhbmssZS5yYW5rLHMsW3UsMV0sITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obCxbZSx0LHJdKS5yZXNoYXBlKG4pfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0SW1wbCh0LCExKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITApfSx0LnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj1uZXcgb2EobmEsdC5zaGFwZSxlKSxvPW5ldyBvYShyYSx0LnNoYXBlLGUpLGE9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxuLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxuLmNvbXBsZXhUZW5zb3JzLmltYWcpXSxpPXRoaXMuY29tcGlsZUFuZFJ1bihyLGEpLHM9dGhpcy5jb21waWxlQW5kUnVuKG8sYSksdT10aGlzLmNvbXBsZXgoaSxzKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk7cmV0dXJuIGkuZGlzcG9zZSgpLHMuZGlzcG9zZSgpLHV9LHQucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz11bih0LGUpLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxsPWUucmVzaGFwZShbaSxyXSksYz10LnJlc2hhcGUoW3Quc2l6ZS9zLHNdKSxoPW5ldyBjYShyLHUsW2ksc10pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxbYyxsXSkucmVzaGFwZShhKX0sdC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7aWYoXCJzdHJpbmdcIj09PShuPW58fFcoZSkpKXt2YXIgcj1BKG4seSh0KSk7cmV0dXJuIHIuZmlsbChlKSxmdC5tYWtlKHQse3ZhbHVlczpyfSxuKX12YXIgbz1uZXcgYWEodCxlKSxhPW8uZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpLGk9dGhpcy5tYWtlT3V0cHV0QXJyYXkodCxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW10saSxhKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCB1bmRlciBzdHJpbmcgZHR5cGVcIik7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLDEsdC5kdHlwZSl9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsXCJzdHJpbmdcIj09PXQuZHR5cGU/XCJcIjowLHQuZHR5cGUpfSx0LnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRyKHQsZSxuKX0sdC5wcm90b3R5cGUubWFrZU91dHB1dEFycmF5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ0Lm1ha2UodCx7fSxlLHRoaXMpfSx0LnByb3RvdHlwZS5tYWtlUGFja2VkVGVuc29yPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZnQubWFrZSh0LHt9LGUsdGhpcyk7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLmlzUGFja2VkPSEwLG59LHQucHJvdG90eXBlLnVucGFja1RlbnNvcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgUGkodC5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxmdC5tYWtlKGUub3V0cHV0U2hhcGUse30sdC5kdHlwZSx0aGlzKSl9LHQucHJvdG90eXBlLnBhY2tUZW5zb3I9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFhhKHQuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sdGhpcy5tYWtlUGFja2VkVGVuc29yKHQuc2hhcGUsdC5kdHlwZSkpfSx0LnByb3RvdHlwZS5wYWNrZWRSZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5yZXNoYXBlKFtmZSh0LnNoYXBlKV0uY29uY2F0KGRlKHQuc2hhcGUpKSkscj1bZmUoZSldLmNvbmNhdChkZShlKSksbz1uZXcgdGkocixuLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW25dKS5yZXNoYXBlKGUpfSx0LnByb3RvdHlwZS5jb21waWxlQW5kUnVuPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7aWYobnVsbD09biYmKG49dC51c2VzUGFja2VkVGV4dHVyZXM/dGhpcy5tYWtlUGFja2VkVGVuc29yKHQub3V0cHV0U2hhcGUsZVswXS5kdHlwZSk6dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5vdXRwdXRTaGFwZSxlWzBdLmR0eXBlKSksMD09PW4uc2l6ZSlyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCkudmFsdWVzPUkobi5kdHlwZSwwKSxuO3ZhciBpPWUubWFwKGZ1bmN0aW9uKGUpe2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkdQR1BVUHJvZ3JhbSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCBpbnB1dC4gRm9yIGNvbXBsZXg2NCBkdHlwZXMsIHBsZWFzZSBzZXBhcmF0ZSB0aGUgcHJvZ3JhbSBpbnRvIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cy5cIik7dmFyIG49by50ZXhEYXRhLmdldChlLmRhdGFJZCk7aWYobnVsbD09bi50ZXh0dXJlKXtpZighdC51c2VzUGFja2VkVGV4dHVyZXMmJnkoZS5zaGFwZSk8PWEuZ2V0TnVtYmVyKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiKSlyZXR1cm57c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm51bGwsaXNVbmlmb3JtOiEwLHVuaWZvcm1WYWx1ZXM6bi52YWx1ZXN9O3QudXNlc1BhY2tlZFRleHR1cmVzJiYobi5pc1BhY2tlZD0hMCxuLnNoYXBlPWUuc2hhcGUpfWVsc2UgaWYoISFuLmlzUGFja2VkIT0hIXQudXNlc1BhY2tlZFRleHR1cmVzKWU9bi5pc1BhY2tlZD9vLnVucGFja1RlbnNvcihlKTpvLnBhY2tUZW5zb3IoZSksbj1vLnRleERhdGEuZ2V0KGUuZGF0YUlkKTtlbHNlIGlmKG4uaXNQYWNrZWQmJiFnZShuLnNoYXBlLGUuc2hhcGUpKXt2YXIgcj1lLGk9ZS5zaGFwZTtlLnNoYXBlPW4uc2hhcGUsZT1vLnBhY2tlZFJlc2hhcGUoZSxpKSxuPW8udGV4RGF0YS5nZXQoZS5kYXRhSWQpLHIuc2hhcGU9aX1yZXR1cm4gby51cGxvYWRUb0dQVShlLmRhdGFJZCkse3NoYXBlOmUuc2hhcGUsdGV4RGF0YTpuLGlzVW5pZm9ybTohMX19KTt0aGlzLnVwbG9hZFRvR1BVKG4uZGF0YUlkKTt2YXIgcyx1PXtzaGFwZTpuLnNoYXBlLHRleERhdGE6dGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCksaXNVbmlmb3JtOiExfSxsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1cIlwiO2UuY29uY2F0KG4pLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9bnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAsbj10LmlzVW5pZm9ybT9cInVuaWZvcm1cIjp0LnRleERhdGEudGV4U2hhcGU7cis9dC5zaGFwZStcIl9cIituK1wiX1wiK2V9KTt2YXIgbz10LnVzZXJDb2RlLGE9dC5jb25zdHJ1Y3Rvci5uYW1lO3JldHVybiBhKz1cIl9cIityK1wiX1wiK299KHQsaSx1KSxjPXRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShsLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWUudXNlckNvZGUsaT1uLm1hcChmdW5jdGlvbih0LG4pe3ZhciByPXtsb2dpY2FsU2hhcGU6dC5zaGFwZSx0ZXhTaGFwZTp0LmlzVW5pZm9ybT9udWxsOnQudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06dC5pc1VuaWZvcm0saXNQYWNrZWQ6IXQuaXNVbmlmb3JtJiZ0LnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfTtyZXR1cm4gbnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAmJihyLmZsYXRPZmZzZXQ9dC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHtuYW1lOmUudmFyaWFibGVOYW1lc1tuXSxzaGFwZUluZm86cn19KSxzPWkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlSW5mb30pLHU9e2xvZ2ljYWxTaGFwZTpyLnNoYXBlLHRleFNoYXBlOnIudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06ITEsaXNQYWNrZWQ6ci50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH0sbD1obyhpLHUsbyxlLnVzZXNQYWNrZWRUZXh0dXJlcyksYz10LmNyZWF0ZVByb2dyYW0obCksaD1udWxsLHA9dC5nZXRVbmlmb3JtTG9jYXRpb24oYyxcIk5BTlwiLCExKTsxPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpJiYoaD10LmdldFVuaWZvcm1Mb2NhdGlvbihjLFwiSU5GSU5JVFlcIiwhMSkpO2Zvcih2YXIgZj17fSxkPTA7ZDxlLnZhcmlhYmxlTmFtZXMubGVuZ3RoO2QrKyl7dmFyIHY9ZS52YXJpYWJsZU5hbWVzW2RdO2Zbdl09dC5nZXRVbmlmb3JtTG9jYXRpb24oYyx2LCExKSxmW1wib2Zmc2V0XCIrdl09dC5nZXRVbmlmb3JtTG9jYXRpb24oYyxcIm9mZnNldFwiK3YsITEpfXJldHVybntwcm9ncmFtOmUsc291cmNlOmwsd2ViR0xQcm9ncmFtOmMsdW5pZm9ybUxvY2F0aW9uczpmLGluU2hhcGVJbmZvczpzLG91dFNoYXBlSW5mbzp1LGluZkxvYzpoLG5hbkxvYzpwfX0oby5ncGdwdSx0LGksdSl9KSxoPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzO3JldHVybiBoJiYocz10aGlzLnN0YXJ0VGltZXIoKSksZnVuY3Rpb24odCxlLG4scixvKXtVYShlLmluU2hhcGVJbmZvcyxuKSxVYShbZS5vdXRTaGFwZUluZm9dLFtyXSk7dmFyIGk9ci50ZXhEYXRhLnRleHR1cmUscz1yLnRleERhdGEudGV4U2hhcGU7ci50ZXhEYXRhLmlzUGFja2VkP3Quc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShpLHNbMF0sc1sxXSk6dC5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKGksc1swXSxzWzFdKSx0LnNldFByb2dyYW0oZS53ZWJHTFByb2dyYW0pLDE9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikmJm51bGwhPT1lLmluZkxvYyYmdC5nbC51bmlmb3JtMWYoZS5pbmZMb2MsMS8wKSxudWxsIT09ZS5uYW5Mb2MmJnQuZ2wudW5pZm9ybTFmKGUubmFuTG9jLE5hTiksbi5mb3JFYWNoKGZ1bmN0aW9uKG4scil7dmFyIG89ZS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbcl0sYT1lLnVuaWZvcm1Mb2NhdGlvbnNbb10saT1lLnVuaWZvcm1Mb2NhdGlvbnNbXCJvZmZzZXRcIitvXTtpZihudWxsIT1hKWlmKG4uaXNVbmlmb3JtKWlmKHkobi5zaGFwZSk8Mil0LmdsLnVuaWZvcm0xZihhLG4udW5pZm9ybVZhbHVlc1swXSk7ZWxzZXt2YXIgcz1uLnVuaWZvcm1WYWx1ZXM7cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8KHM9bmV3IEZsb2F0MzJBcnJheShzKSksdC5nbC51bmlmb3JtMWZ2KGEscyl9ZWxzZSBudWxsIT1uLnRleERhdGEuc2xpY2UmJm51bGwhPWkmJnQuZ2wudW5pZm9ybTFpKGksbi50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHQuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKG4udGV4RGF0YS50ZXh0dXJlLGEscil9KSxudWxsIT1vJiZvKHQsZS53ZWJHTFByb2dyYW0pLHQuZXhlY3V0ZVByb2dyYW0oKX0odGhpcy5ncGdwdSxjLGksdSxyKSxoJiYocz10aGlzLmVuZFRpbWVyKHMpLHRoaXMuYWN0aXZlVGltZXJzLnB1c2goe25hbWU6dC5jb25zdHJ1Y3Rvci5uYW1lLHF1ZXJ5OnRoaXMuZ2V0UXVlcnlUaW1lKHMpfSkpLGEuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIil8fCF0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS5pc1BhY2tlZHx8dC5pc1BhY2tTaGFkZXI/bjp0aGlzLnVucGFja1RlbnNvcihuKX0sdC5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0IGluIHRoaXMuYmluYXJ5Q2FjaGV8fCh0aGlzLmJpbmFyeUNhY2hlW3RdPWUoKSksdGhpcy5iaW5hcnlDYWNoZVt0XX0sdC5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcn0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuZGlzcG9zZWR8fCh0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLmNhbnZhcy5yZW1vdmUoKSxudWxsIT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQmJnRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMucmVtb3ZlKCksdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5JiYodGhpcy5ncGdwdS5wcm9ncmFtPW51bGwsdGhpcy5ncGdwdS5kaXNwb3NlKCkpLHRoaXMuZGlzcG9zZWQ9ITApfSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIG51bGw9PXRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZSYmKHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZT1GZShmdW5jdGlvbigpe3ZhciBlPWEuZ2V0Qm9vbChcIkRFQlVHXCIpO2Euc2V0KFwiREVCVUdcIiwhMSk7dmFyIG49dC5hYnMoQm4oMWUtOCkpLmRhdGFTeW5jKClbMF07cmV0dXJuIGEuc2V0KFwiREVCVUdcIixlKSxuPjA/MzI6MTZ9KSksdGhpcy5mbG9hdFByZWNpc2lvblZhbHVlfSx0LnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sdC5wcm90b3R5cGUudXBsb2FkVG9HUFU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5zaGFwZSxvPW4uZHR5cGUsYT1uLnZhbHVlcyxpPW4udGV4dHVyZSxzPW4udXNhZ2UsdT1uLmlzUGFja2VkO2lmKG51bGw9PWkpe3ZhciBsLGM9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7YyYmKGw9cGVyZm9ybWFuY2Uubm93KCkpO3ZhciBoPXZlKHIsdSk7bi50ZXhTaGFwZT1oO3ZhciBwPXRoaXMuYWNxdWlyZVRleHR1cmUoaCxzLG8sdSk7aWYobi50ZXh0dXJlPXAsbnVsbCE9YSl7aWYodSl7dmFyIGY9ZmUociksZD0xLHY9MTtyLmxlbmd0aCYmKGQ9KGU9ZGUocikpWzBdLHY9ZVsxXSksdGhpcy5ncGdwdS51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUocCxmLGQsdixoWzBdLGhbMV0semkoYSkpfWVsc2UgdGhpcy5ncGdwdS51cGxvYWRNYXRyaXhUb1RleHR1cmUocCxoWzBdLGhbMV0semkoYSkpO24udmFsdWVzPW51bGwsYyYmKHRoaXMudXBsb2FkV2FpdE1zKz1wZXJmb3JtYW5jZS5ub3coKS1sKX19fSx0LnByb3RvdHlwZS5jb252ZXJ0QW5kQ2FjaGVPbkNQVT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLmR0eXBlO3JldHVybiB0aGlzLnJlbGVhc2VHUFVEYXRhKHQpLG4udXNhZ2U9dWEuVVBMT0FELG51bGwhPWUmJihuLnZhbHVlcz1mdW5jdGlvbih0LGUpe2lmKFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIHQ7aWYoXCJpbnQzMlwiPT09ZXx8XCJib29sXCI9PT1lKXtmb3IodmFyIG49XCJpbnQzMlwiPT09ZT9uZXcgSW50MzJBcnJheSh0Lmxlbmd0aCk6bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoOysrciluW3JdPU1hdGgucm91bmQodFtyXSk7cmV0dXJuIG59dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIitlKX0oZSxyKSksbi52YWx1ZXN9LHQucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHRoaXMubnVtQnl0ZXNJbkdQVSs9dGhpcy5jb21wdXRlQnl0ZXModCxuKSwhdGhpcy53YXJuZWRBYm91dE1lbW9yeSYmdGhpcy5udW1CeXRlc0luR1BVPjEwMjQqdGhpcy5udW1NQkJlZm9yZVdhcm5pbmcqMTAyNCl7dmFyIG89KHRoaXMubnVtQnl0ZXNJbkdQVS8xMDI0LzEwMjQpLnRvRml4ZWQoMik7dGhpcy53YXJuZWRBYm91dE1lbW9yeT0hMCxjb25zb2xlLndhcm4oXCJIaWdoIG1lbW9yeSB1c2FnZSBpbiBHUFU6IFwiK28rXCIgTUIsIG1vc3QgbGlrZWx5IGR1ZSB0byBhIG1lbW9yeSBsZWFrXCIpfXJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHQsZSxyKX0sdC5wcm90b3R5cGUuY29tcHV0ZUJ5dGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMF0qdFsxXSpNKGUpfSx0fSgpO2Z1bmN0aW9uIHppKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P3Q6bmV3IEZsb2F0MzJBcnJheSh0KX1PdCgpJiZEdC5yZWdpc3RlckJhY2tlbmQoXCJ3ZWJnbFwiLGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBVaX0sMik7dmFyIFZpPUFuKHthYnNfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhYnNcIik7cmV0dXJuXCJjb21wbGV4NjRcIj09PWUuZHR5cGU/RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbXBsZXhBYnMoZSl9LHskeDplfSk6RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hYnMoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnRvRmxvYXQoKS5zdGVwKC0xKSl9fX0pfX0pLEdpPUFuKHthY29zXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYWNvc1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hY29zKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoQm4oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpLm5lZygpfX19KX19KSxxaT1Bbih7YWNvc2hfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhY29zaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hY29zaChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KG4udG9GbG9hdCgpLnNxdWFyZSgpLnN1YigxKS5zcXJ0KCkpfX19KX19KSxIaT1Bbih7YXNpbl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImFzaW5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXNpbihlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KEJuKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSl9fSksJGk9QW4oe2FzaW5oXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYXNpbmhcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXNpbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChCbigxKS5hZGQobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfX0pLGppPUFuKHthdGFuXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYXRhblwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hdGFuKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkuc3F1YXJlKCkuYWRkKDEpKX19fSl9fSksS2k9QW4oe2F0YW5oXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYXRhbmhcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXRhbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihCbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpKX19fSl9fSksWGk9QW4oe2NlaWxfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJjZWlsXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2VpbChlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksWWk9QW4oe2NsaXBCeVZhbHVlXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcImNsaXBCeVZhbHVlXCIpO3JldHVybiBkKGU8PW4sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNsaXA6IG1pbiAoXCIrZStcIikgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIituK1wiKS5cIn0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG8pe3ZhciBhPXQuY2xpcChyLGUsbik7cmV0dXJuIG8oW3JdKSxhfSx7JHg6cn0sZnVuY3Rpb24odCxyKXt2YXIgbz1yWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LndoZXJlKG8uZ3JlYXRlckVxdWFsKGUpLmxvZ2ljYWxBbmQoby5sZXNzRXF1YWwobikpLFhuKHQpKX19fSl9fSksUWk9QW4oe2Nvc186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImNvc1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5jb3MoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW4oKS5uZWcoKS5tdWwodCl9fX0pfX0pLEppPUFuKHtjb3NoXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiY29zaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5jb3NoKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuc2luaCgpLm11bFN0cmljdCh0KX19fSl9fSksWmk9QW4oe2VyZl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImVyZlwiKTtyZXR1cm4gZChcImludDMyXCI9PT1lLmR0eXBlfHxcImZsb2F0MzJcIj09PWUuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIklucHV0IGR0eXBlIG11c3QgYmUgYGludDMyYCBvciBgZmxvYXQzMmAuXCJ9KSxcImludDMyXCI9PT1lLmR0eXBlJiYoZT1lLnRvRmxvYXQoKSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5lcmYoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnNxdWFyZSgpLm5lZygpLmV4cCgpLm11bCgyL01hdGguc3FydChNYXRoLlBJKSkpfX19KX19KSx0cz1Bbih7ZXhwXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiZXhwXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cChlKTtyZXR1cm4gbihbcl0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChlWzBdKX19fSl9fSksZXM9QW4oe2V4cG0xXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiZXhwbTFcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXhwbTEoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmV4cCgpKX19fSl9fSksbnM9QW4oe2Zsb29yXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiZmxvb3JcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5mbG9vcihlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSkscnM9QW4oe2xvZ186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImxvZ1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2coZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKSl9fX0pfX0pLG9zPUFuKHtsb2cxcF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImxvZzFwXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZzFwKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5hZGQoMSkpfX19KX19KSxhcz1Bbih7bG9nU2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImxvZ1NpZ21vaWRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc29mdHBsdXMoZS5uZWcoKSkubmVnKCk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLm5lZygpLnNpZ21vaWQoKSl9fX0pfX0pLGlzPUFuKHtuZWdfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJuZWdcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5uZWcoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZWcoKX19fSl9fSksc3M9QW4oe3JlY2lwcm9jYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJyZWNpcHJvY2FsXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlY2lwcm9jYWwoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnNxdWFyZSgpLm5lZygpKX19fSl9fSksdXM9QW4oe3JvdW5kXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwicm91bmRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yb3VuZChlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksbHM9QW4oe3JzcXJ0XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwicnNxcnRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQucnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnBvdygxLjUpLm11bCgyKSkubmVnKCl9fX0pfX0pLGNzPUFuKHtzaWdtb2lkXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic2lnbW9pZFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaWdtb2lkKGUpO3JldHVybiBuKFtyXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5tdWwoQm4oMSkuc3ViKG4pKSl9fX0pfX0pLGhzPUFuKHtzaWduXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic2lnblwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpZ24oZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLHBzPUFuKHtpc05hTl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImlzTmFOXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNOYU4oZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLGZzPUFuKHtpc0luZl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImlzSW5mXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNJbmYoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLGRzPUFuKHtpc0Zpbml0ZV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImlzRmluaXRlXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNGaW5pdGUoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLHZzPUFuKHtzaW5fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzaW5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2luKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zKCkubXVsKHQpfX19KX19KSxtcz1Bbih7c2luaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNpbmhcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2luaChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLmNvc2goKS5tdWxTdHJpY3QodCl9fX0pfX0pLGdzPUFuKHtzb2Z0cGx1c186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNvZnRwbHVzXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNvZnRwbHVzKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zaWdtb2lkKCkpfX19KX19KSx5cz1Bbih7c3FydF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNxcnRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc3FydChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxcnQoKS5tdWwoMikpfX19KX19KSx4cz1Bbih7c3F1YXJlXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic3F1YXJlXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXtyZXR1cm4gbihbZV0pLHQuc3F1YXJlKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnRvRmxvYXQoKS5tdWwoMikpfX19KX19KSx3cz1Bbih7c3RlcF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj13bih0LFwieFwiLFwic3RlcFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0ZXAobixlKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksYnM9QW4oe3Rhbl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInRhblwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC50YW4oZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLmNvcygpLnNxdWFyZSgpKX19fSl9fSksQ3M9QW4oe3RhbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJ0YW5oXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnRhbmgoZSk7cmV0dXJuIG4oW3JdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBCbigxKS5zdWIobi5zcXVhcmUoKSkubXVsU3RyaWN0KHQpfX19KX19KTtmdW5jdGlvbiBFcyh0LGUsbixyLG8sYSl7dmFyIGkscyx1PXduKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbD13bihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGM9d24obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPXduKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz13bihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLGQoMj09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoMj09PWwucmFua3x8MT09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDI9PT1jLnJhbmt8fDE9PT1jLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pLG51bGwhPWkmJmQoMj09PWkucmFua3x8MT09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSksbnVsbCE9cyYmZCgyPT09cy5yYW5rfHwxPT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogb2Zmc2V0IG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksTnModSxsLGMscyxpLGEpfWZ1bmN0aW9uIFJzKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9d24odCxcInhcIixcImJhdGNoTm9ybVwiKSxsPXduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksYz13bihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9d24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPXduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksZCgzPT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCgzPT09bC5yYW5rfHwxPT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoMz09PWMucmFua3x8MT09PWMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSksbnVsbCE9aSYmZCgzPT09aS5yYW5rfHwxPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSxudWxsIT1zJiZkKDM9PT1zLnJhbmt8fDE9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxOcyh1LGwsYyxzLGksYSl9ZnVuY3Rpb24gU3ModCxlLG4scixvLGEpe3ZhciBpLHMsdT13bih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGw9d24oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxjPXduKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT13bihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9d24ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDQ9PT1sLnJhbmt8fDE9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCg0PT09Yy5yYW5rfHwxPT09Yy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSxudWxsIT1pJiZkKDQ9PT1pLnJhbmt8fDE9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBzY2FsZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pLG51bGwhPXMmJmQoND09PXMucmFua3x8MT09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLE5zKHUsbCxjLHMsaSxhKX1mdW5jdGlvbiBOcyh0LGUsbixyLG8sYSl7bnVsbD09YSYmKGE9LjAwMSk7dmFyIGkscyx1LGw9d24odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPXduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksaD13bihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtudWxsIT1vJiYoaT13bihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9d24ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxkKGMucmFuaz09PWgucmFuayxmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSksZChudWxsPT1zfHxjLnJhbms9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgb2Zmc2V0IHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSxkKG51bGw9PWl8fGMucmFuaz09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSksdT0wPT09bC5yYW5rfHwxPT09bC5yYW5rP2wuYXM0RCgxLDEsMSxsLnNpemUpOjI9PT1sLnJhbms/bC5hczREKDEsMSxsLnNoYXBlWzBdLGwuc2hhcGVbMV0pOjM9PT1sLnJhbms/bC5hczREKDEsbC5zaGFwZVswXSxsLnNoYXBlWzFdLGwuc2hhcGVbMl0pOmw7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuYmF0Y2hOb3JtYWxpemF0aW9uKHUsa3MoYyksa3MoaCksYSxrcyhpKSxrcyhzKSk7cmV0dXJuIGUoW2wsYyxoLGldKSxufSx7JHg6bCwkbWVhbjpjLCR2YXJpYW5jZTpoLCRzY2FsZTppLCRvZmZzZXQ6c30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPWVbMl0saT1lWzNdLHM9bnVsbD09aT9CbigxKTppLGw9aW8oci5zaGFwZSx1LnNoYXBlKSxjPVtdO2lmKDE9PT1yLnJhbmspe2Zvcih2YXIgaD0wO2g8dS5zaGFwZS5sZW5ndGgtMTsrK2gpYy5wdXNoKHUuc2hhcGVbaF0pO2MucHVzaCgxKX12YXIgcD1uLnN1YihyKSxmPXQubXVsKHMpLGQ9bHMoby5hZGQoQm4oYSkpKSx2PWQubXVsKGQpLm11bChkKS5tdWwoQm4oLS41KSk7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1yLnJhbms/dC5tdWwoWHIoZC5hczREKDEsMSwxLHIuc2hhcGVbMF0pLGMpKS5tdWwocykucmVzaGFwZShuLnNoYXBlKTp0Lm11bChkKS5tdWwocykucmVzaGFwZShuLnNoYXBlKX0sJG1lYW46ZnVuY3Rpb24oKXt2YXIgdD1kLm11bChCbigtMSkpLm11bChmKTtyZXR1cm4gMT09PXIucmFuayYmKHQ9dC5zdW0obCkpLHQucmVzaGFwZShyLnNoYXBlKX0sJHZhcmlhbmNlOmZ1bmN0aW9uKCl7dmFyIHQ9di5tdWwocCkubXVsKGYpO3JldHVybiAxPT09ci5yYW5rJiYodD10LnN1bShsKSksdC5yZXNoYXBlKHIuc2hhcGUpfSwkc2NhbGU6ZnVuY3Rpb24oKXt2YXIgZT1wLm11bChkKSxuPXQubXVsKGUpO3JldHVybiAxPT09ci5yYW5rJiYobj1uLnN1bShsKSksbi5yZXNoYXBlKHIuc2hhcGUpfSwkb2Zmc2V0OmZ1bmN0aW9uKCl7dmFyIGU9dDtyZXR1cm4gMT09PXIucmFuayYmKGU9ZS5zdW0obCkpLGUucmVzaGFwZShyLnNoYXBlKX19fSkucmVzaGFwZShsLnNoYXBlKX1mdW5jdGlvbiBrcyh0KXtyZXR1cm4gbnVsbD09dD9udWxsOjA9PT10LnJhbms/dC5hczFEKCk6MT09PXQucmFuaz90OjI9PT10LnJhbms/dC5hczREKDEsMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0pOjM9PT10LnJhbms/dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pOnR9ZnVuY3Rpb24gSXMoKXtEZShcInRmLmJhdGNoTm9ybWFsaXphdGlvbigpIGlzIGdvaW5nIGF3YXkuIFVzZSB0Zi5iYXRjaE5vcm0oKSBpbnN0ZWFkLCBhbmQgbm90ZSB0aGUgcG9zaXRpb25hbCBhcmd1bWVudCBjaGFuZ2Ugb2Ygc2NhbGUsIG9mZnNldCwgYW5kIHZhcmlhbmNlRXBzaWxvblwiKX12YXIgQXM9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLElzKCksRXModCxlLG4sYSxvLHIpfX0pLFRzPUFuKHtiYXRjaE5vcm1hbGl6YXRpb24zZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSxJcygpLFJzKHQsZSxuLGEsbyxyKX19KSxEcz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uNGRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksSXMoKSxTcyh0LGUsbixhLG8scil9fSksT3M9QW4oe2JhdGNoTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSxJcygpLE5zKHQsZSxuLGEsbyxyKX19KSxfcz1Bbih7YmF0Y2hOb3JtXzpOc30pLE1zPUFuKHtiYXRjaE5vcm0yZF86RXN9KSxGcz1Bbih7YmF0Y2hOb3JtM2RfOlJzfSksQnM9QW4oe2JhdGNoTm9ybTRkXzpTc30pO2Z1bmN0aW9uIFBzKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciBzLHU9VXMoZSksbD11WzBdLGM9dVsxXTtpZihcImNoYW5uZWxzTGFzdFwiPT09aSlzPVtsLGMsdFszXSx0WzNdXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7cz1bbCxjLHRbMV0sdFsxXV19cmV0dXJuIExzKHQscyxuLHIsbyxhLCExLGkpfWZ1bmN0aW9uIExzKHQsZSxuLHIsbyxhLGkscyl7dm9pZCAwPT09aSYmKGk9ITEpLHZvaWQgMD09PXMmJihzPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciB1PVstMSwtMSwtMSwtMV0sbD11WzBdLGM9dVsxXSxoPXVbMl0scD11WzNdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1zKWw9dFswXSxjPXRbMV0saD10WzJdLHA9dFszXTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIrcyk7bD10WzBdLHA9dFsxXSxjPXRbMl0saD10WzNdfXZhciBmLHY9ZVswXSxtPWVbMV0sZz1lWzNdLHk9VXMobikseD15WzBdLGI9eVsxXSxDPVVzKHIpLEU9Q1swXSxSPUNbMV0sUz1Wcyh2LEUpLE49VnMobSxSKSxrPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7dmFyIHUsbCxjO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXt2YXIgaD0wPT09dD9cIlZBTElEXCI6XCJOVU1CRVJcIjt1PXt0b3A6dCxib3R0b206dCxsZWZ0OnQscmlnaHQ6dCx0eXBlOmh9O3ZhciBwPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtudWxsPT1vJiYobz1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0xKTt2YXIgbz1WcyhlLHIpO3JldHVybiBNYXRoLmZsb29yKCh0WzBdKihuLTEpLW4rbykvMil9KHQsZSxyKSk7dmFyIGk9dFswXSxzPXRbMV0sdT1HcygoaS1lKzIqbykvcisxLGEpO2Qodyh1KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK3UrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pO3ZhciBsPUdzKChzLWUrMipvKS9yKzEsYSk7cmV0dXJuIGQodyhsKSxmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiK2wrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pLFt1LGwsbl19KFtlLG4sMV0sYSwxLHIsdCxzKTtsPXBbMF0sYz1wWzFdfWVsc2UgaWYoXCJzYW1lXCI9PT10KXtsPU1hdGguY2VpbChlL3IpLGM9TWF0aC5jZWlsKG4vbyk7dmFyIGY9TWF0aC5tYXgoMCwobC0xKSpyK2EtZSksdj1NYXRoLm1heCgwLChjLTEpKm8raS1uKSxtPU1hdGguZmxvb3IoZi8yKSxnPWYtbSx5PU1hdGguZmxvb3Iodi8yKSx4PXYteTt1PXt0b3A6bSxib3R0b206ZyxsZWZ0OnkscmlnaHQ6eCx0eXBlOlwiU0FNRVwifX1lbHNle2lmKFwidmFsaWRcIiE9PXQpdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIit0KTt1PXt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MCx0eXBlOlwiVkFMSURcIn0sbD1NYXRoLmNlaWwoKGUtYSsxKS9yKSxjPU1hdGguY2VpbCgobi1pKzEpL28pfXJldHVybntwYWRJbmZvOnUsb3V0SGVpZ2h0Omwsb3V0V2lkdGg6Y319KG8sYyxoLHgsYixTLE4sYSksST1rLnBhZEluZm8sQT1rLm91dEhlaWdodCxUPWsub3V0V2lkdGgsRD1pP2cqcDpnO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09cz9mPVtsLEQsQSxUXTpcImNoYW5uZWxzTGFzdFwiPT09cyYmKGY9W2wsQSxULERdKSx7YmF0Y2hTaXplOmwsZGF0YUZvcm1hdDpzLGluSGVpZ2h0OmMsaW5XaWR0aDpoLGluQ2hhbm5lbHM6cCxvdXRIZWlnaHQ6QSxvdXRXaWR0aDpULG91dENoYW5uZWxzOkQscGFkSW5mbzpJLHN0cmlkZUhlaWdodDp4LHN0cmlkZVdpZHRoOmIsZmlsdGVySGVpZ2h0OnYsZmlsdGVyV2lkdGg6bSxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6UyxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpOLGRpbGF0aW9uSGVpZ2h0OkUsZGlsYXRpb25XaWR0aDpSLGluU2hhcGU6dCxvdXRTaGFwZTpmLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIFdzKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPSExKSx2b2lkIDA9PT1pJiYoaT1cImNoYW5uZWxzTGFzdFwiKTt2YXIgcz1bLTEsLTEsLTEsLTEsLTFdLHU9c1swXSxsPXNbMV0sYz1zWzJdLGg9c1szXSxwPXNbNF07aWYoXCJjaGFubmVsc0xhc3RcIj09PWkpdT10WzBdLGw9dFsxXSxjPXRbMl0saD10WzNdLHA9dFs0XTtlbHNle2lmKFwiY2hhbm5lbHNGaXJzdFwiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIraSk7dT10WzBdLHA9dFsxXSxsPXRbMl0sYz10WzNdLGg9dFs0XX12YXIgZixkPWVbMF0sdj1lWzFdLG09ZVsyXSxnPWVbNF0seT16cyhuKSx4PXlbMF0sdz15WzFdLGI9eVsyXSxDPXpzKHIpLEU9Q1swXSxSPUNbMV0sUz1DWzJdLE49ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUsbCl7dmFyIGMsaCxwLGY7aWYoXCJzYW1lXCI9PT10KXtoPU1hdGguY2VpbChlL28pLHA9TWF0aC5jZWlsKG4vYSksZj1NYXRoLmNlaWwoci9pKTt2YXIgZD0oaC0xKSpvK3MtZSx2PShwLTEpKmErdS1uLG09KGYtMSkqaStsLXIsZz1NYXRoLmZsb29yKGQvMikseT1kLWcseD1NYXRoLmZsb29yKHYvMiksdz12LXgsYj1NYXRoLmZsb29yKG0vMiksQz1tLWI7Yz17dG9wOngsYm90dG9tOncsbGVmdDpiLHJpZ2h0OkMsZnJvbnQ6ZyxiYWNrOnksdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT10KXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrdCk7Yz17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsZnJvbnQ6MCxiYWNrOjAsdHlwZTpcIlZBTElEXCJ9LGg9TWF0aC5jZWlsKChlLXMrMSkvbykscD1NYXRoLmNlaWwoKG4tdSsxKS9hKSxmPU1hdGguY2VpbCgoci1sKzEpL2kpfXJldHVybntwYWRJbmZvOmMsb3V0RGVwdGg6aCxvdXRIZWlnaHQ6cCxvdXRXaWR0aDpmfX0obyxsLGMsaCx4LHcsYixWcyhkLEUpLFZzKHYsUiksVnMobSxTKSksaz1OLnBhZEluZm8sST1OLm91dERlcHRoLEE9Ti5vdXRIZWlnaHQsVD1OLm91dFdpZHRoLEQ9YT9nKnA6ZztyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PWk/Zj1bdSxELEksQSxUXTpcImNoYW5uZWxzTGFzdFwiPT09aSYmKGY9W3UsSSxBLFQsRF0pLHtiYXRjaFNpemU6dSxkYXRhRm9ybWF0OmksaW5EZXB0aDpsLGluSGVpZ2h0OmMsaW5XaWR0aDpoLGluQ2hhbm5lbHM6cCxvdXREZXB0aDpJLG91dEhlaWdodDpBLG91dFdpZHRoOlQsb3V0Q2hhbm5lbHM6RCxwYWRJbmZvOmssc3RyaWRlRGVwdGg6eCxzdHJpZGVIZWlnaHQ6dyxzdHJpZGVXaWR0aDpiLGZpbHRlckRlcHRoOmQsZmlsdGVySGVpZ2h0OnYsZmlsdGVyV2lkdGg6bSxkaWxhdGlvbkRlcHRoOkUsZGlsYXRpb25IZWlnaHQ6UixkaWxhdGlvbldpZHRoOlMsaW5TaGFwZTp0LG91dFNoYXBlOmYsZmlsdGVyU2hhcGU6ZX19ZnVuY3Rpb24gVXModCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdF06dH1mdW5jdGlvbiB6cyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOnR9ZnVuY3Rpb24gVnModCxlKXtyZXR1cm4gZTw9MT90OnQrKHQtMSkqKGUtMSl9ZnVuY3Rpb24gR3ModCxlKXtpZighZSlyZXR1cm4gdDtzd2l0Y2goZSl7Y2FzZVwicm91bmRcIjpyZXR1cm4gTWF0aC5yb3VuZCh0KTtjYXNlXCJjZWlsXCI6cmV0dXJuIE1hdGguY2VpbCh0KTtjYXNlXCJmbG9vclwiOnJldHVybiBNYXRoLmZsb29yKHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3VuZGluZ01vZGUgXCIrZSl9fWZ1bmN0aW9uIHFzKHQpe3ZhciBlPVVzKHQpLG49ZVswXSxyPWVbMV07cmV0dXJuIDE9PT1uJiYxPT09cn1mdW5jdGlvbiBIcyh0LGUpe3JldHVybiBxcyh0KXx8cXMoZSl9ZnVuY3Rpb24gJHModCxlLG4scixvLGEpe2QodC5sZW5ndGg9PT1lLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiBpblNoYXBlIChcIit0Lmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK2UucmFuaytcIikgbXVzdCBtYXRjaFwifSk7dmFyIGk9dCxzPWUsdT0hMTszPT09ZS5yYW5rJiYodT0hMCxzPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSxpPVsxLHRbMF0sdFsxXSx0WzJdXSk7dmFyIGw9aVszXSxjPXMuc2hhcGVbM107ZCg0PT09aS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgbGVuZ3RoIFwiK2kubGVuZ3RoK1wiLlwifSksZCg0PT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitzLnJhbmt9KSxkKDQ9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIituLnJhbmt9KSxkKGw9PT1uLnNoYXBlWzJdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiK2wrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzJdK1wiLlwifSksZChjPT09bi5zaGFwZVszXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIrYytcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzNdK1wiLlwifSksbnVsbCE9YSYmZCh3KG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSk7dmFyIGg9THMoaSxuLnNoYXBlLHIsMSxvLGEpLHA9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5jb252MmREZXJJbnB1dChzLG4saCk7cmV0dXJuIGUoW24sc10pLHJ9LHtkeTREOnMsZmlsdGVyOm59LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxpPWVbMV07cmV0dXJue2R5NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gWXModCxuLHIsbyxcIk5IV0NcIiwxLGEpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gSnModCxpLG4uc2hhcGUscixvLGEpfX19KTtyZXR1cm4gdT9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9ZnVuY3Rpb24ganModCxlLG4scixvLGEpe3ZhciBpPXQ7Mz09PXQucmFuayYmKGk9dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgcz1lOzM9PT1zLnJhbmsmJihzPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksZCg0PT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK2kuc2hhcGUrXCIuXCJ9KSxkKDQ9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pLGQoND09PW4ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgXCIrbitcIi5cIn0pLGQoaS5zaGFwZVszXT09PW5bMl0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIraS5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK25bMl0rXCIuXCJ9KSxkKHMuc2hhcGVbM109PT1uWzNdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitzLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzNdK1wiKS5cIn0pLG51bGwhPWEmJmQodyhvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KTt2YXIgdT1McyhpLnNoYXBlLG4sciwxLG8sYSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252MmREZXJGaWx0ZXIoaSxzLHUpfSx7eDREOmksZHk0RDpzfSl9ZnVuY3Rpb24gS3ModCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XToyPT09dC5sZW5ndGg/W3RbMF0sdFsxXSwxXTp0fSh0KSxuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm4gMT09PW4mJjE9PT1yJiYxPT09b312YXIgWHM9QW4oe2NvbnYxZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOV0NcIiksdm9pZCAwPT09YSYmKGE9MSk7dmFyIHM9d24odCxcInhcIixcImNvbnYxZFwiKSx1PXduKGUsXCJmaWx0ZXJcIixcImNvbnYxZFwiKSxsPXMsYz0hMTsyPT09cy5yYW5rJiYoYz0hMCxsPXMuYXMzRCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSkpLGQoMz09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoMz09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxudWxsIT1pJiZkKHcociksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSksZChsLnNoYXBlWzJdPT09dS5zaGFwZVsxXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBkZXB0aCBvZiBpbnB1dCAoXCIrbC5zaGFwZVsyXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Uuc2hhcGVbMV0rXCIuXCJ9KSxkKEhzKG4sYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxRDogRWl0aGVyIHN0cmlkZSBvciBkaWxhdGlvbiBtdXN0IGJlIDEuIEdvdCBzdHJpZGUgXCIrbitcIiBhbmQgZGlsYXRpb24gJ1wiK2ErXCInXCJ9KSxkKFwiTldDXCI9PT1vLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTldDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KTt2YXIgaD11LmFzNEQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSkscD1sLmFzNEQobC5zaGFwZVswXSwxLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSksZj1ZcyhwLGgsWzEsbl0scixcIk5IV0NcIixbMSxhXSxpKTtyZXR1cm4gYz9mLmFzMkQoZi5zaGFwZVsyXSxmLnNoYXBlWzNdKTpmLmFzM0QoZi5zaGFwZVswXSxmLnNoYXBlWzJdLGYuc2hhcGVbM10pfX0pLFlzPUFuKHtjb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTkhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxXSk7dmFyIHM9d24odCxcInhcIixcImNvbnYyZFwiKSx1PXduKGUsXCJmaWx0ZXJcIixcImNvbnYyZFwiKSxsPXMsYz0hMTszPT09cy5yYW5rJiYoYz0hMCxsPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksZCg0PT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLG51bGwhPWkmJmQodyhyKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSxkKGwuc2hhcGVbM109PT11LnNoYXBlWzJdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0IChcIitsLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIn0pLGQoSHMobixhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSxkKFwiTkhXQ1wiPT09byxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pO3ZhciBoPUxzKGwuc2hhcGUsdS5zaGFwZSxuLGEscixpKSxwPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuY29udjJkKGwsdSxoKTtyZXR1cm4gZShbdSxsXSksbn0se3g6bCwkZmlsdGVyOnV9LGZ1bmN0aW9uKHQsZSl7dmFyIG89ZSxpPW9bMF0scz1vWzFdO3JldHVybiBkKHFzKGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSx7eDpmdW5jdGlvbigpe3JldHVybiAkcyhzLnNoYXBlLHQsaSxuLHIpfSwkZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGpzKHMsdCxpLnNoYXBlLG4scil9fX0pO3JldHVybiBjP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH19KSxRcz1Bbih7Y29udjNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dm9pZCAwPT09byYmKG89XCJOREhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxLDFdKTt2YXIgaT13bih0LFwieFwiLFwiY29udjNkXCIpLHM9d24oZSxcImZpbHRlclwiLFwiY29udjNkXCIpLHU9aSxsPSExOzQ9PT1pLnJhbmsmJihsPSEwLHU9aS5hczVEKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXSkpLGQoNT09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoNT09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxkKHUuc2hhcGVbNF09PT1zLnNoYXBlWzNdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGRlcHRoIG9mIGlucHV0IChcIit1LnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrcy5zaGFwZVszXStcIi5cIn0pLGQoZnVuY3Rpb24odCxlKXtyZXR1cm4gS3ModCl8fEtzKGUpfShuLGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M0Q6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pLGQoXCJOREhXQ1wiPT09byxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KTt2YXIgYz1Xcyh1LnNoYXBlLHMuc2hhcGUsbixhLHIpLGg9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5jb252M2QodSxzLGMpO3JldHVybiBlKFt1LHNdKSxufSx7eDp1LCRmaWx0ZXI6c30sZnVuY3Rpb24odCxlKXtkKEtzKGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252M0Q6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KTt2YXIgbz1lWzBdLGk9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe2QodC5sZW5ndGg9PT1lLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiBpblNoYXBlIChcIit0Lmxlbmd0aCtcIikgYW5kIHJhbmsgb2YgZHkgKFwiK2UucmFuaytcIikgbXVzdCBtYXRjaFwifSk7dmFyIGE9dCxpPWUscz0hMTs0PT09ZS5yYW5rJiYocz0hMCxpPWUuYXM1RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10pLGE9WzEsdFswXSx0WzFdLHRbMl0sdFszXV0pO3ZhciB1PWFbNF0sbD1pLnNoYXBlWzRdO2QoNT09PWEubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA1LCBidXQgZ290IGxlbmd0aCBcIithLmxlbmd0aCtcIi5cIn0pLGQoNT09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIraS5yYW5rfSksZCg1PT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrbi5yYW5rfSksZCh1PT09bi5zaGFwZVszXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIit1K1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVszXStcIi5cIn0pLGQobD09PW4uc2hhcGVbNF0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2wrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVs0XStcIi5cIn0pO3ZhciBjPVdzKGEsbi5zaGFwZSxyLDEsbyksaD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjNkRGVySW5wdXQoaSxuLGMpfSx7ZHk1RDppfSk7cmV0dXJuIHM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9KG8uc2hhcGUsdCxpLG4scil9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10OzQ9PT10LnJhbmsmJihhPXQuYXM1RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdLHQuc2hhcGVbM10pKTt2YXIgaT1lOzQ9PT1pLnJhbmsmJihpPWUuYXM1RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10pKSxkKDU9PT1hLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgXCIrYS5zaGFwZStcIi5cIn0pLGQoNT09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSBcIitpLnNoYXBlK1wiLlwifSksZCg1PT09bi5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBcIituK1wiLlwifSksZChhLnNoYXBlWzRdPT09blszXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIithLnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIrblszXStcIi5cIn0pLGQoaS5zaGFwZVs0XT09PW5bNF0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK2kuc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK25bNF0rXCIpLlwifSk7dmFyIHM9V3MoYS5zaGFwZSxuLHIsMSxvKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYzZERlckZpbHRlcihhLGkscyl9LHt4NUQ6YSxkeTVEOml9KX0obyx0LGkuc2hhcGUsbixyKX19fSk7cmV0dXJuIGw/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSksSnM9QW4oe2NvbnYyZERlckZpbHRlcl86anN9KSxacz1Bbih7ZGVwdGh3aXNlQ29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPXduKHQsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIiksdT13bihlLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksbD1zLGM9ITE7Mz09PXMucmFuayYmKGM9ITAsbD1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLGQoND09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKGwuc2hhcGVbM109PT11LnNoYXBlWzJdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyAoXCIrbC5zaGFwZVszXStcIikgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gZmlsdGVyIFwiK3Uuc2hhcGVbMl0rXCIuXCJ9KSxudWxsPT1hJiYoYT1bMSwxXSksZChIcyhuLGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pLG51bGwhPWkmJmQodyhyKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KTt2YXIgaD1McyhsLnNoYXBlLHUuc2hhcGUsbixhLHIsaSwhMCkscD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmRlcHRod2lzZUNvbnYyRChsLHUsaCk7cmV0dXJuIGUoW2wsdV0pLG59LHt4OmwsJGZpbHRlcjp1fSxmdW5jdGlvbih0LGUpe2QocXMoYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSk7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZSxhPSExOzM9PT1lLnJhbmsmJihhPSEwLG89ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgaT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGh3aXNlQ29udjJERGVySW5wdXQobyxuLHIpfSx7ZHk0RDpvfSk7cmV0dXJuIGE/aS5hczNEKGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKTppfShuLnNoYXBlLHQscixoKX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt2YXIgbz10OzM9PT10LnJhbmsmJihvPXQuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKSk7dmFyIGE9ZTtyZXR1cm4gMz09PWEucmFuayYmKGE9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyKG8sYSxyKX0se3g0RDpvLGR5NEQ6YX0pfShuLHQsci5zaGFwZSxoKX19fSk7cmV0dXJuIGM/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfX0pLHR1PUFuKHtzZXBhcmFibGVDb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVsxLDFdKSx2b2lkIDA9PT1pJiYoaT1cIk5IV0NcIik7dmFyIHM9d24odCxcInhcIixcInNlcGFyYWJsZUNvbnYyZFwiKSx1PXduKGUsXCJkZXB0aHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxsPXduKG4sXCJwb2ludHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxjPXMsaD0hMTtpZigzPT09cy5yYW5rJiYoaD0hMCxjPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksXCJOQ0hXXCI9PT1pKXRocm93IG5ldyBFcnJvcihcInNlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgTkhXQyBpcyBzdXBwb3J0ZWRcIik7ZCg0PT09Yy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGRlcHRod2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDQ9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoMT09PWwuc2hhcGVbMF0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrbC5zaGFwZVswXStcIi5cIn0pLGQoMT09PWwuc2hhcGVbMV0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHNlY29uZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrbC5zaGFwZVsxXStcIi5cIn0pO3ZhciBwPXUuc2hhcGVbMl0sZj11LnNoYXBlWzNdO2QobC5zaGFwZVsyXT09PXAqZixmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgdGhpcmQgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSBcIitwKmYrXCIsIGJ1dCBnb3QgXCIrbC5zaGFwZVsyXStcIi5cIn0pO3ZhciB2PVpzKGMsdSxyLG8saSxhKSxtPVlzKHYsbCwxLFwidmFsaWRcIixpKTtyZXR1cm4gaD9tLmFzM0QobS5zaGFwZVsxXSxtLnNoYXBlWzJdLG0uc2hhcGVbM10pOm19fSksZXU9QW4oe2NvbnYyZFRyYW5zcG9zZV86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiAkcyhuLHduKHQsXCJ4XCIsXCJjb252MmRUcmFuc3Bvc2VcIiksd24oZSxcImZpbHRlclwiLFwiY29udjJkVHJhbnNwb3NlXCIpLHIsbyxhKX19KTt2YXIgbnU9QW4oe21hdE11bF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG87dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKTt2YXIgYT13bih0LFwiYVwiLFwibWF0TXVsXCIpLGk9d24oZSxcImJcIixcIm1hdE11bFwiKTtvPVJ0KGEsaSksYT1vWzBdLGk9b1sxXTt2YXIgcz1uP2Euc2hhcGVbYS5yYW5rLTJdOmEuc2hhcGVbYS5yYW5rLTFdLHU9cj9pLnNoYXBlW2kucmFuay0xXTppLnNoYXBlW2kucmFuay0yXSxsPW4/YS5zaGFwZVthLnJhbmstMV06YS5zaGFwZVthLnJhbmstMl0sYz1yP2kuc2hhcGVbaS5yYW5rLTJdOmkuc2hhcGVbaS5yYW5rLTFdLGg9YS5zaGFwZS5zbGljZSgwLC0yKSxwPWkuc2hhcGUuc2xpY2UoMCwtMiksZj15KGgpLHY9eShwKTtkKGEucmFuaz49MiYmaS5yYW5rPj0yJiZhLnJhbms9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIG9mIGF0IGxlYXN0IDIsIGdvdCByYW5rcyBcIithLnJhbmsrXCIgYW5kIFwiK2kucmFuaytcIi5cIn0pLGQoeChoLHApLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK2grXCIpIGFuZCAoXCIrcCtcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIithLnNoYXBlK1wiIGFuZCBcIitpLnNoYXBlK1wiIG11c3QgbWF0Y2guXCJ9KSxkKHM9PT11LGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIrcytcIikgYW5kIChcIit1K1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Euc2hhcGUrXCIgYW5kIFwiK2kuc2hhcGUrXCIgYW5kIHRyYW5zcG9zZUE9XCIrbitcIiBhbmQgdHJhbnNwb3NlQj1cIityK1wiIG11c3QgbWF0Y2guXCJ9KTt2YXIgbT1hLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbbCxjXSksZz1uP2EuYXMzRChmLHMsbCk6YS5hczNEKGYsbCxzKSx3PXI/aS5hczNEKHYsYyx1KTppLmFzM0Qodix1LGMpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LmJhdGNoTWF0TXVsKGcsdyxuLHIpO3JldHVybiBlKFtnLHddKSxvfSx7JGE6ZywkYjp3fSxmdW5jdGlvbih0LGUpe3ZhciBvPWUsYT1vWzBdLGk9b1sxXTtyZXR1cm4gbnx8cj8hbiYmcj97JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoaSwhMSwhMSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGEsITAsITEpfX06biYmIXI/eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHQsITEsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bCh0LCExLCExKX19OnskYTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh0LCEwLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoYSwhMCwhMCl9fTp7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoaSwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKHQsITAsITEpfX19KS5yZXNoYXBlKG0pfX0pLHJ1PUFuKHtkb3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInQxXCIsXCJkb3RcIikscj13bihlLFwidDJcIixcImRvdFwiKTtkKCEoMSE9PW4ucmFuayYmMiE9PW4ucmFua3x8MSE9PXIucmFuayYmMiE9PXIucmFuayksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRvdDogaW5wdXRzIG11c3QgYWxsIGJlIHJhbmsgMSBvciAyLCBidXQgZ290IHJhbmtzIFwiK24ucmFuaytcIiBhbmQgXCIrci5yYW5rK1wiLlwifSk7dmFyIG89MT09PW4ucmFuaz9uLnNpemU6bi5zaGFwZVsxXSxhPTE9PT1yLnJhbms/ci5zaXplOnIuc2hhcGVbMF07cmV0dXJuIGQobz09PWEsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRvdDogaW5uZXIgZGltZW5zaW9ucyBvZiBpbnB1dHMgbXVzdCBtYXRjaCwgYnV0IGdvdCBcIitvK1wiIGFuZCBcIithK1wiLlwifSksMT09PW4ucmFuayYmMT09PXIucmFuaz9uLmFzMkQoMSwtMSkubWF0TXVsKHIuYXMyRCgtMSwxKSkuYXNTY2FsYXIoKToxPT09bi5yYW5rJiYyPT09ci5yYW5rP24uYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpLmFzMUQoKToyPT09bi5yYW5rJiYxPT09ci5yYW5rP24ubWF0TXVsKHIuYXMyRCgtMSwxKSkuYXMxRCgpOm4ubWF0TXVsKHIuYXMyRChyLnNoYXBlWzBdLHIuc2hhcGVbMV0pKX19KSxvdT1Bbih7b3V0ZXJQcm9kdWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ2MVwiLFwib3V0ZXJQcm9kdWN0XCIpLHI9d24oZSxcInYyXCIsXCJvdXRlclByb2R1Y3RcIik7cmV0dXJuIGQoMT09PW4ucmFuayYmMT09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KSxuLmFzMkQoLTEsMSkubWF0TXVsKHIuYXMyRCgxLC0xKSl9fSk7dmFyIGF1PUFuKHtyZXZlcnNlXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO2lmKDA9PT1uLnJhbmspcmV0dXJuIG4uY2xvbmUoKTt2YXIgcj1OKGUsbi5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXZlcnNlKG4scil9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXZlcnNlKHIpfX19KS5yZXNoYXBlQXMobil9fSksaXU9QW4oe3JldmVyc2UxZF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGQoMT09PWUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitlLnJhbmsrXCIuXCJ9KSxhdShlLDApfX0pLHN1PUFuKHtyZXZlcnNlMmRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGQoMj09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTJEOiB4IG11c3QgYmUgcmFuayAyIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSxhdShuLGUpfX0pLHV1PUFuKHtyZXZlcnNlM2RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGQoMz09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSxhdShuLGUpfX0pLGx1PUFuKHtyZXZlcnNlNGRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIGQoND09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSxhdShuLGUpfX0pO2Z1bmN0aW9uIGN1KHQsZSxuLHIsbyxhKXt2YXIgaT13bih0LFwieFwiLFwibWF4UG9vbFwiKSxzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksbnVsbD09ciYmKHI9WzEsMV0pLGQoND09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLGQoSHMobixyKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIityK1wiJ1wifSksbnVsbCE9YSYmZCh3KG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KTt2YXIgbD1QcyhzLnNoYXBlLGUsbixyLG8sYSksYz1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heFBvb2wocyxsKTtyZXR1cm4gZShbcyxuXSksbn0se3g6c30sZnVuY3Rpb24odCxhKXt2YXIgaT1hWzBdLHM9YVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1PXduKHQsXCJkeVwiLFwibWF4UG9vbEJhY2twcm9wXCIpLGw9d24oZSxcImlucHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIiksYz13bihuLFwib3V0cHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIik7ZChsLnJhbms9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIlJhbmsgb2YgaW5wdXQgKFwiK2wucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIrdS5yYW5rK1wiKVwifSksbnVsbD09YSYmKGE9WzEsMV0pLGQoSHMobyxhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2tQcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitvK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoND09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksbnVsbCE9cyYmZCh3KGkpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK3MrXCIgYnV0IGdvdCBwYWQgXCIraStcIi5cIn0pO3ZhciBoPVBzKGwuc2hhcGUscixvLGEsaSxzKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1heFBvb2xCYWNrcHJvcCh1LGwsYyxoKX0seyRkeTp1LCRpbnB1dDpsfSl9KHQsaSxzLGUsbixyLG8pfX19KTtyZXR1cm4gdT9jLmFzM0QoYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM10pOmN9ZnVuY3Rpb24gaHUodCxlLG4scixvLGEpe3ZhciBpPXduKHQsXCJ4XCIsXCJhdmdQb29sXCIsXCJmbG9hdDMyXCIpO251bGw9PXImJihyPVsxLDFdKSxkKEhzKG4sciksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrcitcIidcIn0pO3ZhciBzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksZCg0PT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxudWxsIT1hJiZkKHcobyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pO3ZhciBsPVBzKHMuc2hhcGUsZSxuLHIsbyxhKSxjPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sKHMsbCl9LHt4OnN9LGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT13bih0LFwiZHlcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKSxzPXduKGUsXCJpbnB1dFwiLFwiYXZnUG9vbEJhY2twcm9wXCIpO2Qocy5yYW5rPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJSYW5rIG9mIGlucHV0IChcIitzLnJhbmsrXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiK2kucmFuaytcIilcIn0pLG51bGw9PW8mJihvPVsxLDFdKSxkKEhzKHIsbyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSk7dmFyIHU9cyxsPWksYz0hMTszPT09cy5yYW5rJiYoYz0hMCx1PXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSxsPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksZCg0PT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pO3ZhciBoPVBzKHUuc2hhcGUsbixyLG8sYSkscD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbEJhY2twcm9wKGwsdSxoKX0se2R5NEQ6bCxpbnB1dDREOnV9KTtyZXR1cm4gYz9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9KHQscyxlLG4scixvKX19fSk7cmV0dXJuIGM9Yy5jYXN0KGkuZHR5cGUpLHU/Yy5hczNEKGMuc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdKTpjfXZhciBwdT1Bbih7bWF4UG9vbF86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gY3UodCxlLG4sMSxyLG8pfX0pLGZ1PUFuKHthdmdQb29sXzpmdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBodSh0LGUsbiwxLHIsbyl9fSksZHU9QW4oe3Bvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtudWxsPT1vJiYobz1bMSwxXSksbnVsbD09YSYmKGE9MSksMD09PXImJihyPVwidmFsaWRcIik7dmFyIGk9d24odCxcInhcIixcIm1heFBvb2xcIikscz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLGQoSHMoYSxvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrYStcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSk7dmFyIGwsYz1QcyhzLnNoYXBlLGUsYSxvLHIpLGg9W2MuZGlsYXRpb25IZWlnaHQsYy5kaWxhdGlvbldpZHRoXTtsPVwic2FtZVwiPT09cj9mdW5jdGlvbih0LGUpe3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQrKHQtMSkqKGVbbl0tMSl9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQtMX0pLHI9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZmxvb3IodC8yKX0pLG89bi5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1yW2VdfSk7cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW3JbZV0sb1tlXV19KX0oW2MuZmlsdGVySGVpZ2h0LGMuZmlsdGVyV2lkdGhdLGgpOltbMCwwXSxbMCwwXV07dmFyIHA9MT09PWhbMF0mJjE9PT1oWzFdLGY9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSksbz1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFsxXX0pLGE9dC5jb25jYXQocixvKSxpPWUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQtYVtlXSV0KSV0fSkscz1vLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB0K2lbZV19KSx1PWUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW3JbZV0sc1tlXV19KSxsPWUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuWzAsaVtlXV19KTtyZXR1cm5bdSxsXX0oW2MuaW5IZWlnaHQsYy5pbldpZHRoXSxoLGwpLHY9ZlswXSxtPWZbMV0sZz1wP3I6XCJ2YWxpZFwiLHk9cD9zOiRyKHMsaCx2KSx4PShcImF2Z1wiPT09bj9mdW5jdGlvbigpe3JldHVybiBodSh5LGUsYSwxLGcpfTpmdW5jdGlvbigpe3JldHVybiBjdSh5LGUsYSwxLGcpfSkoKSx3PXA/eDpJcih4LGgsbSk7cmV0dXJuIHU/dy5hczNEKHcuc2hhcGVbMV0sdy5zaGFwZVsyXSx3LnNoYXBlWzNdKTp3fX0pO3ZhciB2dT1Bbih7c2xpY2VfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLGE9d24odCxcInhcIixcInNsaWNlXCIpO2lmKDA9PT1hLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlXCIpO3I9XCJudW1iZXJcIj09dHlwZW9mIGU/W2VdLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLTEpLmZpbGwoMCkpOmUubGVuZ3RoPGEucmFuaz9lLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLWUubGVuZ3RoKS5maWxsKDApKTplLnNsaWNlKCksbz0obz1udWxsPT1uP25ldyBBcnJheShhLnJhbmspLmZpbGwoLTEpOlwibnVtYmVyXCI9PXR5cGVvZiBuP1tuXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKC0xKSk6bi5sZW5ndGg8YS5yYW5rP24uY29uY2F0KG5ldyBBcnJheShhLnJhbmstbi5sZW5ndGgpLmZpbGwoLTEpKTpuKS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD49MD90OihkKC0xPT09dCxmdW5jdGlvbigpe3JldHVyblwiQmFkIHZhbHVlIGluIHNpemVcIn0pLGEuc2hhcGVbZV0tcltlXSl9KSxmdW5jdGlvbih0LGUsbil7ZCh0LnJhbms9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIrZStcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrdC5yYW5rK1wiKS5cIn0pLGQodC5yYW5rPT09bi5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogTGVuZ3RoIG9mIHNpemUgXCIrbitcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrdC5yYW5rK1wiKS5cIn0pO2Zvcih2YXIgcj1mdW5jdGlvbihyKXtkKGVbcl0rbltyXTw9dC5zaGFwZVtyXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBiZWdpbltcIityK1wiXSArIHNpemVbXCIrcitcIl0gKFwiKyhlW3JdK25bcl0pK1wiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIityK1wiXSAoXCIrdC5zaGFwZVtyXStcIilcIn0pfSxvPTA7bzx0LnJhbms7KytvKXIobyl9KGEscixvKTt2YXIgaT1hLnNoYXBlO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2xpY2UoYSxyLG8pfSx7JHg6YX0sZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQucmFuaztuKyspZS5wdXNoKFtyW25dLGlbbl0tcltuXS1vW25dXSk7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucGFkKGUpfX19KX19KSxtdT1Bbih7c2xpY2UxZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJzbGljZTFkXCIpO3JldHVybiBkKDE9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMSB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pLHZ1KHIsW2VdLFtuXSl9fSksZ3U9QW4oe3NsaWNlMmRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwic2xpY2UyZFwiKTtyZXR1cm4gZCgyPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTJkIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSx2dShyLGUsbil9fSkseXU9QW4oe3NsaWNlM2RfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwic2xpY2UzZFwiKTtyZXR1cm4gZCgzPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTNkIGV4cGVjdHMgYSByYW5rLTMgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSx2dShyLGUsbil9fSkseHU9QW4oe3NsaWNlNGRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwic2xpY2U0ZFwiKTtyZXR1cm4gZCg0PT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTRkIGV4cGVjdHMgYSByYW5rLTQgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSx2dShyLGUsbil9fSk7ZnVuY3Rpb24gd3UodCxlLG4scixvKXtyZXR1cm4gZS5yYW5rPG4ucmFuayYmKGU9ZS5yZXNoYXBlKGVuKGUuc2hhcGUscikpKSx0LnJhbms8bi5yYW5rJiYodD10LnJlc2hhcGUoZW4odC5zaGFwZSxyKSkpLHskeDpmdW5jdGlvbigpe3ZhciByPXQubXVsKG4uZXF1YWwoZSkuY2FzdCh0LmR0eXBlKSk7cmV0dXJuIG51bGw9PW8/cjpyLnRyYW5zcG9zZShvKX19fXZhciBidT1Bbih7YWxsXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJhbGxcIixcImJvb2xcIiksbz1OKGUsci5zaGFwZSksYT1vLGk9cm4oYSxyLnJhbmspO251bGwhPWkmJihyPXIudHJhbnNwb3NlKGkpLGE9YW4oYS5sZW5ndGgsci5yYW5rKSk7dmFyIHM9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFsbChyLGEpfSx7JHg6cn0pO2lmKG4pe3ZhciB1PWVuKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxDdT1Bbih7YW55XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJhbnlcIixcImJvb2xcIiksbz1OKGUsci5zaGFwZSksYT1vLGk9cm4oYSxyLnJhbmspO251bGwhPWkmJihyPXIudHJhbnNwb3NlKGkpLGE9YW4oYS5sZW5ndGgsci5yYW5rKSk7dmFyIHM9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFueShyLGEpfSx7JHg6cn0pO2lmKG4pe3ZhciB1PWVuKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxFdT1Bbih7YXJnTWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPXduKHQsXCJ4XCIsXCJhcmdNYXhcIik7bnVsbD09ZSYmKGU9MCk7dmFyIHI9TihlLG4uc2hhcGUpLG89cm4ocixuLnJhbmspO3JldHVybiBudWxsIT1vJiYobj1uLnRyYW5zcG9zZShvKSxyPWFuKHIubGVuZ3RoLG4ucmFuaykpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYXJnTWF4KG4sclswXSk7cmV0dXJuIGUoW25dKSxvfSx7JHg6bn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSl9fSksUnU9QW4oe2FyZ01pbl86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj13bih0LFwieFwiLFwiYXJnTWluXCIpO251bGw9PWUmJihlPTApO3ZhciByPU4oZSxuLnNoYXBlKSxvPXJuKHIsbi5yYW5rKTtyZXR1cm4gbnVsbCE9byYmKG49bi50cmFuc3Bvc2Uobykscj1hbihyLmxlbmd0aCxuLnJhbmspKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LmFyZ01pbihuLHJbMF0pO3JldHVybiBlKFtuXSksb30seyR4Om59LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9fX0pfX0pLFN1PUFuKHtsb2dTdW1FeHBfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcImxvZ1N1bUV4cFwiKSxvPU4oZSxyLnNoYXBlKSxhPXIubWF4KG8sITApLGk9ci5zdWIoYSkuZXhwKCkuc3VtKG8pLmxvZygpLHM9YS5yZXNoYXBlKGkuc2hhcGUpLmFkZChpKTtpZihuKXt2YXIgdT1lbihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksTnU9QW4oe21heF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwibWF4XCIpLG89cixhPU4oZSxyLnNoYXBlKSxpPWEscz1ybihpLHIucmFuayk7bnVsbCE9cyYmKHI9ci50cmFuc3Bvc2UocyksaT1hbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heChyLGkpO3JldHVybiBlKFtvLG5dKSxufSx7JHg6cn0sZnVuY3Rpb24odCxlKXtyZXR1cm4gd3UodCxlWzFdLGVbMF0sYSxzKX0pO2lmKG4pe3ZhciBsPWVuKHUuc2hhcGUsYSk7dT11LnJlc2hhcGUobCl9cmV0dXJuIHV9fSksa3U9QW4oe21lYW5fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcIm1lYW5cIiksbz1OKGUsci5zaGFwZSksYT15KHRuKHIuc2hhcGUsbylbMV0pO3JldHVybiBrbihmdW5jdGlvbih0KXt2YXIgcj1CbihhKTtyZXR1cm57dmFsdWU6KHIuZHR5cGU9PT10LmR0eXBlP3Q6dC5jYXN0KHIuZHR5cGUpKS5kaXYocikuc3VtKGUsbiksZ3JhZEZ1bmM6ZnVuY3Rpb24oZSl7dmFyIG49dC5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24odCl7blt0XT0xfSksZS5yZXNoYXBlKG4pLm11bChHbih0LnNoYXBlLFwiZmxvYXQzMlwiKSkuZGl2KGEpfX19KShyKX19KSxJdT1Bbih7bWluXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJtaW5cIiksbz1yLGE9TihlLHIuc2hhcGUpLGk9YSxzPXJuKGksci5yYW5rKTtudWxsIT1zJiYocj1yLnRyYW5zcG9zZShzKSxpPWFuKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWluKHIsaSk7cmV0dXJuIGUoW28sbl0pLG59LHskeDpyfSxmdW5jdGlvbih0LGUpe3JldHVybiB3dSh0LGVbMV0sZVswXSxhLHMpfSk7aWYobil7dmFyIGw9ZW4odS5zaGFwZSxhKTt1PXUucmVzaGFwZShsKX1yZXR1cm4gdX19KSxBdT1Bbih7bW9tZW50c186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1OKGUsKHQ9d24odCxcInhcIixcIm1vbWVudHNcIikpLnNoYXBlKSxvPXQubWVhbihyLG4pLGE9by5zaGFwZTtufHwoYT1lbihvLnNoYXBlLHIpKTt2YXIgaT10LnRvRmxvYXQoKS5zdWIoby5yZXNoYXBlKGEpKS5zcXVhcmUoKTtyZXR1cm57bWVhbjpvLHZhcmlhbmNlOmkubWVhbihyLG4pfX19KSxUdT1Bbih7c3VtXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJzdW1cIik7XCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpO3ZhciBvPU4oZSxyLnNoYXBlKTtyZXR1cm4ga24oZnVuY3Rpb24odCl7dmFyIGU9cm4obyx0LnJhbmspLHI9byxhPXQ7bnVsbCE9ZSYmKGE9dC50cmFuc3Bvc2UoZSkscj1hbihyLmxlbmd0aCx0LnJhbmspKTt2YXIgaT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3VtKGEscil9LHtwZXJtdXRlZFg6YX0pO2lmKG4pe3ZhciBzPWVuKGkuc2hhcGUsbyk7aT1pLnJlc2hhcGUocyl9cmV0dXJue3ZhbHVlOmksZ3JhZEZ1bmM6ZnVuY3Rpb24oZSl7dmFyIG49dC5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24odCl7blt0XT0xfSksZS5yZXNoYXBlKG4pLm11bChHbih0LnNoYXBlLFwiZmxvYXQzMlwiKSl9fX0pKHIpfX0pLER1PUFuKHtwcm9kXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJwcm9kXCIpO1wiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpKTt2YXIgbz1OKGUsci5zaGFwZSksYT1ybihvLHIucmFuayksaT1vLHM9cjtudWxsIT1hJiYocz1yLnRyYW5zcG9zZShhKSxpPWFuKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5wcm9kKHMsaSl9LHtwZXJtdXRlZFg6c30pO2lmKG4pe3ZhciBsPWVuKHUuc2hhcGUsbyk7dT11LnJlc2hhcGUobCl9cmV0dXJuIHV9fSk7dmFyIE91PUFuKHtlcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJlcXVhbFwiKSxvPXduKGUsXCJiXCIsXCJlcXVhbFwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXF1YWwocixvKX0seyRhOnIsJGI6b30pfX0pLF91PUFuKHtlcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwiZXF1YWxTdHJpY3RcIikscj13bihlLFwiYlwiLFwiZXF1YWxTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZXF1YWxTdHJpY3Q6IFwiKSxuLmVxdWFsKHIpfX0pLE11PUFuKHtncmVhdGVyXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImdyZWF0ZXJcIiksbz13bihlLFwiYlwiLFwiZ3JlYXRlclwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ3JlYXRlcihyLG8pfSx7JGE6ciwkYjpvfSl9fSksRnU9QW4oe2dyZWF0ZXJFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJncmVhdGVyRXF1YWxcIiksbz13bihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ3JlYXRlckVxdWFsKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfSwkYjpmdW5jdGlvbigpe3JldHVybiBYbihyKX19fSl9fSksQnU9QW4oe2dyZWF0ZXJFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyRXF1YWxTdHJpY3Q6IFwiKSxuLmdyZWF0ZXJFcXVhbChyKX19KSxQdT1Bbih7Z3JlYXRlclN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwiZ3JlYXRlclN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJncmVhdGVyU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGdyZWF0ZXJTdHJpY3Q6IFwiKSxuLmdyZWF0ZXIocil9fSksTHU9QW4oe2xlc3NfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibGVzc1wiKSxvPXduKGUsXCJiXCIsXCJsZXNzXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sZXNzKHIsbyl9LHskYTpyLCRiOm99KX19KSxXdT1Bbih7bGVzc0VxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImxlc3NFcXVhbFwiKSxvPXduKGUsXCJiXCIsXCJsZXNzRXF1YWxcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlc3NFcXVhbChyLG8pfSx7JGE6ciwkYjpvfSl9fSksVXU9QW4oe2xlc3NFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibGVzc0VxdWFsU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImxlc3NFcXVhbFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBsZXNzRXF1YWxTdHJpY3Q6IFwiKSxuLmxlc3NFcXVhbChyKX19KSx6dT1Bbih7bGVzc1N0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibGVzc1N0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJsZXNzU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGxlc3NTdHJpY3Q6IFwiKSxuLmxlc3Mocil9fSksVnU9QW4oe25vdEVxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcIm5vdEVxdWFsXCIpLG89d24oZSxcImJcIixcIm5vdEVxdWFsXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5ub3RFcXVhbChyLG8pfSx7JGE6ciwkYjpvfSl9fSksR3U9QW4oe25vdEVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJub3RFcXVhbFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJub3RFcXVhbFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBub3RFcXVhbFN0cmljdDogXCIpLG4ubm90RXF1YWwocil9fSk7dmFyIHF1PUFuKHthZGRfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiYWRkXCIpLG89d24oZSxcImJcIixcImFkZFwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkKHIsbyl9LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQpe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXQsbj1pbyhyLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKHIuc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPXQsbj1pbyhvLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKG8uc2hhcGUpfX19KX19KSxIdT1Bbih7YWRkTl86ZnVuY3Rpb24odCl7ZChBcnJheS5pc0FycmF5KHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGJlIGEgbGlzdCBvZiB0ZW5zb3JzXCJ9KSxkKHQubGVuZ3RoPj0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5hZGROKCksIGJ1dCBnb3QgXCIrdC5sZW5ndGh9KTt2YXIgZT10Lm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB3bih0LFwidGVuc29yc1wiK2UsXCJhZGROXCIpfSksbj1lWzBdO2UuZm9yRWFjaChmdW5jdGlvbih0KXtpZih0LmR0eXBlIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZVwiKX0pLGUuZm9yRWFjaChmdW5jdGlvbih0KXtpZigheCh0LnNoYXBlLG4uc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfSk7dmFyIHI9ZTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZE4oZSl9LHIsZnVuY3Rpb24odCl7dmFyIG49e307cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlLHIpe25bcl09ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX0pLG59KX19KSwkdT1Bbih7YWRkU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJhZGRTdHJpY3RcIikscj13bihlLFwiYlwiLFwiYWRkU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGFkZFN0cmljdDogXCIpLG4uYWRkKHIpfX0pLGp1PUFuKHthdGFuMl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJhdGFuMlwiKSxvPXduKGUsXCJiXCIsXCJhdGFuMlwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmF0YW4yKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9cXUobi5zcXVhcmUoKSxyLnNxdWFyZSgpKSxvPXQubXVsKHIuZGl2KGUpKSxpPWlvKG4uc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUobi5zaGFwZSl9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9cXUobi5zcXVhcmUoKSxyLnNxdWFyZSgpKSxvPWlzKHQubXVsKG4uZGl2KGUpKSksaT1pbyhyLnNoYXBlLGEpO3JldHVybiBpLmxlbmd0aD4wJiYobz1vLnN1bShpKSksby5yZXNoYXBlKHIuc2hhcGUpfX19KX19KSxLdT1Bbih7ZGl2XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImRpdlwiKSxvPXduKGUsXCJiXCIsXCJkaXZcIik7aWYobj1SdChyLG8pLHI9blswXSxvPW5bMV0sXCJpbnQzMlwiPT09ci5kdHlwZSYmXCJpbnQzMlwiPT09by5kdHlwZSlyZXR1cm4gWXUocixvKTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LnJlYWxEaXZpZGUocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT10LmRpdihyLnRvRmxvYXQoKSksbz1pbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1pbyhyLnNoYXBlLGEpO28ubGVuZ3RoPjAmJihlPWUuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSkpO3ZhciBpPXIuc3F1YXJlKCk7cmV0dXJuIGUuZGl2KGkudG9GbG9hdCgpKS5uZWcoKX19fSl9fSksWHU9QW4oe2RpdlN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwiZGl2XCIpLHI9d24oZSxcImJcIixcImRpdlwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBkaXZpZGVTdHJpY3Q6IFwiKSxuLmRpdihyKX19KSxZdT1Bbih7Zmxvb3JEaXZfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiZmxvb3JEaXZcIiksbz13bihlLFwiYlwiLFwiZmxvb3JEaXZcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5mbG9vckRpdihyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXQuZGl2KHIudG9GbG9hdCgpKSxvPWlvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPWlvKHIuc2hhcGUsYSk7by5sZW5ndGg+MCYmKGU9ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKSk7dmFyIGk9ci5zcXVhcmUoKTtyZXR1cm4gZS5kaXYoaS50b0Zsb2F0KCkpLm5lZygpfX19KX19KSxRdT1Bbih7bWF4aW11bV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJtYXhpbXVtXCIpLG89d24oZSxcImJcIixcIm1heGltdW1cIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLFwiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpLG89by50b0ludCgpKSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4aW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmdyZWF0ZXJFcXVhbChyKS50b0Zsb2F0KCkpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxlc3MocikudG9GbG9hdCgpKX19fSl9fSksSnU9QW4oe21heGltdW1TdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcIm1heGltdW1TdHJpY3RcIikscj13bihlLFwiYlwiLFwibWF4aW11bVN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtYXhpbXVtU3RyaWN0OiBcIiksbi5tYXhpbXVtKHIpfX0pLFp1PUFuKHttaW5pbXVtXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcIm1pbmltdW1cIiksbz13bihlLFwiYlwiLFwibWluaW11bVwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCksbz1vLnRvSW50KCkpLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5taW5pbXVtKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubGVzc0VxdWFsKHIpLnRvRmxvYXQoKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZ3JlYXRlcihyKS50b0Zsb2F0KCkpfX19KX19KSx0bD1Bbih7bWluaW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibWluaW11bVN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJtaW5pbXVtU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1pbmltdW1TdHJpY3Q6IFwiKSxuLm1pbmltdW0ocil9fSksZWw9QW4oe21vZF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJtb2RcIiksbz13bihlLFwiYlwiLFwibW9kXCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubW9kKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9aW8obi5zaGFwZSxhKTtyZXR1cm4gZS5sZW5ndGg+MD90LnN1bShlKS5yZXNoYXBlKG4uc2hhcGUpOnR9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi5kaXYocikuZmxvb3IoKS5uZWcoKSksbz1pbyhyLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSk6ZX19fSl9fSksbmw9QW4oe21vZFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibW9kU3RyaWN0XCIpLHI9d24oZSxcImJcIixcIm1vZFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtb2RTdHJpY3Q6IFwiKSxuLm1vZChyKX19KSxybD1Bbih7bXVsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcIm11bFwiKSxvPXduKGUsXCJiXCIsXCJtdWxcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tdWx0aXBseShyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXQubXVsKHIudG9GbG9hdCgpKSxvPWlvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPWlvKHIuc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKTplfX19KX19KSxvbD1Bbih7bXVsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJtdWxcIikscj13bihlLFwiYlwiLFwibXVsXCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG11bHRpcGx5U3RyaWN0OiBcIiksbi5tdWwocil9fSksYWw9QW4oe3Bvd186ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYmFzZVwiLFwicG93XCIpLHI9d24oZSxcImV4cFwiLFwicG93XCIpLG89c28obi5zaGFwZSxyLnNoYXBlKTtyZXR1cm4gdD1uLmNhc3QoQ3Qobi5kdHlwZSxyLmR0eXBlKSksZT1yLmNhc3QoQ3Qobi5kdHlwZSxyLmR0eXBlKSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5wb3cobixyKTtyZXR1cm4gZShbbixyLG9dKSxvfSx7JGJhc2U6biwkZXhwOnJ9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sYT1lWzJdO3JldHVybnskYmFzZTpmdW5jdGlvbigpe3ZhciBlPXIudG9GbG9hdCgpLGE9dC5tdWwoZS5tdWwobi5wb3coZS5zdWIoQm4oMSkpKSkpLGk9aW8obi5zaGFwZSxvKTtyZXR1cm4gaS5sZW5ndGg+MCYmKGE9YS5zdW0oaSkpLGEucmVzaGFwZShuLnNoYXBlKX0sJGV4cDpmdW5jdGlvbigpe3ZhciBlPW4uZ3JlYXRlcigwKSxpPW4ubG9nKCkud2hlcmUoZSxYbihuKSkscz10Lm11bChhLm11bChpKSksdT1pbyhyLnNoYXBlLG8pO3JldHVybiB1Lmxlbmd0aD4wJiYocz1zLnN1bSh1KSkscy5yZXNoYXBlKHIuc2hhcGUpfX19KX19KSxpbD1Bbih7cG93U3RyaWN0XzpmdW5jdGlvbih0LGUpe3JldHVybiB2KHQuc2hhcGUsZS5zaGFwZSxcIkVycm9yIGluIHBvd1N0cmljdDogXCIpLHQucG93KGUpfX0pLHNsPUFuKHtzcXVhcmVkRGlmZmVyZW5jZV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSxvPXduKGUsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LnNxdWFyZWREaWZmZXJlbmNlKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1CbigyKTtyZXR1cm57JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zdWIocikubXVsKG8pKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwoci5zdWIobikubXVsKG8pKX19fSl9fSksdWw9QW4oe3NxdWFyZWREaWZmZXJlbmNlU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDogXCIpLG4uc3F1YXJlZERpZmZlcmVuY2Uocil9fSksbGw9QW4oe3N1Yl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJzdWJcIiksbz13bihlLFwiYlwiLFwic3ViXCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdWJ0cmFjdChyLG8pfSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0KXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT10LG49aW8oci5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShyLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10LG49aW8oby5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUubmVnKCkucmVzaGFwZShvLnNoYXBlKX19fSl9fSksY2w9QW4oe3N1YlN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwic3ViU3RyaWN0XCIpLHI9d24oZSxcImJcIixcInN1YlN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzdWJTdHJpY3Q6IFwiKSxuLnN1YihyKX19KTt2YXIgaGw9QW4oe2xvZ2ljYWxBbmRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIikscj13bihlLFwiYlwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKTtyZXR1cm4gc28obi5zaGFwZSxyLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbEFuZChuLHIpfSx7JGE6biwkYjpyfSl9fSkscGw9QW4oe2xvZ2ljYWxOb3RfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJsb2dpY2FsTm90XCIsXCJib29sXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbE5vdChlKX0seyR4OmV9KX19KSxmbD1Bbih7bG9naWNhbE9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIikscj13bihlLFwiYlwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpO3JldHVybiBzbyhuLnNoYXBlLHIuc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsT3IobixyKX0seyRhOm4sJGI6cn0pfX0pLGRsPUFuKHtsb2dpY2FsWG9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpLHI9d24oZSxcImJcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIik7cmV0dXJuIHNvKG4uc2hhcGUsci5zaGFwZSksZmwodCxlKS5sb2dpY2FsQW5kKGhsKHQsZSkubG9naWNhbE5vdCgpKX19KSx2bD1Bbih7d2hlcmVfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bihlLFwiYVwiLFwid2hlcmVcIiksbz13bihuLFwiYlwiLFwid2hlcmVcIiksYT13bih0LFwiY29uZGl0aW9uXCIsXCJ3aGVyZVwiLFwiYm9vbFwiKTtyZXR1cm4gdihyLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLDE9PT1hLnJhbms/ZChhLnNoYXBlWzBdPT09ci5zaGFwZVswXSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBgYWAgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiBgY29uZGl0aW9uYC5cIn0pOnYoYS5zaGFwZSxvLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LnNlbGVjdChhLHIsbyk7cmV0dXJuIGUoW2FdKSxufSx7JGNvbmRpdGlvbjphLCRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskY29uZGl0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pLnRvRmxvYXQoKX0sJGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5jYXN0KHQuZHR5cGUpKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sb2dpY2FsTm90KCkuY2FzdCh0LmR0eXBlKSl9fX0pfX0pLG1sPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsKGU9d24odCxcImNvbmRpdGlvblwiLFwid2hlcmVBc3luY1wiLFwiYm9vbFwiKSkuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIG49by5zZW50KCkscj1acihlLnNoYXBlLG4pLHQhPT1lJiZlLmRpc3Bvc2UoKSxbMixyXX19KX0pfTt2YXIgZ2w9QW4oe2VsdV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImVsdVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5lbHUoZSk7cmV0dXJuIG4oW3JdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZWx1RGVyKHQsbil9LHtkeTp0LHk6bn0pfX19KX19KSx5bD1Bbih7bGVha3lSZWx1XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS4yKTt2YXIgbj13bih0LFwieFwiLFwibGVha3lSZWx1XCIpO3JldHVybiBRdShCbihlKS5tdWwobiksbil9fSkseGw9QW4oe3ByZWx1XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJwcmVsdVwiKSxyPXduKGUsXCJhbHBoYVwiLFwicHJlbHVcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQucHJlbHUobixyKTtyZXR1cm4gZShbbixyXSksb30seyR4Om4sJGFscGhhOnJ9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1uLmdyZWF0ZXIoMCk7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHZsKG8sdCx0Lm11bChyKSl9LCRhbHBoYTpmdW5jdGlvbigpe3ZhciBlPXZsKG8sWG4odCksdC5tdWwobikpLGE9aW8oci5zaGFwZSx0LnNoYXBlKTtyZXR1cm4gYS5sZW5ndGg+MCYmKGU9ZS5zdW0oYSkpLGUucmVzaGFwZShyLnNoYXBlKX19fSl9fSksd2w9QW4oe3JlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJyZWx1XCIpO3JldHVyblwiYm9vbFwiPT09ZS5kdHlwZT9lLnRvSW50KCk6RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yZWx1KGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3Qobi5zdGVwKCkudG9GbG9hdCgpKX19fSl9fSksYmw9QW4oe3NlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzZWx1XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3ZhciBlPW4uZ3JlYXRlcihCbigwKSkscj1CbihiaSksbz1CbihDaSksYT10Lm11bChvKSxpPXQubXVsKHIpLm11bChuLnRvRmxvYXQoKS5leHAoKSk7cmV0dXJuIHZsKGUsYSxpKX19fSl9fSk7dmFyIENsPUFuKHt0cmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInRyYW5zcG9zZVwiKTtyZXR1cm4gbnVsbD09ZSYmKGU9bi5zaGFwZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pLnJldmVyc2UoKSksZChuLnJhbms9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK24ucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtIFwiK2UrXCIuXCJ9KSxlLmZvckVhY2goZnVuY3Rpb24odCl7ZCh0Pj0wJiZ0PG4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiQWxsIGVudHJpZXMgaW4gJ3Blcm0nIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisobi5yYW5rLTEpK1wiIGJ1dCBnb3QgXCIrZX0pfSksbi5yYW5rPD0xP24uY2xvbmUoKTpEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhbnNwb3NlKG4sZSl9LHskeDpufSxmdW5jdGlvbih0KXt2YXIgbj1vbihlKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC50cmFuc3Bvc2Uobil9fX0pfX0pO3ZhciBFbD1Bbih7bG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ZSYmKGU9NSksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09byYmKG89LjUpO3ZhciBhPXduKHQsXCJ4XCIsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvblwiKTtkKDQ9PT1hLnJhbmt8fDM9PT1hLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICAgIHJhbmsgXCIrYS5yYW5rK1wiLlwifSksZCh3KGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjogZGVwdGhSYWRpdXMgbXVzdCBiZSBhbiBpbnRlZ2VyIGJ1dCBnb3QgZGVwdGhSYWRpdXMgXCIrZStcIi5cIn0pO3ZhciBpPWEscz0hMTszPT09YS5yYW5rJiYocz0hMCxpPWEuYXM0RCgxLGEuc2hhcGVbMF0sYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSk7dmFyIHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsYSl7dmFyIHM9dC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREKGksZSxuLHIsbyk7cmV0dXJuIGEoW2ksc10pLHN9LHt4NEQ6aX0sZnVuY3Rpb24odCxhKXt2YXIgaT1hWzBdLHM9YVsxXTtyZXR1cm57eDREOmZ1bmN0aW9uKCl7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihhKXtyZXR1cm4gYS5MUk5HcmFkKHQsaSxzLGUsbixyLG8pfSx7fSl9fX0pO3JldHVybiBzP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KTt2YXIgUmw9QW4oe25vcm1fOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPVwiZXVjbGlkZWFuXCIpLHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbz1mdW5jdGlvbiB0KGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1udWxsKSwwPT09ZS5yYW5rKXJldHVybiBlLmFicygpO2lmKDEhPT1lLnJhbmsmJm51bGw9PT1yKXJldHVybiB0KGUucmVzaGFwZShbLTFdKSxuLHIpO2lmKDE9PT1lLnJhbmt8fFwibnVtYmVyXCI9PXR5cGVvZiByfHxBcnJheS5pc0FycmF5KHIpJiYxPT09ci5sZW5ndGgpe2lmKDE9PT1uKXJldHVybiBlLmFicygpLnN1bShyKTtpZihuPT09MS8wKXJldHVybiBlLmFicygpLm1heChyKTtpZihuPT09LTEvMClyZXR1cm4gZS5hYnMoKS5taW4ocik7aWYoXCJldWNsaWRlYW5cIj09PW58fDI9PT1uKXJldHVybiBlLmFicygpLnBvdyhCbigyLFwiaW50MzJcIikpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK24pfWlmKEFycmF5LmlzQXJyYXkocikmJjI9PT1yLmxlbmd0aCl7aWYoMT09PW4pcmV0dXJuIGUuYWJzKCkuc3VtKHJbMF0pLm1heChyWzFdLTEpO2lmKG49PT0xLzApcmV0dXJuIGUuYWJzKCkuc3VtKHJbMV0pLm1heChyWzBdKTtpZihuPT09LTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWluKHJbMF0pO2lmKFwiZnJvXCI9PT1ufHxcImV1Y2xpZGVhblwiPT09bilyZXR1cm4gZS5zcXVhcmUoKS5zdW0ocikuc3FydCgpO3Rocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIituKX10aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIGF4aXM6IFwiK3IpfSh0PXduKHQsXCJ4XCIsXCJub3JtXCIpLGUsbiksYT1vLnNoYXBlO2lmKHIpe3ZhciBpPU4obix0LnNoYXBlKTthPWVuKG8uc2hhcGUsaSl9cmV0dXJuIG8ucmVzaGFwZShhKX19KTtmdW5jdGlvbiBTbCh0LGUpe2Zvcih2YXIgbj1bXSxyPXQ7cjxlOysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24gTmwodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbilmb3IodmFyIHI9MDtyPHRbbl0ubGVuZ3RoOysrcillLnB1c2godFtuXVtyXSk7cmV0dXJuIGV9dmFyIGtsPUFuKHtnYXRoZXJfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcj13bih0LFwieFwiLFwiZ2F0aGVyXCIpLG89d24oZSxcImluZGljZXNcIixcImdhdGhlclwiLFwiaW50MzJcIik7bj1OKG4sci5zaGFwZSlbMF07dmFyIGE9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj10LnNoYXBlW25dLG89W10sYT0xLGk9MSxzPTA7czxuO3MrKylvLnB1c2godC5zaGFwZVtzXSksYSo9dC5zaGFwZVtzXTtmb3Iocz0wO3M8ZS5yYW5rO3MrKylvLnB1c2goZS5zaGFwZVtzXSk7Zm9yKHM9bisxO3M8dC5yYW5rO3MrKylvLnB1c2godC5zaGFwZVtzXSksaSo9dC5zaGFwZVtzXTtyZXR1cm57YmF0Y2hTaXplOmEsc2xpY2VTaXplOmksZGltU2l6ZTpyLG91dHB1dFNoYXBlOm99fShyLG8sbik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBhPXQuZ2F0aGVyKHIsby5mbGF0dGVuKCksbik7cmV0dXJuIGUoW29dKSxhfSx7JHg6cn0sZnVuY3Rpb24odCxlKXt2YXIgbz1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3ZhciBlPXIuc2hhcGUsYT1vLnNpemUsaT1lLnNsaWNlKDAsbikscz1pLmxlbmd0aCx1PWUuc2xpY2UobixlLmxlbmd0aCkuc2xpY2UoMSksbD11Lmxlbmd0aCxjPVNsKDAscyksaD1TbChzKzEscysxK2wpLHA9TmwoW2ksW2FdLHVdKSxmPXQucmVzaGFwZShwKSxkPW8ucmVzaGFwZShbYV0pLHY9TmwoW1tzXSxjLGhdKSxtPWYudHJhbnNwb3NlKHYpLGc9SWwobSxkLHIuc2hhcGVbbl0pLHk9b24odik7cmV0dXJuIGc9Zy50cmFuc3Bvc2UoeSl9fX0pLnJlc2hhcGUoYS5vdXRwdXRTaGFwZSl9fSksSWw9QW4oe3Vuc29ydGVkU2VnbWVudFN1bV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIiksbz13bihlLFwic2VnbWVudElkc1wiLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsXCJpbnQzMlwiKTtyZXR1cm4gZCh3KG4pLGZ1bmN0aW9uKCl7cmV0dXJuXCJudW1TZWdtZW50cyBtdXN0IGJlIG9mIGR0eXBlIGludFwifSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIGE9dC51bnNvcnRlZFNlZ21lbnRTdW0ocixvLG4pO3JldHVybiBlKFtvXSksYX0seyR4OnJ9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIG49UXUoZSxYbihlKSkscj1rbCh0LG4pLG89RnUoZSxCbigwLFwiaW50MzJcIikpLGE9ci5yYW5rLW8ucmFuayxpPTA7aTxhOysraSlvPV9yKG8saSsxKTtvPWhsKG8sR24oci5zaGFwZSxcImJvb2xcIikpO3ZhciBzPVhuKHIpO3JldHVybiB2bChvLHIscyl9KHQsbil9fX0pfX0pO3ZhciBBbD1Bbih7YmFzaWNMU1RNQ2VsbF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPXduKHQsXCJmb3JnZXRCaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHM9d24oZSxcImxzdG1LZXJuZWxcIixcImJhc2ljTFNUTUNlbGxcIiksdT13bihuLFwibHN0bUJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksbD13bihyLFwiZGF0YVwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxjPXduKG8sXCJjXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGg9d24oYSxcImhcIixcImJhc2ljTFNUTUNlbGxcIikscD1sLmNvbmNhdChoLDEpLm1hdE11bChzKS5hZGQodSksZj1wLnNoYXBlWzBdLGQ9cC5zaGFwZVsxXS80LHY9W2YsZF0sbT1wLnNsaWNlKFswLDBdLHYpLGc9cC5zbGljZShbMCxkXSx2KSx5PXAuc2xpY2UoWzAsMipkXSx2KSx4PXAuc2xpY2UoWzAsMypkXSx2KSx3PW0uc2lnbW9pZCgpLm11bFN0cmljdChnLnRhbmgoKSkuYWRkU3RyaWN0KGMubXVsU3RyaWN0KGkuYWRkKHkpLnNpZ21vaWQoKSkpLGI9dy50YW5oKCkubXVsU3RyaWN0KHguc2lnbW9pZCgpKTtyZXR1cm5bdyxiXX19KSxUbD1Bbih7bXVsdGlSTk5DZWxsXzpmdW5jdGlvbih0LGUsbixyKXtmb3IodmFyIG89d24oZSxcImRhdGFcIixcIm11bHRpUk5OQ2VsbFwiKSxhPWJuKG4sXCJjXCIsXCJtdWx0aVJOTkNlbGxcIiksaT1ibihyLFwiaFwiLFwibXVsdGlSTk5DZWxsXCIpLHM9byx1PVtdLGw9MDtsPHQubGVuZ3RoO2wrKyl7dmFyIGM9dFtsXShzLGFbbF0saVtsXSk7dS5wdXNoKGNbMF0pLHUucHVzaChjWzFdKSxzPWNbMV19dmFyIGg9W10scD1bXTtmb3IobD0wO2w8dS5sZW5ndGg7bCs9MiloLnB1c2godVtsXSkscC5wdXNoKHVbbCsxXSk7cmV0dXJuW2gscF19fSk7dmFyIERsPUFuKHttb3ZpbmdBdmVyYWdlXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSEwKTt2YXIgYT13bih0LFwidlwiLFwibW92aW5nQXZlcmFnZVwiKSxpPXduKGUsXCJ4XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLHM9d24obixcImRlY2F5XCIsXCJtb3ZpbmdBdmVyYWdlXCIpO1N0KGEsaSksZCh4KGEuc2hhcGUsaS5zaGFwZSksZnVuY3Rpb24oKXtyZXR1cm5cIlNoYXBlIG1pc21hdGNoIGluIHYgYW5kIHhcIn0pO3ZhciB1PUJuKDEpLGw9dS5zdWIocyksYz1pLnN1YihhKS5tdWwobCk7aWYobyl7ZChudWxsIT1yLGZ1bmN0aW9uKCl7cmV0dXJuXCJXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuXCJ9KTt2YXIgaD13bihyLFwic3RlcFwiLFwibW92aW5nQXZlcmFnZVwiKTtjPWMuZGl2KHUuc3ViKGFsKHMsaCkpKX1yZXR1cm4gYS5hZGQoYyl9fSk7dmFyIE9sPUFuKHtzdHJpZGVkU2xpY2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1KXtpZih2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx2b2lkIDA9PT11JiYodT0wKSwwIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJlbGxpcHNpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDAhPT1zKXRocm93IG5ldyBFcnJvcihcIm5ldyBheGlzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dmFyIGw9d24odCxcInhcIixcInN0cmlkZWRTbGljZVwiKTtpZihyLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiAxPT09dH0pKXt2YXIgYz1mbihsLnNoYXBlLGUsbixyLG8sYSxpLHMsdSksaD1jWzBdLHA9Y1sxXSxmPWNbMl0sZD1wLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybi0xPT09Zi5pbmRleE9mKGUpfSk7cmV0dXJuIHZ1KGwsaCxwKS5yZXNoYXBlKGQpfXJldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RyaWRlZFNsaWNlKGwsZSxuLHIsbyxhLGkscyx1KX0seyR4Omx9KX19KTt2YXIgX2w9QW4oe3RvcGtfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0hMCk7dmFyIHI9d24odCxcInhcIixcInRvcGtcIik7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJ0b3BrKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgb2YgcmFuayAxIG9yIGhpZ2hlclwiKTt2YXIgbz1yLnNoYXBlW3Iuc2hhcGUubGVuZ3RoLTFdO2lmKGU+byl0aHJvdyBuZXcgRXJyb3IoXCInaycgcGFzc2VkIHRvIHRvcGsoKSBtdXN0IGJlIDw9IHRoZSBsYXN0IGRpbWVuc2lvbiAoXCIrbytcIikgYnV0IGdvdCBcIitlKTt2YXIgYT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9wayhyLGUsbil9LHskeDpyfSk7cmV0dXJue3ZhbHVlczphWzBdLGluZGljZXM6YVsxXX19fSk7dmFyIE1sPUFuKHtzY2F0dGVyTkRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwiaW5kaWNlc1wiLFwic2NhdHRlck5EXCIsXCJpbnQzMlwiKSxvPXduKGUsXCJ1cGRhdGVzXCIsXCJzY2F0dGVyTkRcIik7cmV0dXJuIGhuKG8scixuKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NhdHRlck5EKHIsbyxuKX0seyRpbmRpY2VzOnIsJHVwZGF0ZXM6b30pfX0pO3ZhciBGbD1Bbih7ZmZ0XzpmdW5jdGlvbih0KXtkKFwiY29tcGxleDY0XCI9PT10LmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrdC5kdHlwZStcIi5cIn0pO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuYXMyRChuLGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZmZ0KHIpfSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSksQmw9QW4oe2lmZnRfOmZ1bmN0aW9uKHQpe2QoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuaWZmdCgpIG11c3QgYmUgY29tcGxleDY0IGJ1dCBnb3QgXCIrdC5kdHlwZStcIi5cIn0pO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuYXMyRChuLGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWZmdChyKX0se2lucHV0OnR9KS5yZXNoYXBlKHQuc2hhcGUpfX0pLFBsPUFuKHtyZmZ0XzpmdW5jdGlvbih0KXtkKFwiZmxvYXQzMlwiPT09dC5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciByZmZ0KCkgbXVzdCBiZSByZWFsIHZhbHVlIGJ1dCBnb3QgXCIrdC5kdHlwZX0pO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuemVyb3NMaWtlKCksbz1Pbih0LHIpLmFzMkQobixlKSxhPUZsKG8pLGk9TWF0aC5mbG9vcihlLzIpKzEscz1fbihhKSx1PU1uKGEpLGw9cy5zcGxpdChbaSxlLWldLHMuc2hhcGUubGVuZ3RoLTEpLGM9dS5zcGxpdChbaSxlLWldLHUuc2hhcGUubGVuZ3RoLTEpLGg9dC5zaGFwZS5zbGljZSgpO3JldHVybiBoW3Quc2hhcGUubGVuZ3RoLTFdPWksT24obFswXSxjWzBdKS5yZXNoYXBlKGgpfX0pLExsPUFuKHtpcmZmdF86ZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lO2lmKGU8PTIpe3ZhciByPXQuYXMyRChuLGUpLG89Qmwocik7cmV0dXJuIF9uKG8pfXZhciBhPVtuLDIqKGUtMSldLGk9X24odCkuYXMyRChuLGUpLHM9TW4odCkuYXMyRChuLGUpLHU9aS5zbGljZShbMCwxXSxbbixlLTJdKS5yZXZlcnNlKDEpLGw9cy5zbGljZShbMCwxXSxbbixlLTJdKS5yZXZlcnNlKDEpLm11bChCbigtMSkpLGM9aS5jb25jYXQodSwxKSxoPXMuY29uY2F0KGwsMSk7cmV0dXJuIHI9T24oYyxoKS5hczJEKGFbMF0sYVsxXSksbz1CbChyKSxfbihvKX19KSxXbD1PYmplY3QuZnJlZXplKHtmZnQ6RmwsaWZmdDpCbCxyZmZ0OlBsLGlyZmZ0OkxsfSk7dmFyIFVsPUFuKHtzcGFyc2VUb0RlbnNlXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0wKTt2YXIgbz13bih0LFwic3BhcnNlSW5kaWNlc1wiLFwic3BhcnNlVG9EZW5zZVwiLFwiaW50MzJcIiksYT13bihlLFwic3BhcnNlVmFsdWVzXCIsXCJzcGFyc2VUb0RlbnNlXCIpLGk9d24ocixcImRlZmF1bHRWYWx1ZVwiLFwic3BhcnNlVG9EZW5zZVwiLGEuZHR5cGUpO3JldHVybiBmdW5jdGlvbih0LGUsbixyKXtpZihcImludDMyXCIhPT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLnNwYXJzZVRvRGVuc2UoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzIFwiK3QuZHR5cGUrXCIuXCIpO2lmKHQucmFuaz4yKXRocm93IG5ldyBFcnJvcihcInNwYXJzZUluZGljZXMgc2hvdWxkIGJlIGEgc2NhbGFyLCB2ZWN0b3IsIG9yIG1hdHJpeCwgYnV0IGdvdCBzaGFwZSBcIit0LnNoYXBlK1wiLlwiKTt2YXIgbz10LnJhbms+MD90LnNoYXBlWzBdOjEsYT10LnJhbms+MT90LnNoYXBlWzFdOjE7aWYobi5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihcIm91dHB1dFNoYXBlIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzOiwgXCIrbi5sZW5ndGgrXCIsIHNob3VsZCBiZTogXCIrYStcIi5cIik7dmFyIGk9ZS5zaXplO2lmKDAhPT1lLnJhbmsmJigxIT09ZS5yYW5rfHxpIT09bykpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzIGhhcyBpbmNvcnJlY3Qgc2hhcGUgXCIrZS5zaGFwZStcIiwgc2hvdWxkIGJlIFtdIG9yIFtcIitvK1wiXVwiKTtpZihlLmR0eXBlIT09ci5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMuZHR5cGUgbXVzdCBtYXRjaCBkZWZhdWx0VmFsdWVzLmR0eXBlXCIpfShvLGEsbixpKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhcnNlVG9EZW5zZShvLGEsbixpKX0seyRzcGFyc2VJbmRpY2VzOm8sJHNwYXJzZVZhbHVlczphLCRkZWZhdWx0VmFsdWU6aX0pfX0pO3ZhciB6bD1Bbih7Z2F0aGVyTkRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24oZSxcImluZGljZXNcIixcImdhdGhlck5EXCIsXCJpbnQzMlwiKSxyPXduKHQsXCJ4XCIsXCJnYXRoZXJORFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdhdGhlck5EKHIsbil9LHskeDpyLCRpbmRpY2VzOm59KX19KTt2YXIgVmw9QW4oe2Ryb3BvdXRfOmZ1bmN0aW9uKHQsZSxuLHIpe2lmKG51bGwhPW4mJiF4KHQuc2hhcGUsbikpdGhyb3cgbmV3IEVycm9yKFwiTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIHlldDogXCIrSlNPTi5zdHJpbmdpZnkobikpO3ZhciBvPXFyKHQuc2hhcGUsMCwxLFwiZmxvYXQzMlwiLHIpLmdyZWF0ZXIoZSk7cmV0dXJuIG89by5kaXYobGwoMSxlKSksdC5tdWwobyl9fSk7ZnVuY3Rpb24gR2wodCxlLG4pe2Zvcih2YXIgcj0xLXQlMixvPW5ldyBGbG9hdDMyQXJyYXkodCksYT0wO2E8dDsrK2Epe3ZhciBpPTIqTWF0aC5QSSphLyh0K3ItMSk7b1thXT1lLW4qTWF0aC5jb3MoaSl9cmV0dXJuIFBuKG8sXCJmbG9hdDMyXCIpfXZhciBxbCxIbD1Bbih7aGFubldpbmRvd186ZnVuY3Rpb24odCl7cmV0dXJuIEdsKHQsLjUsLjUpfX0pLCRsPUFuKHtoYW1taW5nV2luZG93XzpmdW5jdGlvbih0KXtyZXR1cm4gR2wodCwuNTQsLjQ2KX19KTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0Lk1FQU49MV09XCJNRUFOXCIsdFt0LlNVTT0yXT1cIlNVTVwiLHRbdC5TVU1fQllfTk9OWkVST19XRUlHSFRTPTNdPVwiU1VNX0JZX05PTlpFUk9fV0VJR0hUU1wifShxbHx8KHFsPXt9KSk7dmFyIGpsPUFuKHthYnNvbHV0ZURpZmZlcmVuY2VfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPXduKHQsXCJsYWJlbHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxhPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLGk9bnVsbDtudWxsIT1uJiYoaT13bihuLFwid2VpZ2h0c1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpKSx2KG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGFic29sdXRlRGlmZmVyZW5jZTogXCIpO3ZhciBzPW8uc3ViKGEpLmFicygpO3JldHVybiBLbChzLGkscil9fSksS2w9QW4oe2NvbXB1dGVXZWlnaHRlZExvc3NfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgcj13bih0LFwibG9zc2VzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpLG89bnVsbDtudWxsIT1lJiYobz13bihlLFwid2VpZ2h0c1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSk7dmFyIGE9bnVsbD09bz9yOnIubXVsKG8pO2lmKG49PT1xbC5OT05FKXJldHVybiBhO2lmKG49PT1xbC5TVU0pcmV0dXJuIGEuc3VtKCk7aWYobj09PXFsLk1FQU4pe2lmKG51bGw9PW8pcmV0dXJuIGEubWVhbigpO3ZhciBpPXIuc2l6ZS9vLnNpemUscz1hLnN1bSgpLmRpdihvLnN1bSgpKTtyZXR1cm4gaT4xP3MuZGl2KEJuKGkpKTpzfWlmKG49PT1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtpZihudWxsPT1vKXJldHVybiBhLnN1bSgpLmRpdihCbihyLnNpemUpKTt2YXIgdT1vLm11bChHbihyLnNoYXBlKSkubm90RXF1YWwoQm4oMCkpLnN1bSgpLnRvRmxvYXQoKTtyZXR1cm4gYS5zdW0oKS5kaXYodSl9dGhyb3cgRXJyb3IoXCJVbmtub3duIHJlZHVjdGlvbjogXCIrbil9fSksWGw9QW4oe2Nvc2luZURpc3RhbmNlXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPXduKHQsXCJsYWJlbHNcIixcImNvc2luZURpc3RhbmNlXCIpLGk9d24oZSxcInByZWRpY3Rpb25zXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxzPW51bGw7bnVsbCE9ciYmKHM9d24ocixcIndlaWdodHNcIixcImNvc2luZURpc3RhbmNlXCIpKSx2KGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGNvc2luZURpc3RhbmNlOiBcIik7dmFyIHU9Qm4oMSkuc3ViKGEubXVsKGkpLnN1bShuLCEwKSk7cmV0dXJuIEtsKHUscyxvKX19KSxZbD1Bbih7aGluZ2VMb3NzXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz13bih0LFwibGFiZWxzXCIsXCJoaW5nZUxvc3NcIiksYT13bihlLFwicHJlZGljdGlvbnNcIixcImhpbmdlTG9zc1wiKSxpPW51bGw7bnVsbCE9biYmKGk9d24obixcIndlaWdodHNcIixcImhpbmdlTG9zc1wiKSksdihvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBoaW5nZUxvc3M6IFwiKTt2YXIgcz1CbigxKTtvPUJuKDIpLm11bChvKS5zdWIocyk7dmFyIHU9cy5zdWIoby5tdWwoYSkpLnJlbHUoKTtyZXR1cm4gS2wodSxpLHIpfX0pLFFsPUFuKHtodWJlckxvc3NfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09byYmKG89cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9d24odCxcImxhYmVsc1wiLFwiaHViZXJMb3NzXCIpLGk9d24oZSxcInByZWRpY3Rpb25zXCIsXCJodWJlckxvc3NcIikscz1udWxsO251bGwhPW4mJihzPXduKG4sXCJ3ZWlnaHRzXCIsXCJodWJlckxvc3NcIikpLHYoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gaHViZXJMb3NzOiBcIik7dmFyIHU9Qm4ociksbD1pLnN1YihhKS5hYnMoKSxjPVp1KGwsdSksaD1sLnN1YihjKSxwPUJuKC41KS5tdWwoYy5zcXVhcmUoKSkuYWRkKHUubXVsKGgpKTtyZXR1cm4gS2wocCxzLG8pfX0pLEpsPUFuKHtsb2dMb3NzXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTFlLTcpLHZvaWQgMD09PW8mJihvPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPXduKHQsXCJsYWJlbHNcIixcImxvZ0xvc3NcIiksaT13bihlLFwicHJlZGljdGlvbnNcIixcImxvZ0xvc3NcIikscz1udWxsO251bGwhPW4mJihzPXduKG4sXCJ3ZWlnaHRzXCIsXCJsb2dMb3NzXCIpKSx2KGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGxvZ0xvc3M6IFwiKTt2YXIgdT1CbigxKSxsPUJuKHIpLGM9YS5tdWwoaS5hZGQobCkubG9nKCkpLm5lZygpLnN1Yih1LnN1YihhKS5tdWwodS5zdWIoaSkuYWRkKGwpLmxvZygpKSk7cmV0dXJuIEtsKGMscyxvKX19KSxabD1Bbih7bWVhblNxdWFyZWRFcnJvcl86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89d24odCxcImxhYmVsc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxhPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxpPW51bGw7bnVsbCE9biYmKGk9d24obixcIndlaWdodHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIikpLHYoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gbWVhblNxdWFyZWRFcnJvcjogXCIpO3ZhciBzPW8uc3F1YXJlZERpZmZlcmVuY2UoYSk7cmV0dXJuIEtsKHMsaSxyKX19KSx0Yz1Bbih7c2lnbW9pZENyb3NzRW50cm9weV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT13bih0LFwibXVsdGlDbGFzc0xhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxpPXduKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIikscz1udWxsO2lmKG51bGwhPW4mJihzPXduKG4sXCJ3ZWlnaHRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpKSx2KGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHk6IFwiKSxyPjApe3ZhciB1PUJuKHIpLGw9Qm4oMSksYz1CbiguNSk7YT1hLm11bChsLnN1Yih1KSkuYWRkKGMubXVsKHUpKX12YXIgaD1mdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJsYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpLHI9d24oZSxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNcIik7dihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0czogXCIpO3ZhciBvPXIucmVsdSgpLGE9ci5tdWwobiksaT1yLmFicygpLm5lZygpLmV4cCgpLmxvZzFwKCk7cmV0dXJuIG8uc3ViKGEpLmFkZChpKX0oYSxpKTtyZXR1cm4gS2woaCxzLG8pfX0pLGVjPUFuKHtzb2Z0bWF4Q3Jvc3NFbnRyb3B5XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPXduKHQsXCJvbmVob3RMYWJlbHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIiksaT13bihlLFwibG9naXRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLHM9bnVsbDtpZihudWxsIT1uJiYocz13bihuLFwid2VpZ2h0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSksdihhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiBcIikscj4wKXt2YXIgdT1CbihyKSxsPUJuKDEpLGM9Qm4oYS5zaGFwZVsxXSk7YT1hLm11bChsLnN1Yih1KSkuYWRkKHUuZGl2KGMpKX12YXIgaD1mdW5jdGlvbih0LGUsbil7aWYodm9pZCAwPT09biYmKG49LTEpLC0xPT09biYmKG49ZS5yYW5rLTEpLG4hPT1lLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggY3Jvc3MgZW50cm9weSBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rIFwiK2UucmFuaytcIiBhbmQgZGltIHdhcyBcIituKTtyZXR1cm4ga24oZnVuY3Rpb24odCxlLHIpe3ZhciBvPWUubG9nU3VtRXhwKFtuXSwhMCksYT1lLnRvRmxvYXQoKS5zdWIobyk7cmV0dXJuIHIoW3QsYV0pLHt2YWx1ZTphLm11bCh0KS5uZWcoKS5zdW0oW25dKSxncmFkRnVuYzpmdW5jdGlvbih0LGUpe3ZhciByPWVbMF0sbz1lWzFdLGE9ZW4odC5zaGFwZSxbbl0pO3JldHVyblt0LnJlc2hhcGUoYSkubXVsKHIudG9GbG9hdCgpLnN1YihvLmV4cCgpKSksdC5yZXNoYXBlKGEpLm11bChvLmV4cCgpLnN1YihyLnRvRmxvYXQoKSkpXX19fSkodCxlKX0oYSxpKTtyZXR1cm4gS2woaCxzLG8pfX0pLG5jPU9iamVjdC5mcmVlemUoe2dldCBSZWR1Y3Rpb24oKXtyZXR1cm4gcWx9LGFic29sdXRlRGlmZmVyZW5jZTpqbCxjb21wdXRlV2VpZ2h0ZWRMb3NzOktsLGNvc2luZURpc3RhbmNlOlhsLGhpbmdlTG9zczpZbCxodWJlckxvc3M6UWwsbG9nTG9zczpKbCxtZWFuU3F1YXJlZEVycm9yOlpsLHNpZ21vaWRDcm9zc0VudHJvcHk6dGMsc29mdG1heENyb3NzRW50cm9weTplY30pO2Z1bmN0aW9uIHJjKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSxEdC50aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInFyMmQoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhIFwiK3Quc2hhcGUubGVuZ3RoK1wiRCBUZW5zb3IuXCIpO2Zvcih2YXIgbj10LnNoYXBlWzBdLHI9dC5zaGFwZVsxXSxvPU1yKG4pLGE9dC5jbG9uZSgpLGk9TG4oW1sxXV0sWzEsMV0pLHM9aS5jbG9uZSgpLHU9bj49cj9yOm4sbD1mdW5jdGlvbih0KXt2YXIgZSx1PWEsbD1zLGM9bztlPUR0LnRpZHkoZnVuY3Rpb24oKXt2YXIgZT1hLnNsaWNlKFt0LHRdLFtuLXQsMV0pLHU9ZS5ub3JtKCksbD1hLnNsaWNlKFt0LHRdLFsxLDFdKSxjPWwuc2lnbigpLm5lZygpLGg9bC5zdWIoYy5tdWwodSkpLHA9ZS5kaXYoaCk7cz0xPT09cC5zaGFwZVswXT9pLmNsb25lKCk6aS5jb25jYXQocC5zbGljZShbMSwwXSxbcC5zaGFwZVswXS0xLHAuc2hhcGVbMV1dKSwwKTt2YXIgZj1jLm1hdE11bChoKS5kaXYodSkubmVnKCksZD1hLnNsaWNlKFt0LDBdLFtuLXQscl0pLHY9Zi5tdWwocyk7YT0wPT09dD9kLnN1Yih2Lm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChkKSkpOmEuc2xpY2UoWzAsMF0sW3Qscl0pLmNvbmNhdChkLnN1Yih2Lm1hdE11bChzLnRyYW5zcG9zZSgpLm1hdE11bChkKSkpLDApO3ZhciBtPW8uc2xpY2UoWzAsdF0sW24sby5zaGFwZVsxXS10XSk7cmV0dXJuIG89MD09PXQ/bS5zdWIobS5tYXRNdWwocykubWF0TXVsKHYudHJhbnNwb3NlKCkpKTpvLnNsaWNlKFswLDBdLFtuLHRdKS5jb25jYXQobS5zdWIobS5tYXRNdWwocykubWF0TXVsKHYudHJhbnNwb3NlKCkpKSwxKSxbcyxhLG9dfSkscz1lWzBdLGE9ZVsxXSxvPWVbMl0sQmUoW3UsbCxjXSl9LGM9MDtjPHU7KytjKWwoYyk7cmV0dXJuIWUmJm4+ciYmKG89by5zbGljZShbMCwwXSxbbixyXSksYT1hLnNsaWNlKFswLDBdLFtyLHJdKSksW28sYV19KX12YXIgb2M9QW4oe2dyYW1TY2htaWR0XzpmdW5jdGlvbih0KXt2YXIgZTtpZihBcnJheS5pc0FycmF5KHQpKXtlPSExLGQobnVsbCE9dCYmdC5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0IHByb2Nlc3M6IGlucHV0IG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHlcIn0pO2Zvcih2YXIgbj10WzBdLnNoYXBlWzBdLHI9ZnVuY3Rpb24oZSl7ZCh0W2VdLnNoYXBlWzBdPT09bixmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0OiBOb24tdW5pcXVlIGxlbmd0aHMgZm91bmQgaW4gdGhlIGlucHV0IHZlY3RvcnM6IChcIit0W2VdLnNoYXBlWzBdK1wiIHZzLiBcIituK1wiKVwifSl9LG89MTtvPHQubGVuZ3RoOysrbylyKG8pfWVsc2UgZT0hMCx0PWRyKHQsdC5zaGFwZVswXSwwKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGpyKHQsWzBdKX0pO2QodC5sZW5ndGg8PXRbMF0uc2hhcGVbMF0sZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdDogTnVtYmVyIG9mIHZlY3RvcnMgKFwiK3QubGVuZ3RoK1wiKSBleGNlZWRzIG51bWJlciBvZiBkaW1lbnNpb25zIChcIit0WzBdLnNoYXBlWzBdK1wiKS5cIn0pO3ZhciBhPVtdLGk9dCxzPWZ1bmN0aW9uKHQpe2EucHVzaChEdC50aWR5KGZ1bmN0aW9uKCl7dmFyIGU9aVt0XTtpZih0PjApZm9yKHZhciBuPTA7bjx0Oysrbil7dmFyIHI9VHUoYVtuXS5tdWxTdHJpY3QoZSkpLm11bChhW25dKTtlPWUuc3ViKHIpfXJldHVybiBlLmRpdihSbChlLFwiZXVjbGlkZWFuXCIpKX0pKX07Zm9yKG89MDtvPHQubGVuZ3RoOysrbylzKG8pO3JldHVybiBlP0tyKGEsMCk6YX19KSxhYz1Bbih7cXJfOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9ITEpLHQucmFuazwyKXRocm93IG5ldyBFcnJvcihcInFyKCkgcmVxdWlyZXMgaW5wdXQgdGVuc29yIHRvIGhhdmUgYSByYW5rID49IDIsIGJ1dCBnb3QgcmFuayBcIit0LnJhbmspO2lmKDI9PT10LnJhbmspcmV0dXJuIHJjKHQsZSk7dmFyIG49dC5zaGFwZS5zbGljZSgwLHQuc2hhcGUubGVuZ3RoLTIpLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSxyPVFyKHQucmVzaGFwZShbbix0LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTJdLHQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV1dKSwwKSxvPVtdLGE9W107cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj1yYyh0LGUpLHI9blswXSxpPW5bMV07by5wdXNoKHIpLGEucHVzaChpKX0pLFtLcihvLDApLnJlc2hhcGUodC5zaGFwZSksS3IoYSwwKS5yZXNoYXBlKHQuc2hhcGUpXX19KSxpYz1PYmplY3QuZnJlZXplKHtncmFtU2NobWlkdDpvYyxxcjphY30pO2Z1bmN0aW9uIHNjKHQsZSxuLHIsbyl7bnVsbD09ciYmKHI9LjUpLG51bGw9PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7dmFyIGE9dC5zaGFwZVswXTtyZXR1cm4gbj1NYXRoLm1pbihuLGEpLGQoMDw9ciYmcjw9MSxmdW5jdGlvbigpe3JldHVyblwiaW91VGhyZXNob2xkIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIityK1wiJ1wifSksZCgyPT09dC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJib3hlcyBtdXN0IGJlIGEgMkQgdGVuc29yLCBidXQgd2FzIG9mIHJhbmsgJ1wiK3QucmFuaytcIidcIn0pLGQoND09PXQuc2hhcGVbMV0sZnVuY3Rpb24oKXtyZXR1cm5cImJveGVzIG11c3QgaGF2ZSA0IGNvbHVtbnMsIGJ1dCAybmQgZGltZW5zaW9uIHdhcyBcIit0LnNoYXBlWzFdfSksZCgxPT09ZS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgbXVzdCBiZSBhIDFEIHRlbnNvclwifSksZChlLnNoYXBlWzBdPT09YSxmdW5jdGlvbigpe3JldHVyblwic2NvcmVzIGhhcyBpbmNvbXBhdGlibGUgc2hhcGUgd2l0aCBib3hlcy4gRXhwZWN0ZWQgXCIrYStcIiwgYnV0IHdhcyBcIitlLnNoYXBlWzBdfSkse21heE91dHB1dFNpemU6bixpb3VUaHJlc2hvbGQ6cixzY29yZVRocmVzaG9sZDpvfX12YXIgdWM9QW4oe3Jlc2l6ZUJpbGluZWFyXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJpbWFnZXNcIixcInJlc2l6ZUJpbGluZWFyXCIpO2QoMz09PXIucmFua3x8ND09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3IucmFuaytcIi5cIn0pLGQoMj09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrZStcIi5cIn0pO3ZhciBvPXIsYT0hMTszPT09ci5yYW5rJiYoYT0hMCxvPXIuYXM0RCgxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZShbb10pLHQucmVzaXplQmlsaW5lYXIobyxpLHMsbil9LHtiYXRjaEltYWdlczpvfSxmdW5jdGlvbih0LGUpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24ocil7cmV0dXJuIHIucmVzaXplQmlsaW5lYXJCYWNrcHJvcCh0LGVbMF0sbil9LHt9KX19fSk7cmV0dXJuIGE/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pLGxjPUFuKHtyZXNpemVOZWFyZXN0TmVpZ2hib3JfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcImltYWdlc1wiLFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2QoMz09PXIucmFua3x8ND09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIityLnJhbmsrXCIuXCJ9KSxkKDI9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIitlK1wiLlwifSksZChcImZsb2F0MzJcIj09PXIuZHR5cGV8fFwiaW50MzJcIj09PXIuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cImBpbWFnZXNgIG11c3QgaGF2ZSBgaW50MzJgIG9yIGBmbG9hdDMyYCBhcyBkdHlwZVwifSk7dmFyIG89cixhPSExOzM9PT1yLnJhbmsmJihhPSEwLG89ci5hczREKDEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0pKTt2YXIgaT1lWzBdLHM9ZVsxXSx1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3JldHVybiBlKFtvXSksdC5yZXNpemVOZWFyZXN0TmVpZ2hib3IobyxpLHMsbil9LHtiYXRjaEltYWdlczpvfSxmdW5jdGlvbih0LGUpe3JldHVybntiYXRjaEltYWdlczpmdW5jdGlvbigpe3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24ocil7cmV0dXJuIHIucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3AodCxlWzBdLG4pfSx7fSl9fX0pO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSxjYz1Bbih7bm9uTWF4U3VwcHJlc3Npb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9LjUpLHZvaWQgMD09PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7dmFyIGE9d24odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxpPXduKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9c2MoYSxpLG4scixvKTtyZXR1cm4gbj1zLm1heE91dHB1dFNpemUscj1zLmlvdVRocmVzaG9sZCxvPXMuc2NvcmVUaHJlc2hvbGQsRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vbk1heFN1cHByZXNzaW9uKGEsaSxuLHIsbyl9LHskYm94ZXM6YX0pfX0pLGhjPWZ1bmN0aW9uKHQsZSxuLGEsaSl7cmV0dXJuIHZvaWQgMD09PWEmJihhPS41KSx2b2lkIDA9PT1pJiYoaT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIscyx1LGwsYyxoO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gcj13bih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIikscz13bihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHU9c2MocixzLG4sYSxpKSxuPXUubWF4T3V0cHV0U2l6ZSxhPXUuaW91VGhyZXNob2xkLGk9dS5zY29yZVRocmVzaG9sZCxbNCxyLmRhdGEoKV07Y2FzZSAxOnJldHVybiBsPW8uc2VudCgpLFs0LHMuZGF0YSgpXTtjYXNlIDI6cmV0dXJuIGM9by5zZW50KCksaD1hcihsLGMsbixhLGkpLHIhPT10JiZyLmRpc3Bvc2UoKSxzIT09ZSYmcy5kaXNwb3NlKCksWzIsaF19fSl9KX0scGM9QW4oe2Nyb3BBbmRSZXNpemVfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT13bih0LFwiaW1hZ2VcIixcImNyb3BBbmRSZXNpemVcIixcImZsb2F0MzJcIikscz13bihlLFwiYm94ZXNcIixcImNyb3BBbmRSZXNpemVcIixcImZsb2F0MzJcIiksdT13bihuLFwiYm94SW5kXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJpbnQzMlwiKTtvPW98fFwiYmlsaW5lYXJcIixhPWF8fDA7dmFyIGw9cy5zaGFwZVswXTtyZXR1cm4gZCg0PT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBpbWFnZSBtdXN0IGJlIHJhbmsgNCxidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSksZCgyPT09cy5yYW5rJiY0PT09cy5zaGFwZVsxXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94ZXMgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2wrXCIsNF0gYnV0IGhhZCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSksZCgxPT09dS5yYW5rJiZ1LnNoYXBlWzBdPT09bCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94SW5kIG11c3QgYmUgaGF2ZSBzaXplIFtcIitsK1wiXSBidXQgaGFkIHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSxkKDI9PT1yLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogY3JvcFNpemUgbXVzdCBiZSBvZiBsZW5ndGggMiwgYnV0IGdvdCBsZW5ndGggXCIrci5sZW5ndGgrXCIuXCJ9KSxkKHJbMF0+PTEmJnJbMV0+PTEsZnVuY3Rpb24oKXtyZXR1cm5cImNyb3BTaXplIG11c3QgYmUgYXRsZWFzdCBbMSwxXSwgYnV0IHdhcyBcIityfSksZChcImJpbGluZWFyXCI9PT1vfHxcIm5lYXJlc3RcIj09PW8sZnVuY3Rpb24oKXtyZXR1cm5cIm1ldGhvZCBtdXN0IGJlIGJpbGluZWFyIG9yIG5lYXJlc3QsIGJ1dCB3YXMgXCIrb30pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3JldHVybiB0LmNyb3BBbmRSZXNpemUoaSxzLHUscixvLGEpfSx7JGltYWdlOmksJGJveGVzOnN9KX19KSxmYz1PYmplY3QuZnJlZXplKHtyZXNpemVCaWxpbmVhcjp1YyxyZXNpemVOZWFyZXN0TmVpZ2hib3I6bGMsbm9uTWF4U3VwcHJlc3Npb246Y2Msbm9uTWF4U3VwcHJlc3Npb25Bc3luYzpoYyxjcm9wQW5kUmVzaXplOnBjfSk7dmFyIGRjPUFuKHttYXRNdWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaTt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PWEmJihhPVwibGluZWFyXCIpO3ZhciBzPXduKHQsXCJhXCIsXCJmdXNlZCBtYXRNdWxcIiksdT13bihlLFwiYlwiLFwiZnVzZWQgbWF0TXVsXCIpO2k9UnQocyx1KSxzPWlbMF0sdT1pWzFdO3ZhciBsPW4/cy5zaGFwZVtzLnJhbmstMl06cy5zaGFwZVtzLnJhbmstMV0sYz1yP3Uuc2hhcGVbdS5yYW5rLTFdOnUuc2hhcGVbdS5yYW5rLTJdLGg9bj9zLnNoYXBlW3MucmFuay0xXTpzLnNoYXBlW3MucmFuay0yXSxwPXI/dS5zaGFwZVt1LnJhbmstMl06dS5zaGFwZVt1LnJhbmstMV0sZj1zLnNoYXBlLnNsaWNlKDAsLTIpLHY9dS5zaGFwZS5zbGljZSgwLC0yKSxtPXkoZiksZz15KHYpO2Qocy5yYW5rPj0yJiZ1LnJhbms+PTImJnMucmFuaz09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK3MucmFuaytcIiBhbmQgXCIrdS5yYW5rK1wiLlwifSksZCh4KGYsdiksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogb3V0ZXIgZGltZW5zaW9ucyAoXCIrZitcIikgYW5kIChcIit2K1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK3Muc2hhcGUrXCIgYW5kIFwiK3Uuc2hhcGUrXCIgbXVzdCBtYXRjaC5cIn0pLGQobD09PWMsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIitsK1wiKSBhbmQgKFwiK2MrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrcy5zaGFwZStcIiBhbmQgXCIrdS5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIituK1wiIGFuZCB0cmFuc3Bvc2VCPVwiK3IrXCIgbXVzdCBtYXRjaC5cIn0pO3ZhciB3LGI9cy5zaGFwZS5zbGljZSgwLC0yKS5jb25jYXQoW2gscF0pLEM9bj9zLmFzM0QobSxsLGgpOnMuYXMzRChtLGgsbCksRT1yP3UuYXMzRChnLHAsYyk6dS5hczNEKGcsYyxwKTtudWxsIT1vJiZzbyhiLCh3PVJ0KHc9d24obyxcImJpYXNcIixcImZ1c2VkIG1hdE11bFwiKSxzKVswXSkuc2hhcGUpO3ZhciBSPXskYTpDLCRiOkV9O3JldHVybiBudWxsIT1vJiYoUi4kYmlhcz13KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LmZ1c2VkQmF0Y2hNYXRNdWwoQyxFLG4scix3LGEpO3JldHVybiBlKFtDLEUsb10pLG99LFIsZnVuY3Rpb24odCxlKXt2YXIgaSxzPWVbMF0sdT1lWzFdLGw9ZVsyXTtpZihudWxsPT1hfHxcImxpbmVhclwiPT09YSlpPXQ7ZWxzZXtpZihcInJlbHVcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIGFjdGl2YXRpb24gXCIrYStcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlwiKTtpPXQubXVsKGwuc3RlcCgpKX12YXIgYz17fTtyZXR1cm4gbnVsbCE9byYmKGM9eyRiaWFzOmZ1bmN0aW9uKCl7dmFyIHQ9aSxlPWlvKHcuc2hhcGUsaS5zaGFwZSk7cmV0dXJuIGUubGVuZ3RoPjAmJih0PXQuc3VtKGUpKSx0LnJlc2hhcGUody5zaGFwZSl9fSksbnx8cj8hbiYmcj9PYmplY3QuYXNzaWduKHskYTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh1LCExLCExKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwocywhMCwhMSl9fSxjKTpuJiYhcj9PYmplY3QuYXNzaWduKHskYTpmdW5jdGlvbigpe3JldHVybiB1Lm1hdE11bChpLCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gcy5tYXRNdWwoaSwhMSwhMSl9fSxjKTpPYmplY3QuYXNzaWduKHskYTpmdW5jdGlvbigpe3JldHVybiB1Lm1hdE11bChpLCEwLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwocywhMCwhMCl9fSxjKTpPYmplY3QuYXNzaWduKHskYTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh1LCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gcy5tYXRNdWwoaSwhMCwhMSl9fSxjKX0pLnJlc2hhcGUoYil9fSksdmM9T2JqZWN0LmZyZWV6ZSh7bWF0TXVsOmRjfSksbWM9T2JqZWN0LmZyZWV6ZSh7aW1hZ2U6ZmMsbGluYWxnOmljLGxvc3NlczpuYyxzcGVjdHJhbDpXbCxmdXNlZDp2YyxvcDpBbixiYXRjaE5vcm1hbGl6YXRpb24yZDpBcyxiYXRjaE5vcm1hbGl6YXRpb24zZDpUcyxiYXRjaE5vcm1hbGl6YXRpb240ZDpEcyxiYXRjaE5vcm1hbGl6YXRpb246T3MsYmF0Y2hOb3JtOl9zLGJhdGNoTm9ybTJkOk1zLGJhdGNoTm9ybTNkOkZzLGJhdGNoTm9ybTRkOkJzLGNvbXBsZXg6T24scmVhbDpfbixpbWFnOk1uLGNvbmNhdDpscixjb25jYXQxZDpjcixjb25jYXQyZDpocixjb25jYXQzZDpwcixjb25jYXQ0ZDpmcixzcGxpdDpkcixjb252MWQ6WHMsY29udjJkOllzLGNvbnYzZDpRcyxjb252MmREZXJGaWx0ZXI6SnMsZGVwdGh3aXNlQ29udjJkOlpzLHNlcGFyYWJsZUNvbnYyZDp0dSxjb252MmRUcmFuc3Bvc2U6ZXUsbWF0TXVsOm51LGRvdDpydSxvdXRlclByb2R1Y3Q6b3UscmV2ZXJzZTphdSxyZXZlcnNlMWQ6aXUscmV2ZXJzZTJkOnN1LHJldmVyc2UzZDp1dSxyZXZlcnNlNGQ6bHUsbWF4UG9vbDpwdSxhdmdQb29sOmZ1LHBvb2w6ZHUsc2xpY2U6dnUsc2xpY2UxZDptdSxzbGljZTJkOmd1LHNsaWNlM2Q6eXUsc2xpY2U0ZDp4dSxhYnM6VmksYWNvczpHaSxhY29zaDpxaSxhc2luOkhpLGFzaW5oOiRpLGF0YW46amksYXRhbmg6S2ksY2VpbDpYaSxjbGlwQnlWYWx1ZTpZaSxjb3M6UWksY29zaDpKaSxlcmY6WmksZXhwOnRzLGV4cG0xOmVzLGZsb29yOm5zLGxvZzpycyxsb2cxcDpvcyxsb2dTaWdtb2lkOmFzLG5lZzppcyxyZWNpcHJvY2FsOnNzLHJvdW5kOnVzLHJzcXJ0OmxzLHNpZ21vaWQ6Y3Msc2lnbjpocyxpc05hTjpwcyxpc0luZjpmcyxpc0Zpbml0ZTpkcyxzaW46dnMsc2luaDptcyxzb2Z0cGx1czpncyxzcXJ0OnlzLHNxdWFyZTp4cyxzdGVwOndzLHRhbjpicyx0YW5oOkNzLGFsbDpidSxhbnk6Q3UsYXJnTWF4OkV1LGFyZ01pbjpSdSxsb2dTdW1FeHA6U3UsbWF4Ok51LG1lYW46a3UsbWluOkl1LG1vbWVudHM6QXUsc3VtOlR1LHByb2Q6RHUsZXF1YWw6T3UsZXF1YWxTdHJpY3Q6X3UsZ3JlYXRlcjpNdSxncmVhdGVyRXF1YWw6RnUsZ3JlYXRlckVxdWFsU3RyaWN0OkJ1LGdyZWF0ZXJTdHJpY3Q6UHUsbGVzczpMdSxsZXNzRXF1YWw6V3UsbGVzc0VxdWFsU3RyaWN0OlV1LGxlc3NTdHJpY3Q6enUsbm90RXF1YWw6VnUsbm90RXF1YWxTdHJpY3Q6R3UsYWRkOnF1LGFkZE46SHUsYWRkU3RyaWN0OiR1LGF0YW4yOmp1LGRpdjpLdSxkaXZTdHJpY3Q6WHUsZmxvb3JEaXY6WXUsbWF4aW11bTpRdSxtYXhpbXVtU3RyaWN0Okp1LG1pbmltdW06WnUsbWluaW11bVN0cmljdDp0bCxtb2Q6ZWwsbW9kU3RyaWN0Om5sLG11bDpybCxtdWxTdHJpY3Q6b2wscG93OmFsLHBvd1N0cmljdDppbCxzcXVhcmVkRGlmZmVyZW5jZTpzbCxzcXVhcmVkRGlmZmVyZW5jZVN0cmljdDp1bCxzdWI6bGwsc3ViU3RyaWN0OmNsLGVsdTpnbCxsZWFreVJlbHU6eWwscHJlbHU6eGwscmVsdTp3bCxzZWx1OmJsLGxvZ2ljYWxBbmQ6aGwsbG9naWNhbE5vdDpwbCxsb2dpY2FsT3I6ZmwsbG9naWNhbFhvcjpkbCx3aGVyZTp2bCx3aGVyZUFzeW5jOm1sLGJ1ZmZlcjpOcixwcmludDprcixiYXRjaFRvU3BhY2VORDpJcixjYXN0OkFyLGNsb25lOlRyLGN1bXN1bTpEcixkZXB0aFRvU3BhY2U6T3IsZXhwYW5kRGltczpfcixleWU6TXIsbXVsdGlub21pYWw6RnIsb25lSG90OkJyLHBhZDpQcixwYWQxZDpMcixwYWQyZDpXcixwYWQzZDpVcixwYWQ0ZDp6cixyYW5kOlZyLHJhbmRvbU5vcm1hbDpHcixyYW5kb21Vbmlmb3JtOnFyLHJlc2hhcGU6SHIsc3BhY2VUb0JhdGNoTkQ6JHIsc3F1ZWV6ZTpqcixzdGFjazpLcix0aWxlOlhyLHRydW5jYXRlZE5vcm1hbDpZcix1bnN0YWNrOlFyLHNldGRpZmYxZEFzeW5jOkpyLGZpbGw6SG4sbGluc3BhY2U6JG4sb25lczpHbixyYW5nZTpqbixzY2FsYXI6Qm4sdGVuc29yOkZuLHRlbnNvcjFkOlBuLHRlbnNvcjJkOkxuLHRlbnNvcjNkOlduLHRlbnNvcjRkOlVuLHRlbnNvcjVkOnpuLHRlbnNvcjZkOlZuLHplcm9zOnFuLG9uZXNMaWtlOktuLHplcm9zTGlrZTpYbix0cmFuc3Bvc2U6Q2wsc29mdG1heDpUbixsb2dTb2Z0bWF4OkRuLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOkVsLG5vcm06UmwsZ2F0aGVyOmtsLHVuc29ydGVkU2VnbWVudFN1bTpJbCxiYXNpY0xTVE1DZWxsOkFsLG11bHRpUk5OQ2VsbDpUbCxtb3ZpbmdBdmVyYWdlOkRsLHN0cmlkZWRTbGljZTpPbCx0b3BrOl9sLHNjYXR0ZXJORDpNbCxmZnQ6RmwsaWZmdDpCbCxyZmZ0OlBsLGlyZmZ0OkxsLHNwYXJzZVRvRGVuc2U6VWwsZ2F0aGVyTkQ6emwsZHJvcG91dDpWbCxoYW5uV2luZG93OkhsLGhhbW1pbmdXaW5kb3c6JGx9KTt2YXIgZ2M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5ibG9ja1NpemU9NDgsdGhpcy5maXJzdFVzZT0hMCxhLmdldChcIklTX0JST1dTRVJcIikmJih0aGlzLmZyb21QaXhlbHMyRENvbnRleHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIikpLHRoaXMuZGF0YT1uZXcgWW4oRHQpfXJldHVybiB0LnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5maXJzdFVzZSYmKHRoaXMuZmlyc3RVc2U9ITEsYS5nZXQoXCJJU19OT0RFXCIpJiZqZShcIlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5IaSB0aGVyZSDwn5GLLiBMb29rcyBsaWtlIHlvdSBhcmUgcnVubmluZyBUZW5zb3JGbG93LmpzIGluIE5vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgYmFja2VuZCwgd2hpY2ggYmluZHMgdG8gVGVuc29yRmxvdyBDKyssIGJ5IHJ1bm5pbmcgbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLCBvciBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUtZ3B1IGlmIHlvdSBoYXZlIENVREEuIFRoZW4gY2FsbCByZXF1aXJlKCdAdGVuc29yZmxvdy90ZmpzLW5vZGUnKTsgKC1ncHUgc3VmZml4IGZvciBDVURBKSBhdCB0aGUgc3RhcnQgb2YgeW91ciBwcm9ncmFtLiBWaXNpdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW5vZGUgZm9yIG1vcmUgZGV0YWlscy5cXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXCIpKSx0aGlzLmRhdGEuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkRhdGEgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTt0aGlzLmRhdGEuc2V0KHQse2R0eXBlOm59KX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlKXtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIk1hdGhCYWNrZW5kQ1BVLndyaXRlKCk6IHZhbHVlcyBjYW4gbm90IGJlIG51bGxcIik7dGhpcy5kYXRhLmdldCh0KS52YWx1ZXM9ZX0sdC5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbih0LGUpe2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7dmFyIG4scjtpZihhLmdldChcIklTX05PREVcIikmJm51bGw9PXQuZ2V0Q29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHJ1bm5pbmcgaW4gbm9kZSwgcGl4ZWxzIG11c3QgYmUgYW4gSFRNTENhbnZhc0VsZW1lbnQgbGlrZSB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBgY2FudmFzYCBucG0gcGFja2FnZVwiKTtpZihudWxsIT10LmdldENvbnRleHQpbj10LmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwwLHQud2lkdGgsdC5oZWlnaHQpLmRhdGE7ZWxzZSBpZih0IGluc3RhbmNlb2YgSW1hZ2VEYXRhKW49dC5kYXRhO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQgb3IgSW1hZ2VEYXRhLCBidXQgd2FzIFwiK3QuY29uc3RydWN0b3IubmFtZSk7aWYobnVsbD09dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlYWQgcGl4ZWxzIGZyb20gSFRNTEltYWdlRWxlbWVudCBvdXRzaWRlIHRoZSBicm93c2VyLlwiKTt0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoPXQud2lkdGgsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5oZWlnaHQ9dC5oZWlnaHQsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZSh0LDAsMCx0LndpZHRoLHQuaGVpZ2h0KSxuPXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwwLHQud2lkdGgsdC5oZWlnaHQpLmRhdGF9aWYoND09PWUpcj1uZXcgSW50MzJBcnJheShuKTtlbHNle3ZhciBvPXQud2lkdGgqdC5oZWlnaHQ7cj1uZXcgSW50MzJBcnJheShvKmUpO2Zvcih2YXIgaT0wO2k8bztpKyspZm9yKHZhciBzPTA7czxlOysrcylyW2kqZStzXT1uWzQqaStzXX1yZXR1cm4gV24ocixbdC5oZWlnaHQsdC53aWR0aCxlXSxcImludDMyXCIpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5yZWFkU3luYyh0KV19KX0pfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLG49ZS5kdHlwZSxyPWUuY29tcGxleFRlbnNvcnM7cmV0dXJuXCJjb21wbGV4NjRcIj09PW4/ZXIoci5yZWFsLmRhdGFTeW5jKCksci5pbWFnLmRhdGFTeW5jKCkpOnRoaXMuZGF0YS5nZXQodCkudmFsdWVzfSx0LnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmRhdGEuaGFzKHQpKXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLmNvbXBsZXhUZW5zb3JzO251bGwhPWUmJihlLnJlYWwuZGlzcG9zZSgpLGUuaW1hZy5kaXNwb3NlKCkpLHRoaXMuZGF0YS5kZWxldGUodCl9fSx0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIGU9aigpLHQoKSxbMix7a2VybmVsTXM6aigpLWV9XX0pfSl9LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybnt1bnJlbGlhYmxlOiEwLHJlYXNvbnM6W1wiVGhlIHJlcG9ydGVkIG1lbW9yeSBpcyBhbiB1cHBlciBib3VuZC4gRHVlIHRvIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb24sIHRoZSB0cnVlIGFsbG9jYXRlZCBtZW1vcnkgbWF5IGJlIGxlc3MuXCJdfX0sdC5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPWZ0Lm1ha2UodC5zaGFwZSx7fSxcImNvbXBsZXg2NFwiKTtyZXR1cm4gdGhpcy5kYXRhLmdldChuLmRhdGFJZCkuY29tcGxleFRlbnNvcnM9e3JlYWw6RHQua2VlcCh0LmNsb25lKCkpLGltYWc6RHQua2VlcChlLmNsb25lKCkpfSxufSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sdC5wcm90b3R5cGUuYXNzZXJ0Tm90Q29tcGxleD1mdW5jdGlvbih0LGUpe0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe251bGwhPXQmJmQoXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm4gZStcIiBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzLlwifSl9KX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2xpY2VcIiksbW4odC5zaGFwZSxlLG4pKXt2YXIgcj1nbihlLHQuc3RyaWRlcyksbz15KG4pO3JldHVybiBGbih0LmRhdGFTeW5jKCkuc3ViYXJyYXkocixyK28pLG4sdC5kdHlwZSl9Zm9yKHZhciBhPU5yKG4sdC5kdHlwZSksaT10LmJ1ZmZlclN5bmMoKSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocykubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQrZVtuXX0pO2EudmFsdWVzW3NdPWkuZ2V0LmFwcGx5KGksdSl9cmV0dXJuIGEudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInN0cmlkZWRTbGljZVwiKTt2YXIgbD1mbih0LnNoYXBlLGUsbixyLG8sYSxpLHMsdSksYz1sWzBdLGg9bFsxXSxwPWxbMl0sZj1oLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybi0xPT09cC5pbmRleE9mKGUpfSk7aWYoZi5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dH0pKXJldHVybiBGbihbXSxmKTtmb3IodmFyIGQ9TnIoaCx0LmR0eXBlKSx2PXQuYnVmZmVyU3luYygpLG09MDttPGQuc2l6ZTttKyspe2Zvcih2YXIgZz1kLmluZGV4VG9Mb2MobSkseT1uZXcgQXJyYXkoZy5sZW5ndGgpLHg9MDt4PHkubGVuZ3RoO3grKyl5W3hdPWdbeF0qclt4XStjW3hdO2Quc2V0LmFwcGx5KGQsW3YuZ2V0LmFwcGx5KHYseSldLmNvbmNhdChnKSl9cmV0dXJuIGQudG9UZW5zb3IoKS5yZXNoYXBlKGYpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbZV0scj1uZXcgQXJyYXkodC5yYW5rLTEpLG89MCxhPTA7YTx0LnJhbms7YSsrKWEhPT1lJiYocltvKytdPXQuc2hhcGVbYV0pO3ZhciBpPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCkscz10LnNoYXBlLnNsaWNlKCk7c1tlXT0xO3ZhciB1PW5ldyBBcnJheShuKTtmb3IoYT0wO2E8dS5sZW5ndGg7YSsrKWlbZV09YSx1W2FdPXRoaXMuc2xpY2UodCxpLHMpLnJlc2hhcGUocik7cmV0dXJuIHV9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJldmVyc2VcIik7Zm9yKHZhciBuPU5yKHQuc2hhcGUsdC5kdHlwZSkscj10LmJ1ZmZlclN5bmMoKSxvPWZ1bmN0aW9uKG8pe3ZhciBhPW4uaW5kZXhUb0xvYyhvKSxpPWEuc2xpY2UoKTtlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV09dC5zaGFwZVtlXS0xLWlbZV19KSxuLnNldC5hcHBseShuLFtyLmdldC5hcHBseShyLGkpXS5jb25jYXQoYSkpfSxhPTA7YTxuLnNpemU7YSsrKW8oYSk7cmV0dXJuIG4udG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjb25jYXRcIik7dmFyIG49dC5tYXAoZnVuY3Rpb24odCl7dmFyIG49eSh0LnNoYXBlLnNsaWNlKGUpKTtyZXR1cm4gdC5hczJEKC0xLG4pfSkscj1zbihuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLDEpLG89TnIocix0WzBdLmR0eXBlKS52YWx1ZXM7aWYoMT09PW5bMF0uc2hhcGVbMF0pe3ZhciBhPTA7bi5mb3JFYWNoKGZ1bmN0aW9uKHQpe28uc2V0KHQuZGF0YVN5bmMoKSxhKSxhKz10LnNpemV9KX1lbHNle3ZhciBpPTA7bi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj0wLGE9MDthPHQuc2hhcGVbMF07KythKWZvcih2YXIgcz1hKnJbMV0raSx1PTA7dTx0LnNoYXBlWzFdOysrdSlvW3MrdV09ZVtuKytdO2krPXQuc2hhcGVbMV19KX12YXIgcz1zbih0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLGUpO3JldHVybiBGbihvLHMsdFswXS5kdHlwZSl9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJuZWdcIiksdGhpcy5tdWx0aXBseShCbigtMSksdCl9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCtuLGltYWc6ZStyfX0pOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsQ3QodC5kdHlwZSxlLmR0eXBlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KX0sdC5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFkZE5cIik7Zm9yKHZhciBlPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRhdGFTeW5jKCl9KSxuPU5yKHRbMF0uc2hhcGUsdFswXS5kdHlwZSkscj1uLnZhbHVlcyxvPTA7bzx0Lmxlbmd0aDtvKyspZm9yKHZhciBhPWVbb10saT0wO2k8ci5sZW5ndGg7aSsrKXJbaV0rPWFbaV07cmV0dXJuIG4udG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQtbixpbWFnOmUtcn19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLEN0KHQuZHR5cGUsZS5kdHlwZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdC1lfSl9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJwb3dcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgucG93KHQsZSl9KX0sdC5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibWF0TXVsXCIpO2Zvcih2YXIgbz1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxhPW4/dC5zaGFwZVsyXTp0LnNoYXBlWzFdLGk9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0scz10LnNoYXBlWzBdLHU9dC5kYXRhU3luYygpLGw9ZS5kYXRhU3luYygpLGM9bj9bdC5zdHJpZGVzWzBdLDEsdC5zdHJpZGVzWzFdXTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXSwxXSxoPWNbMF0scD1jWzFdLGY9Y1syXSxkPXI/WzEsZS5zdHJpZGVzWzFdLGUuc3RyaWRlc1swXV06W2Uuc3RyaWRlc1sxXSwxLGUuc3RyaWRlc1swXV0sdj1kWzBdLG09ZFsxXSxnPWRbMl0seT1hKmkseD1OcihbcyxhLGldLHQuZHR5cGUpLHc9eC52YWx1ZXMsYj10aGlzLmJsb2NrU2l6ZSxDPTA7QzxzO0MrKylmb3IodmFyIEU9MDtFPGE7RSs9Yilmb3IodmFyIFI9MDtSPGk7Uis9Yilmb3IodmFyIFM9MDtTPG87Uys9Yilmb3IodmFyIE49TWF0aC5taW4oRStiLGEpLGs9TWF0aC5taW4oUitiLGkpLEk9TWF0aC5taW4oUytiLG8pLEE9RTtBPE47QSsrKWZvcih2YXIgVD1SO1Q8aztUKyspe2Zvcih2YXIgRD0wLE89UztPPEk7TysrKUQrPXVbQypoK0EqcCtPKmZdKmxbTyp2K1QqbStDKmddO3dbQyp5KyhBKmkrVCldKz1EfXJldHVybiB4LnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPXRoaXMuYmF0Y2hNYXRNdWwodCxlLG4scik7cmV0dXJuIG8mJihpPXRoaXMuYWRkKGksbykpLGEmJihpPWZ1bmN0aW9uKHQsZSxuKXtpZihcImxpbmVhclwiPT09ZSlyZXR1cm4gdC5saW5lYXIobik7aWYoXCJyZWx1XCI9PT1lKXJldHVybiB0LnJlbHUobik7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIitlK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIENQVSBiYWNrZW5kLlwiKX0odGhpcyxhLGkpKSxpfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCpuLWUqcixpbWFnOnQqcitlKm59fSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxDdCh0LmR0eXBlLGUuZHR5cGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pfSx0LnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwicmVhbERpdmlkZVwiKTtyZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImZsb2F0MzJcIixmdW5jdGlvbih0LGUpe3JldHVybiB0L2V9KX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJmbG9vckRpdlwiKTtyZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImludDMyXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5mbG9vcih0L2UpfSl9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3VtXCIpLG5uKFwic3VtXCIsZSx0LnJhbmspO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLEN0KHQuZHR5cGUsXCJpbnQzMlwiKSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPTAscD0wO3A8aTsrK3ApaCs9dVtjK3BdO3NbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3VtXCIpO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLEN0KHQuZHR5cGUsXCJpbnQzMlwiKSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPTEscD0wO3A8aTsrK3ApaCo9dVtjK3BdO3NbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInVuc29ydGVkU2VnbWVudFN1bVwiKTtmb3IodmFyIHI9W10sbz10LnJhbmstZS5yYW5rLGE9MDthPG87KythKWU9ZS5leHBhbmREaW1zKGErMSk7Zm9yKGE9MDthPG47KythKXt2YXIgaT1CbihhLFwiaW50MzJcIikscz1PdShpLGUpLmFzVHlwZShcImZsb2F0MzJcIikubXVsKHQpLnN1bSgwKTtyLnB1c2gocyl9cmV0dXJuIEtyKHIpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFyZ01pblwiKTt2YXIgbj1bZV07bm4oXCJhcmdNaW5cIixuLHQucmFuayk7Zm9yKHZhciByPXRuKHQuc2hhcGUsbiksbz1yWzBdLGE9clsxXSxpPXFuKG8sXCJpbnQzMlwiKSxzPXkoYSksdT1pLmRhdGFTeW5jKCksbD10LmRhdGFTeW5jKCksYz0wO2M8dS5sZW5ndGg7KytjKXtmb3IodmFyIGg9YypzLHA9bFtoXSxmPTAsZD0wO2Q8czsrK2Qpe3ZhciB2PWxbaCtkXTt2PHAmJihwPXYsZj1kKX11W2NdPWZ9cmV0dXJuIGl9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXJnTWF4XCIpO3ZhciBuPVtlXTtubihcImFyZ01heFwiLG4sdC5yYW5rKTtmb3IodmFyIHI9dG4odC5zaGFwZSxuKSxvPXJbMF0sYT1yWzFdLGk9cW4obyxcImludDMyXCIpLHM9eShhKSx1PWkuZGF0YVN5bmMoKSxsPXQuZGF0YVN5bmMoKSxjPTA7Yzx1Lmxlbmd0aDsrK2Mpe2Zvcih2YXIgaD1jKnMscD1sW2hdLGY9MCxkPTA7ZDxzOysrZCl7dmFyIHY9bFtoK2RdO3Y+cCYmKHA9dixmPWQpfXVbY109Zn1yZXR1cm4gaX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY3Vtc3VtXCIpLGUhPT10LnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKHQucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7Zm9yKHZhciBvPUN0KHQuZHR5cGUsXCJpbnQzMlwiKSxhPXFuKHQuc2hhcGUsbyksaT1hLmRhdGFTeW5jKCkscz10LmRhdGFTeW5jKCksdT10LnNoYXBlW3QucmFuay0xXSxsPXI/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCt1LWUtMX06ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSxjPTA7YzxzLmxlbmd0aDtjKz11KWZvcih2YXIgaD0wO2g8dTtoKyspe3ZhciBwPWwoYyxoKTtpZigwPT09aClpW3BdPW4/MDpzW3BdO2Vsc2V7dmFyIGY9bChjLGgtMSk7aVtwXT1uP3NbZl0raVtmXTpzW3BdK2lbZl19fXJldHVybiBhfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJlcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1lPzE6MH0pfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJub3RFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQhPT1lPzE6MH0pfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImxlc3NcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0PGU/MTowfSl9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJsZXNzRXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0PD1lPzE6MH0pfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImdyZWF0ZXJcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0PmU/MTowfSl9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJncmVhdGVyRXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0Pj1lPzE6MH0pfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibG9naWNhbE5vdFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPWVbcl0/MDoxO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSxcImJvb2xcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibG9naWNhbEFuZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQmJmV9KX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImxvZ2ljYWxPclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGV9KX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZSxuXSxcInNlbGVjdFwiKTtmb3IodmFyIHI9dC5kYXRhU3luYygpLG89ZS5kYXRhU3luYygpLGE9bi5kYXRhU3luYygpLGk9cW4oZS5zaGFwZSxDdChlLmR0eXBlLG4uZHR5cGUpKSxzPWkuZGF0YVN5bmMoKSx1PTAsbD0wPT09dC5yYW5rfHx0LnJhbms+MXx8MT09PWUucmFuaz8xOmUuc2hhcGVbMV0sYz0wO2M8ci5sZW5ndGg7YysrKWZvcih2YXIgaD0wO2g8bDtoKyspMT09PXJbY10/c1t1KytdPW9bY106c1t1KytdPWFbY107cmV0dXJuIGl9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdF0sXCJ3aGVyZVwiKTt2YXIgZT10LmRhdGFTeW5jKCk7cmV0dXJuIFpyKHQuc2hhcGUsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInRvcGtcIiksdXIodC5kYXRhU3luYygpLHQuc2hhcGUsdC5kdHlwZSxlKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJtaW5cIiksbm4oXCJtaW5cIixlLHQucmFuayk7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsdC5kdHlwZSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPXVbY10scD0wO3A8aTsrK3Ape3ZhciBmPXVbYytwXTtmPGgmJihoPWYpfXNbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJtaW5pbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfSl9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJtb2RcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7dmFyIG49dCVlO3JldHVybiB0PDAmJmU8MHx8dD49MCYmZT49MD9uOihuK2UpJWV9KX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJtYXhcIiksbm4oXCJtYXhcIixlLHQucmFuayk7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsdC5kdHlwZSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPXVbY10scD0wO3A8aTsrK3Ape3ZhciBmPXVbYytwXTtmPmgmJihoPWYpfXNbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJtYXhpbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLm1heCh0LGUpfSl9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYWxsXCIpLG5uKFwiYWxsXCIsZSx0LnJhbmspO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLHQuZHR5cGUpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD11W2NdLHA9MDtwPGk7KytwKXt2YXIgZj11W2MrcF07aD1oJiZmfXNbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhbnlcIiksbm4oXCJhbnlcIixlLHQucmFuayk7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsdC5kdHlwZSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPXVbY10scD0wO3A8aTsrK3Ape3ZhciBmPXVbYytwXTtoPWh8fGZ9c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXt2YXIgbj10LWU7cmV0dXJuIG4qbn0pfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY2VpbFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5jZWlsKGVbcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiZmxvb3JcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZmxvb3IoZVtyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInhcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcillW3JdPDA/bltyXT0tMTplW3JdPjA/bltyXT0xOm5bcl09MDtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInhcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTnVtYmVyLmlzTmFOKGVbcl0pJiYobltyXT0xKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0sXCJib29sXCIpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInhcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTWF0aC5hYnMoZVtyXSk9PT0xLzAmJihuW3JdPTEpO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSxcImJvb2xcIil9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwieFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilOdW1iZXIuaXNGaW5pdGUoZVtyXSkmJihuW3JdPTEpO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSxcImJvb2xcIil9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicm91bmRcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89TWF0aC5mbG9vcihlW3JdKTtlW3JdLW88LjU/bltyXT1NYXRoLmZsb29yKGVbcl0pOmVbcl0tbz4uNT9uW3JdPU1hdGguY2VpbChlW3JdKTpuW3JdPW8lMj09MD9vOm8rMX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJleHBcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwKGVbcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiZXhwbTFcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwbTEoZVtyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibG9nXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZyhvKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImxvZzFwXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZzFwKG8pfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzcXJ0XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLnNxcnQobyl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyc3FydFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09MS9NYXRoLnNxcnQobyl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3F1YXJlXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1vKm99cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJlY2lwcm9jYWxcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPTEvZVtyXTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5saW5lYXI9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyZWx1XCIpO2Zvcih2YXIgZT1xbih0LnNoYXBlLHQuZHR5cGUpLG49ZS5kYXRhU3luYygpLHI9dC5kYXRhU3luYygpLG89MDtvPHIubGVuZ3RoOysrbyluW29dPU1hdGgubWF4KDAscltvXSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInByZWx1XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3JldHVybiB0PDA/ZSp0OnR9KX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiZWx1XCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgbz1uW3JdO2Vbcl09bz49MD9vOk1hdGguZXhwKG8pLTF9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZWx1RGVyXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj1lLmRhdGFTeW5jKCksbz10LmRhdGFTeW5jKCksYT0wO2E8ci5sZW5ndGg7KythKXt2YXIgaT1yW2FdO25bYV09aT49MT9vW2FdOm9bYV0qKGkrMSl9cmV0dXJuIGZ0Lm1ha2UoZS5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNlbHVcIik7Zm9yKHZhciBlPWJpLG49Q2kscj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbz10LmRhdGFTeW5jKCksYT0wO2E8by5sZW5ndGg7KythKXt2YXIgaT1vW2FdO3JbYV09aT49MD9uKmk6ZSooTWF0aC5leHAoaSktMSl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOnJ9KX0sdC5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjbGlwXCIpO2Zvcih2YXIgcj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbz10LmRhdGFTeW5jKCksYT0wO2E8by5sZW5ndGg7KythKXt2YXIgaT1vW2FdO3JbYV09aT5uP246aTxlP2U6aX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6cn0pfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFicyhuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8dC5zaXplOysrcil7dmFyIG89blsyKnJdLGE9blsyKnIrMV07ZVtyXT1NYXRoLmh5cG90KG8sYSl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiaW50XCIpO2Zvcih2YXIgZT1uZXcgSW50MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPW5bcl07cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9LFwiaW50MzJcIil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzaWdtb2lkXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09MS8oMStNYXRoLmV4cCgtbltyXSkpO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic29mdHBsdXNcIik7Zm9yKHZhciBlPU1hdGgubG9nKDEuMTkyMDkyODk1NTA3ODEyNWUtNykrMixuPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxyPXQuZGF0YVN5bmMoKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb10+LWUsaT1yW29dPGUscz1NYXRoLmV4cChyW29dKSx1PXZvaWQgMDt1PWk/czphP3Jbb106TWF0aC5sb2coMStzKSxuW29dPXV9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5zaW4obltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY29zXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3MobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC50YW4obltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFzaW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW4obltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFjb3NcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3MobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImF0YW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW4obltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiYXRhbjJcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguYXRhbjIodCxlKX0pfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2luaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguc2luaChuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY29zaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguY29zaChuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPWIobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhc2luaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXNpbmgobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhY29zaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWNvc2gobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhdGFuaFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXRhbmgobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiZXJmXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgbz1uW3JdLGE9MS8oMSsuMzI3NTkxMSpvKTtlW3JdPTEtKCgoKDEuMDYxNDA1NDI5KmEtMS40NTMxNTIwMjcpKmErMS40MjE0MTM3NDEpKmEtLjI4NDQ5NjczNikqYSsuMjU0ODI5NTkyKSphKk1hdGguZXhwKC1vKm8pfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInN0ZXBcIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxyPXQuZGF0YVN5bmMoKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb107aXNOYU4oYSk/bltvXT1OYU46bltvXT1hPjA/MTplfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiY29udjJkXCIpO2Zvcih2YXIgcj1uLmZpbHRlckhlaWdodCxvPW4uZmlsdGVyV2lkdGgsYT1uLmRpbGF0aW9uSGVpZ2h0LGk9bi5kaWxhdGlvbldpZHRoLHM9bi5wYWRJbmZvLmxlZnQsdT1uLnBhZEluZm8udG9wLGw9TnIobi5vdXRTaGFwZSx0LmR0eXBlKSxjPXQuZGF0YVN5bmMoKSxoPWUuZGF0YVN5bmMoKSxwPWwudmFsdWVzLGY9MDtmPG4uYmF0Y2hTaXplOysrZilmb3IodmFyIGQ9Zip0LnN0cmlkZXNbMF0sdj1mKmwuc3RyaWRlc1swXSxtPTA7bTxuLm91dEhlaWdodDsrK20pZm9yKHZhciBnPXYrbSpsLnN0cmlkZXNbMV0seT1tKm4uc3RyaWRlSGVpZ2h0LXMseD0wO3g8cjt4Kyspe3ZhciB3PXkreCphO2lmKCEodzwwfHx3Pj1uLmluSGVpZ2h0KSlmb3IodmFyIGI9eCplLnN0cmlkZXNbMF0sQz1kK3cqdC5zdHJpZGVzWzFdLEU9MDtFPG4ub3V0V2lkdGg7KytFKWZvcih2YXIgUj1nK0Uqbi5vdXRDaGFubmVscyxTPUUqbi5zdHJpZGVXaWR0aC11LE49MDtOPG87TisrKXt2YXIgaz1TK04qaTtpZighKGs8MHx8az49bi5pbldpZHRoKSlmb3IodmFyIEk9YitOKmUuc3RyaWRlc1sxXSxBPUMraypuLmluQ2hhbm5lbHMsVD1JLEQ9MDtEPG4uaW5DaGFubmVsczsrK0Qpe2Zvcih2YXIgTz1jW0ErRF0sXz0wO188bi5vdXRDaGFubmVsczsrK18pcFtSK19dKz1PKmhbVCtfXTtUKz1uLm91dENoYW5uZWxzfX19cmV0dXJuIGwudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bi5maWx0ZXJEZXB0aCxvPW4uZmlsdGVySGVpZ2h0LGE9bi5maWx0ZXJXaWR0aCxpPW4uZGlsYXRpb25EZXB0aCxzPW4uZGlsYXRpb25IZWlnaHQsdT1uLmRpbGF0aW9uV2lkdGgsbD1uLnBhZEluZm8uZnJvbnQsYz1uLnBhZEluZm8ubGVmdCxoPW4ucGFkSW5mby50b3AscD1OcihuLm91dFNoYXBlLHQuZHR5cGUpLGY9dC5kYXRhU3luYygpLGQ9ZS5kYXRhU3luYygpLHY9cC52YWx1ZXMsbT0wO208bi5iYXRjaFNpemU7KyttKWZvcih2YXIgZz1tKnQuc3RyaWRlc1swXSx5PW0qcC5zdHJpZGVzWzBdLHg9MDt4PG4ub3V0RGVwdGg7Kyt4KWZvcih2YXIgdz15K3gqcC5zdHJpZGVzWzFdLGI9eCpuLnN0cmlkZURlcHRoLWwsQz0wO0M8cjtDKyspe3ZhciBFPWIrQyppO2lmKCEoRTwwfHxFPj1uLmluRGVwdGgpKWZvcih2YXIgUj1DKmUuc3RyaWRlc1swXSxTPWcrRSp0LnN0cmlkZXNbMV0sTj0wO048bi5vdXRIZWlnaHQ7KytOKWZvcih2YXIgaz13K04qcC5zdHJpZGVzWzJdLEk9TipuLnN0cmlkZUhlaWdodC1oLEE9MDtBPG87QSsrKXt2YXIgVD1JK0EqcztpZighKFQ8MHx8VD49bi5pbkhlaWdodCkpZm9yKHZhciBEPVIrQSplLnN0cmlkZXNbMV0sTz1TK1QqdC5zdHJpZGVzWzJdLF89MDtfPG4ub3V0V2lkdGg7KytfKWZvcih2YXIgTT1rK18qbi5vdXRDaGFubmVscyxGPV8qbi5zdHJpZGVXaWR0aC1jLEI9MDtCPGE7QisrKXt2YXIgUD1GK0IqdTtpZighKFA8MHx8UD49bi5pbldpZHRoKSlmb3IodmFyIEw9RCtCKmUuc3RyaWRlc1syXSxXPU8rUCpuLmluQ2hhbm5lbHMsVT1MLHo9MDt6PG4uaW5DaGFubmVsczsrK3ope2Zvcih2YXIgVj1mW1crel0sRz0wO0c8bi5vdXRDaGFubmVsczsrK0cpdltNK0ddKz1WKmRbVStHXTtVKz1uLm91dENoYW5uZWxzfX19fXJldHVybiBwLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJjb252MmREZXJJbnB1dFwiKTtmb3IodmFyIHI9TnIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGw9dC5kYXRhU3luYygpLGM9dC5zdHJpZGVzLGg9Y1swXSxwPWNbMV0sZj1jWzJdLGQ9ZS5kYXRhU3luYygpLHY9ZS5zdHJpZGVzLG09dlswXSxnPXZbMV0seT12WzJdLHg9bi5iYXRjaFNpemUsdz1uLmZpbHRlckhlaWdodCxiPW4uZmlsdGVyV2lkdGgsQz1uLmluQ2hhbm5lbHMsRT1uLmluSGVpZ2h0LFI9bi5pbldpZHRoLFM9bi5vdXRDaGFubmVscyxOPW4ub3V0SGVpZ2h0LGs9bi5vdXRXaWR0aCxJPW4uc3RyaWRlSGVpZ2h0LEE9bi5zdHJpZGVXaWR0aCxUPXctMS1uLnBhZEluZm8udG9wLEQ9Yi0xLW4ucGFkSW5mby5sZWZ0LE89MDtPPHg7KytPKWZvcih2YXIgXz0wO188QzsrK18pZm9yKHZhciBNPTA7TTxFOysrTSlmb3IodmFyIEY9TS1ULEI9TWF0aC5tYXgoMCxNYXRoLmNlaWwoRi9JKSksUD1NYXRoLm1pbihOLCh3K0YpL0kpLEw9MDtMPFI7KytMKXtmb3IodmFyIFc9TC1ELFU9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVy9BKSksej1NYXRoLm1pbihrLChiK1cpL0EpLFY9MCxHPUI7RzxQOysrRylmb3IodmFyIHE9RypJLUYsSD1VO0g8ejsrK0gpZm9yKHZhciAkPWgqTytwKkcrZipILGo9bSoody0xLXEpK2cqKGItMS0oSCpBLVcpKSt5Kl8sSz0wO0s8UzsrK0spe1YrPWxbJCtLXSpkW2orS119b1tpKk8rcypNK3UqTCtfXT1WfXJldHVybiByLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9TnIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGw9YVszXSxjPXQuZGF0YVN5bmMoKSxoPXQuc3RyaWRlcyxwPWhbMF0sZj1oWzFdLGQ9aFsyXSx2PWhbM10sbT1lLmRhdGFTeW5jKCksZz1lLnN0cmlkZXMseT1nWzBdLHg9Z1sxXSx3PWdbMl0sYj1nWzNdLEM9bi5iYXRjaFNpemUsRT1uLmZpbHRlckRlcHRoLFI9bi5maWx0ZXJIZWlnaHQsUz1uLmZpbHRlcldpZHRoLE49bi5pbkNoYW5uZWxzLGs9bi5pbkRlcHRoLEk9bi5pbkhlaWdodCxBPW4uaW5XaWR0aCxUPW4ub3V0Q2hhbm5lbHMsRD1uLm91dERlcHRoLE89bi5vdXRIZWlnaHQsXz1uLm91dFdpZHRoLE09bi5zdHJpZGVEZXB0aCxGPW4uc3RyaWRlSGVpZ2h0LEI9bi5zdHJpZGVXaWR0aCxQPUUtMS1uLnBhZEluZm8uZnJvbnQsTD1SLTEtbi5wYWRJbmZvLnRvcCxXPVMtMS1uLnBhZEluZm8ubGVmdCxVPTA7VTxDOysrVSlmb3IodmFyIHo9MDt6PE47Kyt6KWZvcih2YXIgVj0wO1Y8azsrK1YpZm9yKHZhciBHPVYtUCxxPU1hdGgubWF4KDAsTWF0aC5jZWlsKEcvTSkpLEg9TWF0aC5taW4oRCwoRStHKS9NKSwkPTA7JDxJOysrJClmb3IodmFyIGo9JC1MLEs9TWF0aC5tYXgoMCxNYXRoLmNlaWwoai9GKSksWD1NYXRoLm1pbihPLChSK2opL0YpLFk9MDtZPEE7KytZKXtmb3IodmFyIFE9WS1XLEo9TWF0aC5tYXgoMCxNYXRoLmNlaWwoUS9CKSksWj1NYXRoLm1pbihfLChTK1EpL0IpLHR0PTAsZXQ9cTtldDxIOysrZXQpZm9yKHZhciBudD1ldCpNLUcscnQ9SztydDxYOysrcnQpZm9yKHZhciBvdD1ydCpGLWosYXQ9SjthdDxaOysrYXQpZm9yKHZhciBpdD1wKlUrZipldCtkKnJ0K3YqYXQsc3Q9eSooRS0xLW50KSt4KihSLTEtb3QpK3cqKFMtMS0oYXQqQi1RKSkrYip6LHV0PTA7dXQ8VDsrK3V0KXt0dCs9Y1tpdCt1dF0qbVtzdCt1dF19b1tpKlUrcypWK3UqJCtsKlkrel09dHR9cmV0dXJuIHIudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJjb252MmREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPU5yKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHU9bi5wYWRJbmZvLmxlZnQsbD1uLnBhZEluZm8udG9wLGM9dC5idWZmZXJTeW5jKCksaD1lLmJ1ZmZlclN5bmMoKSxwPTA7cDxhOysrcClmb3IodmFyIGY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGwtcCkvcikpLGQ9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrbC1wKS9yKSx2PTA7djxpOysrdilmb3IodmFyIG09TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHUtdikvbykpLGc9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK3UtdikvbykseT0wO3k8bi5pbkNoYW5uZWxzOysreSlmb3IodmFyIHg9MDt4PG4ub3V0Q2hhbm5lbHM7Kyt4KXtmb3IodmFyIHc9MCxiPTA7YjxuLmJhdGNoU2l6ZTsrK2IpZm9yKHZhciBDPWY7QzxkOysrQylmb3IodmFyIEU9cCtDKnItbCxSPW07UjxnOysrUil7dmFyIFM9ditSKm8tdTt3Kz1jLmdldChiLEUsUyx5KSpoLmdldChiLEMsUix4KX1zLnNldCh3LHAsdix5LHgpfXJldHVybiBzLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW4uc3RyaWRlRGVwdGgsbz1uLnN0cmlkZUhlaWdodCxhPW4uc3RyaWRlV2lkdGgsaT1uLmZpbHRlckRlcHRoLHM9bi5maWx0ZXJIZWlnaHQsdT1uLmZpbHRlcldpZHRoLGw9TnIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksYz1sLnZhbHVlcyxoPWwuc3RyaWRlcyxwPWhbMF0sZj1oWzFdLGQ9aFsyXSx2PWhbM10sbT1lLmRhdGFTeW5jKCksZz1lLnN0cmlkZXMseT1nWzBdLHg9Z1sxXSx3PWdbMl0sYj1nWzNdLEM9dC5kYXRhU3luYygpLEU9dC5zdHJpZGVzLFI9RVswXSxTPUVbMV0sTj1FWzJdLGs9RVszXSxJPW4ucGFkSW5mby5mcm9udCxBPW4ucGFkSW5mby5sZWZ0LFQ9bi5wYWRJbmZvLnRvcCxEPTA7RDxpOysrRClmb3IodmFyIE89TWF0aC5tYXgoMCxNYXRoLmNlaWwoKEktRCkvcikpLF89TWF0aC5taW4obi5vdXREZXB0aCwobi5pbkRlcHRoK0ktRCkvciksTT1EKnAsRj0wO0Y8czsrK0YpZm9yKHZhciBCPU1hdGgubWF4KDAsTWF0aC5jZWlsKChULUYpL28pKSxQPU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K1QtRikvbyksTD1GKmYrTSxXPTA7Vzx1OysrVylmb3IodmFyIFU9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKEEtVykvYSkpLHo9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK0EtVykvYSksVj1XKmQrTCxHPTA7RzxuLmluQ2hhbm5lbHM7KytHKWZvcih2YXIgcT1HKnYrVixIPTA7SDxuLm91dENoYW5uZWxzOysrSCl7Zm9yKHZhciAkPTAsaj0wO2o8bi5iYXRjaFNpemU7KytqKWZvcih2YXIgSz1qKlIsWD1qKnksWT1PO1k8XzsrK1kpZm9yKHZhciBRPShEK1kqci1JKSpTK0ssSj1ZKngrWCxaPUI7WjxQOysrWilmb3IodmFyIHR0PShGK1oqby1UKSpOK1EsZXQ9Wip3K0osbnQ9VTtudDx6OysrbnQpe3ZhciBydD1udCpiK2V0OyQrPUNbKFcrbnQqYS1BKSprK3R0K0ddKm1bcnQrSF19Y1txK0hdPSR9cmV0dXJuIGwudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsbD1uLm91dENoYW5uZWxzL24uaW5DaGFubmVscyxjPU5yKG4ub3V0U2hhcGUsdC5kdHlwZSksaD10LmRhdGFTeW5jKCkscD1lLmRhdGFTeW5jKCksZj1jLnZhbHVlcyxkPTA7ZDxuLmJhdGNoU2l6ZTsrK2QpZm9yKHZhciB2PWQqdC5zdHJpZGVzWzBdLG09ZCpjLnN0cmlkZXNbMF0sZz0wO2c8bi5vdXRIZWlnaHQ7KytnKWZvcih2YXIgeT1tK2cqYy5zdHJpZGVzWzFdLHg9ZypuLnN0cmlkZUhlaWdodC1zLHc9MDt3PHI7Kyt3KXt2YXIgYj14K3cqYTtpZighKGI8MHx8Yj49bi5pbkhlaWdodCkpZm9yKHZhciBDPXcqZS5zdHJpZGVzWzBdLEU9ditiKnQuc3RyaWRlc1sxXSxSPTA7UjxuLm91dFdpZHRoOysrUilmb3IodmFyIFM9eStSKmMuc3RyaWRlc1syXSxOPVIqbi5zdHJpZGVXaWR0aC11LGs9MDtrPG87KytrKXt2YXIgST1OK2sqaTtpZighKEk8MHx8ST49bi5pbldpZHRoKSlmb3IodmFyIEE9QytrKmUuc3RyaWRlc1sxXSxUPUUrSSpuLmluQ2hhbm5lbHMsRD1TLE89QSxfPTA7XzxuLmluQ2hhbm5lbHM7KytfKXtmb3IodmFyIE09aFtUK19dLEY9MDtGPGw7KytGKWZbRCtGXSs9TSpwW08rRl07RCs9bCxPKz1sfX19cmV0dXJuIGMudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImRlcHRod2lzZUNvbnYyRERlcklucHV0XCIpO2Zvcih2YXIgcj1OcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD10LmRhdGFTeW5jKCksYz10LnN0cmlkZXMsaD1jWzBdLHA9Y1sxXSxmPWNbMl0sZD1lLmRhdGFTeW5jKCksdj1lLnN0cmlkZXMsbT12WzBdLGc9dlsxXSx5PXZbMl0seD1uLmJhdGNoU2l6ZSx3PW4uZmlsdGVySGVpZ2h0LGI9bi5maWx0ZXJXaWR0aCxDPW4uaW5DaGFubmVscyxFPW4uaW5IZWlnaHQsUj1uLmluV2lkdGgsUz1uLm91dENoYW5uZWxzLE49bi5vdXRIZWlnaHQsaz1uLm91dFdpZHRoLEk9bi5zdHJpZGVIZWlnaHQsQT1uLnN0cmlkZVdpZHRoLFQ9dy0xLW4ucGFkSW5mby50b3AsRD1iLTEtbi5wYWRJbmZvLmxlZnQsTz1TL0MsXz0wO188eDsrK18pZm9yKHZhciBNPTA7TTxDOysrTSlmb3IodmFyIEY9MDtGPEU7KytGKWZvcih2YXIgQj1GLVQsUD1NYXRoLm1heCgwLE1hdGguY2VpbChCL0kpKSxMPU1hdGgubWluKE4sKHcrQikvSSksVz0wO1c8UjsrK1cpe2Zvcih2YXIgVT1XLUQsej1NYXRoLm1heCgwLE1hdGguY2VpbChVL0EpKSxWPU1hdGgubWluKGssKGIrVSkvQSksRz0wLHE9UDtxPEw7KytxKWZvcih2YXIgSD1xKkktQiwkPXo7JDxWOysrJClmb3IodmFyIGo9aCpfK3AqcStmKiQsSz1tKih3LTEtSCkrZyooYi0xLSgkKkEtVSkpK3kqTSxYPTA7WDxPOysrWCl7Rys9bFtqKyhNKk8rWCldKmRbSytYXX1vW2kqXytzKkYrdSpXK01dPUd9cmV0dXJuIHIudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPU5yKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHU9bi5wYWRJbmZvLmxlZnQsbD1uLnBhZEluZm8udG9wLGM9bi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHMsaD10LmJ1ZmZlclN5bmMoKSxwPWUuYnVmZmVyU3luYygpLGY9MDtmPGE7KytmKWZvcih2YXIgZD1NYXRoLm1heCgwLE1hdGguY2VpbCgobC1mKS9yKSksdj1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtsLWYpL3IpLG09MDttPGk7KyttKWZvcih2YXIgZz1NYXRoLm1heCgwLE1hdGguY2VpbCgodS1tKS9vKSkseT1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrdS1tKS9vKSx4PTA7eDxuLm91dENoYW5uZWxzOysreCl7Zm9yKHZhciB3PU1hdGgudHJ1bmMoeC9jKSxiPXglYyxDPTAsRT0wO0U8bi5iYXRjaFNpemU7KytFKWZvcih2YXIgUj1kO1I8djsrK1IpZm9yKHZhciBTPWYrUipyLWwsTj1nO048eTsrK04pe3ZhciBrPW0rTipvLXU7Qys9aC5nZXQoRSxTLGssdykqcC5nZXQoRSxSLE4seCl9cy5zZXQoQyxmLG0sdyxiKX1yZXR1cm4gcy50b1RlbnNvcigpfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ0aWxlXCIpO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5yYW5rKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10LnNoYXBlW3JdKmVbcl07dmFyIG89TnIobix0LmR0eXBlKSxhPXQuYnVmZmVyU3luYygpO2ZvcihyPTA7cjxvLnZhbHVlcy5sZW5ndGg7KytyKXtmb3IodmFyIGk9by5pbmRleFRvTG9jKHIpLHM9bmV3IEFycmF5KHQucmFuayksdT0wO3U8cy5sZW5ndGg7dSsrKXNbdV09aVt1XSV0LnNoYXBlW3VdO3ZhciBsPWEubG9jVG9JbmRleChzKTtvLnZhbHVlc1tyXT1hLnZhbHVlc1tsXX1yZXR1cm4gby50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicGFkXCIpO3ZhciByPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdC5zaGFwZVtuXStlWzFdfSksbz1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLGE9dC5idWZmZXJTeW5jKCksaT1OcihyLHQuZHR5cGUpOzAhPT1uJiZpLnZhbHVlcy5maWxsKG4pO2Zvcih2YXIgcz0wO3M8dC5zaXplO3MrKyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGw9dS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtvW2VdfSk7aS5zZXQuYXBwbHkoaSxbYS5nZXQuYXBwbHkoYSx1KV0uY29uY2F0KGwpKX1yZXR1cm4gaS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInRyYW5zcG9zZVwiKTtmb3IodmFyIG49bmV3IEFycmF5KHQucmFuaykscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dC5zaGFwZVtlW3JdXTt2YXIgbz10LmRhdGFTeW5jKCksYT1OcihuLHQuZHR5cGUpLGk9dC5idWZmZXJTeW5jKCk7Zm9yKHI9MDtyPHQuc2l6ZTsrK3Ipe2Zvcih2YXIgcz1pLmluZGV4VG9Mb2MociksdT1uZXcgQXJyYXkocy5sZW5ndGgpLGw9MDtsPHUubGVuZ3RoO2wrKyl1W2xdPXNbZVtsXV07dmFyIGM9YS5sb2NUb0luZGV4KHUpO2EudmFsdWVzW2NdPW9bcl19cmV0dXJuIGEudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJnYXRoZXJcIik7dmFyIHI9dC5zaGFwZS5zbGljZSgpLG89ZS5kYXRhU3luYygpO3Jbbl09by5sZW5ndGg7Zm9yKHZhciBhPU5yKHIsdC5kdHlwZSksaT10LmJ1ZmZlclN5bmMoKSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocyksbD11LnNsaWNlKCk7bFtuXT1vW3Vbbl1dO3ZhciBjPWkubG9jVG9JbmRleChsKTthLnZhbHVlc1tzXT1pLnZhbHVlc1tjXX1yZXR1cm4gYS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0XSxcImJhdGNoVG9TcGFjZU5EXCIpO3ZhciByPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pLG89S2UodC5zaGFwZSxlLHIpLGE9WGUoby5sZW5ndGgsZS5sZW5ndGgpLGk9WWUodC5zaGFwZSxlLHIpLHM9UWUobixlLmxlbmd0aCksdT1KZShpLG4sZS5sZW5ndGgpO3JldHVybiB0LnJlc2hhcGUobykudHJhbnNwb3NlKGEpLnJlc2hhcGUoaSkuc2xpY2Uocyx1KX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdF0sXCJzcGFjZVRvQmF0Y2hORFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSxvPVtbMCwwXV07by5wdXNoLmFwcGx5KG8sbik7Zm9yKHZhciBhPTErZS5sZW5ndGg7YTx0LnNoYXBlLmxlbmd0aDsrK2Epby5wdXNoKFswLDBdKTt2YXIgaT10LnBhZChvKSxzPUtlKGkuc2hhcGUsZSxyLCExKSx1PVhlKHMubGVuZ3RoLGUubGVuZ3RoLCExKSxsPVllKGkuc2hhcGUsZSxyLCExKTtyZXR1cm4gaS5yZXNoYXBlKHMpLnRyYW5zcG9zZSh1KS5yZXNoYXBlKGwpfSx0LnByb3RvdHlwZS5wb29sPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInBvb2xcIik7Zm9yKHZhciByPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD1lLnBhZEluZm8udG9wLGM9ZS5wYWRJbmZvLmxlZnQsaD1cIm1heFwiPT09bj9OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHA9dC5kYXRhU3luYygpLGY9TnIoZS5vdXRTaGFwZSx0LmR0eXBlKSxkPWYudmFsdWVzLHY9ZS5vdXRTaGFwZVsxXSplLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sbT1lLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10sZz1lLm91dFNoYXBlWzNdLHk9MDt5PGUuYmF0Y2hTaXplOysreSlmb3IodmFyIHg9eSp2LHc9eSp0LnN0cmlkZXNbMF0sYj0wO2I8ZS5pbkNoYW5uZWxzOysrYilmb3IodmFyIEM9MDtDPGUub3V0SGVpZ2h0OysrQylmb3IodmFyIEU9QypyLWwsUj1NYXRoLm1heCgwLEUpLFM9TWF0aC5taW4oZS5pbkhlaWdodCxzK0UpLE49eCtDKm0saz0wO2s8ZS5vdXRXaWR0aDsrK2spe2Zvcih2YXIgST1rKm8tYyxBPU1hdGgubWF4KDAsSSksVD1NYXRoLm1pbihlLmluV2lkdGgsdStJKSxEPWgsTz0wLF89MCxNPVI7TTxTO00rPWEpe2Zvcih2YXIgRj13K00qdC5zdHJpZGVzWzFdLEI9QTtCPFQ7Qis9aSl7dmFyIFA9cFtGK0IqdC5zdHJpZGVzWzJdK2JdO1wibWF4XCI9PT1uJiZQPkQ/RD1QOlwiYXZnXCI9PT1uJiYoTys9UCxfKyspfWlmKGlzTmFOKEQpKWJyZWFrfWRbTitrKmcrYl09XCJhdmdcIj09PW4/Ty9fOkR9cmV0dXJuIGYudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBvb2wodCxlLFwibWF4XCIpfSx0LnByb3RvdHlwZS5tYXhQb29sUG9zaXRpb25zPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPU5yKGUub3V0U2hhcGUsXCJpbnQzMlwiKSxyPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQsaT1lLmRpbGF0aW9uV2lkdGgscz1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsbD1lLnBhZEluZm8udG9wLGM9ZS5wYWRJbmZvLmxlZnQsaD10LmJ1ZmZlclN5bmMoKSxwPTA7cDxlLmJhdGNoU2l6ZTsrK3ApZm9yKHZhciBmPTA7ZjxlLmluQ2hhbm5lbHM7KytmKWZvcih2YXIgZD0wO2Q8ZS5vdXRIZWlnaHQ7KytkKXtmb3IodmFyIHY9ZCpyLWwsbT12O208MDspbSs9YTtmb3IodmFyIGc9TWF0aC5taW4oZS5pbkhlaWdodCxzK3YpLHk9MDt5PGUub3V0V2lkdGg7Kyt5KXtmb3IodmFyIHg9eSpvLWMsdz14O3c8MDspdys9aTtmb3IodmFyIGI9TWF0aC5taW4oZS5pbldpZHRoLHUreCksQz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksRT0tMSxSPW07UjxnO1IrPWEpZm9yKHZhciBTPVItdixOPXc7TjxiO04rPWkpe3ZhciBrPU4teCxJPWguZ2V0KHAsUixOLGYpO0k+QyYmKEM9SSxFPVMqdStrKX1uLnNldChFLHAsZCx5LGYpfX1yZXR1cm4gbi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFtlLG5dLFwibWF4UG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgbz10aGlzLm1heFBvb2xQb3NpdGlvbnMoZSxyKSxhPXIuc3RyaWRlSGVpZ2h0LGk9ci5zdHJpZGVXaWR0aCxzPXIuZGlsYXRpb25IZWlnaHQsdT1yLmRpbGF0aW9uV2lkdGgsbD1yLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPXIuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1jLTEtci5wYWRJbmZvLmxlZnQscD1sLTEtci5wYWRJbmZvLnRvcCxmPU5yKGUuc2hhcGUsXCJmbG9hdDMyXCIpLGQ9by5idWZmZXJTeW5jKCksdj10LmJ1ZmZlclN5bmMoKSxtPTA7bTxyLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPTA7ZzxyLmluQ2hhbm5lbHM7KytnKWZvcih2YXIgeT0wO3k8ci5pbkhlaWdodDsrK3kpZm9yKHZhciB4PTA7eDxyLmluV2lkdGg7Kyt4KXtmb3IodmFyIHc9eS1wLGI9eC1oLEM9MCxFPTA7RTxsO0UrPXMpe3ZhciBSPSh3K0UpL2E7aWYoIShSPDB8fFI+PXIub3V0SGVpZ2h0fHxNYXRoLmZsb29yKFIpIT09UikpZm9yKHZhciBTPTA7UzxjO1MrPXUpe3ZhciBOPShiK1MpL2k7aWYoIShOPDB8fE4+PXIub3V0V2lkdGh8fE1hdGguZmxvb3IoTikhPT1OKSl7dmFyIGs9bCpjLTEtZC5nZXQobSxSLE4sZyk9PT1FKmMrUz8xOjA7aWYoMCE9PWspQys9di5nZXQobSxSLE4sZykqa319fWYuc2V0KEMsbSx5LHgsZyl9cmV0dXJuIGYudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJhdmdQb29sQmFja3Byb3BcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPW4uZGlsYXRpb25IZWlnaHQsdT1uLmRpbGF0aW9uV2lkdGgsbD1uLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPW4uZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1jLTEtbi5wYWRJbmZvLmxlZnQscD1sLTEtbi5wYWRJbmZvLnRvcCxmPU5yKGUuc2hhcGUsXCJmbG9hdDMyXCIpLGQ9MS8oYSppKSx2PXQuYnVmZmVyU3luYygpLG09MDttPG4uYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPG4uaW5DaGFubmVsczsrK2cpZm9yKHZhciB5PTA7eTxuLmluSGVpZ2h0OysreSlmb3IodmFyIHg9MDt4PG4uaW5XaWR0aDsrK3gpe2Zvcih2YXIgdz15LXAsYj14LWgsQz0wLEU9MDtFPGw7RSs9cyl7dmFyIFI9KHcrRSkvcjtpZighKFI8MHx8Uj49bi5vdXRIZWlnaHR8fE1hdGguZmxvb3IoUikhPT1SKSlmb3IodmFyIFM9MDtTPGM7Uys9dSl7dmFyIE49KGIrUykvbztpZighKE48MHx8Tj49bi5vdXRXaWR0aHx8TWF0aC5mbG9vcihOKSE9PU4pKUMrPXYuZ2V0KG0sUixOLGcpfX1mLnNldChDKmQsbSx5LHgsZyl9cmV0dXJuIGYudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3JldHVybiBKbih0LGUsdGhpcyl9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gWm4odCxlKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImF2Z1Bvb2xcIiksdGhpcy5wb29sKHQsZSxcImF2Z1wiKS50b0Zsb2F0KCl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicmVzaXplQmlsaW5lYXJcIik7Zm9yKHZhciBvPXQuc2hhcGUsYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGw9dC5kYXRhU3luYygpLGM9bmV3IEZsb2F0MzJBcnJheSh5KFthLGUsbix1XSkpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLHA9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGY9MCxkPWhbMF0vcFswXSx2PWhbMV0vcFsxXSxtPTA7bTxhO20rKylmb3IodmFyIGc9MDtnPGU7ZysrKWZvcih2YXIgeD1kKmcsdz1NYXRoLmZsb29yKHgpLGI9eC13LEM9TWF0aC5taW4oaS0xLE1hdGguY2VpbCh4KSksRT1tKnQuc3RyaWRlc1swXSt3KnQuc3RyaWRlc1sxXSxSPW0qdC5zdHJpZGVzWzBdK0MqdC5zdHJpZGVzWzFdLFM9MDtTPG47UysrKWZvcih2YXIgTj12KlMsaz1NYXRoLmZsb29yKE4pLEk9Ti1rLEE9TWF0aC5taW4ocy0xLE1hdGguY2VpbChOKSksVD1FK2sqdC5zdHJpZGVzWzJdLEQ9UitrKnQuc3RyaWRlc1syXSxPPUUrICtBKnQuc3RyaWRlc1syXSxfPVIrQSp0LnN0cmlkZXNbMl0sTT0wO008dTtNKyspe3ZhciBGPWxbVCtNXSxCPWxbRCtNXSxQPUYrKGxbTytNXS1GKSpJLEw9UCsoQisobFtfK01dLUIpKkktUCkqYjtjW2YrK109TH1yZXR1cm4gRm4oYyxbYSxlLG4sdV0pfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsbD11WzFdLGM9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcykscD1bbiYmbD4xP2EtMTphLG4mJmM+MT9pLTE6aV0sZj1bbiYmbD4xP2wtMTpsLG4mJmM+MT9jLTE6Y10sZD1wWzBdL2ZbMF0sdj1wWzFdL2ZbMV0sbT10LmRhdGFTeW5jKCksZz0wLHk9MDt5PG87eSsrKWZvcih2YXIgeD15KmUuc3RyaWRlc1swXSx3PTA7dzxsO3crKylmb3IodmFyIGI9dypkLEM9TWF0aC5mbG9vcihiKSxFPU1hdGgubWluKE1hdGguY2VpbChiKSxhLTEpLFI9eCtDKmUuc3RyaWRlc1sxXSxTPXgrRSplLnN0cmlkZXNbMV0sTj1iLUMsaz0xLU4sST0wO0k8YztJKyspZm9yKHZhciBBPUkqdixUPU1hdGguZmxvb3IoQSksRD1NYXRoLm1pbihNYXRoLmNlaWwoQSksaS0xKSxPPUEtVCxfPTEtTyxNPVIrVCplLnN0cmlkZXNbMl0sRj1SK0QqZS5zdHJpZGVzWzJdLEI9UytUKmUuc3RyaWRlc1syXSxQPVMrRCplLnN0cmlkZXNbMl0sTD1rKl8sVz1rKk8sVT1OKl8sej1OKk8sVj0wO1Y8cztWKyspe3ZhciBHPW1bZysrXTtoW00rVl0rPUcqTCxoW0YrVl0rPUcqVyxoW0IrVl0rPUcqVSxoW1ArVl0rPUcqen1yZXR1cm4gVW4oaCxbbyxpLGEsc10sZS5kdHlwZSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtmb3IodmFyIG89dC5zaGFwZSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sbD10LmRhdGFTeW5jKCksYz1uZXcgRmxvYXQzMkFycmF5KGEqZSpuKnUpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLHA9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGY9aFswXS9wWzBdLGQ9aFsxXS9wWzFdLHY9MCxtPTA7bTxhO20rKylmb3IodmFyIGc9bSp0LnN0cmlkZXNbMF0seT0wO3k8ZTt5KyspZm9yKHZhciB4PWYqeSx3PWcrTWF0aC5taW4oaS0xLHI/TWF0aC5yb3VuZCh4KTpNYXRoLmZsb29yKHgpKSp0LnN0cmlkZXNbMV0sYj0wO2I8bjtiKyspZm9yKHZhciBDPWQqYixFPXcrTWF0aC5taW4ocy0xLHI/TWF0aC5yb3VuZChDKTpNYXRoLmZsb29yKEMpKSp0LnN0cmlkZXNbMl0sUj0wO1I8dTtSKyspe3ZhciBTPWxbRStSXTtjW3YrK109U31yZXR1cm4gRm4oYyxbYSxlLG4sdV0sdC5kdHlwZSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcFwiKTtmb3IodmFyIHI9ZS5zaGFwZSxvPXJbMF0sYT1yWzFdLGk9clsyXSxzPXJbM10sdT10LnNoYXBlLGw9dVsxXSxjPXVbMl0saD1uZXcgRmxvYXQzMkFycmF5KG8qYSppKnMpLHA9dC5kYXRhU3luYygpLGY9W24mJmw+MT9hLTE6YSxuJiZjPjE/aS0xOmldLGQ9W24mJmw+MT9sLTE6bCxuJiZjPjE/Yy0xOmNdLHY9ZlswXS9kWzBdLG09ZlsxXS9kWzFdLGc9MS92LHk9MS9tLHg9MipNYXRoLmNlaWwoZykrMix3PTIqTWF0aC5jZWlsKHkpKzIsYj0wO2I8bztiKyspZm9yKHZhciBDPWIqZS5zdHJpZGVzWzBdLEU9MDtFPGE7RSsrKWZvcih2YXIgUj1DK0UqZS5zdHJpZGVzWzFdLFM9TWF0aC5mbG9vcihFKmcpLE49TWF0aC5mbG9vcihTLXgvMiksaz0wO2s8aTtrKyspZm9yKHZhciBJPVIrayplLnN0cmlkZXNbMl0sQT1NYXRoLmZsb29yKGsqeSksVD1NYXRoLmZsb29yKEEtdy8yKSxEPTA7RDxzO0QrKyl7Zm9yKHZhciBPPTAsXz0wO188eDtfKyspe3ZhciBNPV8rTjtpZighKE08MHx8TT49bCkpe3ZhciBGPUMrTSp0LnN0cmlkZXNbMV0sQj1NKnY7aWYoRT09PU1hdGgubWluKGEtMSxuP01hdGgucm91bmQoQik6TWF0aC5mbG9vcihCKSkpZm9yKHZhciBQPTA7UDx3O1ArKyl7dmFyIEw9UCtUO2lmKCEoTDwwfHxMPj1jKSl7dmFyIFc9RitMKnQuc3RyaWRlc1syXSxVPUwqbTtrPT09TWF0aC5taW4oaS0xLG4/TWF0aC5yb3VuZChVKTpNYXRoLmZsb29yKFUpKSYmKE8rPXBbVytEXSl9fX19aFtJK0RdPU99cmV0dXJuIFVuKGgsZS5zaGFwZSxlLmR0eXBlKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZSxuLG8sYV0sXCJiYXRjaE5vcm1cIik7Zm9yKHZhciBpPXQuZGF0YVN5bmMoKSxzPWUuZGF0YVN5bmMoKSx1PW4uZGF0YVN5bmMoKSxsPW8/by5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzFdKSxjPWE/YS5kYXRhU3luYygpOm5ldyBGbG9hdDMyQXJyYXkoWzBdKSxoPW5ldyBGbG9hdDMyQXJyYXkoaS5sZW5ndGgpLHA9Yy5sZW5ndGgsZj1sLmxlbmd0aCxkPXUubGVuZ3RoLHY9cy5sZW5ndGgsbT0wLGc9MCx5PTAseD0wLHc9MDt3PGkubGVuZ3RoOysrdyloW3ddPWNbbSsrXSsoaVt3XS1zW2crK10pKmxbeSsrXS9NYXRoLnNxcnQodVt4KytdK3IpLG0+PXAmJihtPTApLGc+PXYmJihnPTApLHk+PWYmJih5PTApLHg+PWQmJih4PTApO3JldHVybiBVbihoLHQuc2hhcGUpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREXCIpO3ZhciBhPXQuc2hhcGVbM10saT1hLTEscz10LmRhdGFTeW5jKCksdT10LnNpemUsbD1uZXcgRmxvYXQzMkFycmF5KHUpO2Z1bmN0aW9uIGModCl7Zm9yKHZhciBuPXQlYSxyPXQtbitNYXRoLm1heCgwLG4tZSksbz10LW4rTWF0aC5taW4obitlLGkpLHU9MDtyPD1vO3IrKyl7dmFyIGw9c1tyXTt1Kz1sKmx9cmV0dXJuIHV9Zm9yKHZhciBoPTA7aDx1O2grKyl7dmFyIHA9YyhoKSxmPXNbaF0qTWF0aC5wb3cobityKnAsLW8pO2xbaF09Zn1yZXR1cm4gVW4obCx0LnNoYXBlKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIkxSTkdyYWRcIik7Zm9yKHZhciBzPXQuc2hhcGVbM10sdT10LmRhdGFTeW5jKCksbD1lLmRhdGFTeW5jKCksYz1uLmRhdGFTeW5jKCksaD1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscD10LnNpemUsZj0wO2Y8cDtmKyspe2Zvcih2YXIgZD1mJXMsdj1mLWQrTWF0aC5tYXgoMCxkLXIpLG09Zi1kK01hdGgubWluKHMsZCtyKzEpLGc9MCx5PXY7eTxtO3krKylnKz1NYXRoLnBvdyhsW3ldLDIpO2c9YSpnK287Zm9yKHk9djt5PG07eSsrKXt2YXIgeD0tMiphKmkqbFt5XSpjW2ZdL2c7Zj09PXkmJih4Kz1NYXRoLnBvdyhnLC1pKSkseCo9dVtmXSxoW3ldKz14fX1yZXR1cm4gVW4oaCx0LnNoYXBlKX0sdC5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJtdWx0aW5vbWlhbFwiKTtmb3IodmFyIG89ZT90OlRuKHQpLGE9by5zaGFwZVswXSxpPW8uc2hhcGVbMV0scz1xbihbYSxuXSxcImludDMyXCIpLHU9cy5kYXRhU3luYygpLGw9by5kYXRhU3luYygpLGM9MDtjPGE7KytjKXt2YXIgaD1jKmkscD1uZXcgRmxvYXQzMkFycmF5KGktMSk7cFswXT1sW2hdO2Zvcih2YXIgZj0xO2Y8cC5sZW5ndGg7KytmKXBbZl09cFtmLTFdK2xbaCtmXTtmb3IodmFyIGQ9RXIoci50b1N0cmluZygpKSx2PWMqbixtPTA7bTxuOysrbSl7dmFyIGc9ZCgpO3VbdittXT1wLmxlbmd0aDtmb3IodmFyIHk9MDt5PHAubGVuZ3RoO3krKylpZihnPHBbeV0pe3VbdittXT15O2JyZWFrfX19cmV0dXJuIHN9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm9uZUhvdFwiKTt2YXIgbz1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSplKTtvLmZpbGwocik7Zm9yKHZhciBhPXQuZGF0YVN5bmMoKSxpPTA7aTx0LnNpemU7KytpKWFbaV0+PTAmJmFbaV08ZSYmKG9baSplK2FbaV1dPW4pO3JldHVybiBMbihvLFt0LnNpemUsZV0sXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJub25NYXhTdXBwcmVzc2lvblwiKSxhcih0LmRhdGFTeW5jKCksZS5kYXRhU3luYygpLG4scixvKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEJhdGNoKHQsITEpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEJhdGNoKHQsITApfSx0LnByb3RvdHlwZS5mZnRCYXRjaD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlWzBdLHI9dC5zaGFwZVsxXSxvPU5yKHQuc2hhcGUsXCJmbG9hdDMyXCIpLGE9TnIodC5zaGFwZSxcImZsb2F0MzJcIiksaT1fbih0KS5hczJEKG4scikscz1Nbih0KS5hczJEKG4sciksdT0wO3U8bjt1KyspZm9yKHZhciBsPWkuc2xpY2UoW3UsMF0sWzEscl0pLGM9cy5zbGljZShbdSwwXSxbMSxyXSksaD1PbihsLGMpLHA9dGhpcy5mZnRJbXBsKGgsZSkuZGF0YVN5bmMoKSxmPTA7ZjxyO2YrKyl7dmFyIGQ9bnIocCxmKTtvLnZhbHVlc1t1KnIrZl09ZC5yZWFsLGEudmFsdWVzW3UqcitmXT1kLmltYWd9cmV0dXJuIE9uKG8udG9UZW5zb3IoKSxhLnRvVGVuc29yKCkpLmFzMkQobixyKX0sdC5wcm90b3R5cGUuZmZ0SW1wbD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuYXMxRCgpLHI9bi5zaXplO2lmKHRoaXMuaXNFeHBvbmVudE9mMihyKSl7dmFyIG89dGhpcy5mZnRSYWRpeDIobixyLGUpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKTtyZXR1cm4gZSYmKG89T24oX24obykuZGl2KEJuKHIpKSxNbihvKS5kaXYoQm4ocikpKSksb312YXIgYT10LmRhdGFTeW5jKCksaT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aC8yKSxuPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgvMikscj0wO3I8dC5sZW5ndGg7cis9MillW3IvMl09dFtyXSxuW3IvMl09dFtyKzFdO3JldHVybntyZWFsOmUsaW1hZzpufX0odGhpcy5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWwoYSxyLGUpKTtyZXR1cm4gT24oaS5yZWFsLGkuaW1hZykuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pfSx0LnByb3RvdHlwZS5pc0V4cG9uZW50T2YyPWZ1bmN0aW9uKHQpe3JldHVybiAwPT0odCZ0LTEpfSx0LnByb3RvdHlwZS5mZnRSYWRpeDI9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1lKXJldHVybiB0O3ZhciByPXQuZGF0YVN5bmMoKSxvPWUvMixhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1NYXRoLmNlaWwodC5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxvPTA7bzx0Lmxlbmd0aDtvKz00KW5bTWF0aC5mbG9vcihvLzQpXT10W29dLHJbTWF0aC5mbG9vcihvLzQpXT10W28rMV07cmV0dXJue3JlYWw6bixpbWFnOnJ9fShyKSxpPU9uKGEucmVhbCxhLmltYWcpLmFzMUQoKSxzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1NYXRoLmZsb29yKHQubGVuZ3RoLzQpLG49bmV3IEZsb2F0MzJBcnJheShlKSxyPW5ldyBGbG9hdDMyQXJyYXkoZSksbz0yO288dC5sZW5ndGg7bys9NCluW01hdGguZmxvb3Ioby80KV09dFtvXSxyW01hdGguZmxvb3Ioby80KV09dFtvKzFdO3JldHVybntyZWFsOm4saW1hZzpyfX0ociksdT1PbihzLnJlYWwscy5pbWFnKS5hczFEKCk7aT10aGlzLmZmdFJhZGl4MihpLG8sbiksdT10aGlzLmZmdFJhZGl4Mih1LG8sbik7dmFyIGw9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSh0LzIpLHI9bmV3IEZsb2F0MzJBcnJheSh0LzIpLG89MDtvPE1hdGguY2VpbCh0LzIpO28rKyl7dmFyIGE9KGU/MjotMikqTWF0aC5QSSooby90KTtuW29dPU1hdGguY29zKGEpLHJbb109TWF0aC5zaW4oYSl9cmV0dXJue3JlYWw6bixpbWFnOnJ9fShlLG4pLGM9T24obC5yZWFsLGwuaW1hZykubXVsKHUpLGg9aS5hZGQoYykscD1pLnN1YihjKSxmPV9uKGgpLmNvbmNhdChfbihwKSksZD1NbihoKS5jb25jYXQoTW4ocCkpO3JldHVybiBPbihmLGQpLmFzMUQoKX0sdC5wcm90b3R5cGUuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheSgyKmUpLG89MDtvPGU7bysrKXtmb3IodmFyIGE9MCxpPTAscz0wO3M8ZTtzKyspe3ZhciB1PW9yKG8qcyxlLG4pLGw9bnIodCxzKTthKz1sLnJlYWwqdS5yZWFsLWwuaW1hZyp1LmltYWcsaSs9bC5yZWFsKnUuaW1hZytsLmltYWcqdS5yZWFsfW4mJihhLz1lLGkvPWUpLHJyKHIsYSxpLG8pfXJldHVybiByfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe2QoXCJOSFdDXCI9PT1uLGZ1bmN0aW9uKCl7cmV0dXJuXCJPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCBcIitufSksZChlPjEsZnVuY3Rpb24oKXtyZXR1cm5cImJsb2NrU2l6ZSBzaG91bGQgYmUgPiAxIGZvciBkZXB0aFRvU3BhY2UsIGJ1dCB3YXM6IFwiK2V9KTtmb3IodmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV0sYT10LnNoYXBlWzJdLGk9dC5zaGFwZVszXSxzPW8qZSx1PWEqZSxsPWkvKGUqZSksYz10LmRhdGFTeW5jKCksaD1uZXcgRmxvYXQzMkFycmF5KHIqcyp1KmwpLHA9MCxmPTA7ZjxyOysrZilmb3IodmFyIHY9MDt2PHM7Kyt2KWZvcih2YXIgbT1NYXRoLmZsb29yKHYvZSksZz12JWUseT0wO3k8dTsrK3kpZm9yKHZhciB4PU1hdGguZmxvb3IoeS9lKSx3PShnKmUreSVlKSpsLGI9MDtiPGw7KytiKXt2YXIgQz1iK3craSooeCthKihtK28qZikpO2hbcCsrXT1jW0NdfXJldHVybiBVbihoLFtyLHMsdSxsXSl9LHQucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5T3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89c28odC5zaGFwZSxlLnNoYXBlKSxhPU5yKG8sbiksaT10LmRhdGFTeW5jKCkscz1lLmRhdGFTeW5jKCksdT1hbyh0LnNoYXBlLG8pLGw9YW8oZS5zaGFwZSxvKSxjPWEudmFsdWVzO2lmKHUubGVuZ3RoK2wubGVuZ3RoPT09MClmb3IodmFyIGg9MDtoPGMubGVuZ3RoOysraCljW2hdPXIoaVtoJWkubGVuZ3RoXSxzW2glcy5sZW5ndGhdKTtlbHNle3ZhciBwPXQuYnVmZmVyU3luYygpLGY9ZS5idWZmZXJTeW5jKCksZD1mdW5jdGlvbihuKXt2YXIgbz1hLmluZGV4VG9Mb2MobiksaD1vLnNsaWNlKC10LnJhbmspO3UuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gaFt0XT0wfSk7dmFyIGQ9cC5sb2NUb0luZGV4KGgpLHY9by5zbGljZSgtZS5yYW5rKTtsLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHZbdF09MH0pO3ZhciBtPWYubG9jVG9JbmRleCh2KTtjW25dPXIoaVtkXSxzW21dKX07Zm9yKGg9MDtoPGMubGVuZ3RoOysraClkKGgpfXJldHVybiBhLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1zbyh0LnNoYXBlLGUuc2hhcGUpLG89TnIocixcImZsb2F0MzJcIiksYT1OcihyLFwiZmxvYXQzMlwiKSxpPXQuZGF0YVN5bmMoKSxzPWUuZGF0YVN5bmMoKSx1PWFvKHQuc2hhcGUsciksbD1hbyhlLnNoYXBlLHIpLGM9by52YWx1ZXMsaD1hLnZhbHVlcztpZih1Lmxlbmd0aCtsLmxlbmd0aD09PTApZm9yKHZhciBwPTA7cDxjLmxlbmd0aDtwKyspe3ZhciBmPXAlaS5sZW5ndGgsZD1wJXMubGVuZ3RoLHY9bihpWzIqZl0saVsyKmYrMV0sc1syKmRdLHNbMipkKzFdKTtjW3BdPXYucmVhbCxoW3BdPXYuaW1hZ31lbHNle3ZhciBtPXRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuYnVmZmVyU3luYygpLGc9dGhpcy5kYXRhLmdldChlLmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5idWZmZXJTeW5jKCkseT1mdW5jdGlvbihyKXt2YXIgYT1vLmluZGV4VG9Mb2MocikscD1hLnNsaWNlKC10LnJhbmspO3UuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gcFt0XT0wfSk7dmFyIGY9bS5sb2NUb0luZGV4KHApLGQ9YS5zbGljZSgtZS5yYW5rKTtsLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGRbdF09MH0pO3ZhciB2PWcubG9jVG9JbmRleChkKSx5PW4oaVsyKmZdLGlbMipmKzFdLHNbMip2XSxzWzIqdisxXSk7Y1tyXT15LnJlYWwsaFtyXT15LmltYWd9O2ZvcihwPTA7cDxjLmxlbmd0aDtwKyspeShwKX1yZXR1cm4gdGhpcy5jb21wbGV4KG8udG9UZW5zb3IoKSxhLnRvVGVuc29yKCkpfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHNyKHQsZSxuKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXtyZXR1cm4gMzJ9LHQucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMWUtN30sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7Zm9yKHZhciBpPXQuc2hhcGUscz1pWzBdLHU9aVsxXSxsPWlbMl0sYz1pWzNdLGg9ZS5zaGFwZVswXSxwPXJbMF0sZj1yWzFdLGQ9TnIoW2gscCxmLGNdLHQuZHR5cGUpLHY9ZS5kYXRhU3luYygpLG09bi5kYXRhU3luYygpLGc9dC5kYXRhU3luYygpLHk9dC5zdHJpZGVzLHg9ZC5zdHJpZGVzLHc9MDt3PGg7dysrKXt2YXIgYj00KncsQz12W2JdLEU9dltiKzFdLFI9dltiKzJdLFM9dltiKzNdLE49bVt3XTtpZighKE4+PXMpKWZvcih2YXIgaz1wPjE/KFItQykqKHUtMSkvKHAtMSk6MCxJPWY+MT8oUy1FKSoobC0xKS8oZi0xKTowLEE9MDtBPHA7QSsrKXt2YXIgVD1wPjE/QyoodS0xKStBKms6LjUqKEMrUikqKHUtMSk7aWYoVDwwfHxUPnUtMSlmb3IodmFyIEQ9MDtEPGY7RCsrKWZvcih2YXIgTz0wO088YztPKyspe3ZhciBfPU8rRCp4WzJdK0EqeFsxXSt3KnhbMF07ZC52YWx1ZXNbX109YX1lbHNlIGlmKFwiYmlsaW5lYXJcIj09PW8pe3ZhciBNPU1hdGguZmxvb3IoVCksRj1NYXRoLmNlaWwoVCksQj1ULU07Zm9yKEQ9MDtEPGY7RCsrKXtpZigoSD1mPjE/RSoobC0xKStEKkk6LjUqKEUrUykqKGwtMSkpPDB8fEg+bC0xKWZvcihPPTA7TzxjO08rKyl7Xz1PK0QqeFsyXStBKnhbMV0rdyp4WzBdO2QudmFsdWVzW19dPWF9ZWxzZXt2YXIgUD1NYXRoLmZsb29yKEgpLEw9TWF0aC5jZWlsKEgpLFc9SC1QO2ZvcihPPTA7TzxjO08rKyl7dmFyIFU9Z1tfPU8rUCp5WzJdK00qeVsxXStOKnlbMF1dLHo9Z1tfPU8rTCp5WzJdK00qeVsxXStOKnlbMF1dLFY9Z1tfPU8rUCp5WzJdK0YqeVsxXStOKnlbMF1dLEc9VSsoei1VKSpXLHE9VisoZ1tfPU8rTCp5WzJdK0YqeVsxXStOKnlbMF1dLVYpKlc7Xz1PK0QqeFsyXStBKnhbMV0rdyp4WzBdLGQudmFsdWVzW19dPUcrKHEtRykqQn19fX1lbHNlIGZvcihEPTA7RDxmOysrRCl7dmFyIEg7aWYoKEg9Zj4xP0UqKGwtMSkrRCpJOi41KihFK1MpKihsLTEpKTwwfHxIPmwtMSlmb3IoTz0wO088YztPKyspe189TytEKnhbMl0rQSp4WzFdK3cqeFswXTtkLnZhbHVlc1tfXT1hfWVsc2V7dmFyICQ9TWF0aC5yb3VuZChIKSxqPU1hdGgucm91bmQoVCk7Zm9yKE89MDtPPGM7TysrKXt2YXIgSz1PKyQqeVsyXStqKnlbMV0rTip5WzBdLFg9TytEKnhbMl0rQSp4WzFdK3cqeFswXTtkLnZhbHVlc1tYXT1nW0tdfX19fX1yZXR1cm4gZC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXBuKDAsdCxuKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zbGljZVNpemUsdT1vLnN0cmlkZXMsbD1vLm91dHB1dFNpemU7cmV0dXJuIHRoaXMuc2NhdHRlcih0LGUsbixsLHMsaSxhLHUsciwhMSl9LHQucHJvdG90eXBlLmdhdGhlck5EPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz11bih0LGUpLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXTtpZigwPT09aSlyZXR1cm4gRm4oW10sYSx0LmR0eXBlKTtmb3IodmFyIGw9bmV3IGx0KFtpLHNdLHQuZHR5cGUpLGM9ZS5kYXRhU3luYygpLGg9dC5kYXRhU3luYygpLHA9MDtwPGk7cCsrKXtmb3IodmFyIGY9W10sZD0wLHY9MDt2PHI7disrKXt2YXIgbT1jW3Aqcit2XTtkKz1tKnVbdl0sZi5wdXNoKG0pfWlmKGQ8MHx8ZD49dC5zaXplL3MpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIitmK1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrdC5zaGFwZSk7Zm9yKHZhciBnPTA7ZzxzO2crKylsLnZhbHVlc1twKnMrZ109aFtkKnMrZ119cmV0dXJuIGwudG9UZW5zb3IoKS5yZXNoYXBlKGEpfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXBuKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsbD1CbigwKTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLHUsaSxhLG8scyxsLCEwKX0sdC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7dmFyIHI9QShuPW58fFcoZSkseSh0KSk7cmV0dXJuIHIuZmlsbChlKSxmdC5tYWtlKHQse3ZhbHVlczpyfSxuKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3RyaW5nIHRlbnNvcnNcIik7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLDEsdC5kdHlwZSl9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXt2YXIgZT1BKHQuZHR5cGUseSh0LnNoYXBlKSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9LHQuZHR5cGUpfSx0LnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRyKHQsZSxuKX0sdC5wcm90b3R5cGUuc2NhdHRlcj1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSxsKXt2YXIgYz1bci9vLG9dLGg9dC5kYXRhU3luYygpLHA9ZS5kYXRhU3luYygpO2lmKDA9PT1yKXJldHVybiBGbihbXSxuLGUuZHR5cGUpO3ZhciBmPW5ldyBsdChjLGUuZHR5cGUpO2YudmFsdWVzLmZpbGwodS5kYXRhU3luYygpWzBdKTtmb3IodmFyIGQ9MDtkPGE7ZCsrKXtmb3IodmFyIHY9W10sbT0wLGc9MDtnPGk7ZysrKXt2YXIgeT1oW2QqaStnXTt2LnB1c2goeSksbSs9eSpzW2ddfWlmKG08MHx8bT49ci9vKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kaWNlczogXCIrditcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiK24pO2Zvcih2YXIgeD0wO3g8bzt4KyspbD9mLnZhbHVlc1ttKm8reF0rPXBbZCpvK3hdOmYudmFsdWVzW20qbyt4XT0wPT09ZS5yYW5rP3BbMF06cFtkKm8reF19cmV0dXJuIGYudG9UZW5zb3IoKS5yZXNoYXBlKG4pfSx0fSgpO0R0LnJlZ2lzdGVyQmFja2VuZChcImNwdVwiLGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnY30sMSk7dmFyIHljPXtmbG9hdDMyOjQsaW50MzI6NCx1aW50MTY6Mix1aW50ODoxLGJvb2w6MX07ZnVuY3Rpb24geGModCxlKXtmb3IodmFyIG49e30scj0wLG89ZnVuY3Rpb24oZSl7dmFyIG89ZS5uYW1lLGE9ZS5kdHlwZSxpPWUuc2hhcGUscz15KGkpLHU9dm9pZCAwO2lmKFwicXVhbnRpemF0aW9uXCJpbiBlKXt2YXIgbD1lLnF1YW50aXphdGlvbjtpZihcInVpbnQ4XCIhPT1sLmR0eXBlJiZcInVpbnQxNlwiIT09bC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgXCIrZS5uYW1lK1wiIGhhcyB1bmtub3duIHF1YW50aXphdGlvbiBkdHlwZSBcIitsLmR0eXBlK1wiLiBTdXBwb3J0ZWQgcXVhbnRpemF0aW9uIGR0eXBlcyBhcmU6ICd1aW50OCcgYW5kICd1aW50MTYnLlwiKTt2YXIgYz15Y1tsLmR0eXBlXSxoPXQuc2xpY2UocixyK3MqYykscD1cInVpbnQ4XCI9PT1sLmR0eXBlP25ldyBVaW50OEFycmF5KGgpOm5ldyBVaW50MTZBcnJheShoKTtpZihcImZsb2F0MzJcIj09PWEpdT1GbG9hdDMyQXJyYXkuZnJvbShwLGZ1bmN0aW9uKHQpe3JldHVybiB0Kmwuc2NhbGUrbC5taW59KTtlbHNle2lmKFwiaW50MzJcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7dT1JbnQzMkFycmF5LmZyb20ocCxmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0Kmwuc2NhbGUrbC5taW4pfSl9cis9cypjfWVsc2V7dmFyIGY9eWNbYV07aD10LnNsaWNlKHIscitzKmYpO2lmKFwiZmxvYXQzMlwiPT09YSl1PW5ldyBGbG9hdDMyQXJyYXkoaCk7ZWxzZSBpZihcImludDMyXCI9PT1hKXU9bmV3IEludDMyQXJyYXkoaCk7ZWxzZXtpZihcImJvb2xcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7dT1uZXcgVWludDhBcnJheShoKX1yKz1zKmZ9dmFyIGQ9dm9pZCAwO2lmKFwiZmxvYXQzMlwiPT09YSlkPUZuKHUsaSxcImZsb2F0MzJcIik7ZWxzZSBpZihcImludDMyXCI9PT1hKWQ9Rm4odSxpLFwiaW50MzJcIik7ZWxzZXtpZihcImJvb2xcIiE9PWEpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIitvK1wiJzogXCIrYSk7ZD1Gbih1LGksXCJib29sXCIpfW5bb109ZH0sYT0wLGk9ZTthPGkubGVuZ3RoO2ErKyl7byhpW2FdKX1yZXR1cm4gbn1mdW5jdGlvbiB3Yyh0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHZhbHVlOiBcIitKU09OLnN0cmluZ2lmeSh0KSk7dmFyIGU9MCxuPVtdO3QuZm9yRWFjaChmdW5jdGlvbih0KXtpZihlKz10LmJ5dGVMZW5ndGgsbi5wdXNoKHQuYnl0ZUxlbmd0aD09PXQuYnVmZmVyLmJ5dGVMZW5ndGg/dDpuZXcgdC5jb25zdHJ1Y3Rvcih0KSksISh0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGVkQXJyYXkgc3VidHlwZTogXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKX0pO3ZhciByPW5ldyBVaW50OEFycmF5KGUpLG89MDtyZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Iuc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSxvKSxvKz10LmJ5dGVMZW5ndGh9KSxyLmJ1ZmZlcn12YXIgYmM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlciYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYXRvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGJ0b2EpO2Z1bmN0aW9uIENjKHQpe3JldHVybiBiYz9CdWZmZXIuYnl0ZUxlbmd0aCh0KTpuZXcgQmxvYihbdF0pLnNpemV9ZnVuY3Rpb24gRWModCl7dmFyIGU9MDt0LmZvckVhY2goZnVuY3Rpb24odCl7ZSs9dC5ieXRlTGVuZ3RofSk7dmFyIG49bmV3IFVpbnQ4QXJyYXkoZSkscj0wO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7bi5zZXQobmV3IFVpbnQ4QXJyYXkodCkscikscis9dC5ieXRlTGVuZ3RofSksbi5idWZmZXJ9ZnVuY3Rpb24gUmModCl7Zm9yKHQ9dC50cmltKCk7dC5lbmRzV2l0aChcIi9cIik7KXQ9dC5zbGljZSgwLHQubGVuZ3RoLTEpO3ZhciBlPXQuc3BsaXQoXCIvXCIpO3JldHVybiBlW2UubGVuZ3RoLTFdfWZ1bmN0aW9uIFNjKHQpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEpTT04gbW9kZWwgdG9wb2xvZ3ksIHJlY2VpdmVkIEFycmF5QnVmZmVyLlwiKTtyZXR1cm57ZGF0ZVNhdmVkOm5ldyBEYXRlLG1vZGVsVG9wb2xvZ3lUeXBlOlwiSlNPTlwiLG1vZGVsVG9wb2xvZ3lCeXRlczpudWxsPT10Lm1vZGVsVG9wb2xvZ3k/MDpDYyhKU09OLnN0cmluZ2lmeSh0Lm1vZGVsVG9wb2xvZ3kpKSx3ZWlnaHRTcGVjc0J5dGVzOm51bGw9PXQud2VpZ2h0U3BlY3M/MDpDYyhKU09OLnN0cmluZ2lmeSh0LndlaWdodFNwZWNzKSksd2VpZ2h0RGF0YUJ5dGVzOm51bGw9PXQud2VpZ2h0RGF0YT8wOnQud2VpZ2h0RGF0YS5ieXRlTGVuZ3RofX12YXIgTmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5zYXZlUm91dGVycz1bXSx0aGlzLmxvYWRSb3V0ZXJzPVtdfXJldHVybiB0LmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyU2F2ZVJvdXRlcj1mdW5jdGlvbihlKXt0LmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMucHVzaChlKX0sdC5yZWdpc3RlckxvYWRSb3V0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzLnB1c2goZSl9LHQuZ2V0U2F2ZUhhbmRsZXJzPWZ1bmN0aW9uKGUpe3JldHVybiB0LmdldEhhbmRsZXJzKGUsXCJzYXZlXCIpfSx0LmdldExvYWRIYW5kbGVycz1mdW5jdGlvbihlLG4pe3JldHVybiB0LmdldEhhbmRsZXJzKGUsXCJsb2FkXCIsbil9LHQuZ2V0SGFuZGxlcnM9ZnVuY3Rpb24oZSxuLHIpe3ZhciBvPVtdO3JldHVybihcImxvYWRcIj09PW4/dC5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzOnQuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycykuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj10KGUscik7bnVsbCE9PW4mJm8ucHVzaChuKX0pLG99LHR9KCksa2M9XCI6Ly9cIixJYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLm1hbmFnZXJzPXt9fXJldHVybiB0LmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyTWFuYWdlcj1mdW5jdGlvbihlLG4pe2QobnVsbCE9ZSxmdW5jdGlvbigpe3JldHVyblwic2NoZW1lIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsLlwifSksZS5lbmRzV2l0aChrYykmJihlPWUuc2xpY2UoMCxlLmluZGV4T2Yoa2MpKSksZChlLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJzY2hlbWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlwifSk7dmFyIHI9dC5nZXRJbnN0YW5jZSgpO2QobnVsbD09ci5tYW5hZ2Vyc1tlXSxmdW5jdGlvbigpe3JldHVyblwiQSBtb2RlbCBzdG9yZSBtYW5hZ2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3Igc2NoZW1lICdcIitlK1wiJy5cIn0pLHIubWFuYWdlcnNbZV09bn0sdC5nZXRNYW5hZ2VyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1t0XTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIG1hbmFnZXIgZm9yIHNjaGVtZSAnXCIrdCtcIidcIik7cmV0dXJuIGV9LHQuZ2V0U2NoZW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnMpfSx0fSgpO2Z1bmN0aW9uIEFjKHQpe2lmKC0xPT09dC5pbmRleE9mKGtjKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdXJsIHN0cmluZyBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIGEgc2NoZW1lLiBTdXBwb3J0ZWQgc2NoZW1lcyBhcmU6IFwiK0ljLmdldFNjaGVtZXMoKS5qb2luKFwiLFwiKSk7cmV0dXJue3NjaGVtZTp0LnNwbGl0KGtjKVswXSxwYXRoOnQuc3BsaXQoa2MpWzFdfX1mdW5jdGlvbiBUYyh0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLGEsaSxzLHUsbCxjLGgscDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGQodCE9PWUsZnVuY3Rpb24oKXtyZXR1cm5cIk9sZCBwYXRoIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWU6ICdcIit0K1wiJ1wifSksZCgocj1OYy5nZXRMb2FkSGFuZGxlcnModCkpLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIGxvYWQgaGFuZGxlciBpcyBmb3VuZCBmb3Igc291cmNlIFVSTCBcIit0K1wiLlwifSksZChyLmxlbmd0aDwyLGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiK3IubGVuZ3RoK1wiKSBsb2FkIGhhbmRsZXJzIGZvciBzb3VyY2UgVVJMIFwiK3QrXCIuXCJ9KSxhPXJbMF0sZCgoaT1OYy5nZXRTYXZlSGFuZGxlcnMoZSkpLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSxkKGkubGVuZ3RoPDIsZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrci5sZW5ndGgrXCIpIHNhdmUgaGFuZGxlcnMgZm9yIGRlc3RpbmF0aW9uIFVSTCBcIitlK1wiLlwifSkscz1pWzBdLHU9QWModCkuc2NoZW1lLGw9QWModCkucGF0aCxjPXU9PT1BYyh0KS5zY2hlbWUsWzQsYS5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gaD1vLnNlbnQoKSxuJiZjP1s0LEljLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwobCldOlszLDNdO2Nhc2UgMjpvLnNlbnQoKSxvLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LHMuc2F2ZShoKV07Y2FzZSA0OnJldHVybiBwPW8uc2VudCgpLCFufHxjP1szLDZdOls0LEljLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwobCldO2Nhc2UgNTpvLnNlbnQoKSxvLmxhYmVsPTY7Y2FzZSA2OnJldHVyblsyLHAubW9kZWxBcnRpZmFjdHNJbmZvXX19KX0pfXZhciBEYz1cIm1vZGVsc19zdG9yZVwiLE9jPVwibW9kZWxfaW5mb19zdG9yZVwiO2Z1bmN0aW9uIF9jKCl7aWYoIWEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBJbmRleGVkREIgZmFjdG9yeSBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50aXMgbm90IGEgd2ViIGJyb3dzZXIuXCIpO3ZhciB0PXdpbmRvdyxlPXQuaW5kZXhlZERCfHx0Lm1vekluZGV4ZWREQnx8dC53ZWJraXRJbmRleGVkREJ8fHQubXNJbmRleGVkREJ8fHQuc2hpbUluZGV4ZWREQjtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgSW5kZXhlZERCLlwiKTtyZXR1cm4gZX1mdW5jdGlvbiBNYyh0KXt2YXIgZT10LnJlc3VsdDtlLmNyZWF0ZU9iamVjdFN0b3JlKERjLHtrZXlQYXRoOlwibW9kZWxQYXRoXCJ9KSxlLmNyZWF0ZU9iamVjdFN0b3JlKE9jLHtrZXlQYXRoOlwibW9kZWxQYXRoXCJ9KX12YXIgRmM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuaW5kZXhlZERCPV9jKCksbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIEluZGV4ZWREQiwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCx0KV19KX0pfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoKV19KX0pfSx0LnByb3RvdHlwZS5kYXRhYmFzZUFjdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7dmFyIG89bi5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO28ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIE1jKG8pfSxvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBhPW8ucmVzdWx0O2lmKG51bGw9PWUpe3ZhciBpPWEudHJhbnNhY3Rpb24oRGMsXCJyZWFkb25seVwiKSxzPWkub2JqZWN0U3RvcmUoRGMpLmdldChuLm1vZGVsUGF0aCk7cy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtpZihudWxsPT1zLnJlc3VsdClyZXR1cm4gYS5jbG9zZSgpLHIobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICdcIituLm1vZGVsUGF0aCtcIicgaW4gSW5kZXhlZERCLlwiKSk7dChzLnJlc3VsdC5tb2RlbEFydGlmYWN0cyl9LHMub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIocy5lcnJvcil9LGkub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fWVsc2V7dmFyIHUsbD1TYyhlKSxjPWEudHJhbnNhY3Rpb24oT2MsXCJyZWFkd3JpdGVcIiksaD1jLm9iamVjdFN0b3JlKE9jKSxwPWgucHV0KHttb2RlbFBhdGg6bi5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHNJbmZvOmx9KTtwLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBvPSh1PWEudHJhbnNhY3Rpb24oRGMsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKERjKS5wdXQoe21vZGVsUGF0aDpuLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0czplLG1vZGVsQXJ0aWZhY3RzSW5mbzpsfSk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdCh7bW9kZWxBcnRpZmFjdHNJbmZvOmx9KX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPShoPWMub2JqZWN0U3RvcmUoT2MpKS5kZWxldGUobi5tb2RlbFBhdGgpO2Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKSxyKG8uZXJyb3IpfSxlLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKG8uZXJyb3IpfX19LHAub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIocC5lcnJvcil9LGMub25jb21wbGV0ZT1mdW5jdGlvbigpe251bGw9PXU/YS5jbG9zZSgpOnUub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fX19LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcihvLmVycm9yKX19KX0sdC5VUkxfU0NIRU1FPVwiaW5kZXhlZGRiOi8vXCIsdH0oKSxCYz1mdW5jdGlvbih0KXtyZXR1cm4gYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChGYy5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKEZjLlVSTF9TQ0hFTUUubGVuZ3RoKSxuZXcgRmMoZSkpOm51bGw7dmFyIGV9O05jLnJlZ2lzdGVyU2F2ZVJvdXRlcihCYyksTmMucmVnaXN0ZXJMb2FkUm91dGVyKEJjKTt2YXIgUGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5pbmRleGVkREI9X2MoKX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMixuZXcgUHJvbWlzZShmdW5jdGlvbihlLG4pe3ZhciByPXQuaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtyLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBNYyhyKX0sci5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgdD1yLnJlc3VsdCxvPXQudHJhbnNhY3Rpb24oT2MsXCJyZWFkb25seVwiKSxhPW8ub2JqZWN0U3RvcmUoT2MpLmdldEFsbCgpO2Eub25zdWNjZXNzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LG49MCxyPWEucmVzdWx0O248ci5sZW5ndGg7bisrKXt2YXIgbz1yW25dO3Rbby5tb2RlbFBhdGhdPW8ubW9kZWxBcnRpZmFjdHNJbmZvfWUodCl9LGEub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gdC5jbG9zZSgpLG4oYS5lcnJvcil9LG8ub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiB0LmNsb3NlKCl9fSxyLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG4oci5lcnJvcil9fSldfSl9KX0sdC5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiB0PShyPXQpLnN0YXJ0c1dpdGgoRmMuVVJMX1NDSEVNRSk/ci5zbGljZShGYy5VUkxfU0NIRU1FLmxlbmd0aCk6cixbMixuZXcgUHJvbWlzZShmdW5jdGlvbihuLHIpe3ZhciBvPWUuaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBNYyhvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZSxhPW8ucmVzdWx0LGk9YS50cmFuc2FjdGlvbihPYyxcInJlYWR3cml0ZVwiKSxzPWkub2JqZWN0U3RvcmUoT2MpLHU9cy5nZXQodCk7dS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtpZihudWxsPT11LnJlc3VsdClyZXR1cm4gYS5jbG9zZSgpLHIobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICdcIit0K1wiJyBpbiBJbmRleGVkREIuXCIpKTt2YXIgbz1zLmRlbGV0ZSh0KSxpPWZ1bmN0aW9uKCl7dmFyIG89KGU9YS50cmFuc2FjdGlvbihEYyxcInJlYWR3cml0ZVwiKSkub2JqZWN0U3RvcmUoRGMpLmRlbGV0ZSh0KTtvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBuKHUucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mbyl9LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcih1LmVycm9yKX19O28ub25zdWNjZXNzPWksby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBpKCksYS5jbG9zZSgpLHIodS5lcnJvcil9fSx1Lm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHUuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT1lP2EuY2xvc2UoKTplLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19LG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcihvLmVycm9yKX19KV19KX0pfSx0fSgpO2lmKGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdHJ5e0ljLnJlZ2lzdGVyTWFuYWdlcihGYy5VUkxfU0NIRU1FLG5ldyBQYyl9Y2F0Y2godCl7fXZhciBMYz1cIi9cIixXYz1cInRlbnNvcmZsb3dqc19tb2RlbHNcIixVYz1cImluZm9cIix6Yz1cIm1vZGVsX3RvcG9sb2d5XCIsVmM9XCJ3ZWlnaHRfc3BlY3NcIixHYz1cIndlaWdodF9kYXRhXCIscWM9XCJtb2RlbF9tZXRhZGF0YVwiO2Z1bmN0aW9uIEhjKHQpe3JldHVybntpbmZvOltXYyx0LFVjXS5qb2luKExjKSx0b3BvbG9neTpbV2MsdCx6Y10uam9pbihMYyksd2VpZ2h0U3BlY3M6W1djLHQsVmNdLmpvaW4oTGMpLHdlaWdodERhdGE6W1djLHQsR2NdLmpvaW4oTGMpLG1vZGVsTWV0YWRhdGE6W1djLHQscWNdLmpvaW4oTGMpfX1mdW5jdGlvbiAkYyh0KXt2YXIgZT10LnNwbGl0KExjKTtpZihlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IGZvcm1hdDogXCIrdCk7cmV0dXJuIGUuc2xpY2UoMSxlLmxlbmd0aC0xKS5qb2luKExjKX12YXIgamM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKCFhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpfHx2b2lkIDA9PT13aW5kb3cubG9jYWxTdG9yYWdlKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgbG9jYWwgc3RvcmFnZS5cIik7aWYodGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlLG51bGw9PXR8fCF0KXRocm93IG5ldyBFcnJvcihcIkZvciBsb2NhbCBzdG9yYWdlLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD10LHRoaXMua2V5cz1IYyh0aGlzLm1vZGVsUGF0aCl9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtlPUpTT04uc3RyaW5naWZ5KHQubW9kZWxUb3BvbG9neSksbj1KU09OLnN0cmluZ2lmeSh0LndlaWdodFNwZWNzKSxyPVNjKHQpO3RyeXtyZXR1cm4gdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5pbmZvLEpTT04uc3RyaW5naWZ5KHIpKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5LGUpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MsbiksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhLChhPXQud2VpZ2h0RGF0YSxiYz9CdWZmZXIuZnJvbShhKS50b1N0cmluZyhcImJhc2U2NFwiKTpidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheShhKSkpKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhLEpTT04uc3RyaW5naWZ5KHtmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5fSkpLFsyLHttb2RlbEFydGlmYWN0c0luZm86cn1dfWNhdGNoKHQpe3Rocm93IHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy50b3BvbG9neSksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcyksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgdG8gbG9jYWwgc3RvcmFnZTogc2l6ZSBxdW90YSBiZWluZyBleGNlZWRlZCBpcyBhIHBvc3NpYmxlIGNhdXNlIG9mIHRoaXMgZmFpbHVyZTogbW9kZWxUb3BvbG9neUJ5dGVzPVwiK3IubW9kZWxUb3BvbG9neUJ5dGVzK1wiLCB3ZWlnaHRTcGVjc0J5dGVzPVwiK3Iud2VpZ2h0U3BlY3NCeXRlcytcIiwgd2VpZ2h0RGF0YUJ5dGVzPVwiK3Iud2VpZ2h0RGF0YUJ5dGVzK1wiLlwiKX12YXIgYTtyZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsYSxpLHM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtpZihudWxsPT0odD1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMuaW5mbykpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGVyZSBpcyBubyBtb2RlbCB3aXRoIG5hbWUgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJ1wiKTtpZihcIkpTT05cIiE9PXQubW9kZWxUb3BvbG9neVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZSBkb2VzIG5vdCBzdXBwb3J0IGxvYWRpbmcgbm9uLUpTT04gbW9kZWwgdG9wb2xvZ3kgeWV0LlwiKTtpZihlPXt9LG51bGw9PShuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSkpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgdG9wb2xvZ3kgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBpcyBtaXNzaW5nLlwiKTtpZihlLm1vZGVsVG9wb2xvZ3k9bixudWxsPT0ocj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHdlaWdodCBzcGVjcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtpZihlLndlaWdodFNwZWNzPXIsbnVsbCE9KGE9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKSkmJihpPUpTT04ucGFyc2UoYSksZS5mb3JtYXQ9aS5mb3JtYXQsZS5nZW5lcmF0ZWRCeT1pLmdlbmVyYXRlZEJ5LGUuY29udmVydGVkQnk9aS5jb252ZXJ0ZWRCeSksbnVsbD09KHM9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIGJpbmFyeSB3ZWlnaHQgdmFsdWVzIG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgYXJlIG1pc3NpbmcuXCIpO3JldHVybiBlLndlaWdodERhdGE9ZnVuY3Rpb24odCl7aWYoYmMpe3ZhciBlPUJ1ZmZlci5mcm9tKHQsXCJiYXNlNjRcIik7cmV0dXJuIGUuYnVmZmVyLnNsaWNlKGUuYnl0ZU9mZnNldCxlLmJ5dGVPZmZzZXQrZS5ieXRlTGVuZ3RoKX1mb3IodmFyIG49YXRvYih0KSxyPW5ldyBVaW50OEFycmF5KG4ubGVuZ3RoKSxvPTA7bzxuLmxlbmd0aDsrK28pci5zZXQoW24uY2hhckNvZGVBdChvKV0sbyk7cmV0dXJuIHIuYnVmZmVyfShzKSxbMixlXX0pfSl9LHQuVVJMX1NDSEVNRT1cImxvY2Fsc3RvcmFnZTovL1wiLHR9KCksS2M9ZnVuY3Rpb24odCl7cmV0dXJuIGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoamMuVVJMX1NDSEVNRSk/KGU9dC5zbGljZShqYy5VUkxfU0NIRU1FLmxlbmd0aCksbmV3IGpjKGUpKTpudWxsO3ZhciBlfTtOYy5yZWdpc3RlclNhdmVSb3V0ZXIoS2MpLE5jLnJlZ2lzdGVyTG9hZFJvdXRlcihLYyk7dmFyIFhjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2QoYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSxmdW5jdGlvbigpe3JldHVyblwiQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlclwifSksZCh2b2lkIDAhPT13aW5kb3cubG9jYWxTdG9yYWdlLGZ1bmN0aW9uKCl7cmV0dXJuXCJDdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgbG9jYWxTdG9yYWdlXCJ9KSx0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2V9cmV0dXJuIHQucHJvdG90eXBlLmxpc3RNb2RlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG4scixhLGk7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtmb3IodD17fSxlPVdjK0xjLG49TGMrVWMscj0wO3I8dGhpcy5MUy5sZW5ndGg7KytyKShhPXRoaXMuTFMua2V5KHIpKS5zdGFydHNXaXRoKGUpJiZhLmVuZHNXaXRoKG4pJiYoaT0kYyhhKSx0W2ldPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGEpKSk7cmV0dXJuWzIsdF19KX0pfSx0LnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7dmFyIG87aWYodD0obz10KS5zdGFydHNXaXRoKGpjLlVSTF9TQ0hFTUUpP28uc2xpY2UoamMuVVJMX1NDSEVNRS5sZW5ndGgpOm8sZT1IYyh0KSxudWxsPT10aGlzLkxTLmdldEl0ZW0oZS5pbmZvKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCBhdCBwYXRoICdcIit0K1wiJ1wiKTtyZXR1cm4gbj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShlLmluZm8pKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS5pbmZvKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS50b3BvbG9neSksdGhpcy5MUy5yZW1vdmVJdGVtKGUud2VpZ2h0U3BlY3MpLHRoaXMuTFMucmVtb3ZlSXRlbShlLndlaWdodERhdGEpLFsyLG5dfSl9KX0sdH0oKTtpZihhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRyeXtJYy5yZWdpc3Rlck1hbmFnZXIoamMuVVJMX1NDSEVNRSxuZXcgWGMpfWNhdGNoKHQpe312YXIgWWM9XCJtb2RlbFwiLFFjPVwiLmpzb25cIixKYz1cIi53ZWlnaHRzLmJpblwiO2Z1bmN0aW9uIFpjKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtyZXR1cm4gc2V0VGltZW91dCh0KX0pLnRoZW4odCl9dmFyIHRoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtpZighYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VyRG93bmxvYWRzKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSBicm93c2VyLlwiKTtlLnN0YXJ0c1dpdGgodC5VUkxfU0NIRU1FKSYmKGU9ZS5zbGljZSh0LlVSTF9TQ0hFTUUubGVuZ3RoKSksbnVsbCE9ZSYmMCE9PWUubGVuZ3RofHwoZT1ZYyksdGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWU9ZStRYyx0aGlzLndlaWdodERhdGFGaWxlTmFtZT1lK0pjfXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixhLGkscztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYoZT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbdC53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSkpLCEodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVyblszLDFdO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXJEb3dubG9hZHMuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7Y2FzZSAxOnJldHVybiBuPVt7cGF0aHM6W1wiLi9cIit0aGlzLndlaWdodERhdGFGaWxlTmFtZV0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0scj17bW9kZWxUb3BvbG9neTp0Lm1vZGVsVG9wb2xvZ3ksZm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx3ZWlnaHRzTWFuaWZlc3Q6bn0sYT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocildLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSkpLChpPW51bGw9PXRoaXMuanNvbkFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLmpzb25BbmNob3IpLmRvd25sb2FkPXRoaXMubW9kZWxUb3BvbG9neUZpbGVOYW1lLGkuaHJlZj1hLFs0LFpjKGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKX0pXTtjYXNlIDI6cmV0dXJuIG8uc2VudCgpLG51bGw9PXQud2VpZ2h0RGF0YT9bMyw0XTooKHM9bnVsbD09dGhpcy53ZWlnaHREYXRhQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMud2VpZ2h0RGF0YUFuY2hvcikuZG93bmxvYWQ9dGhpcy53ZWlnaHREYXRhRmlsZU5hbWUscy5ocmVmPWUsWzQsWmMoZnVuY3Rpb24oKXtyZXR1cm4gcy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfSldKTtjYXNlIDM6by5zZW50KCksby5sYWJlbD00O2Nhc2UgNDpyZXR1cm5bMix7bW9kZWxBcnRpZmFjdHNJbmZvOlNjKHQpfV19fSl9KX0sdC5VUkxfU0NIRU1FPVwiZG93bmxvYWRzOi8vXCIsdH0oKSxlaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYobnVsbD09dHx8dC5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCBcIit0KTt0aGlzLmZpbGVzPXR9cmV0dXJuIHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG49dGhpcztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3JldHVybiB0PXRoaXMuZmlsZXNbMF0sZT10aGlzLmZpbGVzLnNsaWNlKDEpLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsbyl7dmFyIGE9bmV3IEZpbGVSZWFkZXI7YS5vbmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGk9SlNPTi5wYXJzZShhLnRhcmdldC5yZXN1bHQpLHM9aS5tb2RlbFRvcG9sb2d5O2lmKG51bGwhPXMpezA9PT1lLmxlbmd0aCYmcih7bW9kZWxUb3BvbG9neTpzfSk7dmFyIHU9aS53ZWlnaHRzTWFuaWZlc3Q7aWYobnVsbCE9dSl7dmFyIGw7dHJ5e2w9bi5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXModSxlKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCBvKHQpfXZhciBjPVtdLGg9W10scD1bXTt1LmZvckVhY2goZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2gucHVzaCh0KSxwLnB1c2gobnVsbCl9KSxjLnB1c2guYXBwbHkoYyx0LndlaWdodHMpfSksdS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1uZXcgRmlsZVJlYWRlcjtlLm9ubG9hZD1mdW5jdGlvbihlKXt2YXIgbj1lLnRhcmdldC5yZXN1bHQsbz1oLmluZGV4T2YodCk7cFtvXT1uLC0xPT09cC5pbmRleE9mKG51bGwpJiZyKHttb2RlbFRvcG9sb2d5OnMsd2VpZ2h0U3BlY3M6Yyx3ZWlnaHREYXRhOkVjKHApfSl9LGUub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbyhcIkZhaWxlZCB0byB3ZWlnaHRzIGRhdGEgZnJvbSBmaWxlIG9mIHBhdGggJ1wiK3QrXCInLlwiKX0sZS5yZWFkQXNBcnJheUJ1ZmZlcihsW3RdKX0pfSl9ZWxzZSBvKG5ldyBFcnJvcihcIndlaWdodE1hbmlmZXN0IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfWVsc2UgbyhuZXcgRXJyb3IoXCJtb2RlbFRvcG9sb2d5IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIGZyb20gZmlsZSAnXCIrdC5uYW1lK1wiJy4gQnJvd3NlckZpbGVzIHN1cHBvcnRzIGxvYWRpbmcgS2VyYXMtc3R5bGUgdGYuTW9kZWwgYXJ0aWZhY3RzIG9ubHkuXCIpfSxhLnJlYWRBc1RleHQodCl9KV19KX0pfSx0LnByb3RvdHlwZS5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gUmModC5uYW1lKX0pLG89e30sYT0wLGk9dDthPGkubGVuZ3RoO2ErKyl7aVthXS5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBhPVJjKHQpO2lmKC0xIT09bi5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBmaWxlIGJhc2VuYW1lIGZvdW5kIGluIHdlaWdodHMgbWFuaWZlc3Q6ICdcIithK1wiJ1wiKTtpZihuLnB1c2goYSksLTE9PT1yLmluZGV4T2YoYSkpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IGZpbGUgd2l0aCBiYXNlbmFtZSAnXCIrYStcIicgaXMgbm90IHByb3ZpZGVkLlwiKTtvW3RdPWVbci5pbmRleE9mKGEpXX0pfWlmKG4ubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBmaWxlcyBpbiB3ZWlnaHRzIG1hbmlmZXN0IChcIituLmxlbmd0aCtcIikgYW5kIHRoZSBudW1iZXIgb2Ygd2VpZ2h0IGZpbGVzIHByb3ZpZGVkIChcIitlLmxlbmd0aCtcIikuXCIpO3JldHVybiBvfSx0fSgpO2Z1bmN0aW9uIG5oKHQsZSxuLHIpeyFmdW5jdGlvbih0KXtkKG51bGwhPXQmJkFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cInByb21pc2VzIG11c3QgYmUgYSBub25lIGVtcHR5IGFycmF5XCJ9KX0odCksZnVuY3Rpb24odCxlKXtkKHQ+PTAmJnQ8PTEsZnVuY3Rpb24oKXtyZXR1cm5cIlByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gXCIrdH0pLGQoZT49MCYmZTw9MSxmdW5jdGlvbigpe3JldHVyblwiUHJvZ3Jlc3MgZnJhY3Rpb24gbXVzdCBiZSBpbiByYW5nZSBbMCwgMV0sIGJ1dCBnb3QgZW5kRnJhY3Rpb24gXCIrZX0pLGQoZT49dCxmdW5jdGlvbigpe3JldHVyblwic3RhcnRGcmFjdGlvbiBtdXN0IGJlIG5vIG1vcmUgdGhhbiBlbmRGcmFjdGlvbiwgYnV0IGdvdCBzdGFydEZyYWN0aW9uIFwiK3QrXCIgYW5kIGVuZEZyYWN0aW9uIFwiK2V9KX0obj1udWxsPT1uPzA6bixyPW51bGw9PXI/MTpyKTt2YXIgbz0wO3JldHVybiBQcm9taXNlLmFsbCh0Lm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS50aGVuKGZ1bmN0aW9uKGEpe3ZhciBpPW4rICsrby90Lmxlbmd0aCooci1uKTtyZXR1cm4gZShpKSxhfSksYX0pKX1mdW5jdGlvbiByaCh0LGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsYSxpLHMsdSxsLGMsaDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PWUmJihlPXt9KSxuPW51bGw9PWUuZmV0Y2hGdW5jP0o6ZS5mZXRjaEZ1bmMscj10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUucmVxdWVzdEluaXQpfSksYT0wLGk9LjUsbnVsbCE9ZS5vblByb2dyZXNzP1szLDJdOls0LFByb21pc2UuYWxsKHIpXTtjYXNlIDE6cmV0dXJuIHM9by5zZW50KCksWzMsNF07Y2FzZSAyOnJldHVybls0LG5oKHIsZS5vblByb2dyZXNzLGEsaSldO2Nhc2UgMzpzPW8uc2VudCgpLG8ubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIHU9cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pLGw9LjUsYz0xLG51bGwhPWUub25Qcm9ncmVzcz9bMyw2XTpbNCxQcm9taXNlLmFsbCh1KV07Y2FzZSA1OnJldHVybiBoPW8uc2VudCgpLFszLDhdO2Nhc2UgNjpyZXR1cm5bNCxuaCh1LGUub25Qcm9ncmVzcyxsLGMpXTtjYXNlIDc6aD1vLnNlbnQoKSxvLmxhYmVsPTg7Y2FzZSA4OnJldHVyblsyLGhdfX0pfSl9ZnVuY3Rpb24gb2godCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obixhLGkpe3JldHVybiB2b2lkIDA9PT1hJiYoYT1cIlwiKSxyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHIscyx1LGwsYyxoLHAsZixkO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZihlPW4ubWFwKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSxyPXt9LHM9bnVsbCE9aT9pLm1hcChmdW5jdGlvbigpe3JldHVybiExfSk6W10sdT1bXSxuLmZvckVhY2goZnVuY3Rpb24odCxuKXt2YXIgbz0wO3Qud2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBhPVwicXVhbnRpemF0aW9uXCJpbiB0P3QucXVhbnRpemF0aW9uLmR0eXBlOnQuZHR5cGUsbD15Y1thXSp5KHQuc2hhcGUpLGM9ZnVuY3Rpb24oKXtlW25dPSEwLG51bGw9PXJbbl0mJihyW25dPVtdKSxyW25dLnB1c2goe21hbmlmZXN0RW50cnk6dCxncm91cE9mZnNldDpvLHNpemVCeXRlczpsfSl9O251bGwhPWk/aS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7ZT09PXQubmFtZSYmKGMoKSxzW25dPSEwKX0pOmMoKSx1LnB1c2godC5uYW1lKSxvKz1sfSl9KSwhcy5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdH0pKXRocm93IGw9aS5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4hc1tlXX0pLG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdlaWdodHMgaW4gbWFuaWZlc3Qgd2l0aCBuYW1lczogXCIrbC5qb2luKFwiLCBcIikrXCIuIFxcbk1hbmlmZXN0IEpTT04gaGFzIHdlaWdodHMgd2l0aCBuYW1lczogXCIrdS5qb2luKFwiLCBcIikrXCIuXCIpO3JldHVybiBjPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSYmdC5wdXNoKG4pLHR9LFtdKSxoPVtdLGMuZm9yRWFjaChmdW5jdGlvbih0KXtuW3RdLnBhdGhzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9YSsoYS5lbmRzV2l0aChcIi9cIik/XCJcIjpcIi9cIikrdDtoLnB1c2goZSl9KX0pLFs0LHQoaCldO2Nhc2UgMTpyZXR1cm4gcD1vLnNlbnQoKSxmPXt9LGQ9MCxjLmZvckVhY2goZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5bdF0ucGF0aHMubGVuZ3RoLG89MCxhPTA7YTxlO2ErKylvKz1wW2QrYV0uYnl0ZUxlbmd0aDtmb3IodmFyIGk9bmV3IEFycmF5QnVmZmVyKG8pLHM9bmV3IFVpbnQ4QXJyYXkoaSksdT0wLGw9MDtsPGU7bCsrKXt2YXIgYz1uZXcgVWludDhBcnJheShwW2QrbF0pO3Muc2V0KGMsdSksdSs9Yy5ieXRlTGVuZ3RofXJbdF0uZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT14YyhpLnNsaWNlKHQuZ3JvdXBPZmZzZXQsdC5ncm91cE9mZnNldCt0LnNpemVCeXRlcyksW3QubWFuaWZlc3RFbnRyeV0pO2Zvcih2YXIgbiBpbiBlKWZbbl09ZVtuXX0pLGQrPWV9KSxbMixmXX19KX0pfX1OYy5yZWdpc3RlclNhdmVSb3V0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgodGguVVJMX1NDSEVNRSk/KGU9dC5zbGljZSh0aC5VUkxfU0NIRU1FLmxlbmd0aCksdm9pZCAwPT09ZSYmKGU9XCJtb2RlbFwiKSxuZXcgdGgoZSkpOm51bGw7dmFyIGV9KTt2YXIgYWg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7aWYodGhpcy5ERUZBVUxUX01FVEhPRD1cIlBPU1RcIixudWxsPT1lJiYoZT17fSksdGhpcy53ZWlnaHRQYXRoUHJlZml4PWUud2VpZ2h0UGF0aFByZWZpeCx0aGlzLm9uUHJvZ3Jlc3M9ZS5vblByb2dyZXNzLG51bGwhPWUuZmV0Y2hGdW5jPyhkKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZmV0Y2hGdW5jLGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYSBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHNpZ25hdHVyZSBvZiBgZmV0Y2hgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSSlcIn0pLHRoaXMuZmV0Y2g9ZS5mZXRjaEZ1bmMpOnRoaXMuZmV0Y2g9SixkKG51bGwhPXQmJnQubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIlVSTCBwYXRoIGZvciBodHRwIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIn0pLEFycmF5LmlzQXJyYXkodCkmJmQoMj09PXQubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aHMgZm9yIGh0dHAgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDIsIChhY3R1YWwgbGVuZ3RoIGlzIFwiK3QubGVuZ3RoK1wiKS5cIn0pLHRoaXMucGF0aD10LG51bGwhPWUucmVxdWVzdEluaXQmJm51bGwhPWUucmVxdWVzdEluaXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoXCJyZXF1ZXN0SW5pdCBpcyBleHBlY3RlZCB0byBoYXZlIG5vIHByZS1leGlzdGluZyBib2R5LCBidXQgaGFzIG9uZS5cIik7dGhpcy5yZXF1ZXN0SW5pdD1lLnJlcXVlc3RJbml0fHx7fX1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsYTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVybihlPU9iamVjdC5hc3NpZ24oe21ldGhvZDp0aGlzLkRFRkFVTFRfTUVUSE9EfSx0aGlzLnJlcXVlc3RJbml0KSkuYm9keT1uZXcgRm9ybURhdGEsbj1be3BhdGhzOltcIi4vbW9kZWwud2VpZ2h0cy5iaW5cIl0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0scj17bW9kZWxUb3BvbG9neTp0Lm1vZGVsVG9wb2xvZ3ksZm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx3ZWlnaHRzTWFuaWZlc3Q6bn0sZS5ib2R5LmFwcGVuZChcIm1vZGVsLmpzb25cIixuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocildLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSksXCJtb2RlbC5qc29uXCIpLG51bGwhPXQud2VpZ2h0RGF0YSYmZS5ib2R5LmFwcGVuZChcIm1vZGVsLndlaWdodHMuYmluXCIsbmV3IEJsb2IoW3Qud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pLFwibW9kZWwud2VpZ2h0cy5iaW5cIiksWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsZSldO2Nhc2UgMTppZigoYT1vLnNlbnQoKSkub2spcmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpTYyh0KSxyZXNwb25zZXM6W2FdfV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIFwiK2Euc3RhdHVzK1wiLlwiKX19KX0pfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsYSxpLHMsdTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsdGhpcy5yZXF1ZXN0SW5pdCldO2Nhc2UgMTppZighKHQ9by5zZW50KCkpLm9rKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgdG8gXCIrdGhpcy5wYXRoK1wiIGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIFwiK3Quc3RhdHVzK1wiLiBQbGVhc2UgdmVyaWZ5IHRoaXMgVVJMIHBvaW50cyB0byB0aGUgbW9kZWwgSlNPTiBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cIik7by5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gby50cnlzLnB1c2goWzIsNCwsNV0pLFs0LHQuanNvbigpXTtjYXNlIDM6cmV0dXJuIGU9by5zZW50KCksWzMsNV07Y2FzZSA0OnRocm93IG8uc2VudCgpLG49XCJGYWlsZWQgdG8gcGFyc2UgbW9kZWwgSlNPTiBvZiByZXNwb25zZSBmcm9tIFwiK3RoaXMucGF0aCtcIi5cIix0aGlzLnBhdGguZW5kc1dpdGgoXCIucGJcIik/bis9XCIgWW91ciBwYXRoIGNvbnRhaW5zIGEgLnBiIGZpbGUgZXh0ZW5zaW9uLiBTdXBwb3J0IGZvciAucGIgbW9kZWxzIGhhdmUgYmVlbiByZW1vdmVkIGluIFRlbnNvckZsb3cuanMgMS4wIGluIGZhdm9yIG9mIC5qc29uIG1vZGVscy4gWW91IGNhbiByZS1jb252ZXJ0IHlvdXIgUHl0aG9uIFRlbnNvckZsb3cgbW9kZWwgdXNpbmcgdGhlIFRlbnNvckZsb3cuanMgMS4wIGNvbnZlcnNpb24gc2NyaXB0cyBvciB5b3UgY2FuIGNvbnZlcnQgeW91ci5wYiBtb2RlbHMgd2l0aCB0aGUgJ3BiMmpzb24nTlBNIHNjcmlwdCBpbiB0aGUgdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlciByZXBvc2l0b3J5LlwiOm4rPVwiIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHNlcnZlciBpcyBzZXJ2aW5nIHZhbGlkIEpTT04gZm9yIHRoaXMgcmVxdWVzdC5cIixuZXcgRXJyb3Iobik7Y2FzZSA1OmlmKHI9ZS5tb2RlbFRvcG9sb2d5LGE9ZS53ZWlnaHRzTWFuaWZlc3QsbnVsbD09ciYmbnVsbD09YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgSlNPTiBmcm9tIEhUVFAgcGF0aCBcIit0aGlzLnBhdGgrXCIgY29udGFpbnMgbmVpdGhlciBtb2RlbCB0b3BvbG9neSBvciBtYW5pZmVzdCBmb3Igd2VpZ2h0cy5cIik7cmV0dXJuIG51bGw9PWE/WzMsN106WzQsdGhpcy5sb2FkV2VpZ2h0cyhhKV07Y2FzZSA2OnU9by5zZW50KCksaT11WzBdLHM9dVsxXSxvLmxhYmVsPTc7Y2FzZSA3OnJldHVyblsyLHttb2RlbFRvcG9sb2d5OnIsd2VpZ2h0U3BlY3M6aSx3ZWlnaHREYXRhOnN9XX19KX0pfSx0LnByb3RvdHlwZS5sb2FkV2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsYSxpLHMsdSxsLGMsaCxwO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpmb3IoZT1BcnJheS5pc0FycmF5KHRoaXMucGF0aCk/dGhpcy5wYXRoWzFdOnRoaXMucGF0aCxuPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGFzdEluZGV4T2YoXCIvXCIpLG49dC5sYXN0SW5kZXhPZihcIj9cIikscj10LnN1YnN0cmluZygwLGUpLG89bj5lP3Quc3Vic3RyaW5nKG4pOlwiXCI7cmV0dXJuW3IrXCIvXCIsb119KGUpLHI9blswXSxhPW5bMV0saT10aGlzLndlaWdodFBhdGhQcmVmaXh8fHIscz1bXSx1PTAsbD10O3U8bC5sZW5ndGg7dSsrKWM9bFt1XSxzLnB1c2guYXBwbHkocyxjLndlaWdodHMpO3JldHVybiBoPVtdLHQuZm9yRWFjaChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goZnVuY3Rpb24odCl7aC5wdXNoKGkrdCthKX0pfSksWzQscmgoaCx7cmVxdWVzdEluaXQ6dGhpcy5yZXF1ZXN0SW5pdCxmZXRjaEZ1bmM6dGhpcy5mZXRjaCxvblByb2dyZXNzOnRoaXMub25Qcm9ncmVzc30pXTtjYXNlIDE6cmV0dXJuIHA9by5zZW50KCksWzIsW3MsRWMocCldXX19KX0pfSx0LlVSTF9TQ0hFTUVfUkVHRVg9L15odHRwcz86XFwvXFwvLyx0fSgpO2Z1bmN0aW9uIGloKHQpe3JldHVybiBudWxsIT10Lm1hdGNoKGFoLlVSTF9TQ0hFTUVfUkVHRVgpfXZhciBzaD1mdW5jdGlvbih0LGUpe3JldHVybihBcnJheS5pc0FycmF5KHQpP3QuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIGloKHQpfSk6aWgodCkpP3VoKHQse29uUHJvZ3Jlc3M6ZX0pOm51bGx9O2Z1bmN0aW9uIHVoKHQsZSl7cmV0dXJuIG5ldyBhaCh0LGUpfU5jLnJlZ2lzdGVyU2F2ZVJvdXRlcihzaCksTmMucmVnaXN0ZXJMb2FkUm91dGVyKHNoKTt2YXIgbGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLm1vZGVsVG9wb2xvZ3k9dCx0aGlzLndlaWdodFNwZWNzPWUsdGhpcy53ZWlnaHREYXRhPW59cmV0dXJuIHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0PXt9LG51bGwhPXRoaXMubW9kZWxUb3BvbG9neSYmKHQ9bih7bW9kZWxUb3BvbG9neTp0aGlzLm1vZGVsVG9wb2xvZ3l9LHQpKSxudWxsIT10aGlzLndlaWdodFNwZWNzJiZ0aGlzLndlaWdodFNwZWNzLmxlbmd0aD4wJiYodD1uKHt3ZWlnaHRTcGVjczp0aGlzLndlaWdodFNwZWNzfSx0KSksbnVsbCE9dGhpcy53ZWlnaHREYXRhJiZ0aGlzLndlaWdodERhdGEuYnl0ZUxlbmd0aD4wJiYodD1uKHt3ZWlnaHREYXRhOnRoaXMud2VpZ2h0RGF0YX0sdCkpLFsyLHRdfSl9KX0sdH0oKSxjaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5zYXZlSGFuZGxlcj10fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5zYXZlSGFuZGxlcih0KV19KX0pfSx0fSgpO3ZhciBoaD1PYmplY3QuZnJlZXplKHticm93c2VyRmlsZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlaCh0KX0sYnJvd3NlckhUVFBSZXF1ZXN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHVoKHQsZSl9LGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzOkVjLGRlY29kZVdlaWdodHM6eGMsZW5jb2RlV2VpZ2h0czpmdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsYTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6Zm9yKHIgaW4gZT1bXSxuPVtdLHQpe2lmKFwiZmxvYXQzMlwiIT09KGE9dFtyXSkuZHR5cGUmJlwiaW50MzJcIiE9PWEuZHR5cGUmJlwiYm9vbFwiIT09YS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK3IrXCInOiBcIithLmR0eXBlKTtlLnB1c2goe25hbWU6cixzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9KSxuLnB1c2goYS5kYXRhKCkpfXJldHVybls0LFByb21pc2UuYWxsKG4pXTtjYXNlIDE6cmV0dXJuWzIse2RhdGE6d2Moby5zZW50KCkpLHNwZWNzOmV9XX19KX0pfSxmcm9tTWVtb3J5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbmV3IGxoKHQsZSxuKX0sZ2V0TG9hZEhhbmRsZXJzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIE5jLmdldExvYWRIYW5kbGVycyh0KX0sZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjpTYyxnZXRTYXZlSGFuZGxlcnM6ZnVuY3Rpb24odCl7cmV0dXJuIE5jLmdldFNhdmVIYW5kbGVycyh0KX0saHR0cDp1aCxpc0hUVFBTY2hlbWU6aWgsbG9hZFdlaWdodHM6ZnVuY3Rpb24odCxlLG4sYSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiXCIpLHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXtyZXR1cm5bMixvaChmdW5jdGlvbih0KXtyZXR1cm4gcmgodCx7cmVxdWVzdEluaXQ6YX0pfSkodCxlLG4pXX0pfSl9LHJlZ2lzdGVyTG9hZFJvdXRlcjpmdW5jdGlvbih0KXtyZXR1cm4gTmMucmVnaXN0ZXJMb2FkUm91dGVyKHQpfSxyZWdpc3RlclNhdmVSb3V0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIE5jLnJlZ2lzdGVyU2F2ZVJvdXRlcih0KX0sd2VpZ2h0c0xvYWRlckZhY3Rvcnk6b2gsd2l0aFNhdmVIYW5kbGVyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgY2godCl9LGNvcHlNb2RlbDpmdW5jdGlvbih0LGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuWzIsVGModCxlLCExKV19KX0pfSxsaXN0TW9kZWxzOmZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsYSxpLHM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnQ9SWMuZ2V0U2NoZW1lcygpLGU9e30sbj0wLHI9dCxvLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoPyhhPXJbbl0sWzQsSWMuZ2V0TWFuYWdlcihhKS5saXN0TW9kZWxzKCldKTpbMyw0XTtjYXNlIDI6Zm9yKHMgaW4gaT1vLnNlbnQoKSllW2Era2Mrc109aVtzXTtvLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyLGVdfX0pfSl9LG1vdmVNb2RlbDpmdW5jdGlvbih0LGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuWzIsVGModCxlLCEwKV19KX0pfSxyZW1vdmVNb2RlbDpmdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiBlPUFjKHQpLFsyLEljLmdldE1hbmFnZXIoZS5zY2hlbWUpLnJlbW92ZU1vZGVsKGUucGF0aCldfSl9KX19KTt2YXIgcGg9QW4oe2NvbmZ1c2lvbk1hdHJpeF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJsYWJlbHNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKSxvPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpO2QobnVsbD09bnx8bj4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4pLGZ1bmN0aW9uKCl7cmV0dXJuXCJJZiBwcm92aWRlZCwgbnVtQ2xhc3NlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSksZCgxPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBsYWJlbHMgdG8gYmUgMSwgYnV0IGdvdCBcIityLnJhbmt9KSxkKDE9PT1vLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIHRoZSByYW5rIG9mIHByZWRpY3Rpb25zIHRvIGJlIDEsIGJ1dCBnb3QgXCIrby5yYW5rfSksZChyLnNoYXBlWzBdPT09by5zaGFwZVswXSxmdW5jdGlvbigpe3JldHVyblwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBleGFtcGxlczogXCIrci5zaGFwZVswXStcIiB2cy4gXCIrby5zaGFwZVswXStcIi4gTGFiZWxzIGFuZCBwcmVkaWN0aW9ucyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCJ9KSxkKG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSxmdW5jdGlvbigpe3JldHVyblwibnVtQ2xhc3NlcyBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbn0pO3ZhciBhPUJyKHIuYXNUeXBlKFwiaW50MzJcIiksbiksaT1CcihvLmFzVHlwZShcImludDMyXCIpLG4pO3JldHVybiBhLnRyYW5zcG9zZSgpLm1hdE11bChpKS5hc1R5cGUoXCJpbnQzMlwiKX19KSxmaD1PYmplY3QuZnJlZXplKHtjb25mdXNpb25NYXRyaXg6cGh9KTt2YXIgZGg9QW4oe2Zyb21QaXhlbHNfOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9MyksZT40KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgVGVuc29yIHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuXCIpO3JldHVybiBEdC5mcm9tUGl4ZWxzKHQsZSl9fSksdmg9T2JqZWN0LmZyZWV6ZSh7dG9QaXhlbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGEsaSxzLHUsbCxjLGgscCxmLGQsdixtLGcseSx4LHcsYixDLEUsUixTO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZihuPXduKHQsXCJpbWdcIixcInRvUGl4ZWxzXCIpLHQgaW5zdGFuY2VvZiBmdHx8KG49bi50b0ludCgpKSwyIT09bi5yYW5rJiYzIT09bi5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgcmFuayAyIG9yIDMgdGVuc29ycywgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwiKTtpZihyPW4uc2hhcGUuc2xpY2UoMCwyKSxhPXJbMF0saT1yWzFdLChzPTI9PT1uLnJhbms/MTpuLnNoYXBlWzJdKT40fHwyPT09cyl0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIGRlcHRoIG9mIHNpemUgMSwgMyBvciA0IGJ1dCBnb3QgXCIrcyk7cmV0dXJuWzQsbi5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdT1vLnNlbnQoKSxsPW4ubWluKCksYz1uLm1heCgpLFs0LFByb21pc2UuYWxsKFtsLmRhdGEoKSxjLmRhdGEoKV0pXTtjYXNlIDI6aWYoaD1vLnNlbnQoKSxwPWhbMF0sZj1oWzFdLGQ9cFswXSx2PWZbMF0sbC5kaXNwb3NlKCksYy5kaXNwb3NlKCksXCJmbG9hdDMyXCI9PT1uLmR0eXBlKXtpZihkPDB8fHY+MSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGZsb2F0MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMV0gYnV0IGdvdCByYW5nZSBbXCIrZCtcIiAtIFwiK3YrXCJdLlwiKX1lbHNle2lmKFwiaW50MzJcIiE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdG9QaXhlbHM6IFwiK24uZHR5cGUrXCIuIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLlwiKTtpZihkPDB8fHY+MjU1KXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZ290IHJhbmdlIFtcIitkK1wiIC0gXCIrditcIl0uXCIpfWZvcihtPVwiZmxvYXQzMlwiPT09bi5kdHlwZT8yNTU6MSxnPW5ldyBVaW50OENsYW1wZWRBcnJheShpKmEqNCkseT0wO3k8YSppOysreSl4PXZvaWQgMCx3PXZvaWQgMCxiPXZvaWQgMCxDPXZvaWQgMCwxPT09cz8oeD11W3ldKm0sdz11W3ldKm0sYj11W3ldKm0sQz0yNTUpOjM9PT1zPyh4PXVbMyp5XSptLHc9dVszKnkrMV0qbSxiPXVbMyp5KzJdKm0sQz0yNTUpOjQ9PT1zJiYoeD11WzQqeV0qbSx3PXVbNCp5KzFdKm0sYj11WzQqeSsyXSptLEM9dVs0KnkrM10qbSksZ1swKyhFPTQqeSldPU1hdGgucm91bmQoeCksZ1tFKzFdPU1hdGgucm91bmQodyksZ1tFKzJdPU1hdGgucm91bmQoYiksZ1tFKzNdPU1hdGgucm91bmQoQyk7cmV0dXJuIG51bGwhPWUmJihlLndpZHRoPWksZS5oZWlnaHQ9YSxSPWUuZ2V0Q29udGV4dChcIjJkXCIpLFM9bmV3IEltYWdlRGF0YShnLGksYSksUi5wdXRJbWFnZURhdGEoUywwLDApKSxuIT09dCYmbi5kaXNwb3NlKCksWzIsZ119fSl9KX0sZnJvbVBpeGVsczpkaH0pLG1oPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lfSx0LmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZSl9LHR9KCksZ2g9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5jbGFzc05hbWVNYXA9e319cmV0dXJuIHQuZ2V0TWFwPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyPWZ1bmN0aW9uKGUpe3QuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwW2UuY2xhc3NOYW1lXT1bZSxlLmZyb21Db25maWddfSx0fSgpO2Z1bmN0aW9uIHloKHQpe2QobnVsbCE9dC5jbGFzc05hbWUsZnVuY3Rpb24oKXtyZXR1cm5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgZG9lcyBub3QgaGF2ZSB0aGUgc3RhdGljIGNsYXNzTmFtZSBwcm9wZXJ0eSBkZWZpbmVkLlwifSksZChcInN0cmluZ1wiPT10eXBlb2YgdC5jbGFzc05hbWUsZnVuY3Rpb24oKXtyZXR1cm5cImNsYXNzTmFtZSBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZywgYnV0IGdvdCB0eXBlIFwiK3R5cGVvZiB0LmNsYXNzTmFtZX0pLGQodC5jbGFzc05hbWUubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgaGFzIGFuIGVtcHR5LXN0cmluZyBhcyBpdHMgY2xhc3NOYW1lLCB3aGljaCBpcyBkaXNhbGxvd2VkLlwifSksZ2gucmVnaXN0ZXIodCl9dmFyIHhoPU9iamVjdC5mcmVlemUoe1NlcmlhbGl6YWJsZTptaCxTZXJpYWxpemF0aW9uTWFwOmdoLHJlZ2lzdGVyQ2xhc3M6eWh9KSx3aD0uMDAxLGJoPS4xO2Z1bmN0aW9uIENoKCl7cmV0dXJuIDMyPT09RHQuYmFja2VuZC5mbG9hdFByZWNpc2lvbigpP3doOmJofWZ1bmN0aW9uIEVoKHQsZSxuKXt2YXIgcj0hMDtpZigoXyh0KXx8XyhlKSkmJihyPSExKSxfKHQpJiZfKGUpJiYocj0hMCkscil7dmFyIG89dC5jb25zdHJ1Y3Rvci5uYW1lLGE9ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKG8hPT1hKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUuIEFjdHVhbDogXCIrbytcIi4gRXhwZWN0ZWQ6IFwiK2EpfWlmKEFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkoZSkpe3ZhciBpPXluKHQpLHM9eW4oZSk7aWYoIXgoaSxzKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgc2hhcGVzLiBBY3R1YWw6IFtcIitpK1wiXS4gRXhwZWN0ZWQ6IFtcIitzK1wiXVwiKX12YXIgdT1fKHQpP3Q6Zyh0KSxsPV8oZSk/ZTpnKGUpO2lmKHUubGVuZ3RoIT09bC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIit1Lmxlbmd0aCtcIiB2cyBleHBlY3RlZDogXCIrbC5sZW5ndGgrXCIuXFxuQWN0dWFsOiAgIFwiK3UrXCIuXFxuRXhwZWN0ZWQ6IFwiK2wrXCIuXCIpO2Zvcih2YXIgYz0wO2M8bC5sZW5ndGg7KytjKXt2YXIgaD11W2NdLHA9bFtjXTtpZighbihoLHApKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIitjK1wiXSA9IFwiK2grXCIsIGV4cGVjdGVkW1wiK2MrXCJdID0gXCIrcCtcIi5cXG5BY3R1YWw6ICAgXCIrdStcIi5cXG5FeHBlY3RlZDogXCIrbCtcIi5cIil9fWZ1bmN0aW9uIFJoKHQsZSxuKXtyZXR1cm4haXNGaW5pdGUodCkmJiFpc0Zpbml0ZShlKXx8IShpc05hTih0KXx8aXNOYU4oZSl8fE1hdGguYWJzKHQtZSk+bil9dmFyIFNoPU9iamVjdC5mcmVlemUoe1RFU1RfRVBTSUxPTl9GTE9BVDE2OmJoLGV4cGVjdEFycmF5c0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbnVsbD09biYmKG49Q2goKSksRWgodCxlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFJoKHQsZSxuKX0pfSx0ZXN0RXBzaWxvbjpDaCxleHBlY3RQcm9taXNlVG9GYWlsOmZ1bmN0aW9uKHQsZSl7dCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZS5mYWlsKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIGUoKX0pfSxleHBlY3RBcnJheXNFcXVhbDpmdW5jdGlvbih0LGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP1tlXTplO3JldHVybiBCKHQpfHxCKHRbMF0pfHxCKGUpfHxCKGVbMF0pP0VoKHQsbixmdW5jdGlvbih0LGUpe3JldHVybiB0PT1lfSk6RWgodCxlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFJoKHQsZSwwKX0pfSxleHBlY3ROdW1iZXJzQ2xvc2U6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PW4mJihuPUNoKCkpLCFSaCh0LGUsbikpdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVycyBkaWZmZXI6IGFjdHVhbCA9PT0gXCIrdCtcIiwgZXhwZWN0ZWQgPT09IFwiK2UpfSxleHBlY3RWYWx1ZXNJblJhbmdlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdPGV8fHRbcl0+bil0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2U6XCIrdFtyXStcIiBsb3c6IFwiK2UrXCIsIGhpZ2g6IFwiK24pfSxleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbDpmdW5jdGlvbih0LGUpe2V4cGVjdChuZXcgRmxvYXQzMkFycmF5KHQpKS50b0VxdWFsKG5ldyBGbG9hdDMyQXJyYXkoZSkpfX0pLE5oPVwiMS4xLjJcIixraD1PYmplY3QuZnJlZXplKHtncGdwdV91dGlsOkxhLHdlYmdsX3V0aWw6a2UsTWF0aEJhY2tlbmRXZWJHTDpVaSxHUEdQVUNvbnRleHQ6V2F9KSxJaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLm1pbmltaXplPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9dGhpcy5jb21wdXRlR3JhZGllbnRzKHQsbiksbz1yLnZhbHVlLGE9ci5ncmFkcztyZXR1cm4gdGhpcy5hcHBseUdyYWRpZW50cyhhKSxPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBhW3RdLmRpc3Bvc2UoKX0pLGU/bzooby5kaXNwb3NlKCksbnVsbCl9LG4ucHJvdG90eXBlLmNvbXB1dGVHcmFkaWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTm4odCxlKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe30sbn0obWgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJaCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10Lm1pbmltaXplJiZudWxsIT10LmNvbXB1dGVHcmFkaWVudHMmJm51bGwhPXQuYXBwbHlHcmFkaWVudHN9fSk7dmFyIEFoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIpe3ZvaWQgMD09PXImJihyPW51bGwpO3ZhciBvPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gby5sZWFybmluZ1JhdGU9ZSxvLnJobz1uLG8uZXBzaWxvbj1yLG8uYWNjdW11bGF0ZWRHcmFkcz17fSxvLmFjY3VtdWxhdGVkVXBkYXRlcz17fSxudWxsPT1yJiYoby5lcHNpbG9uPUR0LmJhY2tlbmQuZXBzaWxvbigpKSxvfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWZ1bmN0aW9uKG4pe3ZhciBvPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ci5hY2N1bXVsYXRlZEdyYWRzW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRHcmFkc1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX1pZihudWxsPT1yLmFjY3VtdWxhdGVkVXBkYXRlc1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkVXBkYXRlc1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX12YXIgYT10W25dLGk9ci5hY2N1bXVsYXRlZEdyYWRzW25dLHM9ci5hY2N1bXVsYXRlZFVwZGF0ZXNbbl07RmUoZnVuY3Rpb24oKXt2YXIgdD1pLm11bChlLnJobykuYWRkKGEuc3F1YXJlKCkubXVsKDEtZS5yaG8pKSxyPXMuYWRkKGUuZXBzaWxvbikuc3FydCgpLmRpdihpLmFkZChlLmVwc2lsb24pLnNxcnQoKSkubXVsKGEpLHU9cy5tdWwoZS5yaG8pLmFkZChyLnNxdWFyZSgpLm11bCgxLWUucmhvKSk7ZS5hY2N1bXVsYXRlZEdyYWRzW25dLmFzc2lnbih0KSxlLmFjY3VtdWxhdGVkVXBkYXRlc1tuXS5hc3NpZ24odSk7dmFyIGw9ci5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24obCl9KX0scj10aGlzO2Zvcih2YXIgbyBpbiB0KW4obyl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO251bGwhPXRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzJiYoT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRVcGRhdGVzW2VdLmRpc3Bvc2UoKX0pLE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZEdyYWRzW2VdLmRpc3Bvc2UoKX0pKX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxyaG86dGhpcy5yaG8sZXBzaWxvbjp0aGlzLmVwc2lsb259fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5yaG8sZS5lcHNpbG9uKX0sbi5jbGFzc05hbWU9XCJBZGFkZWx0YU9wdGltaXplclwiLG59KEloKTt5aChBaCk7dmFyIFRoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuKXt2b2lkIDA9PT1uJiYobj0uMSk7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLmxlYXJuaW5nUmF0ZT1lLHIuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU9bixyLmFjY3VtdWxhdGVkR3JhZHM9e30scn1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1mdW5jdGlvbihuKXt2YXIgbz1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PXIuYWNjdW11bGF0ZWRHcmFkc1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkR3JhZHNbbl09SG4oby5zaGFwZSxlLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKS52YXJpYWJsZSghMSl9KX12YXIgYT10W25dLGk9ci5hY2N1bXVsYXRlZEdyYWRzW25dO0ZlKGZ1bmN0aW9uKCl7dmFyIHQ9aS5hZGQoYS5zcXVhcmUoKSk7ZS5hY2N1bXVsYXRlZEdyYWRzW25dLmFzc2lnbih0KTt2YXIgcj1hLmRpdih0LmFkZChEdC5iYWNrZW5kLmVwc2lsb24oKSkuc3FydCgpKS5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24ocil9KX0scj10aGlzO2Zvcih2YXIgbyBpbiB0KW4obyl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO251bGwhPXRoaXMuYWNjdW11bGF0ZWRHcmFkcyYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEdyYWRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkR3JhZHNbZV0uZGlzcG9zZSgpfSl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU6dGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZX19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKX0sbi5jbGFzc05hbWU9XCJBZGFncmFkT3B0aW1pemVyXCIsbn0oSWgpO3loKFRoKTt2YXIgRGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scixvKXt2b2lkIDA9PT1vJiYobz1udWxsKTt2YXIgYT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGEubGVhcm5pbmdSYXRlPWUsYS5iZXRhMT1uLGEuYmV0YTI9cixhLmVwc2lsb249byxhLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9e30sYS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD17fSxGZShmdW5jdGlvbigpe2EuYWNjQmV0YTE9Qm4obikudmFyaWFibGUoKSxhLmFjY0JldGEyPUJuKHIpLnZhcmlhYmxlKCl9KSxudWxsPT1vJiYoYS5lcHNpbG9uPUR0LmJhY2tlbmQuZXBzaWxvbigpKSxhfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztGZShmdW5jdGlvbigpe3ZhciBuPWxsKDEsZS5hY2NCZXRhMSkscj1sbCgxLGUuYWNjQmV0YTIpO2Zvcih2YXIgbyBpbiB0KXt2YXIgYT1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW29dO2lmKG51bGw9PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSl7dmFyIGk9ITE7ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dPVhuKGEpLnZhcmlhYmxlKGkpfWlmKG51bGw9PWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb10pe2k9ITE7ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXT1YbihhKS52YXJpYWJsZShpKX12YXIgcz10W29dLHU9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dLGw9ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXSxjPXUubXVsKGUuYmV0YTEpLmFkZChzLm11bCgxLWUuYmV0YTEpKSxoPWwubXVsKGUuYmV0YTIpLmFkZChzLnNxdWFyZSgpLm11bCgxLWUuYmV0YTIpKSxwPWMuZGl2KG4pLGY9aC5kaXYocik7ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dLmFzc2lnbihjKSxlLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W29dLmFzc2lnbihoKTt2YXIgZD1wLmRpdihmLnNxcnQoKS5hZGQoZS5lcHNpbG9uKSkubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKGEpO2EuYXNzaWduKGQpfWUuYWNjQmV0YTEuYXNzaWduKGUuYWNjQmV0YTEubXVsKGUuYmV0YTEpKSxlLmFjY0JldGEyLmFzc2lnbihlLmFjY0JldGEyLm11bChlLmJldGEyKSl9KX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtlXS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50JiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2VdLmRpc3Bvc2UoKX0pfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbn19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmJldGExLGUuYmV0YTIsZS5lcHNpbG9uKX0sbi5jbGFzc05hbWU9XCJBZGFtT3B0aW1pemVyXCIsbn0oSWgpO3loKERoKTt2YXIgT2g9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scixvLGEpe3ZvaWQgMD09PW8mJihvPW51bGwpLHZvaWQgMD09PWEmJihhPTApO3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS5sZWFybmluZ1JhdGU9ZSxpLmJldGExPW4saS5iZXRhMj1yLGkuZXBzaWxvbj1vLGkuZGVjYXk9YSxpLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9e30saS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybT17fSxGZShmdW5jdGlvbigpe2kuaXRlcmF0aW9uPUJuKDApLnZhcmlhYmxlKCksaS5hY2NCZXRhMT1CbihuKS52YXJpYWJsZSgpfSksbnVsbD09byYmKGkuZXBzaWxvbj1EdC5iYWNrZW5kLmVwc2lsb24oKSksaX1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7RmUoZnVuY3Rpb24oKXt2YXIgbj1sbCgxLGUuYWNjQmV0YTEpLHI9S3UoLWUubGVhcm5pbmdSYXRlLGUuaXRlcmF0aW9uLm11bChlLmRlY2F5KS5hZGQoMSkpO2Zvcih2YXIgbyBpbiB0KXt2YXIgYT1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW29dO2lmKG51bGw9PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSl7dmFyIGk9ITE7ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dPVhuKGEpLnZhcmlhYmxlKGkpfWlmKG51bGw9PWUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bb10pe2k9ITE7ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtvXT1YbihhKS52YXJpYWJsZShpKX12YXIgcz10W29dLHU9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dLGw9ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtvXSxjPXUubXVsKGUuYmV0YTEpLmFkZChzLm11bCgxLWUuYmV0YTEpKSxoPWwubXVsKGUuYmV0YTIpLHA9cy5hYnMoKSxmPWgubWF4aW11bShwKTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10uYXNzaWduKGMpLGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bb10uYXNzaWduKGYpO3ZhciBkPXIuZGl2KG4pLm11bChjLmRpdihmLmFkZChlLmVwc2lsb24pKSkuYWRkKGEpO2EuYXNzaWduKGQpfWUuaXRlcmF0aW9uLmFzc2lnbihlLml0ZXJhdGlvbi5hZGQoMSkpLGUuYWNjQmV0YTEuYXNzaWduKGUuYWNjQmV0YTEubXVsKGUuYmV0YTEpKX0pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLml0ZXJhdGlvbi5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtlXS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW2VdLmRpc3Bvc2UoKX0pfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbixkZWNheTp0aGlzLmRlY2F5fX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24sZS5kZWNheSl9LG4uY2xhc3NOYW1lPVwiQWRhbWF4T3B0aW1pemVyXCIsbn0oSWgpO3loKE9oKTt2YXIgX2g9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ubGVhcm5pbmdSYXRlPWUsbi5zZXRMZWFybmluZ1JhdGUoZSksbn1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7T2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihuKXt2YXIgcj10W25dLG89RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtGZShmdW5jdGlvbigpe3ZhciB0PWUuYy5tdWwocikuYWRkKG8pO28uYXNzaWduKHQpfSl9KX0sbi5wcm90b3R5cGUuc2V0TGVhcm5pbmdSYXRlPWZ1bmN0aW9uKHQpe3RoaXMubGVhcm5pbmdSYXRlPXQsbnVsbCE9dGhpcy5jJiZ0aGlzLmMuZGlzcG9zZSgpLHRoaXMuYz1QZShCbigtdCkpfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5jLmRpc3Bvc2UoKX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZX19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSl9LG4uY2xhc3NOYW1lPVwiU0dET3B0aW1pemVyXCIsbn0oSWgpO3loKF9oKTt2YXIgTWg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPXQuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiBvLmxlYXJuaW5nUmF0ZT1lLG8ubW9tZW50dW09bixvLnVzZU5lc3Rlcm92PXIsby5tPUJuKG8ubW9tZW50dW0pLG8uYWNjdW11bGF0aW9ucz17fSxvfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWZ1bmN0aW9uKG4pe3ZhciBvPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ci5hY2N1bXVsYXRpb25zW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0aW9uc1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX12YXIgYT1yLmFjY3VtdWxhdGlvbnNbbl0saT10W25dO0ZlKGZ1bmN0aW9uKCl7dmFyIHQscj1lLm0ubXVsKGEpLmFkZChpKTt0PWUudXNlTmVzdGVyb3Y/ZS5jLm11bChpLmFkZChyLm11bChlLm0pKSkuYWRkKG8pOmUuYy5tdWwocikuYWRkKG8pLGUuYWNjdW11bGF0aW9uc1tuXS5hc3NpZ24ociksby5hc3NpZ24odCl9KX0scj10aGlzO2Zvcih2YXIgbyBpbiB0KW4obyl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtpZih0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5tLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGlvbnMpZm9yKHZhciBlIGluIHRoaXMuYWNjdW11bGF0aW9ucyl0aGlzLmFjY3VtdWxhdGlvbnNbZV0uZGlzcG9zZSgpfSxuLnByb3RvdHlwZS5zZXRNb21lbnR1bT1mdW5jdGlvbih0KXt0aGlzLm1vbWVudHVtPXR9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsbW9tZW50dW06dGhpcy5tb21lbnR1bSx1c2VOZXN0ZXJvdjp0aGlzLnVzZU5lc3Rlcm92fX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUubW9tZW50dW0sZS51c2VOZXN0ZXJvdil9LG4uY2xhc3NOYW1lPVwiTW9tZW50dW1PcHRpbWl6ZXJcIixufShfaCk7eWgoTWgpO3ZhciBGaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyLG8sYSl7dm9pZCAwPT09biYmKG49LjkpLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPW51bGwpLHZvaWQgMD09PWEmJihhPSExKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkubGVhcm5pbmdSYXRlPWUsaS5kZWNheT1uLGkubW9tZW50dW09cixpLmVwc2lsb249byxpLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9e30saS5hY2N1bXVsYXRlZE1lYW5HcmFkcz17fSxpLmFjY3VtdWxhdGVkTW9tZW50cz17fSxpLmNlbnRlcmVkPWEsbnVsbD09byYmKGkuZXBzaWxvbj1EdC5iYWNrZW5kLmVwc2lsb24oKSksaX1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1mdW5jdGlvbihuKXt2YXIgbz1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PXIuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl09WG4obykudmFyaWFibGUoITEpfSl9aWYobnVsbD09ci5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuXSYmci5jZW50ZXJlZCl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfWlmKG51bGw9PXIuYWNjdW11bGF0ZWRNb21lbnRzW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRNb21lbnRzW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfXZhciBhPXIuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXSxpPXIuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl0scz1yLmFjY3VtdWxhdGVkTW9tZW50c1tuXSx1PXRbbl07RmUoZnVuY3Rpb24oKXt2YXIgdD1hLm11bChlLmRlY2F5KS5hZGQodS5zcXVhcmUoKS5tdWwoMS1lLmRlY2F5KSk7aWYoZS5jZW50ZXJlZCl7dmFyIHI9aS5tdWwoZS5kZWNheSkuYWRkKHUubXVsKDEtZS5kZWNheSkpLGw9cy5tdWwoZS5tb21lbnR1bSkuYWRkKHUubXVsKGUubGVhcm5pbmdSYXRlKS5kaXYodC5zdWIoci5zcXVhcmUoKS5hZGQoZS5lcHNpbG9uKSkuc3FydCgpKSk7ZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dLmFzc2lnbih0KSxlLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dLmFzc2lnbihyKSxlLmFjY3VtdWxhdGVkTW9tZW50c1tuXS5hc3NpZ24obCk7dmFyIGM9by5zdWIobCk7by5hc3NpZ24oYyl9ZWxzZXt2YXIgaD1hLm11bChlLmRlY2F5KS5hZGQodS5zcXVhcmUoKS5tdWwoMS1lLmRlY2F5KSk7bD1zLm11bChlLm1vbWVudHVtKS5hZGQodS5tdWwoZS5sZWFybmluZ1JhdGUpLmRpdihoLmFkZChlLmVwc2lsb24pLnNxcnQoKSkpO2UuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXS5hc3NpZ24oaCksZS5hY2N1bXVsYXRlZE1vbWVudHNbbl0uYXNzaWduKGwpO2M9by5zdWIobCk7by5hc3NpZ24oYyl9fSl9LHI9dGhpcztmb3IodmFyIG8gaW4gdCluKG8pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztudWxsIT10aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW2VdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMmJnRoaXMuY2VudGVyZWQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRNZWFuR3JhZHNbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1vbWVudHMmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkTW9tZW50c1tlXS5kaXNwb3NlKCl9KX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxkZWNheTp0aGlzLmRlY2F5LG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyZWQ6dGhpcy5jZW50ZXJlZH19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmRlY2F5LGUubW9tZW50dW0sZS5lcHNpbG9uLGUuY2VudGVyZWQpfSxuLmNsYXNzTmFtZT1cIlJNU1Byb3BPcHRpbWl6ZXJcIixufShJaCk7eWgoRmgpO3ZhciBCaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuc2dkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgX2godCl9LHQubW9tZW50dW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksbmV3IE1oKHQsZSxuKX0sdC5ybXNwcm9wPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz0hMSksbmV3IEZoKHQsZSxuLHIsbyl9LHQuYWRhbT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMSksdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPS45OTkpLHZvaWQgMD09PXImJihyPW51bGwpLG5ldyBEaCh0LGUsbixyKX0sdC5hZGFkZWx0YT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDEpLHZvaWQgMD09PWUmJihlPS45NSksdm9pZCAwPT09biYmKG49bnVsbCksbmV3IEFoKHQsZSxuKX0sdC5hZGFtYXg9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMiksdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPS45OTkpLHZvaWQgMD09PXImJihyPW51bGwpLHZvaWQgMD09PW8mJihvPTApLG5ldyBPaCh0LGUsbixyLG8pfSx0LmFkYWdyYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjEpLG5ldyBUaCh0LGUpfSx0fSgpLFBoPXtzZ2Q6Qmguc2dkLG1vbWVudHVtOkJoLm1vbWVudHVtLGFkYWRlbHRhOkJoLmFkYWRlbHRhLGFkYWdyYWQ6QmguYWRhZ3JhZCxybXNwcm9wOkJoLnJtc3Byb3AsYWRhbWF4OkJoLmFkYW1heCxhZGFtOkJoLmFkYW19LExoPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZXRJbW1lZGlhdGU/c2V0SW1tZWRpYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0KCl9O2Z1bmN0aW9uIFdoKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3JldHVybiBMaChmdW5jdGlvbigpe3JldHVybiB0KCl9KX0pfWh0PW1jO2V4cG9ydHtBaCBhcyBBZGFkZWx0YU9wdGltaXplcixUaCBhcyBBZGFncmFkT3B0aW1pemVyLERoIGFzIEFkYW1PcHRpbWl6ZXIsT2ggYXMgQWRhbWF4T3B0aW1pemVyLFluIGFzIERhdGFTdG9yYWdlLGEgYXMgRU5WLGkgYXMgRW52aXJvbm1lbnQsUW4gYXMgS2VybmVsQmFja2VuZCxNaCBhcyBNb21lbnR1bU9wdGltaXplcixJaCBhcyBPcHRpbWl6ZXIsRmggYXMgUk1TUHJvcE9wdGltaXplcix2dCBhcyBSYW5rLHFsIGFzIFJlZHVjdGlvbixfaCBhcyBTR0RPcHRpbWl6ZXIsZnQgYXMgVGVuc29yLGx0IGFzIFRlbnNvckJ1ZmZlcixkdCBhcyBWYXJpYWJsZSxWaSBhcyBhYnMsR2kgYXMgYWNvcyxxaSBhcyBhY29zaCxxdSBhcyBhZGQsSHUgYXMgYWRkTiwkdSBhcyBhZGRTdHJpY3QsYnUgYXMgYWxsLEN1IGFzIGFueSxFdSBhcyBhcmdNYXgsUnUgYXMgYXJnTWluLEhpIGFzIGFzaW4sJGkgYXMgYXNpbmgsamkgYXMgYXRhbixqdSBhcyBhdGFuMixLaSBhcyBhdGFuaCxmdSBhcyBhdmdQb29sLCRlIGFzIGJhY2tlbmQsQWwgYXMgYmFzaWNMU1RNQ2VsbCxfcyBhcyBiYXRjaE5vcm0sTXMgYXMgYmF0Y2hOb3JtMmQsRnMgYXMgYmF0Y2hOb3JtM2QsQnMgYXMgYmF0Y2hOb3JtNGQsT3MgYXMgYmF0Y2hOb3JtYWxpemF0aW9uLEFzIGFzIGJhdGNoTm9ybWFsaXphdGlvbjJkLFRzIGFzIGJhdGNoTm9ybWFsaXphdGlvbjNkLERzIGFzIGJhdGNoTm9ybWFsaXphdGlvbjRkLElyIGFzIGJhdGNoVG9TcGFjZU5ELHZoIGFzIGJyb3dzZXIsTnIgYXMgYnVmZmVyLEFyIGFzIGNhc3QsWGkgYXMgY2VpbCxZaSBhcyBjbGlwQnlWYWx1ZSxUciBhcyBjbG9uZSxPbiBhcyBjb21wbGV4LGxyIGFzIGNvbmNhdCxjciBhcyBjb25jYXQxZCxociBhcyBjb25jYXQyZCxwciBhcyBjb25jYXQzZCxmciBhcyBjb25jYXQ0ZCxYcyBhcyBjb252MWQsWXMgYXMgY29udjJkLEpzIGFzIGNvbnYyZERlckZpbHRlcixldSBhcyBjb252MmRUcmFuc3Bvc2UsUXMgYXMgY29udjNkLFFpIGFzIGNvcyxKaSBhcyBjb3NoLERyIGFzIGN1bXN1bSxrbiBhcyBjdXN0b21HcmFkLERlIGFzIGRlcHJlY2F0aW9uV2FybixPciBhcyBkZXB0aFRvU3BhY2UsWnMgYXMgZGVwdGh3aXNlQ29udjJkLFRlIGFzIGRpc2FibGVEZXByZWNhdGlvbldhcm5pbmdzLEJlIGFzIGRpc3Bvc2UsT2UgYXMgZGlzcG9zZVZhcmlhYmxlcyxLdSBhcyBkaXYsWHUgYXMgZGl2U3RyaWN0LHJ1IGFzIGRvdCxWbCBhcyBkcm9wb3V0LGdsIGFzIGVsdSxBZSBhcyBlbmFibGVEZWJ1Z01vZGUsSWUgYXMgZW5hYmxlUHJvZE1vZGUsbCBhcyBlbnZpcm9ubWVudCxPdSBhcyBlcXVhbCxfdSBhcyBlcXVhbFN0cmljdCxaaSBhcyBlcmYsdHMgYXMgZXhwLF9yIGFzIGV4cGFuZERpbXMsZXMgYXMgZXhwbTEsTXIgYXMgZXllLEZsIGFzIGZmdCxIbiBhcyBmaWxsLEdlIGFzIGZpbmRCYWNrZW5kLHFlIGFzIGZpbmRCYWNrZW5kRmFjdG9yeSxucyBhcyBmbG9vcixZdSBhcyBmbG9vckRpdix2YyBhcyBmdXNlZCxrbCBhcyBnYXRoZXIsemwgYXMgZ2F0aGVyTkQsemUgYXMgZ2V0QmFja2VuZCxDbiBhcyBncmFkLEVuIGFzIGdyYWRzLE11IGFzIGdyZWF0ZXIsRnUgYXMgZ3JlYXRlckVxdWFsLEJ1IGFzIGdyZWF0ZXJFcXVhbFN0cmljdCxQdSBhcyBncmVhdGVyU3RyaWN0LCRsIGFzIGhhbW1pbmdXaW5kb3csSGwgYXMgaGFubldpbmRvdyxCbCBhcyBpZmZ0LE1uIGFzIGltYWcsZmMgYXMgaW1hZ2UsaGggYXMgaW8sTGwgYXMgaXJmZnQsZHMgYXMgaXNGaW5pdGUsZnMgYXMgaXNJbmYscHMgYXMgaXNOYU4sUGUgYXMga2VlcCx5bCBhcyBsZWFreVJlbHUsTHUgYXMgbGVzcyxXdSBhcyBsZXNzRXF1YWwsVXUgYXMgbGVzc0VxdWFsU3RyaWN0LHp1IGFzIGxlc3NTdHJpY3QsaWMgYXMgbGluYWxnLCRuIGFzIGxpbnNwYWNlLEVsIGFzIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uLHJzIGFzIGxvZyxvcyBhcyBsb2cxcCxhcyBhcyBsb2dTaWdtb2lkLERuIGFzIGxvZ1NvZnRtYXgsU3UgYXMgbG9nU3VtRXhwLGhsIGFzIGxvZ2ljYWxBbmQscGwgYXMgbG9naWNhbE5vdCxmbCBhcyBsb2dpY2FsT3IsZGwgYXMgbG9naWNhbFhvcixuYyBhcyBsb3NzZXMsbnUgYXMgbWF0TXVsLGZoIGFzIG1hdGgsTnUgYXMgbWF4LHB1IGFzIG1heFBvb2wsUXUgYXMgbWF4aW11bSxKdSBhcyBtYXhpbXVtU3RyaWN0LGt1IGFzIG1lYW4sX2UgYXMgbWVtb3J5LEl1IGFzIG1pbixadSBhcyBtaW5pbXVtLHRsIGFzIG1pbmltdW1TdHJpY3QsZWwgYXMgbW9kLG5sIGFzIG1vZFN0cmljdCxBdSBhcyBtb21lbnRzLERsIGFzIG1vdmluZ0F2ZXJhZ2UscmwgYXMgbXVsLG9sIGFzIG11bFN0cmljdCxUbCBhcyBtdWx0aVJOTkNlbGwsRnIgYXMgbXVsdGlub21pYWwsaXMgYXMgbmVnLFdoIGFzIG5leHRGcmFtZSxSbCBhcyBub3JtLFZ1IGFzIG5vdEVxdWFsLEd1IGFzIG5vdEVxdWFsU3RyaWN0LEJyIGFzIG9uZUhvdCxHbiBhcyBvbmVzLEtuIGFzIG9uZXNMaWtlLEFuIGFzIG9wLG91IGFzIG91dGVyUHJvZHVjdCxQciBhcyBwYWQsTHIgYXMgcGFkMWQsV3IgYXMgcGFkMmQsVXIgYXMgcGFkM2QsenIgYXMgcGFkNGQsZHUgYXMgcG9vbCxhbCBhcyBwb3csaWwgYXMgcG93U3RyaWN0LHhsIGFzIHByZWx1LGtyIGFzIHByaW50LER1IGFzIHByb2QsTWUgYXMgcHJvZmlsZSxWciBhcyByYW5kLEdyIGFzIHJhbmRvbU5vcm1hbCxxciBhcyByYW5kb21Vbmlmb3JtLGpuIGFzIHJhbmdlLFVlIGFzIHJlYWR5LF9uIGFzIHJlYWwsc3MgYXMgcmVjaXByb2NhbCxIZSBhcyByZWdpc3RlckJhY2tlbmQsd2wgYXMgcmVsdSxWZSBhcyByZW1vdmVCYWNrZW5kLEhyIGFzIHJlc2hhcGUsYXUgYXMgcmV2ZXJzZSxpdSBhcyByZXZlcnNlMWQsc3UgYXMgcmV2ZXJzZTJkLHV1IGFzIHJldmVyc2UzZCxsdSBhcyByZXZlcnNlNGQsUGwgYXMgcmZmdCx1cyBhcyByb3VuZCxscyBhcyByc3FydCxCbiBhcyBzY2FsYXIsTWwgYXMgc2NhdHRlck5ELGJsIGFzIHNlbHUsdHUgYXMgc2VwYXJhYmxlQ29udjJkLHhoIGFzIHNlcmlhbGl6YXRpb24sV2UgYXMgc2V0QmFja2VuZCxKciBhcyBzZXRkaWZmMWRBc3luYyxjcyBhcyBzaWdtb2lkLGhzIGFzIHNpZ24sdnMgYXMgc2luLG1zIGFzIHNpbmgsdnUgYXMgc2xpY2UsbXUgYXMgc2xpY2UxZCxndSBhcyBzbGljZTJkLHl1IGFzIHNsaWNlM2QseHUgYXMgc2xpY2U0ZCxUbiBhcyBzb2Z0bWF4LGdzIGFzIHNvZnRwbHVzLCRyIGFzIHNwYWNlVG9CYXRjaE5ELFVsIGFzIHNwYXJzZVRvRGVuc2UsV2wgYXMgc3BlY3RyYWwsZHIgYXMgc3BsaXQseXMgYXMgc3FydCx4cyBhcyBzcXVhcmUsc2wgYXMgc3F1YXJlZERpZmZlcmVuY2UsdWwgYXMgc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QsanIgYXMgc3F1ZWV6ZSxLciBhcyBzdGFjayx3cyBhcyBzdGVwLE9sIGFzIHN0cmlkZWRTbGljZSxsbCBhcyBzdWIsY2wgYXMgc3ViU3RyaWN0LFR1IGFzIHN1bSxicyBhcyB0YW4sQ3MgYXMgdGFuaCxGbiBhcyB0ZW5zb3IsUG4gYXMgdGVuc29yMWQsTG4gYXMgdGVuc29yMmQsV24gYXMgdGVuc29yM2QsVW4gYXMgdGVuc29yNGQsem4gYXMgdGVuc29yNWQsVm4gYXMgdGVuc29yNmQsSXQgYXMgdGVuc29yX3V0aWwsU2ggYXMgdGVzdF91dGlsLEZlIGFzIHRpZHksWHIgYXMgdGlsZSxMZSBhcyB0aW1lLF9sIGFzIHRvcGssUGggYXMgdHJhaW4sQ2wgYXMgdHJhbnNwb3NlLFlyIGFzIHRydW5jYXRlZE5vcm1hbCxJbCBhcyB1bnNvcnRlZFNlZ21lbnRTdW0sUXIgYXMgdW5zdGFjayxaIGFzIHV0aWwsUm4gYXMgdmFsdWVBbmRHcmFkLFNuIGFzIHZhbHVlQW5kR3JhZHMsd3QgYXMgdmFyaWFibGUsTm4gYXMgdmFyaWFibGVHcmFkcyxOaCBhcyB2ZXJzaW9uX2NvcmUsa2ggYXMgd2ViZ2wsdmwgYXMgd2hlcmUsbWwgYXMgd2hlcmVBc3luYyxxbiBhcyB6ZXJvcyxYbiBhcyB6ZXJvc0xpa2V9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtY29yZS5lc20uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnR7dXRpbCx0aWR5LGRlcHJlY2F0aW9uV2FybixUZW5zb3Isc3RhY2ssdGVuc29yLEVOVixjbG9uZSxkaXNwb3NlLHRlbnNvcl91dGlsLHRlbnNvcjFkLHRlbnNvcjJkLGJyb3dzZXIsaW1hZ2V9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7dmFyIGV4dGVuZFN0YXRpY3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZXh0ZW5kU3RhdGljcz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gZSllLmhhc093blByb3BlcnR5KHIpJiYodFtyXT1lW3JdKX0pKHQsZSl9O2Z1bmN0aW9uIF9fZXh0ZW5kcyh0LGUpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPXR9ZXh0ZW5kU3RhdGljcyh0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KHIucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyByKX1mdW5jdGlvbiBfX2F3YWl0ZXIodCxlLHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBhKHQpe3RyeXtzKG4ubmV4dCh0KSl9Y2F0Y2godCl7byh0KX19ZnVuY3Rpb24gdSh0KXt0cnl7cyhuLnRocm93KHQpKX1jYXRjaCh0KXtvKHQpfX1mdW5jdGlvbiBzKHQpe3QuZG9uZT9pKHQudmFsdWUpOm5ldyByKGZ1bmN0aW9uKGUpe2UodC52YWx1ZSl9KS50aGVuKGEsdSl9cygobj1uLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gX19nZW5lcmF0b3IodCxlKXt2YXIgcixuLGksbyxhPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OnUoMCksdGhyb3c6dSgxKSxyZXR1cm46dSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIHUobyl7cmV0dXJuIGZ1bmN0aW9uKHUpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7YTspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBhLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OmEubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89YS5vcHMucG9wKCksYS50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPWEudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7YT0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7YS5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZhLmxhYmVsPGlbMV0pe2EubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmYS5sYWJlbDxpWzJdKXthLmxhYmVsPWlbMl0sYS5vcHMucHVzaChvKTticmVha31pWzJdJiZhLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWV9bz1lLmNhbGwodCxhKX1jYXRjaCh0KXtvPVs2LHRdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyx1XSl9fX12YXIgY29tbW9uanNHbG9iYWw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp7fTtmdW5jdGlvbiB1bndyYXBFeHBvcnRzKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGVmYXVsdFwiKT90LmRlZmF1bHQ6dH1mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZSh0LGUpe3JldHVybiB0KGU9e2V4cG9ydHM6e319LGUuZXhwb3J0cyksZS5leHBvcnRzfXZhciBhbGVhPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLmM9dC5jLGUuczA9dC5zMCxlLnMxPXQuczEsZS5zMj10LnMyLGV9ZnVuY3Rpb24gaSh0LGUpe3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZSxyPXRoaXMsbj0oZT00MDIyODcxMTk3LGZ1bmN0aW9uKHQpe3Q9dC50b1N0cmluZygpO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj0uMDI1MTk2MDMyODI0MTY5MzgqKGUrPXQuY2hhckNvZGVBdChyKSk7bi09ZT1uPj4+MCxlPShuKj1lKT4+PjAsZSs9NDI5NDk2NzI5Nioobi09ZSl9cmV0dXJuIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqKGU+Pj4wKX0pO3IubmV4dD1mdW5jdGlvbigpe3ZhciB0PTIwOTE2Mzkqci5zMCsyLjMyODMwNjQzNjUzODY5NjNlLTEwKnIuYztyZXR1cm4gci5zMD1yLnMxLHIuczE9ci5zMixyLnMyPXQtKHIuYz0wfHQpfSxyLmM9MSxyLnMwPW4oXCIgXCIpLHIuczE9bihcIiBcIiksci5zMj1uKFwiIFwiKSxyLnMwLT1uKHQpLHIuczA8MCYmKHIuczArPTEpLHIuczEtPW4odCksci5zMTwwJiYoci5zMSs9MSksci5zMi09bih0KSxyLnMyPDAmJihyLnMyKz0xKSxuPW51bGx9KHQpLGk9ZSYmZS5zdGF0ZSxvPXIubmV4dDtyZXR1cm4gby5pbnQzMj1mdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2KnIubmV4dCgpfDB9LG8uZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuIG8oKSsxLjExMDIyMzAyNDYyNTE1NjVlLTE2KigyMDk3MTUyKm8oKXwwKX0sby5xdWljaz1vLGkmJihcIm9iamVjdFwiPT10eXBlb2YgaSYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMuYWxlYT1pfSgwLHQsITEpfSkseG9yMTI4PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGV9ZnVuY3Rpb24gaSh0LGUpe3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9XCJcIjtlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54PDwxMTtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53Xj1lLnc+Pj4xOV50XnQ+Pj44fSx0PT09KDB8dCk/ZS54PXQ6cis9dDtmb3IodmFyIG49MDtuPHIubGVuZ3RoKzY0O24rKyllLnhePTB8ci5jaGFyQ29kZUF0KG4pLGUubmV4dCgpfSh0KSxpPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LG8uaW50MzI9ci5uZXh0LG8ucXVpY2s9byxpJiYoXCJvYmplY3RcIj09dHlwZW9mIGkmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLnhvcjEyOD1pfSgwLHQsITEpfSkseG9yd293PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGUudj10LnYsZS5kPXQuZCxlfWZ1bmN0aW9uIGkodCxlKXt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueD4+PjI7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUudz1lLnYsKGUuZD1lLmQrMzYyNDM3fDApKyhlLnY9ZS52XmUudjw8NF50XnQ8PDEpfDB9LGUueD0wLGUueT0wLGUuej0wLGUudz0wLGUudj0wLHQ9PT0oMHx0KT9lLng9dDpyKz10O2Zvcih2YXIgbj0wO248ci5sZW5ndGgrNjQ7bisrKWUueF49MHxyLmNoYXJDb2RlQXQobiksbj09ci5sZW5ndGgmJihlLmQ9ZS54PDwxMF5lLng+Pj40KSxlLm5leHQoKX0odCksaT1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxvLmludDMyPXIubmV4dCxvLnF1aWNrPW8saSYmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy54b3J3b3c9aX0oMCx0LCExKX0pLHhvcnNoaWZ0Nz1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS54PXQueC5zbGljZSgpLGUuaT10LmksZX1mdW5jdGlvbiBpKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxyLG49ZS54LGk9ZS5pO3JldHVybiB0PW5baV0scj0odF49dD4+PjcpXnQ8PDI0LHJePSh0PW5baSsxJjddKV50Pj4+MTAscl49KHQ9bltpKzMmN10pXnQ+Pj4zLHJePSh0PW5baSs0JjddKV50PDw3LHQ9bltpKzcmN10scl49KHRePXQ8PDEzKV50PDw5LG5baV09cixlLmk9aSsxJjcscn0sZnVuY3Rpb24odCxlKXt2YXIgcixuPVtdO2lmKGU9PT0oMHxlKSluWzBdPWU7ZWxzZSBmb3IoZT1cIlwiK2Uscj0wO3I8ZS5sZW5ndGg7KytyKW5bNyZyXT1uWzcmcl08PDE1XmUuY2hhckNvZGVBdChyKStuW3IrMSY3XTw8MTM7Zm9yKDtuLmxlbmd0aDw4OyluLnB1c2goMCk7Zm9yKHI9MDtyPDgmJjA9PT1uW3JdOysrcik7Zm9yKDg9PXI/bls3XT0tMTpuW3JdLHQueD1uLHQuaT0wLHI9MjU2O3I+MDstLXIpdC5uZXh0KCl9KGUsdCl9KHQpLGk9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0sby5pbnQzMj1yLm5leHQsby5xdWljaz1vLGkmJihpLngmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLnhvcnNoaWZ0Nz1pfSgwLHQsITEpfSkseG9yNDA5Nj1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS5pPXQuaSxlLnc9dC53LGUuWD10Llguc2xpY2UoKSxlfWZ1bmN0aW9uIGkodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LHIsbj1lLncsaT1lLlgsbz1lLmk7cmV0dXJuIGUudz1uPW4rMTY0MDUzMTUyN3wwLHI9aVtvKzM0JjEyN10sdD1pW289bysxJjEyN10scl49cjw8MTMsdF49dDw8MTcscl49cj4+PjE1LHRePXQ+Pj4xMixyPWlbb109cl50LGUuaT1vLHIrKG5ebj4+PjE2KXwwfSxmdW5jdGlvbih0LGUpe3ZhciByLG4saSxvLGEsdT1bXSxzPTEyODtmb3IoZT09PSgwfGUpPyhuPWUsZT1udWxsKTooZSs9XCJcXDBcIixuPTAscz1NYXRoLm1heChzLGUubGVuZ3RoKSksaT0wLG89LTMyO288czsrK28pZSYmKG5ePWUuY2hhckNvZGVBdCgobyszMiklZS5sZW5ndGgpKSwwPT09byYmKGE9biksbl49bjw8MTAsbl49bj4+PjE1LG5ePW48PDQsbl49bj4+PjEzLG8+PTAmJihhPWErMTY0MDUzMTUyN3wwLGk9MD09KHI9dVsxMjcmb11ePW4rYSk/aSsxOjApO2ZvcihpPj0xMjgmJih1WzEyNyYoZSYmZS5sZW5ndGh8fDApXT0tMSksaT0xMjcsbz01MTI7bz4wOy0tbyluPXVbaSszNCYxMjddLHI9dVtpPWkrMSYxMjddLG5ePW48PDEzLHJePXI8PDE3LG5ePW4+Pj4xNSxyXj1yPj4+MTIsdVtpXT1uXnI7dC53PWEsdC5YPXUsdC5pPWl9KGUsdCl9KHQpLGk9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0sby5pbnQzMj1yLm5leHQsby5xdWljaz1vLGkmJihpLlgmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLnhvcjQwOTY9aX0oMCx0LCExKX0pLHR5Y2hlaT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS5hPXQuYSxlLmI9dC5iLGUuYz10LmMsZS5kPXQuZCxlfWZ1bmN0aW9uIGkodCxlKXt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS5iLHI9ZS5jLG49ZS5kLGk9ZS5hO3JldHVybiB0PXQ8PDI1XnQ+Pj43XnIscj1yLW58MCxuPW48PDI0Xm4+Pj44XmksaT1pLXR8MCxlLmI9dD10PDwyMF50Pj4+MTJecixlLmM9cj1yLW58MCxlLmQ9bjw8MTZecj4+PjE2XmksZS5hPWktdHwwfSxlLmE9MCxlLmI9MCxlLmM9LTE2NDA1MzE1MjcsZS5kPTEzNjcxMzA1NTEsdD09PU1hdGguZmxvb3IodCk/KGUuYT10LzQyOTQ5NjcyOTZ8MCxlLmI9MHx0KTpyKz10O2Zvcih2YXIgbj0wO248ci5sZW5ndGgrMjA7bisrKWUuYl49MHxyLmNoYXJDb2RlQXQobiksZS5uZXh0KCl9KHQpLGk9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0sby5pbnQzMj1yLm5leHQsby5xdWljaz1vLGkmJihcIm9iamVjdFwiPT10eXBlb2YgaSYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMudHljaGVpPWl9KDAsdCwhMSl9KSxzZWVkcmFuZG9tPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlLHIpe3ZhciBuLGk9dGhpcyxvPTI1NixhPTYsdT1cInJhbmRvbVwiLHM9ci5wb3cobyxhKSxjPXIucG93KDIsNTIpLGw9MipjLGY9by0xO2Z1bmN0aW9uIGgodCxoLHYpe3ZhciB5PVtdLF89ZChmdW5jdGlvbiB0KGUscil7dmFyIG4saT1bXSxvPXR5cGVvZiBlO2lmKHImJlwib2JqZWN0XCI9PW8pZm9yKG4gaW4gZSl0cnl7aS5wdXNoKHQoZVtuXSxyLTEpKX1jYXRjaCh0KXt9cmV0dXJuIGkubGVuZ3RoP2k6XCJzdHJpbmdcIj09bz9lOmUrXCJcXDBcIn0oKGg9MT09aD97ZW50cm9weTohMH06aHx8e30pLmVudHJvcHk/W3QsbShlKV06bnVsbD09dD9mdW5jdGlvbigpe3RyeXt2YXIgdDtyZXR1cm4gbiYmKHQ9bi5yYW5kb21CeXRlcyk/dD10KG8pOih0PW5ldyBVaW50OEFycmF5KG8pLChpLmNyeXB0b3x8aS5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKHQpKSxtKHQpfWNhdGNoKHQpe3ZhciByPWkubmF2aWdhdG9yLGE9ciYmci5wbHVnaW5zO3JldHVyblsrbmV3IERhdGUsaSxhLGkuc2NyZWVuLG0oZSldfX0oKTp0LDMpLHkpLHc9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlLHI9dC5sZW5ndGgsbj10aGlzLGk9MCxhPW4uaT1uLmo9MCx1PW4uUz1bXTtyfHwodD1bcisrXSk7Zm9yKDtpPG87KXVbaV09aSsrO2ZvcihpPTA7aTxvO2krKyl1W2ldPXVbYT1mJmErdFtpJXJdKyhlPXVbaV0pXSx1W2FdPWU7KG4uZz1mdW5jdGlvbih0KXtmb3IodmFyIGUscj0wLGk9bi5pLGE9bi5qLHU9bi5TO3QtLTspZT11W2k9ZiZpKzFdLHI9cipvK3VbZiYodVtpXT11W2E9ZiZhK2VdKSsodVthXT1lKV07cmV0dXJuIG4uaT1pLG4uaj1hLHJ9KShvKX0oeSksZz1mdW5jdGlvbigpe2Zvcih2YXIgdD13LmcoYSksZT1zLHI9MDt0PGM7KXQ9KHQrcikqbyxlKj1vLHI9dy5nKDEpO2Zvcig7dD49bDspdC89MixlLz0yLHI+Pj49MTtyZXR1cm4odCtyKS9lfTtyZXR1cm4gZy5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHcuZyg0KX0sZy5xdWljaz1mdW5jdGlvbigpe3JldHVybiB3LmcoNCkvNDI5NDk2NzI5Nn0sZy5kb3VibGU9ZyxkKG0ody5TKSxlKSwoaC5wYXNzfHx2fHxmdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gaSYmKGkuUyYmcChpLHcpLHQuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcCh3LHt9KX0pLG4/KHJbdV09dCxlKTp0fSkoZyxfLFwiZ2xvYmFsXCJpbiBoP2guZ2xvYmFsOnRoaXM9PXIsaC5zdGF0ZSl9ZnVuY3Rpb24gcCh0LGUpe3JldHVybiBlLmk9dC5pLGUuaj10LmosZS5TPXQuUy5zbGljZSgpLGV9ZnVuY3Rpb24gZCh0LGUpe2Zvcih2YXIgcixuPXQrXCJcIixpPTA7aTxuLmxlbmd0aDspZVtmJmldPWYmKHJePTE5KmVbZiZpXSkrbi5jaGFyQ29kZUF0KGkrKyk7cmV0dXJuIG0oZSl9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLHQpfWlmKHJbXCJzZWVkXCIrdV09aCxkKHIucmFuZG9tKCksZSksdC5leHBvcnRzKXt0LmV4cG9ydHM9aDt0cnl7bj1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKHQpe319ZWxzZSAwfShbXSxNYXRoKX0pO3NlZWRyYW5kb20uYWxlYT1hbGVhLHNlZWRyYW5kb20ueG9yMTI4PXhvcjEyOCxzZWVkcmFuZG9tLnhvcndvdz14b3J3b3csc2VlZHJhbmRvbS54b3JzaGlmdDc9eG9yc2hpZnQ3LHNlZWRyYW5kb20ueG9yNDA5Nj14b3I0MDk2LHNlZWRyYW5kb20udHljaGVpPXR5Y2hlaTt2YXIgc2VlZHJhbmRvbSQxPXNlZWRyYW5kb20sc2VlZHJhbmRvbV8xPXNlZWRyYW5kb20kMS5hbGVhO2Z1bmN0aW9uIGRlZXBNYXBJbnRlcm5hbCh0LGUscixuKXtpZih2b2lkIDA9PT1yJiYocj1uZXcgTWFwKSx2b2lkIDA9PT1uJiYobj1uZXcgU2V0KSxudWxsPT10KXJldHVybiBudWxsO2lmKG4uaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKHIuaGFzKHQpKXJldHVybiByLmdldCh0KTt2YXIgaT1lKHQpO2lmKGkucmVjdXJzZSYmbnVsbCE9PWkudmFsdWUpdGhyb3cgbmV3IEVycm9yKFwiQSBkZWVwIG1hcCBmdW5jdGlvbiBtYXkgbm90IHJldHVybiBib3RoIGEgdmFsdWUgYW5kIHJlY3Vyc2U9dHJ1ZS5cIik7aWYoaS5yZWN1cnNlKXtpZihpc0l0ZXJhYmxlKHQpKXt2YXIgbz1BcnJheS5pc0FycmF5KHQpP1tdOnt9O2Zvcih2YXIgYSBpbiBuLmFkZCh0KSx0KXt2YXIgdT1kZWVwTWFwSW50ZXJuYWwodFthXSxlLHIsbik7b1thXT11fXJldHVybiBuLmRlbGV0ZSh0KSxvfXRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlY3Vyc2UgaW50byBub24taXRlcmFibGUgdHlwZTogXCIrdCl9cmV0dXJuIHIuc2V0KHQsaS52YWx1ZSksaS52YWx1ZX1mdW5jdGlvbiBkZWVwWmlwKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXppcFRvTGlzdCksZGVlcFppcEludGVybmFsKHQsZSl9ZnVuY3Rpb24gZGVlcFppcEludGVybmFsKHQsZSxyKXt2b2lkIDA9PT1yJiYocj1uZXcgU2V0KTt2YXIgbj10WzBdO2lmKHIuaGFzKG4pKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO3ZhciBpPWUodCk7aWYoaS5yZWN1cnNlJiZudWxsIT09aS52YWx1ZSl0aHJvdyBuZXcgRXJyb3IoXCJBIGRlZXAgemlwIGZ1bmN0aW9uIG1heSBub3QgcmV0dXJuIGJvdGggYSB2YWx1ZSBhbmQgcmVjdXJzZT10cnVlLlwiKTtpZihpLnJlY3Vyc2Upe2lmKGlzSXRlcmFibGUobikpe3ZhciBvPUFycmF5LmlzQXJyYXkobik/W106e307ci5hZGQobik7dmFyIGE9ZnVuY3Rpb24obil7dmFyIGk9ZGVlcFppcEludGVybmFsKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0W25dfSksZSxyKTtvW25dPWl9O2Zvcih2YXIgdSBpbiBuKWEodSk7cmV0dXJuIHIuZGVsZXRlKG4pLG99dGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcmVjdXJzZSBpbnRvIG5vbi1pdGVyYWJsZSB0eXBlOiBcIituKX1yZXR1cm4gaS52YWx1ZX1mdW5jdGlvbiB6aXBUb0xpc3QodCl7cmV0dXJuIG51bGw9PT10P251bGw6aXNJdGVyYWJsZSh0WzBdKT97dmFsdWU6bnVsbCxyZWN1cnNlOiEwfTp7dmFsdWU6dCxyZWN1cnNlOiExfX1mdW5jdGlvbiBkZWVwTWFwQW5kQXdhaXRBbGwodCxlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4saSxvLGEsdTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihzKXtzd2l0Y2gocy5sYWJlbCl7Y2FzZSAwOnI9bmV3IE1hcCxkZWVwTWFwSW50ZXJuYWwodCxlLHIpLG49MCxpPUFycmF5LmZyb20oci5rZXlzKCkpLHMubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48aS5sZW5ndGg/KG89aVtuXSwoYT1yLmdldChvKSlpbnN0YW5jZW9mIFByb21pc2U/WzQsYV06WzMsM10pOlszLDRdO2Nhc2UgMjp1PXMuc2VudCgpLHIuc2V0KG8sdSkscy5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMixkZWVwTWFwSW50ZXJuYWwodCxlLHIpXX19KX0pfWZ1bmN0aW9uIGlzSXRlcmFibGUodCl7cmV0dXJuIG51bGwhPXQmJihBcnJheS5pc0FycmF5KHQpfHxcIm9iamVjdFwiPT10eXBlb2YgdCYmISh0IGluc3RhbmNlb2YgVGVuc29yKSl9ZnVuY3Rpb24gY2FuVGVuc29yaWZ5KHQpe3JldHVybiBudWxsPT10fHxpc1ByaW1pdGl2ZSh0KXx8QXJyYXkuaXNBcnJheSh0KXx8XCJvYmplY3RcIj09dHlwZW9mIHQmJnQgaW5zdGFuY2VvZiBUZW5zb3J8fHV0aWwuaXNUeXBlZEFycmF5KHQpfWZ1bmN0aW9uIGlzUHJpbWl0aXZlKHQpe3JldHVybiBudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHR9dmFyIFJpbmdCdWZmZXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuY2FwYWNpdHk9dCx0aGlzLmJlZ2luPTAsdGhpcy5lbmQ9MCxudWxsPT10KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgcmluZyBidWZmZXIgb2YgdW5rbm93biBjYXBhY2l0eS5cIik7aWYodDwxKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgY3JlYXRlIHJpbmcgYnVmZmVyIG9mIGNhcGFjaXR5IDwgMS5cIik7dGhpcy5kYXRhPW5ldyBBcnJheSh0KSx0aGlzLmRvdWJsZWRDYXBhY2l0eT0yKnR9cmV0dXJuIHQucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24odCl7Zm9yKDt0PDA7KXQrPXRoaXMuZG91YmxlZENhcGFjaXR5O3JldHVybiB0JXRoaXMuZG91YmxlZENhcGFjaXR5fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgZ2V0IGl0ZW0gYXQgYSBuZWdhdGl2ZSBpbmRleC5cIik7cmV0dXJuIHRoaXMuZGF0YVt0JXRoaXMuY2FwYWNpdHldfSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzZXQgaXRlbSBhdCBhIG5lZ2F0aXZlIGluZGV4LlwiKTt0aGlzLmRhdGFbdCV0aGlzLmNhcGFjaXR5XT1lfSx0LnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVuZC10aGlzLmJlZ2luO3JldHVybiB0PDAmJih0PXRoaXMuZG91YmxlZENhcGFjaXR5K3QpLHR9LHQucHJvdG90eXBlLmlzRnVsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aCgpPT09dGhpcy5jYXBhY2l0eX0sdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5sZW5ndGgoKX0sdC5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXtpZih0aGlzLmlzRnVsbCgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZnVsbC5cIik7dGhpcy5zZXQodGhpcy5lbmQsdCksdGhpcy5lbmQ9dGhpcy53cmFwKHRoaXMuZW5kKzEpfSx0LnByb3RvdHlwZS5wdXNoQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLHI9dDtlPHIubGVuZ3RoO2UrKyl7dmFyIG49cltlXTt0aGlzLnB1c2gobil9fSx0LnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGVtcHR5LlwiKTt0aGlzLmVuZD10aGlzLndyYXAodGhpcy5lbmQtMSk7dmFyIHQ9dGhpcy5nZXQodGhpcy5lbmQpO3JldHVybiB0aGlzLnNldCh0aGlzLmVuZCx2b2lkIDApLHR9LHQucHJvdG90eXBlLnVuc2hpZnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5pc0Z1bGwoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGZ1bGwuXCIpO3RoaXMuYmVnaW49dGhpcy53cmFwKHRoaXMuYmVnaW4tMSksdGhpcy5zZXQodGhpcy5iZWdpbix0KX0sdC5wcm90b3R5cGUuc2hpZnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGVtcHR5LlwiKTt2YXIgdD10aGlzLmdldCh0aGlzLmJlZ2luKTtyZXR1cm4gdGhpcy5zZXQodGhpcy5iZWdpbix2b2lkIDApLHRoaXMuYmVnaW49dGhpcy53cmFwKHRoaXMuYmVnaW4rMSksdH0sdC5wcm90b3R5cGUuc2h1ZmZsZUV4Y2lzZT1mdW5jdGlvbih0KXtpZih0aGlzLmlzRW1wdHkoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGVtcHR5LlwiKTt2YXIgZT10aGlzLndyYXAodGhpcy5iZWdpbit0KSxyPXRoaXMuZ2V0KGUpO3JldHVybiB0aGlzLnNldChlLHRoaXMucG9wKCkpLHJ9LHR9KCksR3Jvd2luZ1JpbmdCdWZmZXI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiB0LmNhbGwodGhpcyxlLklOSVRJQUxfQ0FQQUNJVFkpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5pc0Z1bGw9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlKXt0LnByb3RvdHlwZS5pc0Z1bGwuY2FsbCh0aGlzKSYmdGhpcy5leHBhbmQoKSx0LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxlKX0sZS5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbihlKXt0LnByb3RvdHlwZS5pc0Z1bGwuY2FsbCh0aGlzKSYmdGhpcy5leHBhbmQoKSx0LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwodGhpcyxlKX0sZS5wcm90b3R5cGUuZXhwYW5kPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTIqdGhpcy5jYXBhY2l0eSxlPW5ldyBBcnJheSh0KSxyPXRoaXMubGVuZ3RoKCksbj0wO248cjtuKyspZVtuXT10aGlzLmdldCh0aGlzLndyYXAodGhpcy5iZWdpbituKSk7dGhpcy5kYXRhPWUsdGhpcy5jYXBhY2l0eT10LHRoaXMuZG91YmxlZENhcGFjaXR5PTIqdGhpcy5jYXBhY2l0eSx0aGlzLmJlZ2luPTAsdGhpcy5lbmQ9cn0sZS5JTklUSUFMX0NBUEFDSVRZPTMyLGV9KFJpbmdCdWZmZXIpO2Z1bmN0aW9uIGl0ZXJhdG9yRnJvbUl0ZW1zKHQpe3JldHVybiBuZXcgQXJyYXlJdGVyYXRvcih0KX1mdW5jdGlvbiBpdGVyYXRvckZyb21GdW5jdGlvbih0KXtyZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbEl0ZXJhdG9yKHQpfWZ1bmN0aW9uIGl0ZXJhdG9yRnJvbUNvbmNhdGVuYXRlZCh0LGUpe3JldHVybiBuZXcgQ2hhaW5lZEl0ZXJhdG9yKHQsZSl9ZnVuY3Rpb24gaXRlcmF0b3JGcm9tWmlwcGVkKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVppcE1pc21hdGNoTW9kZS5GQUlMKSxuZXcgWmlwSXRlcmF0b3IodCxlKX12YXIgWmlwTWlzbWF0Y2hNb2RlLExhenlJdGVyYXRvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD1bXSxbNCx0aGlzLm5leHQoKV07Y2FzZSAxOmU9ci5zZW50KCksci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gZS5kb25lP1szLDRdOih0LnB1c2goZS52YWx1ZSksWzQsdGhpcy5uZXh0KCldKTtjYXNlIDM6cmV0dXJuIGU9ci5zZW50KCksWzMsMl07Y2FzZSA0OnJldHVyblsyLHRdfX0pfSl9LHQucHJvdG90eXBlLnRvQXJyYXlGb3JUZXN0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD10aGlzLnByZWZldGNoKDEwMCksZT1bXSxbNCx0Lm5leHQoKV07Y2FzZSAxOnI9bi5zZW50KCksbi5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gci5kb25lP1szLDRdOihlLnB1c2goci52YWx1ZSksWzQsdC5uZXh0KCldKTtjYXNlIDM6cmV0dXJuIHI9bi5zZW50KCksWzMsMl07Y2FzZSA0OnJldHVyblsyLGVdfX0pfSl9LHQucHJvdG90eXBlLnJlc29sdmVGdWxseT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLm5leHQoKV07Y2FzZSAxOnQ9ZS5zZW50KCksZS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gdC5kb25lP1szLDRdOls0LHRoaXMubmV4dCgpXTtjYXNlIDM6cmV0dXJuIHQ9ZS5zZW50KCksWzMsMl07Y2FzZSA0OnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5yZXNvbHZlV2hpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5uZXh0KCldO2Nhc2UgMTplPW4uc2VudCgpLHI9dChlLnZhbHVlKSxuLmxhYmVsPTI7Y2FzZSAyOnJldHVybiBlLmRvbmV8fCFyP1szLDRdOls0LHRoaXMubmV4dCgpXTtjYXNlIDM6cmV0dXJuIGU9bi5zZW50KCkscj10KGUudmFsdWUpLFszLDJdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUuaGFuZGxlRXJyb3JzPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRXJyb3JIYW5kbGluZ0xhenlJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5maWx0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGaWx0ZXJJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXA9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXBBc3luYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEFzeW5jTWFwSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUuc2VyaWFsTWFwQXN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBBc3luY01hcEl0ZXJhdG9yKHRoaXMsdCkuc2VyaWFsKCl9LHQucHJvdG90eXBlLmZsYXRtYXA9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGbGF0bWFwSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUuZm9yRWFjaEFzeW5jPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5tYXAodCkucmVzb2x2ZUZ1bGx5KCldfSl9KX0sdC5wcm90b3R5cGUuc2VyaWFsRm9yRWFjaD1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMuc2VyaWFsTWFwQXN5bmModCkucmVzb2x2ZVdoaWxlKGZ1bmN0aW9uKHQpe3JldHVybiEwPT09dH0pXX0pfSl9LHQucHJvdG90eXBlLnJvd01ham9yQmF0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITApLG5ldyBSb3dNYWpvckJhdGNoSXRlcmF0b3IodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5jb2x1bW5NYWpvckJhdGNoPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITApLHZvaWQgMD09PXImJihyPXppcFRvTGlzdCksdGhpcy5yb3dNYWpvckJhdGNoKHQsZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBkZWVwWmlwKHQscil9KX0sdC5wcm90b3R5cGUuY29uY2F0ZW5hdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IENoYWluZWRJdGVyYXRvcihpdGVyYXRvckZyb21JdGVtcyhbdGhpcyx0XSksZSl9LHQucHJvdG90eXBlLnRha2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MHx8bnVsbD09dD90aGlzOm5ldyBUYWtlSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUuc2tpcD1mdW5jdGlvbih0KXtyZXR1cm4gdDwwfHxudWxsPT10P3RoaXM6bmV3IFNraXBJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5wcmVmZXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByZWZldGNoSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUuc2h1ZmZsZT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgU2h1ZmZsZUl0ZXJhdG9yKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc2VyaWFsPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZXJpYWxJdGVyYXRvcih0aGlzKX0sdH0oKSxBcnJheUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLml0ZW1zPWUsci50cmF2PTAscn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwiQXJyYXkgb2YgXCIrdGhpcy5pdGVtcy5sZW5ndGgrXCIgaXRlbXNcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy50cmF2Pj10aGlzLml0ZW1zLmxlbmd0aD9bMix7dmFsdWU6bnVsbCxkb25lOiEwfV06KHQ9dGhpcy5pdGVtc1t0aGlzLnRyYXZdLGU9dCBpbnN0YW5jZW9mIFRlbnNvcj9jbG9uZSh0KTp0LHRoaXMudHJhdisrLFsyLHt2YWx1ZTplLGRvbmU6ITF9XSl9KX0pfSxlfShMYXp5SXRlcmF0b3IpLEZ1bmN0aW9uQ2FsbEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLm5leHRGbj1lLHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIkZ1bmN0aW9uIGNhbGxcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7dHJ5e3JldHVyblsyLHRoaXMubmV4dEZuKCldfWNhdGNoKHQpe3Rocm93IHQubWVzc2FnZT1cIkVycm9yIHRocm93biB3aGlsZSBpdGVyYXRpbmcgdGhyb3VnaCBhIGRhdGFzZXQ6IFwiK3QubWVzc2FnZSx0fXJldHVyblsyXX0pfSl9LGV9KExhenlJdGVyYXRvciksU2VyaWFsSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIudXBzdHJlYW09ZSxyLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSkscn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBTZXJpYWxcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMudXBzdHJlYW0ubmV4dCgpXX0pfSl9LGV9KExhenlJdGVyYXRvciksU2tpcEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLm1heENvdW50PXIsbi5jb3VudD0wLG4ubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFNraXBcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY291bnQrKzx0aGlzLm1heENvdW50P1s0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTpbMywyXTtjYXNlIDE6cmV0dXJuKHQ9ZS5zZW50KCkpLmRvbmU/WzIsdF06KGRpc3Bvc2UodC52YWx1ZSksWzMsMF0pO2Nhc2UgMjpyZXR1cm5bMix0aGlzLnVwc3RyZWFtLm5leHQoKV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxUYWtlSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4ubWF4Q291bnQ9cixuLmNvdW50PTAsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBUYWtlXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvdW50Kys+PXRoaXMubWF4Q291bnQ/WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dOlsyLHRoaXMudXBzdHJlYW0ubmV4dCgpXX0pfSl9LGV9KExhenlJdGVyYXRvciksUm93TWFqb3JCYXRjaEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyLG4pe3ZvaWQgMD09PW4mJihuPSEwKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkudXBzdHJlYW09ZSxpLmJhdGNoU2l6ZT1yLGkuZW5hYmxlU21hbGxMYXN0QmF0Y2g9bixpLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksaX1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBSb3dNYWpvckJhdGNoXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6dD1bXSxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0Lmxlbmd0aDx0aGlzLmJhdGNoU2l6ZT9bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV06WzMsM107Y2FzZSAyOnJldHVybihlPXIuc2VudCgpKS5kb25lP3RoaXMuZW5hYmxlU21hbGxMYXN0QmF0Y2gmJnQubGVuZ3RoPjA/WzIse3ZhbHVlOnQsZG9uZTohMX1dOlsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XToodC5wdXNoKGUudmFsdWUpLFszLDFdKTtjYXNlIDM6cmV0dXJuWzIse3ZhbHVlOnQsZG9uZTohMX1dfX0pfSl9LGV9KExhenlJdGVyYXRvciksRmlsdGVySXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4ucHJlZGljYXRlPXIsbi5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gRmlsdGVyXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6cmV0dXJuKHQ9ZS5zZW50KCkpLmRvbmV8fHRoaXMucHJlZGljYXRlKHQudmFsdWUpP1syLHRdOihkaXNwb3NlKHQudmFsdWUpLFszLDBdKTtjYXNlIDI6cmV0dXJuWzJdfX0pfSl9LGV9KExhenlJdGVyYXRvciksTWFwSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4udHJhbnNmb3JtPXIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBNYXBcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saSxvLGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOmlmKCh0PXUuc2VudCgpKS5kb25lKXJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTtmb3IoZT10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIodC52YWx1ZSkscj10aGlzLnRyYW5zZm9ybSh0LnZhbHVlKSxuPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcihyKSxpPTAsbz1lO2k8by5sZW5ndGg7aSsrKWE9b1tpXSx0ZW5zb3JfdXRpbC5pc1RlbnNvckluTGlzdChhLG4pfHxhLmRpc3Bvc2UoKTtyZXR1cm5bMix7dmFsdWU6cixkb25lOiExfV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxFcnJvckhhbmRsaW5nTGF6eUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLmhhbmRsZXI9cixuLmNvdW50PTAsbi5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gaGFuZGxlRXJyb3JzXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOmUubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGUudHJ5cy5wdXNoKFsxLDMsLDRdKSxbNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAyOnJldHVyblsyLGUuc2VudCgpXTtjYXNlIDM6cmV0dXJuIHQ9ZS5zZW50KCksdGhpcy5oYW5kbGVyKHQpP1szLDRdOlsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTtjYXNlIDQ6cmV0dXJuWzMsMF07Y2FzZSA1OnJldHVyblsyXX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLEFzeW5jTWFwSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4udHJhbnNmb3JtPXIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBBc3luY01hcFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpLG8sYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6cmV0dXJuKHQ9dS5zZW50KCkpLmRvbmU/WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dOihlPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcih0LnZhbHVlKSxbNCx0aGlzLnRyYW5zZm9ybSh0LnZhbHVlKV0pO2Nhc2UgMjpmb3Iocj11LnNlbnQoKSxuPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcihyKSxpPTAsbz1lO2k8by5sZW5ndGg7aSsrKWE9b1tpXSx0ZW5zb3JfdXRpbC5pc1RlbnNvckluTGlzdChhLG4pfHxhLmRpc3Bvc2UoKTtyZXR1cm5bMix7dmFsdWU6cixkb25lOiExfV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxPbmVUb01hbnlJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBlLm91dHB1dFF1ZXVlPW5ldyBHcm93aW5nUmluZ0J1ZmZlcixlLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksZX1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIDAhPT10aGlzLm91dHB1dFF1ZXVlLmxlbmd0aCgpP1szLDJdOls0LHRoaXMucHVtcCgpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpP1szLDBdOlsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTtjYXNlIDI6cmV0dXJuWzIse3ZhbHVlOnRoaXMub3V0cHV0UXVldWUuc2hpZnQoKSxkb25lOiExfV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxGbGF0bWFwSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4udHJhbnNmb3JtPXIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBGbGF0bWFwXCJ9LGUucHJvdG90eXBlLnB1bXA9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscixuLGksbyxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTppZigodD11LnNlbnQoKSkuZG9uZSlyZXR1cm5bMiwhMV07Zm9yKGU9dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHQudmFsdWUpLHI9dGhpcy50cmFuc2Zvcm0odC52YWx1ZSksbj10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIociksdGhpcy5vdXRwdXRRdWV1ZS5wdXNoQWxsKHIpLGk9MCxvPWU7aTxvLmxlbmd0aDtpKyspYT1vW2ldLHRlbnNvcl91dGlsLmlzVGVuc29ySW5MaXN0KGEsbil8fGEuZGlzcG9zZSgpO3JldHVyblsyLCEwXX19KX0pfSxlfShPbmVUb01hbnlJdGVyYXRvciksQ2hhaW5lZEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uYmFzZUVycm9ySGFuZGxlcj1yLG4ubGFzdFJlYWQ9bnVsbCxuLml0ZXJhdG9yPW51bGwsbi5tb3JlSXRlcmF0b3JzPWUsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwiVE9ETzogZmlsbCBpbiB1cHN0cmVhbSBvZiBjaGFpbmVkIHN1bW1hcmllcyAtPiBDaGFpbmVkXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMucmVhZEZyb21DaGFpbih0aGlzLmxhc3RSZWFkKSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnJlYWRGcm9tQ2hhaW49ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdF07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxudWxsIT10aGlzLml0ZXJhdG9yP1szLDNdOls0LHRoaXMubW9yZUl0ZXJhdG9ycy5uZXh0KCldO2Nhc2UgMjppZigoZT1uLnNlbnQoKSkuZG9uZSlyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV07dGhpcy5pdGVyYXRvcj1lLnZhbHVlLG51bGwhPXRoaXMuYmFzZUVycm9ySGFuZGxlciYmKHRoaXMuaXRlcmF0b3I9dGhpcy5pdGVyYXRvci5oYW5kbGVFcnJvcnModGhpcy5iYXNlRXJyb3JIYW5kbGVyKSksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bNCx0aGlzLml0ZXJhdG9yLm5leHQoKV07Y2FzZSA0OnJldHVybihyPW4uc2VudCgpKS5kb25lPyh0aGlzLml0ZXJhdG9yPW51bGwsWzIsdGhpcy5yZWFkRnJvbUNoYWluKHQpXSk6WzIscl19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKTshZnVuY3Rpb24odCl7dFt0LkZBSUw9MF09XCJGQUlMXCIsdFt0LlNIT1JURVNUPTFdPVwiU0hPUlRFU1RcIix0W3QuTE9OR0VTVD0yXT1cIkxPTkdFU1RcIn0oWmlwTWlzbWF0Y2hNb2RlfHwoWmlwTWlzbWF0Y2hNb2RlPXt9KSk7dmFyIFppcEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2b2lkIDA9PT1yJiYocj1aaXBNaXNtYXRjaE1vZGUuRkFJTCk7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLml0ZXJhdG9ycz1lLG4ubWlzbWF0Y2hNb2RlPXIsbi5jb3VudD0wLG4uY3VycmVudFByb21pc2U9bnVsbCxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJ7VE9ETzogZmlsbCBpbiB1cHN0cmVhbSBvZiB6aXAgc3VtbWFyaWVzfSAtPiBaaXBcIn0sZS5wcm90b3R5cGUubmV4dFN0YXRlPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIExhenlJdGVyYXRvcj97dmFsdWU6dC5uZXh0KCkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gcisrLHQuZG9uZSYmbisrLHQudmFsdWV9KSxyZWN1cnNlOiExfTp7dmFsdWU6bnVsbCxyZWN1cnNlOiEwfX12YXIgcixuLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0XTtjYXNlIDE6cmV0dXJuIG8uc2VudCgpLHI9MCxuPTAsWzQsZGVlcE1hcEFuZEF3YWl0QWxsKHRoaXMuaXRlcmF0b3JzLGUpXTtjYXNlIDI6aWYoaT1vLnNlbnQoKSxyPT09bilyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV07aWYobj4wKXN3aXRjaCh0aGlzLm1pc21hdGNoTW9kZSl7Y2FzZSBaaXBNaXNtYXRjaE1vZGUuRkFJTDp0aHJvdyBuZXcgRXJyb3IoXCJaaXBwZWQgc3RyZWFtcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIE1pc21hdGNoZWQgYXQgZWxlbWVudCBcIit0aGlzLmNvdW50K1wiLlwiKTtjYXNlIFppcE1pc21hdGNoTW9kZS5TSE9SVEVTVDpyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV07Y2FzZSBaaXBNaXNtYXRjaE1vZGUuTE9OR0VTVDp9cmV0dXJuIHRoaXMuY291bnQrKyxbMix7dmFsdWU6aSxkb25lOiExfV19fSl9KX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jdXJyZW50UHJvbWlzZT10aGlzLm5leHRTdGF0ZSh0aGlzLmN1cnJlbnRQcm9taXNlKSxbNCx0aGlzLmN1cnJlbnRQcm9taXNlXTtjYXNlIDE6cmV0dXJuWzIsdC5zZW50KCldfX0pfSl9LGV9KExhenlJdGVyYXRvciksUHJlZmV0Y2hJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5idWZmZXJTaXplPXIsbi5idWZmZXI9bmV3IFJpbmdCdWZmZXIociksbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBQcmVmZXRjaFwifSxlLnByb3RvdHlwZS5yZWZpbGw9ZnVuY3Rpb24oKXtmb3IoOyF0aGlzLmJ1ZmZlci5pc0Z1bGwoKTspe3ZhciB0PXRoaXMudXBzdHJlYW0ubmV4dCgpO3RoaXMuYnVmZmVyLnB1c2godCl9fSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVmaWxsKCksdGhpcy5idWZmZXIuc2hpZnQoKX0sZX0oTGF6eUl0ZXJhdG9yKSxTaHVmZmxlSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIsbil7dmFyIGk9dC5jYWxsKHRoaXMsZSxyKXx8dGhpcztyZXR1cm4gaS51cHN0cmVhbT1lLGkud2luZG93U2l6ZT1yLGkudXBzdHJlYW1FeGhhdXN0ZWQ9ITEsaS5yYW5kb209c2VlZHJhbmRvbV8xKG58fHV0aWwubm93KCkudG9TdHJpbmcoKSksaS5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLGl9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5yYW5kb21JbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy5yYW5kb20oKSp0KX0sZS5wcm90b3R5cGUuY2hvb3NlSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yYW5kb21JbnQodGhpcy5idWZmZXIubGVuZ3RoKCkpfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6dGhpcy51cHN0cmVhbUV4aGF1c3RlZHx8dGhpcy5yZWZpbGwoKSxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0aGlzLmJ1ZmZlci5pc0VtcHR5KCk/WzMsM106KHQ9dGhpcy5jaG9vc2VJbmRleCgpLFs0LHRoaXMuYnVmZmVyLnNodWZmbGVFeGNpc2UodCldKTtjYXNlIDI6cmV0dXJuKGU9ci5zZW50KCkpLmRvbmU/KHRoaXMudXBzdHJlYW1FeGhhdXN0ZWQ9ITAsWzMsMV0pOih0aGlzLnJlZmlsbCgpLFsyLGVdKTtjYXNlIDM6cmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dfX0pfSl9LGV9KFByZWZldGNoSXRlcmF0b3IpLERhdGFzZXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5zaXplPW51bGx9cmV0dXJuIHQucHJvdG90eXBlLmJhdGNoPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpczt2b2lkIDA9PT1lJiYoZT0hMCk7dmFyIG49dGhpcztyZXR1cm4gdXRpbC5hc3NlcnQodD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaFNpemUgbmVlZHMgdG8gYmUgcG9zaXRpdmUsIGJ1dCBpdCBpc1xcbiAgICAgIFwiK3R9KSxkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHIsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsbi5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsci5zZW50KCkuY29sdW1uTWFqb3JCYXRjaCh0LGUsZGVlcEJhdGNoQ29uY2F0KV19fSl9KX0sdGhpcy5zaXplPT09MS8wfHxudWxsPT10aGlzLnNpemU/dGhpcy5zaXplOmU/TWF0aC5jZWlsKHRoaXMuc2l6ZS90KTpNYXRoLmZsb29yKHRoaXMuc2l6ZS90KSl9LHQucHJvdG90eXBlLmNvbmNhdGVuYXRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm4gbj0oZT1pLnNlbnQoKSkuY29uY2F0ZW5hdGUsWzQsdC5pdGVyYXRvcigpXTtjYXNlIDI6cmV0dXJuWzIsbi5hcHBseShlLFtpLnNlbnQoKV0pXX19KX0pfSx0aGlzLnNpemU9PT0xLzB8fHQuc2l6ZT09PTEvMD8xLzA6bnVsbCE9dGhpcy5zaXplJiZudWxsIT10LnNpemU/dGhpcy5zaXplK3Quc2l6ZTpudWxsKX0sdC5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KX0pXX19KX0pfSx0aGlzLnNpemU9PT0xLzA/MS8wOm51bGwpfSx0LnByb3RvdHlwZS5mb3JFYWNoQXN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLmZvckVhY2hBc3luYyh0KV19fSl9KX0sdC5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBkZXByZWNhdGlvbldhcm4oXCJkYXRhc2V0LmZvckVhY2goKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFBsZWFzZSB1c2UgZGF0YXNldC5mb3JFYWNoQXN5bmMoKSBpbnN0ZWFkXCIpLFsyLHRoaXMuZm9yRWFjaEFzeW5jKHQpXX0pfSl9LHQucHJvdG90eXBlLm1hcD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiB0KGUpfSl9KV19fSl9KX0sdGhpcy5zaXplKX0sdC5wcm90b3R5cGUubWFwQXN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5tYXBBc3luYyh0KV19fSl9KX0sdGhpcy5zaXplKX0sdC5wcm90b3R5cGUucHJlZmV0Y2g9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZihudWxsPT10KXRocm93IG5ldyBSYW5nZUVycm9yKFwiYERhdGFzZXQucHJlZmV0Y2goKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuXCIpO3ZhciByPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5wcmVmZXRjaCh0KV19fSl9KX0sdGhpcy5zaXplKX0sdC5wcm90b3R5cGUucmVwZWF0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuWzIsaXRlcmF0b3JGcm9tQ29uY2F0ZW5hdGVkKGl0ZXJhdG9yRnJvbUZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXt9LFs0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLCh0LnZhbHVlPWUuc2VudCgpLHQuZG9uZT0hMSx0KV19fSl9KX0pLnRha2UodCkpXX0pfSl9LG51bGwhPXRoaXMuc2l6ZSYmdD4wP3RoaXMuc2l6ZSp0OjA9PT10PzA6bnVsbCE9dGhpcy5zaXplJiYodm9pZCAwPT09dHx8dDwwKT8xLzA6bnVsbCl9LHQucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5za2lwKHQpXX19KX0pfSxudWxsIT10aGlzLnNpemUmJnQ+PTAmJnRoaXMuc2l6ZT49dD90aGlzLnNpemUtdDpudWxsIT10aGlzLnNpemUmJih0aGlzLnNpemU8dHx8dm9pZCAwPT09dHx8dDwwKT8wOm51bGwpfSx0LnByb3RvdHlwZS5zaHVmZmxlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj10aGlzO2lmKHZvaWQgMD09PXImJihyPSEwKSxudWxsPT10fHx0PDApdGhyb3cgbnVsbD09dGhpcy5zaXplP25ldyBSYW5nZUVycm9yKFwiYERhdGFzZXQuc2h1ZmZsZSgpYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC5cIik6bmV3IFJhbmdlRXJyb3IoXCJgRGF0YXNldC5zaHVmZmxlKClgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLiAgSWYgeW91ciBkYXRhIGZpdHMgaW4gbWFpbiBtZW1vcnkgKGZvciByZWd1bGFyIEpTIG9iamVjdHMpLCBhbmQvb3IgR1BVIG1lbW9yeSAoZm9yIGB0Zi5UZW5zb3JgcyksIGNvbnNpZGVyIHNldHRpbmcgYnVmZmVyU2l6ZSB0byB0aGUgZGF0YXNldCBzaXplIChcIit0aGlzLnNpemUrXCIgZWxlbWVudHMpXCIpO3ZhciBpPXRoaXMsbz1zZWVkcmFuZG9tXzEoZXx8dXRpbC5ub3coKS50b1N0cmluZygpKTtyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihuLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPW8uaW50MzIoKSxyJiYoZSs9by5pbnQzMigpKSxbNCxpLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixuLnNlbnQoKS5zaHVmZmxlKHQsZS50b1N0cmluZygpKV19fSl9KX0sdGhpcy5zaXplKX0sdC5wcm90b3R5cGUudGFrZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLnRha2UodCldfX0pfSl9LG51bGwhPXRoaXMuc2l6ZSYmdGhpcy5zaXplPnQ/dDpudWxsIT10aGlzLnNpemUmJnRoaXMuc2l6ZTw9dD90aGlzLnNpemU6bnVsbCl9LHQucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6aWYodGhpcy5zaXplPT09MS8wKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSBkYXRhIHN0cmVhbSB0byBhcnJheS5cIik7cmV0dXJuWzQsdGhpcy5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsdC5zZW50KCkudG9BcnJheSgpXX19KX0pfSx0LnByb3RvdHlwZS50b0FycmF5Rm9yVGVzdD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDppZih0aGlzLnNpemU9PT0xLzApdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGluZmluaXRlIGRhdGEgc3RyZWFtIHRvIGFycmF5LlwiKTtyZXR1cm5bNCx0aGlzLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMix0LnNlbnQoKS50b0FycmF5Rm9yVGVzdCgpXX19KX0pfSx0Lk1BWF9CVUZGRVJfU0laRT0xZTQsdH0oKTtmdW5jdGlvbiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9bnVsbCksbmV3KGZ1bmN0aW9uKHIpe2Z1bmN0aW9uIG4oKXt2YXIgdD1udWxsIT09ciYmci5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHQuc2l6ZT1lLHR9cmV0dXJuIF9fZXh0ZW5kcyhuLHIpLG4ucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMix0KCldfSl9KX0sbn0oRGF0YXNldCkpfWZ1bmN0aW9uIGFycmF5KHQpe3ZhciBlPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsaXRlcmF0b3JGcm9tSXRlbXModCldfSl9KX0sdC5sZW5ndGgpfWZ1bmN0aW9uIHppcCh0KXt2YXIgZSxyPXRoaXM7aWYoIWlzSXRlcmFibGUodCkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHRvIHppcCgpIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5LlwiKTtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWU9bnVsbD09ZT90W25dLnNpemU6TWF0aC5taW4oZSx0W25dLnNpemUpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE9iamVjdClmb3IodmFyIGkgaW4gdCllPW51bGw9PWU/dFtpXS5zaXplOk1hdGgubWluKGUsdFtpXS5zaXplKTtyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihyLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGRlZXBNYXBBbmRBd2FpdEFsbCh0LGZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBEYXRhc2V0KXJldHVybnt2YWx1ZTp0Lml0ZXJhdG9yKCkscmVjdXJzZTohMX07aWYoaXNJdGVyYWJsZSh0KSlyZXR1cm57dmFsdWU6bnVsbCxyZWN1cnNlOiEwfTt0aHJvdyBuZXcgRXJyb3IoXCJMZWF2ZXMgb2YgdGhlIHN0cnVjdHVyZSBwYXNzZWQgdG8gemlwKCkgbXVzdCBiZSBEYXRhc2V0cywgbm90IHByaW1pdGl2ZXMuXCIpfSldO2Nhc2UgMTpyZXR1cm5bMixpdGVyYXRvckZyb21aaXBwZWQoZS5zZW50KCksWmlwTWlzbWF0Y2hNb2RlLlNIT1JURVNUKV19fSl9KX0sZSl9ZnVuY3Rpb24gZGVlcEJhdGNoQ29uY2F0KHQpe3JldHVybiBudWxsPT09dD9udWxsOmNhblRlbnNvcmlmeSh0WzBdKT97dmFsdWU6YmF0Y2hDb25jYXQodCkscmVjdXJzZTohMX06e3ZhbHVlOm51bGwscmVjdXJzZTohMH19ZnVuY3Rpb24gYmF0Y2hDb25jYXQodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhbid0IG1ha2UgYSBiYXRjaCBvZiB6ZXJvIGVsZW1lbnRzLlwiKTtyZXR1cm4gdFswXWluc3RhbmNlb2YgVGVuc29yP3N0YWNrKHQpOnRlbnNvcih0KX12YXIgVGV4dExpbmVEYXRhc2V0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLmlucHV0PWUscn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmlucHV0Lml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm4gdD1yLnNlbnQoKSxlPXQuZGVjb2RlVVRGOCgpLFsyLGUuc3BsaXQoXCJcXG5cIildfX0pfSl9LGV9KERhdGFzZXQpLENPREVfUVVPVEU9J1wiJyxTVEFURV9PVVQ9U3ltYm9sKFwib3V0XCIpLFNUQVRFX0ZJRUxEPVN5bWJvbChcImZpZWxkXCIpLFNUQVRFX1FVT1RFPVN5bWJvbChcInF1b3RlXCIpLFNUQVRFX1FVT1RFX0FGVEVSX1FVT1RFPVN5bWJvbChcInF1b3RlYWZ0ZXJxdW90ZVwiKSxTVEFURV9XSVRISU5fUVVPVEVfSU5fUVVPVEU9U3ltYm9sKFwicXVvdGVpbnF1b3RlXCIpLENTVkRhdGFzZXQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5pbnB1dD1lLG4uaGFzSGVhZGVyPSEwLG4uZnVsbENvbHVtbk5hbWVzPW51bGwsbi5jb2x1bW5OYW1lc1ZhbGlkYXRlZD0hMSxuLmNvbHVtbkNvbmZpZ3M9bnVsbCxuLmNvbmZpZ3VyZWRDb2x1bW5zT25seT0hMSxuLmRlbGltaXRlcj1cIixcIixuLmRlbGltV2hpdGVzcGFjZT0hMSxuLmJhc2U9bmV3IFRleHRMaW5lRGF0YXNldChlKSxyfHwocj17fSksbi5oYXNIZWFkZXI9ITEhPT1yLmhhc0hlYWRlcixuLmZ1bGxDb2x1bW5OYW1lcz1yLmNvbHVtbk5hbWVzLG4uY29sdW1uQ29uZmlncz1yLmNvbHVtbkNvbmZpZ3Msbi5jb25maWd1cmVkQ29sdW1uc09ubHk9ci5jb25maWd1cmVkQ29sdW1uc09ubHksci5kZWxpbVdoaXRlc3BhY2U/KHV0aWwuYXNzZXJ0KG51bGw9PXIuZGVsaW1pdGVyLGZ1bmN0aW9uKCl7cmV0dXJuXCJEZWxpbWl0ZXIgc2hvdWxkIG5vdCBiZSBwcm92aWRlZCB3aGVuIGRlbGltV2hpdGVzcGFjZSBpcyB0cnVlLlwifSksbi5kZWxpbVdoaXRlc3BhY2U9ITAsbi5kZWxpbWl0ZXI9XCIgXCIpOm4uZGVsaW1pdGVyPXIuZGVsaW1pdGVyP3IuZGVsaW1pdGVyOlwiLFwiLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLmNvbHVtbk5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkP1szLDJdOls0LHRoaXMuc2V0Q29sdW1uTmFtZXMoKV07Y2FzZSAxOnQuc2VudCgpLHQubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzIsdGhpcy5jb25maWd1cmVkQ29sdW1uc09ubHk/T2JqZWN0LmtleXModGhpcy5jb2x1bW5Db25maWdzKTp0aGlzLmZ1bGxDb2x1bW5OYW1lc119fSl9KX0sZS5wcm90b3R5cGUuc2V0Q29sdW1uTmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscixuLGksbyxhPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLm1heWJlUmVhZEhlYWRlckxpbmUoKV07Y2FzZSAxOmlmKHQ9dS5zZW50KCksIXRoaXMuZnVsbENvbHVtbk5hbWVzJiYhdCl0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gbmFtZXMgbXVzdCBiZSBwcm92aWRlZCBpZiB0aGVyZSBpcyBubyBoZWFkZXIgbGluZS5cIik7aWYodGhpcy5mdWxsQ29sdW1uTmFtZXMmJnQmJnV0aWwuYXNzZXJ0KHQubGVuZ3RoPT09dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgbGVuZ3RoIG9mIHByb3ZpZGVkIGNvbHVtbk5hbWVzIChcIithLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgudG9TdHJpbmcoKStcIikgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgaGVhZGVyIGxpbmUgcmVhZCBmcm9tIGZpbGUgKFwiK3QubGVuZ3RoLnRvU3RyaW5nKCkrXCIpLlwifSksdGhpcy5mdWxsQ29sdW1uTmFtZXN8fCh0aGlzLmZ1bGxDb2x1bW5OYW1lcz10KSxlPXRoaXMuZnVsbENvbHVtbk5hbWVzLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0W2VdPXRbZV0rMXx8MSx0fSx7fSkscj1PYmplY3Qua2V5cyhlKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0+MX0pLHV0aWwuYXNzZXJ0KDA9PT1yLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRHVwbGljYXRlIGNvbHVtbiBuYW1lcyBmb3VuZDogXCIrci50b1N0cmluZygpfSksdGhpcy5jb2x1bW5Db25maWdzKWZvcihuPTAsaT1PYmplY3Qua2V5cyh0aGlzLmNvbHVtbkNvbmZpZ3MpO248aS5sZW5ndGg7bisrKWlmKG89aVtuXSwtMT09PXRoaXMuZnVsbENvbHVtbk5hbWVzLmluZGV4T2YobykpdGhyb3cgbmV3IEVycm9yKCdUaGUga2V5IFwiJytvKydcIiBwcm92aWRlZCBpbiBjb2x1bW5Db25maWdzIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgY29sdW1uIG5hbWVzICgnK3RoaXMuZnVsbENvbHVtbk5hbWVzLnRvU3RyaW5nKCkrXCIpLlwiKTtyZXR1cm4gdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZD0hMCxbMl19fSl9KX0sZS5wcm90b3R5cGUubWF5YmVSZWFkSGVhZGVyTGluZT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmhhc0hlYWRlcj9bNCx0aGlzLmJhc2UuaXRlcmF0b3IoKV06WzMsM107Y2FzZSAxOnJldHVybls0LHIuc2VudCgpLm5leHQoKV07Y2FzZSAyOmlmKCh0PXIuc2VudCgpKS5kb25lKXRocm93IG5ldyBFcnJvcihcIk5vIGRhdGEgd2FzIGZvdW5kIGZvciBDU1YgcGFyc2luZy5cIik7cmV0dXJuIGU9dC52YWx1ZSxbMix0aGlzLnBhcnNlUm93KGUsITEpXTtjYXNlIDM6cmV0dXJuWzIsbnVsbF19fSl9KX0sZS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkP1szLDJdOls0LHRoaXMuc2V0Q29sdW1uTmFtZXMoKV07Y2FzZSAxOnIuc2VudCgpLHIubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsdGhpcy5iYXNlLml0ZXJhdG9yKCldO2Nhc2UgMzpyZXR1cm4gdD1yLnNlbnQoKSx0aGlzLmhhc0hlYWRlciYmKHQ9dC5za2lwKDEpKSxbMix0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5tYWtlRGF0YUVsZW1lbnQodCl9KV19fSl9KX0sZS5wcm90b3R5cGUubWFrZURhdGFFbGVtZW50PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnBhcnNlUm93KHQpLHI9e30sbj17fSxpPTA7aTx0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGg7aSsrKXt2YXIgbz10aGlzLmZ1bGxDb2x1bW5OYW1lc1tpXSxhPXRoaXMuY29sdW1uQ29uZmlncz90aGlzLmNvbHVtbkNvbmZpZ3Nbb106bnVsbDtpZighdGhpcy5jb25maWd1cmVkQ29sdW1uc09ubHl8fGEpe3ZhciB1PWVbaV0scz1udWxsO2lmKFwiXCI9PT11KWlmKGEmJnZvaWQgMCE9PWEuZGVmYXVsdClzPWEuZGVmYXVsdDtlbHNle2lmKGEmJihhLnJlcXVpcmVkfHxhLmlzTGFiZWwpKXRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIGNvbHVtbiBcIitvK1wiIGlzIGVtcHR5IGluIHRoaXMgbGluZTogXCIrdCk7cz12b2lkIDB9ZWxzZXt2YXIgYz1OdW1iZXIodSk7aWYoaXNOYU4oYykpcz1hJiZcImJvb2xcIj09PWEuZHR5cGU/dGhpcy5nZXRCb29sZWFuKHUpOnU7ZWxzZSBpZihhJiZhLmR0eXBlKXN3aXRjaChhLmR0eXBlKXtjYXNlXCJmbG9hdDMyXCI6cz1jO2JyZWFrO2Nhc2VcImludDMyXCI6cz1NYXRoLmZsb29yKGMpO2JyZWFrO2Nhc2VcImJvb2xcIjpzPXRoaXMuZ2V0Qm9vbGVhbih1KTticmVhaztkZWZhdWx0OnM9Y31lbHNlIHM9Y31hJiZhLmlzTGFiZWw/bltvXT1zOnJbb109c319cmV0dXJuIDA9PT1PYmplY3Qua2V5cyhuKS5sZW5ndGg/cjp7eHM6cix5czpufX0sZS5wcm90b3R5cGUuZ2V0Qm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm5cIjFcIj09PXR8fFwidHJ1ZVwiPT09dC50b0xvd2VyQ2FzZSgpPzE6MH0sZS5wcm90b3R5cGUucGFyc2VSb3c9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0hMCk7Zm9yKHZhciByPVtdLG49MCxpPXQubGVuZ3RoLG89U1RBVEVfT1VULGE9MDthPGk7YSsrKXN3aXRjaChvKXtjYXNlIFNUQVRFX09VVDpzd2l0Y2godC5jaGFyQXQoYSkpe2Nhc2UgQ09ERV9RVU9URTpuPWErMSxvPVNUQVRFX1FVT1RFO2JyZWFrO2Nhc2UgdGhpcy5kZWxpbWl0ZXI6aWYobj1hKzEsXCIgXCI9PT10aGlzLmRlbGltaXRlciYmdGhpcy5kZWxpbVdoaXRlc3BhY2UpYnJlYWs7ci5wdXNoKFwiXCIpLG89U1RBVEVfT1VUO2JyZWFrO2RlZmF1bHQ6bz1TVEFURV9GSUVMRCxuPWF9YnJlYWs7Y2FzZSBTVEFURV9GSUVMRDpzd2l0Y2godC5jaGFyQXQoYSkpe2Nhc2UgdGhpcy5kZWxpbWl0ZXI6ci5wdXNoKHQuc3Vic3RyaW5nKG4sYSkpLG89U1RBVEVfT1VULG49YSsxfWJyZWFrO2Nhc2UgU1RBVEVfUVVPVEU6c3dpdGNoKHQuY2hhckF0KGEpKXtjYXNlIENPREVfUVVPVEU6bz1TVEFURV9RVU9URV9BRlRFUl9RVU9URX1icmVhaztjYXNlIFNUQVRFX1FVT1RFX0FGVEVSX1FVT1RFOnN3aXRjaCh0LmNoYXJBdChhKSl7Y2FzZSB0aGlzLmRlbGltaXRlcjpyLnB1c2godC5zdWJzdHJpbmcobixhLTEpKSxvPVNUQVRFX09VVCxuPWErMTticmVhaztjYXNlIENPREVfUVVPVEU6bz1TVEFURV9RVU9URTticmVhaztkZWZhdWx0Om89U1RBVEVfV0lUSElOX1FVT1RFX0lOX1FVT1RFfWJyZWFrO2Nhc2UgU1RBVEVfV0lUSElOX1FVT1RFX0lOX1FVT1RFOnN3aXRjaCh0LmNoYXJBdChhKSl7Y2FzZSBDT0RFX1FVT1RFOm89U1RBVEVfUVVPVEV9fWlmKG89PT1TVEFURV9RVU9URV9BRlRFUl9RVU9URT9yLnB1c2godC5zdWJzdHJpbmcobixpLTEpKTpyLnB1c2godC5zdWJzdHJpbmcobikpLGUmJnIubGVuZ3RoIT09dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm93IGluIGNzdiBmaWxlLiBTaG91bGQgaGF2ZSBcIit0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgrXCIgZWxlbWVudHMgaW4gYSByb3csIGJ1dCBnb3QgXCIrcik7cmV0dXJuIHJ9LGV9KERhdGFzZXQpLGVudmlyb25tZW50PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZ2xvYmFsPXQsdGhpcy5mbGFncz17fSx0aGlzLmZsYWdSZWdpc3RyeT17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfXJldHVybiB0LnByb3RvdHlwZS5yZWdpc3RlckZsYWc9ZnVuY3Rpb24odCxlLHIpe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdPXtldmFsdWF0aW9uRm46ZSxzZXRIb29rOnJ9LG51bGwhPXRoaXMudXJsRmxhZ3NbdF0pe3ZhciBuPXRoaXMudXJsRmxhZ3NbdF07Y29uc29sZS53YXJuKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiK3QrXCI6IFwiK24rXCIuXCIpLHRoaXMuc2V0KHQsbil9fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5mbGFncz90aGlzLmZsYWdzW3RdOih0aGlzLmZsYWdzW3RdPXRoaXMuZXZhbHVhdGVGbGFnKHQpLHRoaXMuZmxhZ3NbdF0pfSx0LnByb3RvdHlwZS5nZXROdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRCb29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0RmxhZ3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZmVhdHVyZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBmbGFnIFwiK3QrXCIgYXMgaXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXCIpO3RoaXMuZmxhZ3NbdF09ZSxudWxsIT10aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rJiZ0aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rKGUpfSx0LnByb3RvdHlwZS5ldmFsdWF0ZUZsYWc9ZnVuY3Rpb24odCl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV2YWx1YXRlIGZsYWcgJ1wiK3QrXCInOiBubyBldmFsdWF0aW9uIGZ1bmN0aW9uIGZvdW5kLlwiKTtyZXR1cm4gdGhpcy5mbGFnUmVnaXN0cnlbdF0uZXZhbHVhdGlvbkZuKCl9LHQucHJvdG90eXBlLnNldEZsYWdzPWZ1bmN0aW9uKHQpe3RoaXMuZmxhZ3M9T2JqZWN0LmFzc2lnbih7fSx0KX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZsYWdzPXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9LHQucHJvdG90eXBlLnBvcHVsYXRlVVJMRmxhZ3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMuZ2xvYmFsJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbiYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKXt2YXIgZT1uKHRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCk7aWYoXCJ0ZmpzZmxhZ3NcImluIGUpZS50ZmpzZmxhZ3Muc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9ZS5zcGxpdChcIjpcIiksbj1yWzBdLGk9clsxXTt0LnVybEZsYWdzW25dPWZ1bmN0aW9uKHQsZSl7aWYoXCJ0cnVlXCI9PT0oZT1lLnRvTG93ZXJDYXNlKCkpfHxcImZhbHNlXCI9PT1lKXJldHVyblwidHJ1ZVwiPT09ZTtpZihcIlwiKyArZT09PWUpcmV0dXJuK2U7dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHZhbHVlIGZsYWcgdmFsdWUgXCIrZStcIiBmb3IgZmxhZyBcIit0K1wiLlwiKX0obixpKX0pfX0sdH0oKTtmdW5jdGlvbiBuKHQpe3ZhciBlPXt9O3JldHVybiB0LnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csZnVuY3Rpb24odCl7Zm9yKHZhciByPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXJbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIGZ1bmN0aW9uKHQsZSxyKXt0W2RlY29kZVVSSUNvbXBvbmVudChlKV09ZGVjb2RlVVJJQ29tcG9uZW50KHJ8fFwiXCIpfShlLHJbMF0sclsxXSksci5qb2luKFwiPVwiKX0pLGV9ZS5FbnZpcm9ubWVudD1yLGUuZ2V0UXVlcnlQYXJhbXM9bixlLnNldEVudmlyb25tZW50R2xvYmFsPWZ1bmN0aW9uKHQpe2UuRU5WPXR9fSk7dW53cmFwRXhwb3J0cyhlbnZpcm9ubWVudCk7dmFyIGVudmlyb25tZW50XzE9ZW52aXJvbm1lbnQuRW52aXJvbm1lbnQsZW52aXJvbm1lbnRfMj1lbnZpcm9ubWVudC5nZXRRdWVyeVBhcmFtcyxlbnZpcm9ubWVudF8zPWVudmlyb25tZW50LkVOVixlbnZpcm9ubWVudF80PWVudmlyb25tZW50LnNldEVudmlyb25tZW50R2xvYmFsLHV0aWwkMT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIodCl7Zm9yKHZhciBlPXQubGVuZ3RoLHI9MCxuPTA7ZT4wOyluPU1hdGgucmFuZG9tKCkqZXwwLHI9dFstLWVdLHRbZV09dFtuXSx0W25dPXJ9ZnVuY3Rpb24gbih0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUoKSl9ZnVuY3Rpb24gaSh0LGUpe2lmKHZvaWQgMD09PWUmJihlPVtdKSxudWxsPT1lJiYoZT1bXSksQXJyYXkuaXNBcnJheSh0KXx8Yyh0KSlmb3IodmFyIHI9MDtyPHQubGVuZ3RoOysrcilpKHRbcl0sZSk7ZWxzZSBlLnB1c2godCk7cmV0dXJuIGV9ZnVuY3Rpb24gbyh0LGUpe2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PXR8fG51bGw9PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdIT09ZVtyXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBhKHQpe3JldHVybiB0JTE9PTB9ZnVuY3Rpb24gdSh0LGUpe3ZhciByPWUubGVuZ3RoO3JldHVybiBuKCh0PW51bGw9PXQ/ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pOltdLmNvbmNhdCh0KSkuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PS1yJiZ0PHJ9KSxmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy1cIityK1wiLCBcIityK1wiKSBidXQgZ290IGF4aXMgXCIrdH0pLG4odC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gYSh0KX0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgXCIrdH0pLHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0PDA/cit0OnR9KX1mdW5jdGlvbiBzKHQsZSl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07aWYoaXNOYU4obil8fCFpc0Zpbml0ZShuKSl0aHJvdyBFcnJvcihcIkEgdGVuc29yIG9mIHR5cGUgXCIrZStcIiBiZWluZyB1cGxvYWRlZCBjb250YWlucyBcIituK1wiLlwiKX19ZnVuY3Rpb24gYyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIGwodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gZih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9ZnVuY3Rpb24gaCh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH1mdW5jdGlvbiBwKHQsZSl7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2h1ZmZsZT1yLGUuY2xhbXA9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUscikpfSxlLm5lYXJlc3RMYXJnZXJFdmVuPWZ1bmN0aW9uKHQpe3JldHVybiB0JTI9PTA/dDp0KzF9LGUuc3VtPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLHI9MDtyPHQubGVuZ3RoO3IrKyllKz10W3JdO3JldHVybiBlfSxlLnJhbmRVbmlmb3JtPWZ1bmN0aW9uKHQsZSl7dmFyIHI9TWF0aC5yYW5kb20oKTtyZXR1cm4gZSpyKygxLXIpKnR9LGUuZGlzdFNxdWFyZWQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPU51bWJlcih0W25dKS1OdW1iZXIoZVtuXSk7cis9aSppfXJldHVybiByfSxlLmFzc2VydD1uLGUuYXNzZXJ0U2hhcGVzTWF0Y2g9ZnVuY3Rpb24odCxlLHIpe3ZvaWQgMD09PXImJihyPVwiXCIpLG4obyh0LGUpLGZ1bmN0aW9uKCl7cmV0dXJuIHIrXCIgU2hhcGVzIFwiK3QrXCIgYW5kIFwiK2UrXCIgbXVzdCBtYXRjaFwifSl9LGUuYXNzZXJ0Tm9uTnVsbD1mdW5jdGlvbih0KXtuKG51bGwhPXQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBpbnB1dCB0byB0aGUgdGVuc29yIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBub24tbnVsbCB2YWx1ZS5cIn0pfSxlLmZsYXR0ZW49aSxlLnNpemVGcm9tU2hhcGU9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2Zvcih2YXIgZT10WzBdLHI9MTtyPHQubGVuZ3RoO3IrKyllKj10W3JdO3JldHVybiBlfSxlLmlzU2NhbGFyU2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10Lmxlbmd0aH0sZS5hcnJheXNFcXVhbD1vLGUuaXNJbnQ9YSxlLnRhbmg9ZnVuY3Rpb24odCl7aWYobnVsbCE9TWF0aC50YW5oKXJldHVybiBNYXRoLnRhbmgodCk7aWYodD09PTEvMClyZXR1cm4gMTtpZih0PT09LTEvMClyZXR1cm4tMTt2YXIgZT1NYXRoLmV4cCgyKnQpO3JldHVybihlLTEpLyhlKzEpfSxlLnNpemVUb1NxdWFyaXNoU2hhcGU9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfSxlLmNyZWF0ZVNodWZmbGVkSW5kaWNlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IFVpbnQzMkFycmF5KHQpLG49MDtuPHQ7KytuKWVbbl09bjtyZXR1cm4gcihlKSxlfSxlLnJpZ2h0UGFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU8PXQubGVuZ3RoP3Q6dCtcIiBcIi5yZXBlYXQoZS10Lmxlbmd0aCl9LGUucmVwZWF0ZWRUcnk9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1mdW5jdGlvbih0KXtyZXR1cm4gMH0pLG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4saSl7dmFyIG89MCxhPWZ1bmN0aW9uKCl7aWYodCgpKW4oKTtlbHNle3ZhciB1PWUoKytvKTtudWxsIT1yJiZvPj1yP2koKTpzZXRUaW1lb3V0KGEsdSl9fTthKCl9KX0sZS5pbmZlckZyb21JbXBsaWNpdFNoYXBlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTEsbj0tMSxpPTA7aTx0Lmxlbmd0aDsrK2kpaWYodFtpXT49MClyKj10W2ldO2Vsc2UgaWYoLTE9PT10W2ldKXtpZigtMSE9PW4pdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIEZvdW5kIC0xIGF0IGRpbSBcIituK1wiIGFuZCBkaW0gXCIraSk7bj1pfWVsc2UgaWYodFtpXTwwKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPCAwLiBGb3VuZCBcIit0W2ldK1wiIGF0IGRpbSBcIitpKTtpZigtMT09PW4pe2lmKGU+MCYmZSE9PXIpdGhyb3cgRXJyb3IoXCJTaXplKFwiK2UrXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIrdCk7cmV0dXJuIHR9aWYoMD09PXIpdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbXCIrdCtcIl0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c1wiKTtpZihlJXIhPTApdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gR290IFwiK2UrXCIgLyBcIityKTt2YXIgbz10LnNsaWNlKCk7cmV0dXJuIG9bbl09ZS9yLG99LGUucGFyc2VBeGlzUGFyYW09dSxlLnNxdWVlemVTaGFwZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1bXSxuPVtdLGk9bnVsbD09ZT9udWxsOnUoZSx0KS5zb3J0KCksbz0wLGE9MDthPHQubGVuZ3RoOysrYSl7aWYobnVsbCE9aSl7aWYoaVtvXT09PWEmJjEhPT10W2FdKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIithK1wiIHNpbmNlIGl0cyBkaW0gJ1wiK3RbYV0rXCInIGlzIG5vdCAxXCIpOyhudWxsPT1pW29dfHxpW29dPmEpJiYxPT09dFthXSYmKHIucHVzaCh0W2FdKSxuLnB1c2goYSkpLGlbb108PWEmJm8rK30xIT09dFthXSYmKHIucHVzaCh0W2FdKSxuLnB1c2goYSkpfXJldHVybntuZXdTaGFwZTpyLGtlcHREaW1zOm59fSxlLmdldFR5cGVkQXJyYXlGcm9tRFR5cGU9ZnVuY3Rpb24odCxlKXt2YXIgcj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dClyPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KXI9bmV3IEludDMyQXJyYXkoZSk7ZWxzZXtpZihcImJvb2xcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7cj1uZXcgVWludDhBcnJheShlKX1yZXR1cm4gcn0sZS5nZXRBcnJheUZyb21EVHlwZT1mdW5jdGlvbih0LGUpe3ZhciByPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KXI9bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpcj1uZXcgSW50MzJBcnJheShlKTtlbHNlIGlmKFwiYm9vbFwiPT09dClyPW5ldyBVaW50OEFycmF5KGUpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7cj1uZXcgQXJyYXkoZSl9cmV0dXJuIHJ9LGUuY2hlY2tDb21wdXRhdGlvbkZvckVycm9ycz1mdW5jdGlvbih0LGUscil7aWYoXCJmbG9hdDMyXCI9PT1lKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2lmKGlzTmFOKGkpfHwhaXNGaW5pdGUoaSkpdGhyb3cgRXJyb3IoXCJUaGUgcmVzdWx0IG9mIHRoZSAnXCIrcitcIicgaXMgXCIraStcIi5cIil9fSxlLmNoZWNrQ29udmVyc2lvbkZvckVycm9ycz1zLGUuaGFzRW5jb2RpbmdMb3NzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIShcImNvbXBsZXg2NFwiPT09ZXx8XCJmbG9hdDMyXCI9PT1lJiZcImNvbXBsZXg2NFwiIT09dHx8XCJpbnQzMlwiPT09ZSYmXCJmbG9hdDMyXCIhPT10JiZcImNvbXBsZXg2NFwiIT09dHx8XCJib29sXCI9PT1lJiZcImJvb2xcIj09PXQpfSxlLmlzVHlwZWRBcnJheT1jLGUuYnl0ZXNQZXJFbGVtZW50PWZ1bmN0aW9uKHQpe2lmKFwiZmxvYXQzMlwiPT09dHx8XCJpbnQzMlwiPT09dClyZXR1cm4gNDtpZihcImNvbXBsZXg2NFwiPT09dClyZXR1cm4gODtpZihcImJvb2xcIj09PXQpcmV0dXJuIDE7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIit0KX0sZS5ieXRlc0Zyb21TdHJpbmdBcnJheT1mdW5jdGlvbih0KXtpZihudWxsPT10KXJldHVybiAwO3ZhciBlPTA7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZSs9Mip0Lmxlbmd0aH0pLGV9LGUuaXNTdHJpbmc9bCxlLmlzQm9vbGVhbj1mLGUuaXNOdW1iZXI9aCxlLmluZmVyRHR5cGU9ZnVuY3Rpb24gdChlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT90KGVbMF0pOmUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/XCJmbG9hdDMyXCI6ZSBpbnN0YW5jZW9mIEludDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P1wiaW50MzJcIjpoKGUpP1wiZmxvYXQzMlwiOmwoZSk/XCJzdHJpbmdcIjpmKGUpP1wiYm9vbFwiOlwiZmxvYXQzMlwifSxlLmlzRnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuISEodCYmdC5jb25zdHJ1Y3RvciYmdC5jYWxsJiZ0LmFwcGx5KX0sZS5uZWFyZXN0RGl2aXNvcj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1lO3I8dDsrK3IpaWYodCVyPT0wKXJldHVybiByO3JldHVybiB0fSxlLmNvbXB1dGVTdHJpZGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU8MilyZXR1cm5bXTt2YXIgcj1uZXcgQXJyYXkoZS0xKTtyW2UtMl09dFtlLTFdO2Zvcih2YXIgbj1lLTM7bj49MDstLW4pcltuXT1yW24rMV0qdFtuKzFdO3JldHVybiByfSxlLnRvVHlwZWRBcnJheT1mdW5jdGlvbih0LGUscil7aWYoXCJzdHJpbmdcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgYSBzdHJpbmdbXSB0byBhIFR5cGVkQXJyYXlcIik7aWYoQXJyYXkuaXNBcnJheSh0KSYmKHQ9aSh0KSksciYmcyh0LGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkmJlwiZmxvYXQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXkmJlwiaW50MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZcImJvb2xcIj09PWV9KHQsZSkpcmV0dXJuIHQ7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpe2Zvcih2YXIgbj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksbz0wO288bi5sZW5ndGg7KytvKTAhPT1NYXRoLnJvdW5kKHRbb10pJiYobltvXT0xKTtyZXR1cm4gbn10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX0sZS50b05lc3RlZEFycmF5PWZ1bmN0aW9uKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlWzBdO3ZhciByPXQucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pO2lmKDA9PT1yKXJldHVybltdO2lmKHIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrdCtcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIGlucHV0IHNpemUuXCIpO3JldHVybiBmdW5jdGlvbiB0KGUscixuKXt2YXIgaT1uZXcgQXJyYXk7aWYoMT09PXIubGVuZ3RoKWZvcih2YXIgbz1yWzBdLGE9MDthPG87YSsrKWlbYV09bltlK2FdO2Vsc2V7bz1yWzBdO3ZhciB1PXIuc2xpY2UoMSkscz11LnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KTtmb3IoYT0wO2E8bzthKyspaVthXT10KGUrYSpzLHUsbil9cmV0dXJuIGl9KDAsdCxlKX0sZS5tYWtlT25lc1R5cGVkQXJyYXk9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9cCh0LGUpLG49MDtuPHIubGVuZ3RoO24rKylyW25dPTE7cmV0dXJuIHJ9LGUubWFrZVplcm9zVHlwZWRBcnJheT1wLGUubm93PWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHBlcmZvcm1hbmNlKXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2Vzcyl7dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lYXN1cmUgdGltZSBpbiB0aGlzIGVudmlyb25tZW50LiBZb3Ugc2hvdWxkIHJ1biB0Zi5qcyBpbiB0aGUgYnJvd3NlciBvciBpbiBOb2RlLmpzXCIpfSxlLmFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnM9ZnVuY3Rpb24odCl7dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe24oTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49MCxmdW5jdGlvbigpe3JldHVyblwiVGVuc29yIG11c3QgaGF2ZSBhIHNoYXBlIGNvbXByaXNlZCBvZiBwb3NpdGl2ZSBpbnRlZ2VycyBidXQgZ290IHNoYXBlIFtcIit0K1wiXS5cIn0pfSl9O3ZhciBkPWZ1bmN0aW9uKCl7aWYobnVsbCE9ZW52aXJvbm1lbnQuRU5WLmdsb2JhbC5mZXRjaClyZXR1cm4gZW52aXJvbm1lbnQuRU5WLmdsb2JhbC5mZXRjaDtpZihlbnZpcm9ubWVudC5FTlYuZ2V0KFwiSVNfTk9ERVwiKSlyZXR1cm4gZS5nZXROb2RlRmV0Y2guZmV0Y2hJbXBvcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgZmV0Y2goKSBtZXRob2QuIFBsZWFzZSBhZGQgeW91ciBvd24gZmV0Y2goKSBmdW5jdGlvbiB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cIil9O2UuZ2V0Tm9kZUZldGNoPXtmZXRjaEltcG9ydDpmdW5jdGlvbigpe3JldHVybiByZXF1aXJlKFwibm9kZS1mZXRjaFwiKX19LGUuZmV0Y2g9ZnVuY3Rpb24odCxyKXtyZXR1cm4gbnVsbD09ZS5zeXN0ZW1GZXRjaCYmKGUuc3lzdGVtRmV0Y2g9ZCgpKSxlLnN5c3RlbUZldGNoKHQscil9fSk7dW53cmFwRXhwb3J0cyh1dGlsJDEpO3ZhciB1dGlsXzE9dXRpbCQxLnNodWZmbGUsdXRpbF8yPXV0aWwkMS5jbGFtcCx1dGlsXzM9dXRpbCQxLm5lYXJlc3RMYXJnZXJFdmVuLHV0aWxfND11dGlsJDEuc3VtLHV0aWxfNT11dGlsJDEucmFuZFVuaWZvcm0sdXRpbF82PXV0aWwkMS5kaXN0U3F1YXJlZCx1dGlsXzc9dXRpbCQxLmFzc2VydCx1dGlsXzg9dXRpbCQxLmFzc2VydFNoYXBlc01hdGNoLHV0aWxfOT11dGlsJDEuYXNzZXJ0Tm9uTnVsbCx1dGlsXzEwPXV0aWwkMS5mbGF0dGVuLHV0aWxfMTE9dXRpbCQxLnNpemVGcm9tU2hhcGUsdXRpbF8xMj11dGlsJDEuaXNTY2FsYXJTaGFwZSx1dGlsXzEzPXV0aWwkMS5hcnJheXNFcXVhbCx1dGlsXzE0PXV0aWwkMS5pc0ludCx1dGlsXzE1PXV0aWwkMS50YW5oLHV0aWxfMTY9dXRpbCQxLnNpemVUb1NxdWFyaXNoU2hhcGUsdXRpbF8xNz11dGlsJDEuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzLHV0aWxfMTg9dXRpbCQxLnJpZ2h0UGFkLHV0aWxfMTk9dXRpbCQxLnJlcGVhdGVkVHJ5LHV0aWxfMjA9dXRpbCQxLmluZmVyRnJvbUltcGxpY2l0U2hhcGUsdXRpbF8yMT11dGlsJDEucGFyc2VBeGlzUGFyYW0sdXRpbF8yMj11dGlsJDEuc3F1ZWV6ZVNoYXBlLHV0aWxfMjM9dXRpbCQxLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUsdXRpbF8yND11dGlsJDEuZ2V0QXJyYXlGcm9tRFR5cGUsdXRpbF8yNT11dGlsJDEuY2hlY2tDb21wdXRhdGlvbkZvckVycm9ycyx1dGlsXzI2PXV0aWwkMS5jaGVja0NvbnZlcnNpb25Gb3JFcnJvcnMsdXRpbF8yNz11dGlsJDEuaGFzRW5jb2RpbmdMb3NzLHV0aWxfMjg9dXRpbCQxLmlzVHlwZWRBcnJheSx1dGlsXzI5PXV0aWwkMS5ieXRlc1BlckVsZW1lbnQsdXRpbF8zMD11dGlsJDEuYnl0ZXNGcm9tU3RyaW5nQXJyYXksdXRpbF8zMT11dGlsJDEuaXNTdHJpbmcsdXRpbF8zMj11dGlsJDEuaXNCb29sZWFuLHV0aWxfMzM9dXRpbCQxLmlzTnVtYmVyLHV0aWxfMzQ9dXRpbCQxLmluZmVyRHR5cGUsdXRpbF8zNT11dGlsJDEuaXNGdW5jdGlvbix1dGlsXzM2PXV0aWwkMS5uZWFyZXN0RGl2aXNvcix1dGlsXzM3PXV0aWwkMS5jb21wdXRlU3RyaWRlcyx1dGlsXzM4PXV0aWwkMS50b1R5cGVkQXJyYXksdXRpbF8zOT11dGlsJDEudG9OZXN0ZWRBcnJheSx1dGlsXzQwPXV0aWwkMS5tYWtlT25lc1R5cGVkQXJyYXksdXRpbF80MT11dGlsJDEubWFrZVplcm9zVHlwZWRBcnJheSx1dGlsXzQyPXV0aWwkMS5ub3csdXRpbF80Mz11dGlsJDEuYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucyx1dGlsXzQ0PXV0aWwkMS5nZXROb2RlRmV0Y2gsdXRpbF80NT11dGlsJDEuc3lzdGVtRmV0Y2gsdXRpbF80Nj11dGlsJDEuZmV0Y2gsV2ViY2FtSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztpZihuLndlYmNhbVZpZGVvRWxlbWVudD1lLG4ud2ViY2FtQ29uZmlnPXIsbi5pc0Nsb3NlZD0hMCxuLnJlc2l6ZT0hMSxuLm5lZWRUb1Jlc2l6ZSgpKWlmKG4ucmVzaXplPSEwLG4uY3JvcFNpemU9W24ud2ViY2FtQ29uZmlnLnJlc2l6ZUhlaWdodCxuLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aF0sbi5jcm9wQm94SW5kPXRlbnNvcjFkKFswXSxcImludDMyXCIpLG4ud2ViY2FtQ29uZmlnLmNlbnRlckNyb3Ape3ZhciBpPTEqbi53ZWJjYW1Db25maWcucmVzaXplV2lkdGgvbi53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGgsbz0xKm4ud2ViY2FtQ29uZmlnLnJlc2l6ZUhlaWdodC9uLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHQsYT0oMS1pKS8yLHU9KDEtbykvMixzPWEraSxjPW8rdTtuLmNyb3BCb3g9dGVuc29yMmQoW3UsYSxjLHNdLFsxLDRdKX1lbHNlIG4uY3JvcEJveD10ZW5zb3IyZChbMCwwLDEsMV0sWzEsNF0pO3JldHVybiBufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJ3ZWJjYW1cIn0sZS5jcmVhdGU9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOmlmKEVOVi5nZXQoXCJJU19OT0RFXCIpKXRocm93IG5ldyBFcnJvcihcInRmLmRhdGEud2ViY2FtIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuXCIpO2lmKCF0KXtpZih0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSwhci5yZXNpemVXaWR0aHx8IXIucmVzaXplSGVpZ2h0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHdlYmNhbSB2aWRlbyBlbGVtZW50LCBvciByZXNpemVXaWR0aCBhbmQgcmVzaXplSGVpZ2h0IHRvIGNyZWF0ZSBhIGhpZGRlbiB2aWRlbyBlbGVtZW50LlwiKTt0LndpZHRoPXIucmVzaXplV2lkdGgsdC5oZWlnaHQ9ci5yZXNpemVIZWlnaHR9cmV0dXJuWzQsKG49bmV3IGUodCxyKSkuc3RhcnQoKV07Y2FzZSAxOnJldHVybiBpLnNlbnQoKSxbMixuXX19KX0pfSxlLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDp0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlJiZ1dGlsXzcoXCJ1c2VyXCI9PT10aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlfHxcImVudmlyb25tZW50XCI9PT10aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIHdlYmNhbSBmYWNpbmcgbW9kZTogXCIrci53ZWJjYW1Db25maWcuZmFjaW5nTW9kZStcIi4gUGxlYXNlIHByb3ZpZGUgJ3VzZXInIG9yICdlbnZpcm9ubWVudCdcIn0pLG4ubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG4udHJ5cy5wdXNoKFsxLDMsLDRdKSx0PXRoaXMsWzQsbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOntkZXZpY2VJZDp0aGlzLndlYmNhbUNvbmZpZy5kZXZpY2VJZCxmYWNpbmdNb2RlOnRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGU/dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZTpcInVzZXJcIix3aWR0aDp0aGlzLndlYmNhbVZpZGVvRWxlbWVudC53aWR0aCxoZWlnaHQ6dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0fX0pXTtjYXNlIDI6cmV0dXJuIHQuc3RyZWFtPW4uc2VudCgpLFszLDRdO2Nhc2UgMzp0aHJvdyhlPW4uc2VudCgpKS5tZXNzYWdlPVwiRXJyb3IgdGhyb3duIHdoaWxlIGluaXRpYWxpemluZyB2aWRlbyBzdHJlYW06IFwiK2UubWVzc2FnZSxlO2Nhc2UgNDppZighdGhpcy5zdHJlYW0pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG9idGFpbiB2aWRlbyBmcm9tIHdlYmNhbS5cIik7dHJ5e3RoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyY09iamVjdD10aGlzLnN0cmVhbX1jYXRjaCh0KXtjb25zb2xlLmxvZyh0KSx0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmM9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5zdHJlYW0pfXJldHVybiB0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5wbGF5KCksdGhpcy5pc0Nsb3NlZD0hMSxbMixuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtyLndlYmNhbVZpZGVvRWxlbWVudC5vbmxvYWRlZG1ldGFkYXRhPWZ1bmN0aW9uKCl7dCgpfX0pXX19KX0pfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtpZih0aGlzLmlzQ2xvc2VkKXJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTt0cnl7dD1icm93c2VyLmZyb21QaXhlbHModGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkVycm9yIHRocm93biBjb252ZXJ0aW5nIHZpZGVvIHRvIHBpeGVsczogXCIrSlNPTi5zdHJpbmdpZnkodCkpfWlmKCF0aGlzLnJlc2l6ZSlyZXR1cm5bMix7dmFsdWU6dCxkb25lOiExfV07dHJ5e3JldHVyblsyLHt2YWx1ZTp0aGlzLmNyb3BBbmRSZXNpemVGcmFtZSh0KSxkb25lOiExfV19Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdGhyb3duIGNyb3BwaW5nIHRoZSB2aWRlbzogXCIrdC5tZXNzYWdlKX1yZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5uZWVkVG9SZXNpemU9ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aHx8IXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZUhlaWdodHx8dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGg9PT10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aCYmdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0PT09dGhpcy53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0KX0sZS5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZUZyYW1lPWZ1bmN0aW9uKHQpe3ZhciBlLHI9dC50b0Zsb2F0KCkuZXhwYW5kRGltcygwKSxuPShlPWltYWdlLmNyb3BBbmRSZXNpemUocix0aGlzLmNyb3BCb3gsdGhpcy5jcm9wQm94SW5kLHRoaXMuY3JvcFNpemUsXCJiaWxpbmVhclwiKSkuc2hhcGU7cmV0dXJuIGUucmVzaGFwZShuLnNsaWNlKDEpKX0sZS5wcm90b3R5cGUuY2FwdHVyZT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLm5leHQoKV07Y2FzZSAxOnJldHVyblsyLHQuc2VudCgpLnZhbHVlXX19KX0pfSxlLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdG9wKCl9KTt0cnl7dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjT2JqZWN0PW51bGx9Y2F0Y2godCl7Y29uc29sZS5sb2codCksdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjPW51bGx9dGhpcy5pc0Nsb3NlZD0hMH0sZS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSB2aWRlbyBzdHJlYW0gdG8gYXJyYXkuXCIpfSxlfShMYXp5SXRlcmF0b3IpLERhdGFTb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXt9fSgpLFN0cmluZ0l0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFNwbGl0SXRlcmF0b3IodGhpcyx0KX0sZX0oTGF6eUl0ZXJhdG9yKSxTcGxpdEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLmltcGw9bmV3IFNwbGl0SXRlcmF0b3JJbXBsKGUsciksbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmltcGwuc3VtbWFyeSgpfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLmltcGwubmV4dCgpXX0pfSl9LGV9KFN0cmluZ0l0ZXJhdG9yKSxTcGxpdEl0ZXJhdG9ySW1wbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5zZXBhcmF0b3I9cixuLmNhcnJ5b3Zlcj1cIlwiLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gU3BsaXQoJ1wiK3RoaXMuc2VwYXJhdG9yK1wiJylcIn0sZS5wcm90b3R5cGUucHVtcD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6aWYoKHQ9by5zZW50KCkpLmRvbmUpcmV0dXJuXCJcIj09PXRoaXMuY2FycnlvdmVyP1syLCExXToodGhpcy5vdXRwdXRRdWV1ZS5wdXNoKHRoaXMuY2FycnlvdmVyKSx0aGlzLmNhcnJ5b3Zlcj1cIlwiLFsyLCEwXSk7Zm9yKChlPXQudmFsdWUuc3BsaXQodGhpcy5zZXBhcmF0b3IpKVswXT10aGlzLmNhcnJ5b3ZlcitlWzBdLHI9MCxuPWUuc2xpY2UoMCwtMSk7cjxuLmxlbmd0aDtyKyspaT1uW3JdLHRoaXMub3V0cHV0UXVldWUucHVzaChpKTtyZXR1cm4gdGhpcy5jYXJyeW92ZXI9ZVtlLmxlbmd0aC0xXSxbMiwhMF19fSl9KX0sZX0oT25lVG9NYW55SXRlcmF0b3IpLEJ5dGVDaHVua0l0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5kZWNvZGVVVEY4PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBVdGY4SXRlcmF0b3IodGhpcyl9LGV9KExhenlJdGVyYXRvciksVXRmOEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLnVwc3RyZWFtPWUsci5pbXBsPW5ldyBVdGY4SXRlcmF0b3JJbXBsKGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbXBsLnN1bW1hcnkoKX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5pbXBsLm5leHQoKV19KX0pfSxlfShTdHJpbmdJdGVyYXRvciksVXRmOEl0ZXJhdG9ySW1wbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztpZihyLnVwc3RyZWFtPWUsRU5WLmdldChcIklTX0JST1dTRVJcIikpci5kZWNvZGVyPW5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO2Vsc2V7dmFyIG49cmVxdWlyZShcInN0cmluZ19kZWNvZGVyXCIpLlN0cmluZ0RlY29kZXI7ci5kZWNvZGVyPW5ldyBuKFwidXRmOFwiKX1yZXR1cm4gcn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBVdGY4XCJ9LGUucHJvdG90eXBlLnB1bXA9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6cmV0dXJuKHQ9bi5zZW50KCkpLmRvbmU/WzIsITFdOihlPXQudmFsdWUscj1FTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKT90aGlzLmRlY29kZXIuZGVjb2RlKGUse3N0cmVhbTohMH0pOnRoaXMuZGVjb2Rlci53cml0ZShCdWZmZXIuZnJvbShlLmJ1ZmZlcikpLHRoaXMub3V0cHV0UXVldWUucHVzaChyKSxbMiwhMF0pfX0pfSl9LGV9KE9uZVRvTWFueUl0ZXJhdG9yKSxGaWxlQ2h1bmtJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dm9pZCAwPT09ciYmKHI9e30pO3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5maWxlPWUsbi5vcHRpb25zPXIsdXRpbC5hc3NlcnQoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fCEhRU5WLmdldChcIklTX0JST1dTRVJcIikmJihlIGluc3RhbmNlb2YgRmlsZXx8ZSBpbnN0YW5jZW9mIEJsb2IpLGZ1bmN0aW9uKCl7cmV0dXJuXCJGaWxlQ2h1bmtJdGVyYXRvciBvbmx5IHN1cHBvcnRzIEZpbGUsIEJsb2IgYW5kIFVpbnQ4QXJyYXkgcmlnaHQgbm93LlwifSksbi5vZmZzZXQ9ci5vZmZzZXR8fDAsbi5jaHVua1NpemU9ci5jaHVua1NpemV8fDEwNDg1NzYsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwiRmlsZUNodW5rcyBcIit0aGlzLmZpbGV9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscj10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMub2Zmc2V0Pj0odGhpcy5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheT90aGlzLmZpbGUuYnl0ZUxlbmd0aDp0aGlzLmZpbGUuc2l6ZSk/WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dOih0PW5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsZSl7dmFyIG49ci5vZmZzZXQrci5jaHVua1NpemU7aWYoci5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheSl0KG5ldyBVaW50OEFycmF5KHIuZmlsZS5zbGljZShyLm9mZnNldCxuKSkpO2Vsc2V7dmFyIGk9bmV3IEZpbGVSZWFkZXI7aS5vbmxvYWQ9ZnVuY3Rpb24ocil7dmFyIG49aS5yZXN1bHQ7aWYobiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYobj1uZXcgVWludDhBcnJheShuKSksIShuIGluc3RhbmNlb2YgVWludDhBcnJheSkpcmV0dXJuIGUobmV3IFR5cGVFcnJvcihcIkZpbGVSZWFkZXIgcmV0dXJuZWQgdW5rbm93biB0eXBlLlwiKSk7dChuKX0saS5vbmFib3J0PWZ1bmN0aW9uKHQpe3JldHVybiBlKG5ldyBFcnJvcihcIkFib3J0ZWRcIikpfSxpLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGUobmV3IEVycm9yKHQudHlwZSkpfTt2YXIgbz1yLmZpbGUuc2xpY2Uoci5vZmZzZXQsbik7aS5yZWFkQXNBcnJheUJ1ZmZlcihvKX1yLm9mZnNldD1ufSksZT17fSxbNCx0XSk7Y2FzZSAxOnJldHVyblsyLChlLnZhbHVlPW4uc2VudCgpLGUuZG9uZT0hMSxlKV19fSl9KX0sZX0oQnl0ZUNodW5rSXRlcmF0b3IpO2Z1bmN0aW9uIHVybENodW5rSXRlcmF0b3IodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLGksbztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOnJldHVybiBFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKT9bNCxmZXRjaCh0KV06WzMsNV07Y2FzZSAxOnJldHVybihyPWEuc2VudCgpKS5vaz9bNCxyLmJsb2IoKV06WzMsM107Y2FzZSAyOnJldHVybiBuPWEuc2VudCgpLFsyLG5ldyBGaWxlQ2h1bmtJdGVyYXRvcihuLGUpXTtjYXNlIDM6dGhyb3cgbmV3IEVycm9yKHIuc3RhdHVzVGV4dCk7Y2FzZSA0OnJldHVyblszLDldO2Nhc2UgNTppZihpPXJlcXVpcmUoXCJub2RlLWZldGNoXCIpLFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIlVSTCBtdXN0IGJlIGEgc3RyaW5nLiBSZXF1ZXN0IG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIG5vZGUuanMgZW52aXJvbm1lbnQgeWV0LlwiKTtyZXR1cm5bNCxpKHQpXTtjYXNlIDY6cmV0dXJuKHI9YS5zZW50KCkpLm9rP1s0LHIuYnVmZmVyKCldOlszLDhdO2Nhc2UgNzpyZXR1cm4gbz1hLnNlbnQoKSxbMixuZXcgRmlsZUNodW5rSXRlcmF0b3IobyxlKV07Y2FzZSA4OnRocm93IG5ldyBFcnJvcihyLnN0YXR1c1RleHQpO2Nhc2UgOTpyZXR1cm5bMl19fSl9KX1mdW5jdGlvbiBpc0xvY2FsUGF0aCh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmXCJmaWxlOi8vXCI9PT10LnN1YnN0cigwLDcpfXZhciBGaWxlRGF0YVNvdXJjZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dm9pZCAwPT09ciYmKHI9e30pO3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5pbnB1dD1lLG4ub3B0aW9ucz1yLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gaXNMb2NhbFBhdGgodGhpcy5pbnB1dCkmJkVOVi5nZXQoXCJJU19OT0RFXCIpJiYodD1yZXF1aXJlKFwiZnNcIiksdGhpcy5pbnB1dD10LnJlYWRGaWxlU3luYyh0aGlzLmlucHV0LnN1YnN0cig3KSkpLFsyLG5ldyBGaWxlQ2h1bmtJdGVyYXRvcih0aGlzLmlucHV0LHRoaXMub3B0aW9ucyldfSl9KX0sZX0oRGF0YVNvdXJjZSksVVJMRGF0YVNvdXJjZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dm9pZCAwPT09ciYmKHI9e30pO3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cmw9ZSxuLmZpbGVPcHRpb25zPXIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBpc0xvY2FsUGF0aCh0aGlzLnVybCk/WzIsbmV3IEZpbGVEYXRhU291cmNlKHRoaXMudXJsLHRoaXMuZmlsZU9wdGlvbnMpLml0ZXJhdG9yKCldOlsyLHVybENodW5rSXRlcmF0b3IodGhpcy51cmwsdGhpcy5maWxlT3B0aW9ucyldfSl9KX0sZX0oRGF0YVNvdXJjZSk7ZnVuY3Rpb24gY3N2KHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxuZXcgQ1NWRGF0YXNldChuZXcgVVJMRGF0YVNvdXJjZSh0KSxlKX1mdW5jdGlvbiBmdW5jKHQpe3ZhciBlPXRoaXMscj1pdGVyYXRvckZyb21GdW5jdGlvbih0KTtyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm5bMixyXX0pfSl9KX1mdW5jdGlvbiBnZW5lcmF0b3IodCl7dmFyIGU9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHQoKV07Y2FzZSAxOnJldHVybiBlPXIuc2VudCgpLFsyLGl0ZXJhdG9yRnJvbUZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGUubmV4dCgpfSldfX0pfSl9KX1mdW5jdGlvbiB3ZWJjYW0odCxlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3JldHVyblsyLFdlYmNhbUl0ZXJhdG9yLmNyZWF0ZSh0LGUpXX0pfSl9dmFyIHZlcnNpb249XCIxLjEuMlwiO2V4cG9ydHthcnJheSxEYXRhc2V0LHppcCxDU1ZEYXRhc2V0LFRleHRMaW5lRGF0YXNldCxjc3YsZnVuYyxnZW5lcmF0b3Isd2ViY2FtLEZpbGVEYXRhU291cmNlLFVSTERhdGFTb3VyY2UsdmVyc2lvbiBhcyB2ZXJzaW9uX2RhdGF9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtZGF0YS5lc20uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnR7YmFja2VuZCx1dGlsLHRpZHksb25lc0xpa2Usc2NhbGFyLHRlbnNvcjFkLHdoZXJlLHplcm9zTGlrZSx0cmFpbixjYXN0LGRpc3Bvc2UsbWVtb3J5LHNlcmlhbGl6YXRpb24sYWRkLG11bCxkaXYsa2VlcCxuZXh0RnJhbWUsVGVuc29yLE9wdGltaXplcixjb25jYXQsbWVhbixpbyx0cmFuc3Bvc2UsZXhwYW5kRGltcyxyZXZlcnNlLHVuc3RhY2ssc3RhY2ssemVyb3Msc3VtLHNwbGl0LG5lZyx2YXJpYWJsZSxvbmVzLGV5ZSxyYW5kb21Vbmlmb3JtLHRydW5jYXRlZE5vcm1hbCxyYW5kb21Ob3JtYWwsc3ViLHNxcnQsbXVsU3RyaWN0LGNsaXBCeVZhbHVlLHJlbHUsbGluYWxnLGxlYWt5UmVsdSxwcmVsdSxlbHUsY29udjFkLGNvbnYyZCxjb252M2QsY29udjJkVHJhbnNwb3NlLHNlcGFyYWJsZUNvbnYyZCxkZXB0aHdpc2VDb252MmQsYW55LG5vdEVxdWFsLGxvZ2ljYWxBbmQsbWF4aW11bSxtaW5pbXVtLGFsbCxiYXRjaE5vcm0yZCxiYXRjaE5vcm0zZCxiYXRjaE5vcm00ZCxtb21lbnRzLHBhZCxtYXhQb29sLGF2Z1Bvb2wsc3F1ZWV6ZSxtYXgsZ3JlYXRlckVxdWFsLGZpbGwsYWJzLGxvZyxzb2Z0cGx1cyxzb2Z0bWF4LGZsb29yLG9uZUhvdCxncmVhdGVyLGVxdWFsLGFyZ01heCxzbGljZTFkLHNsaWNlMmQsc2xpY2UzZCxzbGljZTRkLGNvbmNhdDFkLGNvbmNhdDJkLGNvbmNhdDNkLGNvbmNhdDRkLHRpbGUsZnVzZWQsZ2F0aGVyLHN0ZXAsbWluLHNlbHUsc2lnbW9pZCx0YW5ofWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO3ZhciBleHRlbmRTdGF0aWNzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKGV4dGVuZFN0YXRpY3M9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmKGVbbl09dFtuXSl9KShlLHQpfTtmdW5jdGlvbiBfX2V4dGVuZHMoZSx0KXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWV4dGVuZFN0YXRpY3MoZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihuLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgbil9dmFyIF9lcHNpbG9uLF9fYXNzaWduPWZ1bmN0aW9uKCl7cmV0dXJuKF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gX19hd2FpdGVyKGUsdCxuLHIpe3JldHVybiBuZXcobnx8KG49UHJvbWlzZSkpKGZ1bmN0aW9uKGksYSl7ZnVuY3Rpb24gbyhlKXt0cnl7bChyLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIHMoZSl7dHJ5e2woci50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gbChlKXtlLmRvbmU/aShlLnZhbHVlKTpuZXcgbihmdW5jdGlvbih0KXt0KGUudmFsdWUpfSkudGhlbihvLHMpfWwoKHI9ci5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKGUsdCl7dmFyIG4scixpLGEsbz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gYT17bmV4dDpzKDApLHRocm93OnMoMSkscmV0dXJuOnMoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGFbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksYTtmdW5jdGlvbiBzKGEpe3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm4gZnVuY3Rpb24oYSl7aWYobil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO287KXRyeXtpZihuPTEsciYmKGk9MiZhWzBdP3IucmV0dXJuOmFbMF0/ci50aHJvd3x8KChpPXIucmV0dXJuKSYmaS5jYWxsKHIpLDApOnIubmV4dCkmJiEoaT1pLmNhbGwocixhWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gocj0wLGkmJihhPVsyJmFbMF0saS52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6aT1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gby5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTpvLmxhYmVsKysscj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPW8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1vLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1hWzBdfHwyPT09YVswXSkpe289MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFpfHxhWzFdPmlbMF0mJmFbMV08aVszXSkpe28ubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmby5sYWJlbDxpWzFdKXtvLmxhYmVsPWlbMV0saT1hO2JyZWFrfWlmKGkmJm8ubGFiZWw8aVsyXSl7by5sYWJlbD1pWzJdLG8ub3BzLnB1c2goYSk7YnJlYWt9aVsyXSYmby5vcHMucG9wKCksby50cnlzLnBvcCgpO2NvbnRpbnVlfWE9dC5jYWxsKGUsbyl9Y2F0Y2goZSl7YT1bNixlXSxyPTB9ZmluYWxseXtuPWk9MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2Esc10pfX19ZnVuY3Rpb24gZXBzaWxvbigpe3JldHVybiBudWxsPT1fZXBzaWxvbiYmKF9lcHNpbG9uPWJhY2tlbmQoKS5lcHNpbG9uKCkpLF9lcHNpbG9ufWZ1bmN0aW9uIGltYWdlRGF0YUZvcm1hdCgpe3JldHVyblwiY2hhbm5lbHNMYXN0XCJ9dmFyIEF0dHJpYnV0ZUVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksUnVudGltZUVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksVmFsdWVFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLE5vdEltcGxlbWVudGVkRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxBc3NlcnRpb25FcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLEluZGV4RXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKTtmdW5jdGlvbiBweUxpc3RSZXBlYXQoZSx0KXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIG49W10scj0wO3I8dDtyKyspbj1uLmNvbmNhdChlKTtyZXR1cm4gbn1yZXR1cm4obj1uZXcgQXJyYXkodCkpLmZpbGwoZSksbn1mdW5jdGlvbiBhc3NlcnQoZSx0KXtpZighZSl0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IodCl9ZnVuY3Rpb24gY291bnQoZSx0KXtmb3IodmFyIG49MCxyPTAsaT1lO3I8aS5sZW5ndGg7cisrKXtpW3JdPT09dCYmbisrfXJldHVybiBufWZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXkoZSl7cmV0dXJuIDE9PT1lLmxlbmd0aD9lWzBdOmV9ZnVuY3Rpb24gdG9MaXN0KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2U6W2VdfWZ1bmN0aW9uIHRvU25ha2VDYXNlKGUpe3ZhciB0PWUucmVwbGFjZSgvKC4pKFtBLVpdW2EtejAtOV0rKS9nLFwiJDFfJDJcIikucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJfXCIhPT10WzBdP3Q6XCJwcml2YXRlXCIrdH1mdW5jdGlvbiB0b0NhbWVsQ2FzZShlKXtyZXR1cm4gZS5sZW5ndGg8PTE/ZTotMT09PWUuaW5kZXhPZihcIl9cIik/ZTplLnJlcGxhY2UoL1tfXSsoXFx3fCQpL2csZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSl9dmFyIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9e307ZnVuY3Rpb24gc2VyaWFsaXplS2VyYXNPYmplY3QoZSl7aWYobnVsbD09PWV8fHZvaWQgMD09PWUpcmV0dXJuIG51bGw7dmFyIHQ9e307cmV0dXJuIHQuY2xhc3NOYW1lPWUuZ2V0Q2xhc3NOYW1lKCksdC5jb25maWc9ZS5nZXRDb25maWcoKSx0fWZ1bmN0aW9uIGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGUpe2lmKG51bGwhPWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBjb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhlKX0pO2Vsc2UgZm9yKHZhciB0PTAsbj1PYmplY3Qua2V5cyhlKTt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XSxpPWVbcl07bnVsbCE9aSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihBcnJheS5pc0FycmF5KGkpfHxcIm5kYXJyYXlcIiE9PWkudHlwZXx8XCJudW1iZXJcIiE9dHlwZW9mIGkudmFsdWU/Y29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoaSk6ZVtyXT1pLnZhbHVlKX19ZnVuY3Rpb24gZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHQsbixyLGkpe3ZhciBhLG8scztpZih2b2lkIDA9PT10JiYodD17fSksdm9pZCAwPT09biYmKG49e30pLHZvaWQgMD09PXImJihyPVwib2JqZWN0XCIpLHZvaWQgMD09PWkmJihpPSExKSxcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIGw9ZSx1PXZvaWQgMDtpZihsIGluIG4pdT1uW2xdO2Vsc2UgaWYobCBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKXU9X0dMT0JBTF9DVVNUT01fT0JKRUNUU1tsXTtlbHNlIGlmKG51bGw9PSh1PXRbbF0pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBcIityK1wiOiBcIitlK1wiLiBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBUaGUgXCIrcitcIiBpcyBkZWZpbmVkIGluIFB5dGhvbiwgaW4gd2hpY2ggY2FzZSBpdCBuZWVkcyB0byBiZSBwb3J0ZWQgdG8gVGVuc29yRmxvdy5qcyBvciB5b3VyIEphdmFTY3JpcHQgY29kZS5cXG4yLiBUaGUgY3VzdG9tIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBKYXZhU2NyaXB0LCBidXQgaXMgbm90IHJlZ2lzdGVyZWQgcHJvcGVybHkgd2l0aCB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5cIik7cmV0dXJuIHV9dmFyIGM9ZTtpZihudWxsPT1jLmNsYXNzTmFtZXx8bnVsbD09Yy5jb25maWcpdGhyb3cgbmV3IFZhbHVlRXJyb3IocitcIjogSW1wcm9wZXIgY29uZmlnIGZvcm1hdDogXCIrSlNPTi5zdHJpbmdpZnkoYykrXCIuXFxuJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LlwiKTt2YXIgcD1jLmNsYXNzTmFtZSxoPXZvaWQgMCxkPXZvaWQgMDtpZihwIGluIG4/KGg9KGE9bltwXSlbMF0sZD1hWzFdKTpwIGluIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM/KGg9KG89X0dMT0JBTF9DVVNUT01fT0JKRUNUUy5jbGFzc05hbWUpWzBdLGQ9b1sxXSk6cCBpbiB0JiYoaD0ocz10W3BdKVswXSxkPXNbMV0pLG51bGw9PWgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIFwiK3IrXCI6IFwiK3ArXCIuIFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFRoZSBcIityK1wiIGlzIGRlZmluZWQgaW4gUHl0aG9uLCBpbiB3aGljaCBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBjb2RlLlxcbjIuIFRoZSBjdXN0b20gXCIrcitcIiBpcyBkZWZpbmVkIGluIEphdmFTY3JpcHQsIGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIHRmLnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcygpLlwiKTtpZihudWxsIT1kKXtmb3IodmFyIGY9e30sZz0wLG09T2JqZWN0LmtleXMoX0dMT0JBTF9DVVNUT01fT0JKRUNUUyk7ZzxtLmxlbmd0aDtnKyspe2ZbUz1tW2ddXT1fR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW1NdfWZvcih2YXIgeT0wLHY9T2JqZWN0LmtleXMobik7eTx2Lmxlbmd0aDt5Kyspe2ZbUz12W3ldXT1uW1NdfWMuY29uZmlnLmN1c3RvbU9iamVjdHM9Zjtmb3IodmFyIGI9X19hc3NpZ24oe30sX0dMT0JBTF9DVVNUT01fT0JKRUNUUyksdz0wLHo9T2JqZWN0LmtleXMobik7dzx6Lmxlbmd0aDt3Kyspe3ZhciBTPXpbd107X0dMT0JBTF9DVVNUT01fT0JKRUNUU1tTXT1uW1NdfWNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGMuY29uZmlnKTt2YXIgST1kKGgsYy5jb25maWcsbixpKTtyZXR1cm4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz1fX2Fzc2lnbih7fSxiKSxJfWI9X19hc3NpZ24oe30sX0dMT0JBTF9DVVNUT01fT0JKRUNUUyk7Zm9yKHZhciBBPTAsXz1PYmplY3Qua2V5cyhuKTtBPF8ubGVuZ3RoO0ErKyl7Uz1fW0FdO19HTE9CQUxfQ1VTVE9NX09CSkVDVFNbU109bltTXX1JPW5ldyBoKGMuY29uZmlnKTtyZXR1cm4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz1fX2Fzc2lnbih7fSxiKSxJfWZ1bmN0aW9uIG51bWJlckNvbXBhcmUoZSx0KXtyZXR1cm4gZTx0Py0xOmU+dD8xOjB9ZnVuY3Rpb24gcmV2ZXJzZU51bWJlckNvbXBhcmUoZSx0KXtyZXR1cm4tMSpudW1iZXJDb21wYXJlKGUsdCl9ZnVuY3Rpb24gdW5pcXVlKGUpe2lmKG51bGw9PWUpcmV0dXJuIGU7Zm9yKHZhciB0PVtdLG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07LTE9PT10LmluZGV4T2YoaSkmJnQucHVzaChpKX1yZXR1cm4gdH1mdW5jdGlvbiBpc09iamVjdEVtcHR5KGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGluIG9iajogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO2Zvcih2YXIgdCBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkodCkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShlLHQsbil7aWYobnVsbCE9biYmZS5pbmRleE9mKG4pPDApdGhyb3cgbmV3IFZhbHVlRXJyb3IobitcIiBpcyBub3QgYSB2YWxpZCBcIit0K1wiLiAgVmFsaWQgdmFsdWVzIGFyZSBcIitlK1wiIG9yIG51bGwvdW5kZWZpbmVkLlwiKX1mdW5jdGlvbiBjaGVja0FycmF5VHlwZUFuZExlbmd0aChlLHQsbixyKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09ciYmKHI9MS8wKSxhc3NlcnQobj49MCksYXNzZXJ0KHI+PW4pLEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPj1uJiZlLmxlbmd0aDw9ciYmZS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PT10fSl9ZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGUsdCl7QXJyYXkuaXNBcnJheShlKT8odXRpbC5hc3NlcnQoZS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVybiB0K1wiIGlzIHVuZXhwZWN0ZWRseSBhbiBlbXB0eSBhcnJheS5cIn0pLGUuZm9yRWFjaChmdW5jdGlvbihlLG4pe3JldHVybiBhc3NlcnRQb3NpdGl2ZUludGVnZXIoZSxcImVsZW1lbnQgXCIrKG4rMSkrXCIgb2YgXCIrdCl9KSk6dXRpbC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCBcIit0K1wiIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKGUpK1wiLlwifSl9ZnVuY3Rpb24gZm9ybWF0QXNGcmllbmRseVN0cmluZyhlKXtyZXR1cm4gbnVsbD09PWU/XCJudWxsXCI6QXJyYXkuaXNBcnJheShlKT9cIltcIitlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZm9ybWF0QXNGcmllbmRseVN0cmluZyhlKX0pLmpvaW4oXCIsXCIpK1wiXVwiOlwic3RyaW5nXCI9PXR5cGVvZiBlPydcIicrZSsnXCInOlwiXCIrZX1mdW5jdGlvbiBkZWJvdW5jZShlLHQpe3ZhciBuLHI9dXRpbC5ub3coKTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGk9W10sYT0wO2E8YXJndW1lbnRzLmxlbmd0aDthKyspaVthXT1hcmd1bWVudHNbYV07dmFyIG89dXRpbC5ub3coKTtyZXR1cm4gby1yPHQ/bjoocj1vLG49ZS5hcHBseSh2b2lkIDAsaSkpfX1mdW5jdGlvbiBjYWxjTDJOb3JtcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHNxcnQoc3VtKG11bFN0cmljdChlLGUpLHQsITApKX0pfXZhciBDb25zdHJhaW50PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLE1heE5vcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZGVmYXVsdE1heFZhbHVlPTIsbi5kZWZhdWx0QXhpcz0wLG4ubWF4VmFsdWU9bnVsbCE9dC5tYXhWYWx1ZT90Lm1heFZhbHVlOm4uZGVmYXVsdE1heFZhbHVlLG4uYXhpcz1udWxsIT10LmF4aXM/dC5heGlzOm4uZGVmYXVsdEF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWNhbGNMMk5vcm1zKGUsdC5heGlzKSxyPWNsaXBCeVZhbHVlKG4sMCx0Lm1heFZhbHVlKTtyZXR1cm4gbXVsKGUsZGl2KHIsYWRkKGVwc2lsb24oKSxuKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttYXhWYWx1ZTp0aGlzLm1heFZhbHVlLGF4aXM6dGhpcy5heGlzfX0sdC5jbGFzc05hbWU9XCJNYXhOb3JtXCIsdH0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heE5vcm0pO3ZhciBVbml0Tm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5kZWZhdWx0QXhpcz0wLG4uYXhpcz1udWxsIT10LmF4aXM/dC5heGlzOm4uZGVmYXVsdEF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBkaXYoZSxhZGQoZXBzaWxvbigpLGNhbGNMMk5vcm1zKGUsdC5heGlzKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntheGlzOnRoaXMuYXhpc319LHQuY2xhc3NOYW1lPVwiVW5pdE5vcm1cIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVW5pdE5vcm0pO3ZhciBOb25OZWc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiByZWx1KGUpfSx0LmNsYXNzTmFtZT1cIk5vbk5lZ1wiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhOb25OZWcpO3ZhciBNaW5NYXhOb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmRlZmF1bHRNaW5WYWx1ZT0wLG4uZGVmYXVsdE1heFZhbHVlPTEsbi5kZWZhdWx0UmF0ZT0xLG4uZGVmYXVsdEF4aXM9MCxuLm1pblZhbHVlPW51bGwhPXQubWluVmFsdWU/dC5taW5WYWx1ZTpuLmRlZmF1bHRNaW5WYWx1ZSxuLm1heFZhbHVlPW51bGwhPXQubWF4VmFsdWU/dC5tYXhWYWx1ZTpuLmRlZmF1bHRNYXhWYWx1ZSxuLnJhdGU9bnVsbCE9dC5yYXRlP3QucmF0ZTpuLmRlZmF1bHRSYXRlLG4uYXhpcz1udWxsIT10LmF4aXM/dC5heGlzOm4uZGVmYXVsdEF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWNhbGNMMk5vcm1zKGUsdC5heGlzKSxyPWFkZChtdWwodC5yYXRlLGNsaXBCeVZhbHVlKG4sdC5taW5WYWx1ZSx0Lm1heFZhbHVlKSksbXVsKDEtdC5yYXRlLG4pKTtyZXR1cm4gbXVsKGUsZGl2KHIsYWRkKGVwc2lsb24oKSxuKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttaW5WYWx1ZTp0aGlzLm1pblZhbHVlLG1heFZhbHVlOnRoaXMubWF4VmFsdWUscmF0ZTp0aGlzLnJhdGUsYXhpczp0aGlzLmF4aXN9fSx0LmNsYXNzTmFtZT1cIk1pbk1heE5vcm1cIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWluTWF4Tm9ybSk7dmFyIENPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQPXttYXhOb3JtOlwiTWF4Tm9ybVwiLG1pbk1heE5vcm06XCJNaW5NYXhOb3JtXCIsbm9uTmVnOlwiTm9uTmVnXCIsdW5pdE5vcm06XCJVbml0Tm9ybVwifTtmdW5jdGlvbiBzZXJpYWxpemVDb25zdHJhaW50KGUpe3JldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChlKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJjb25zdHJhaW50XCIpfWZ1bmN0aW9uIGdldENvbnN0cmFpbnQoZSl7cmV0dXJuIG51bGw9PWU/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZT9kZXNlcmlhbGl6ZUNvbnN0cmFpbnQoe2NsYXNzTmFtZTplIGluIENPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQP0NPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2VdOmUsY29uZmlnOnt9fSk6ZSBpbnN0YW5jZW9mIENvbnN0cmFpbnQ/ZTpkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoZSl9ZnVuY3Rpb24gbWF4Tm9ybShlKXtyZXR1cm4gbmV3IE1heE5vcm0oZSl9ZnVuY3Rpb24gdW5pdE5vcm0oZSl7cmV0dXJuIG5ldyBVbml0Tm9ybShlKX1mdW5jdGlvbiBub25OZWcoKXtyZXR1cm4gbmV3IE5vbk5lZ31mdW5jdGlvbiBtaW5NYXhOb3JtKGUpe3JldHVybiBuZXcgTWluTWF4Tm9ybShlKX12YXIgZXhwb3J0c19jb25zdHJhaW50cz1PYmplY3QuZnJlZXplKHttYXhOb3JtOm1heE5vcm0sdW5pdE5vcm06dW5pdE5vcm0sbm9uTmVnOm5vbk5lZyxtaW5NYXhOb3JtOm1pbk1heE5vcm19KSxWQUxJRF9EQVRBX0ZPUk1BVF9WQUxVRVM9W1wiY2hhbm5lbHNGaXJzdFwiLFwiY2hhbm5lbHNMYXN0XCJdLFZBTElEX1BBRERJTkdfTU9ERV9WQUxVRVM9W1widmFsaWRcIixcInNhbWVcIixcImNhdXNhbFwiXSxWQUxJRF9QT09MX01PREVfVkFMVUVTPVtcIm1heFwiLFwiYXZnXCJdLFZBTElEX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERVM9W1wic3VtXCIsXCJtdWxcIixcImNvbmNhdFwiLFwiYXZlXCJdLG5hbWVNYXA9bmV3IE1hcDtmdW5jdGlvbiBjaGVja0RhdGFGb3JtYXQoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9EQVRBX0ZPUk1BVF9WQUxVRVMsXCJEYXRhRm9ybWF0XCIsZSl9ZnVuY3Rpb24gY2hlY2tQYWRkaW5nTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX1BBRERJTkdfTU9ERV9WQUxVRVMsXCJQYWRkaW5nTW9kZVwiLGUpfWZ1bmN0aW9uIGNoZWNrUG9vbE1vZGUoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9QT09MX01PREVfVkFMVUVTLFwiUG9vbE1vZGVcIixlKX12YXIgX25hbWVTY29wZVN0YWNrPVtdLF9uYW1lU2NvcGVEaXZpZGVyPVwiL1wiO2Z1bmN0aW9uIG5hbWVTY29wZShlLHQpe19uYW1lU2NvcGVTdGFjay5wdXNoKGUpO3RyeXt2YXIgbj10KCk7cmV0dXJuIF9uYW1lU2NvcGVTdGFjay5wb3AoKSxufWNhdGNoKGUpe3Rocm93IF9uYW1lU2NvcGVTdGFjay5wb3AoKSxlfX1mdW5jdGlvbiBjdXJyZW50TmFtZVNjb3BlUHJlZml4KCl7cmV0dXJuIDA9PT1fbmFtZVNjb3BlU3RhY2subGVuZ3RoP1wiXCI6X25hbWVTY29wZVN0YWNrLmpvaW4oX25hbWVTY29wZURpdmlkZXIpK19uYW1lU2NvcGVEaXZpZGVyfWZ1bmN0aW9uIGdldFNjb3BlZFRlbnNvck5hbWUoZSl7aWYoIWlzVmFsaWRUZW5zb3JOYW1lKGUpKXRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIHRlbnNvciBuYW1lOiAnXCIrZStcIidcIik7cmV0dXJuIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKStlfWZ1bmN0aW9uIGdldFVuaXF1ZVRlbnNvck5hbWUoZSl7aWYoIWlzVmFsaWRUZW5zb3JOYW1lKGUpKXRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIHRlbnNvciBuYW1lOiAnXCIrZStcIidcIik7bmFtZU1hcC5oYXMoZSl8fG5hbWVNYXAuc2V0KGUsMCk7dmFyIHQ9bmFtZU1hcC5nZXQoZSk7aWYobmFtZU1hcC5zZXQoZSxuYW1lTWFwLmdldChlKSsxKSx0PjApe3ZhciBuPWUrXCJfXCIrdDtyZXR1cm4gbmFtZU1hcC5zZXQobiwxKSxufXJldHVybiBlfXZhciB0ZW5zb3JOYW1lUmVnZXg9bmV3IFJlZ0V4cCgvXltBLVphLXpdWy1BLVphLXowLTlcXC5fXFwvXSokLyk7ZnVuY3Rpb24gaXNWYWxpZFRlbnNvck5hbWUoZSl7cmV0dXJuISFlLm1hdGNoKHRlbnNvck5hbWVSZWdleCl9ZnVuY3Rpb24gaXNJbnRlZ2VyKGUpe3JldHVybiBlPT09cGFyc2VJbnQoZS50b1N0cmluZygpLDEwKX1mdW5jdGlvbiBhcnJheVByb2QoZSx0LG4pe251bGw9PXQmJih0PTApLG51bGw9PW4mJihuPWUubGVuZ3RoKTtmb3IodmFyIHI9MSxpPXQ7aTxuOysraSlyKj1lW2ldO3JldHVybiByfWZ1bmN0aW9uIHRvQXJyYXkxRChlKXtyZXR1cm4gZT1BcnJheS5pc0FycmF5KGUpP25ldyBGbG9hdDMyQXJyYXkoZSk6ZSx0ZW5zb3IxZChlKX1mdW5jdGlvbiBtaW4kMShlKXtyZXR1cm4gbWluKHRvQXJyYXkxRChlKSkuZGF0YVN5bmMoKVswXX1mdW5jdGlvbiBtYXgkMShlKXtyZXR1cm4gbWF4KHRvQXJyYXkxRChlKSkuZGF0YVN5bmMoKVswXX1mdW5jdGlvbiByYW5nZShlLHQpe2lmKHQ8ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImVuZCAoXCIrdCtcIikgPCBiZWdpbiAoXCIrZStcIikgaXMgZm9yYmlkZGVuLlwiKTtmb3IodmFyIG49W10scj1lO3I8dDsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIGNhc3QkMShlLHQpe3JldHVybiBlLmFzVHlwZSh0KX1mdW5jdGlvbiBleHBhbmREaW1zJDEoZSx0KXt2b2lkIDA9PT10JiYodD0tMSk7dmFyIG49ZS5zaGFwZS5zbGljZSgpO3JldHVybiB0PDAmJih0PW4ubGVuZ3RoK3QrMSksbi5zcGxpY2UodCwwLDEpLGUucmVzaGFwZShuKX1mdW5jdGlvbiByZXBlYXQoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1lLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInJlcGVhdCgpIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgcmVjZWl2ZWQgYSByYW5rLVwiK2Uuc2hhcGUubGVuZ3RoK1wiIHRlbnNvci5cIik7cmV0dXJuIHRpbGUkMShleHBhbmREaW1zJDEoZSwxKSxbMSx0LDFdKX0pfWZ1bmN0aW9uIGZsYXR0ZW4oZSl7dmFyIHQ9W2FycmF5UHJvZChlLnNoYXBlKV07cmV0dXJuIGUucmVzaGFwZSh0KX1mdW5jdGlvbiBiYXRjaEZsYXR0ZW4oZSl7aWYoZS5yYW5rPD0xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYmF0Y2hGbGF0dGVuIHJlcXVpcmVzIGEgbWluaW11bSByYW5rIG9mIDIuIEdvdCByYW5rOiBcIitlLnJhbmsrXCIuXCIpO3ZhciB0PVtlLnNoYXBlWzBdLGFycmF5UHJvZChlLnNoYXBlLDEpXTtyZXR1cm4gZS5yZXNoYXBlKHQpfWZ1bmN0aW9uIHNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBzbGljZTFkKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlMmQoZSxbdCwwXSxbbixlLnNoYXBlWzFdXSk7Y2FzZSAzOnJldHVybiBzbGljZTNkKGUsW3QsMCwwXSxbbixlLnNoYXBlWzFdLGUuc2hhcGVbMl1dKTtjYXNlIDQ6cmV0dXJuIHNsaWNlNGQoZSxbdCwwLDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM11dKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIitlLnJhbmspfX0pfWZ1bmN0aW9uIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIHNsaWNlMWQoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gc2xpY2UyZChlLFswLHRdLFtlLnNoYXBlWzBdLG5dKTtjYXNlIDM6cmV0dXJuIHNsaWNlM2QoZSxbMCwwLHRdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sbl0pO2Nhc2UgNDpyZXR1cm4gc2xpY2U0ZChlLFswLDAsMCx0XSxbZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sbl0pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrZS5yYW5rKX19KX1mdW5jdGlvbiBzbGljZUFsb25nQXhpcyhlLHQsbixyKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChlLHQsbik7Y2FzZSAyOnN3aXRjaChyKXtjYXNlIDE6cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiK3IpfWNhc2UgMzpzd2l0Y2gocil7Y2FzZSAxOnJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlM2QoZSxbMCx0LDBdLFtlLnNoYXBlWzBdLG4sZS5zaGFwZVsyXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiK3IpfWNhc2UgNDpzd2l0Y2gocil7Y2FzZSAxOnJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlNGQoZSxbMCx0LDAsMF0sW2Uuc2hhcGVbMF0sbixlLnNoYXBlWzJdLGUuc2hhcGVbM11dKTtjYXNlIDM6cmV0dXJuIHNsaWNlNGQoZSxbMCwwLHQsMF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxuLGUuc2hhcGVbM11dKTtjYXNlIDQ6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIityKX1kZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fSl9ZnVuY3Rpb24gY29uY2F0ZW5hdGUoZSx0KXt2YXIgbjtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHQ8MCYmKHQ9MCE9PShuPWVbMF0ucmFuayk/bjowKSx0PT09ZVswXS5yYW5rJiYodD0tMSksY29uY2F0KGUsdCl9ZnVuY3Rpb24gY29uY2F0QWxvbmdGaXJzdEF4aXMoZSx0KXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIGNvbmNhdDFkKFtlLHRdKTtjYXNlIDI6cmV0dXJuIGNvbmNhdDJkKFtlLHRdLDApO2Nhc2UgMzpyZXR1cm4gY29uY2F0M2QoW2UsdF0sMCk7Y2FzZSA0OnJldHVybiBjb25jYXQ0ZChbZSx0XSwwKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29uY2F0QWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrZS5yYW5rKX19ZnVuY3Rpb24gdGlsZSQxKGUsdCl7aWYoQXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKSxlLnJhbmshPT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBsZW5ndGggb2YgaW5wdXQgbiAoXCIrdC5sZW5ndGgrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiBpbnB1dCB4IChcIitlLnJhbmsrXCIpXCIpO3JldHVybiB0aWxlKGUsdCl9ZnVuY3Rpb24gcmFuZG9tTm9ybWFsJDEoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49MSkscmFuZG9tTm9ybWFsKGUsdCxuLHIsaSl9ZnVuY3Rpb24gZG90KGUsdCxuLHIpe2lmKGUucmFuazwyfHx0LnJhbms8Mil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImRvdCByZXF1aXJlcyBib3RoIGlucHV0cyB0byBiZSByYW5rID49IDIgYnV0IGdvdCB4IHNoYXBlID0gXCIrZS5zaGFwZStcIiBhbmQgeSBzaGFwZSA9IFwiK3Quc2hhcGUpO2lmKHQucmFuaz49MyYmKHM9ZS5zaGFwZS5zbGljZSgtMSlbMF0pIT09KGM9dC5zaGFwZS5zbGljZSgtMilbMF0pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiSWYgcmFuayB5ID49IDMsIHRoZW4gdGhlIHNlY29uZCBsYXN0IGRpbSBvZiB5IG11c3QgZXF1YWwgdGhlIGxhc3QgZGltIG9mIHggYnV0IGdvdCB4IHNoYXBlID0gXCIrZS5zaGFwZStcIiBhbmQgIHkgc2hhcGUgPSBcIit0LnNoYXBlKTtpZigyPT09ZS5yYW5rJiYyPT09dC5yYW5rKXt2YXIgaT0hMSxhPSExO3JldHVybiBmdXNlZC5tYXRNdWwoZSx0LGksYSxyP3Jlc2hhcGVCaWFzKGUucmFuayxyLGltYWdlRGF0YUZvcm1hdCgpKTpudWxsLG4pfXZhciBvPWUuc2hhcGUuc2xpY2UoKSxzPW8ucG9wKCk7ZT1lLnJlc2hhcGUoWy0xLHNdKTt2YXIgbD10LnNoYXBlLnNsaWNlKCksdT1sLnBvcCgpLGM9bC5wb3AoKSxwPWwuY29uY2F0KFt1XSksaD1BcnJheS5mcm9tKHtsZW5ndGg6dC5yYW5rfSxmdW5jdGlvbihlLG4pe3JldHVybiAwPT09bj90LnJhbmstMjpuPD10LnJhbmstMj9uLTE6bn0pO3Q9dC50cmFuc3Bvc2UoaCkucmVzaGFwZShbYywtMV0pO3ZhciBkPW8uY29uY2F0KHApO2k9ITEsYT0hMTtyZXR1cm4gZnVzZWQubWF0TXVsKGUsdCxpLGEscj9yZXNoYXBlQmlhcyhlLnJhbmsscixpbWFnZURhdGFGb3JtYXQoKSk6bnVsbCxuKS5yZXNoYXBlKGQpfWZ1bmN0aW9uIGdhdGhlciQxKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiB0PUFycmF5LmlzQXJyYXkodCk/dGVuc29yMWQodCxcImludDMyXCIpOnQudG9JbnQoKSxnYXRoZXIoZSx0LG4pfSl9ZnVuY3Rpb24gc3F1YXJlKGUpe3JldHVybiBtdWxTdHJpY3QoZSxlKX1mdW5jdGlvbiByZXNoYXBlQmlhcyhlLHQsbil7dmFyIHI9dC5zaGFwZTtpZigxIT09dC5yYW5rJiZ0LnJhbmshPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5leHBlY3RlZCBiaWFzIGRpbWVuc2lvbnM6IFwiK3QucmFuaytcIjsgZXhwZWN0ZWQgaXQgdG8gYmUgMSBvciBcIitlKTtpZig1PT09ZSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLHJbMF0sMSwxLDFdKTp0LnJlc2hhcGUoWzEsclszXSxyWzBdLHJbMV0sclsyXV0pO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLDEsMSwxLHJbMF1dKTp0LnJlc2hhcGUoWzFdLmNvbmNhdChyKSl9ZWxzZSBpZig0PT09ZSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLHJbMF0sMSwxXSk6dC5yZXNoYXBlKFsxLHJbMl0sclswXSxyWzFdXSk7aWYoXCJjaGFubmVsc0xhc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsMSwxLHJbMF1dKTp0LnJlc2hhcGUoWzFdLmNvbmNhdChyKSl9ZWxzZSBpZigzPT09ZSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLHJbMF0sMV0pOnQucmVzaGFwZShbMSxyWzFdLHJbMF1dKTtpZihcImNoYW5uZWxzTGFzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSwxLHJbMF1dKTp0LnJlc2hhcGUoWzFdLmNvbmNhdChyKSl9ZWxzZSBpZihlPDMpcmV0dXJuIHQ7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnB1dCByYW5rIGJ5IGJpYXNBZGQ6IFwiK3QucmFuayl9ZnVuY3Rpb24gYmlhc0FkZChlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09biYmKG49aW1hZ2VEYXRhRm9ybWF0KCkpLGNoZWNrRGF0YUZvcm1hdChuKSxlLmFkZChyZXNoYXBlQmlhcyhlLnJhbmssdCxuKSl9KX1mdW5jdGlvbiBlbHUkMShlLHQpe2lmKHZvaWQgMD09PXQmJih0PTEpLDEhPT10KXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiU3VwcG9ydCBmb3IgYWxwaGEgdmFsdWVzIG90aGVyIHRoYW4gMSAoXCIrdCtcIikgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIGVsdShlKX1mdW5jdGlvbiBzb2Z0c2lnbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBkaXYoZSxhYnMoZSkuYWRkKDEpKX0pfWZ1bmN0aW9uIGRyb3BvdXQoZSx0LG4scil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsIT1uJiYhdXRpbC5hcnJheXNFcXVhbChlLnNoYXBlLG4pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIHlldDogXCIrSlNPTi5zdHJpbmdpZnkobikpO2lmKG51bGwhPXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgZHJvcG91dCB5ZXQuXCIpO3ZhciBpPXN0ZXAoYWRkKC10LHJhbmRvbVVuaWZvcm0oZS5zaGFwZSwwLDEsXCJmbG9hdDMyXCIpKSk7cmV0dXJuIGk9bXVsKDEvKDEtdCksaSksbXVsKGUsaSl9KX1mdW5jdGlvbiBoYXJkU2lnbW9pZChlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWFkZCguNSxtdWwoLjIsZSkpO3JldHVybiBjbGlwQnlWYWx1ZSh0LDAsMSl9KX1mdW5jdGlvbiBpblRyYWluUGhhc2UoZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksbj9lKCk6dCgpfXZhciBWQUxJRF9GQU5fTU9ERV9WQUxVRVM9W1wiZmFuSW5cIixcImZhbk91dFwiLFwiZmFuQXZnXCJdLFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVM9W1wibm9ybWFsXCIsXCJ1bmlmb3JtXCIsXCJ0cnVuY2F0ZWROb3JtYWxcIl07ZnVuY3Rpb24gY2hlY2tGYW5Nb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfRkFOX01PREVfVkFMVUVTLFwiRmFuTW9kZVwiLGUpfWZ1bmN0aW9uIGNoZWNrRGlzdHJpYnV0aW9uKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUyxcIkRpc3RyaWJ1dGlvblwiLGUpfXZhciBJbml0aWFsaXplcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZnJvbUNvbmZpZ1VzZXNDdXN0b21PYmplY3RzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksWmVyb3M9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHplcm9zKGUsdCl9LHQuY2xhc3NOYW1lPVwiWmVyb3NcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFplcm9zKTt2YXIgT25lcz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gb25lcyhlLHQpfSx0LmNsYXNzTmFtZT1cIk9uZXNcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE9uZXMpO3ZhciBDb25zdGFudD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIGFyZ3VtZW50IG9mIHR5cGUgQ29uc3RhbnRDb25maWcgYnV0IGdvdCBcIit0KTtpZih2b2lkIDA9PT10LnZhbHVlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29uZmlnIG11c3QgaGF2ZSB2YWx1ZSBzZXQgYnV0IGdvdCBcIit0KTtyZXR1cm4gbi52YWx1ZT10LnZhbHVlLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtdWwoc2NhbGFyKG4udmFsdWUpLG9uZXMoZSx0KSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue3ZhbHVlOnRoaXMudmFsdWV9fSx0LmNsYXNzTmFtZT1cIkNvbnN0YW50XCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb25zdGFudCk7dmFyIFJhbmRvbVVuaWZvcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9NSU5WQUw9LS4wNSxuLkRFRkFVTFRfTUFYVkFMPS4wNSxuLm1pbnZhbD10Lm1pbnZhbHx8bi5ERUZBVUxUX01JTlZBTCxuLm1heHZhbD10Lm1heHZhbHx8bi5ERUZBVUxUX01BWFZBTCxuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHJhbmRvbVVuaWZvcm0oZSx0aGlzLm1pbnZhbCx0aGlzLm1heHZhbCx0KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21pbnZhbDp0aGlzLm1pbnZhbCxtYXh2YWw6dGhpcy5tYXh2YWwsc2VlZDp0aGlzLnNlZWR9fSx0LmNsYXNzTmFtZT1cIlJhbmRvbVVuaWZvcm1cIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJhbmRvbVVuaWZvcm0pO3ZhciBSYW5kb21Ob3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9NRUFOPTAsbi5ERUZBVUxUX1NURERFVj0uMDUsbi5tZWFuPXQubWVhbnx8bi5ERUZBVUxUX01FQU4sbi5zdGRkZXY9dC5zdGRkZXZ8fG4uREVGQVVMVF9TVERERVYsbi5zZWVkPXQuc2VlZCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe2lmKFwiZmxvYXQzMlwiIT09KHQ9dHx8XCJmbG9hdDMyXCIpJiZcImludDMyXCIhPT10KXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwicmFuZG9tTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgXCIrdCtcIi5cIik7cmV0dXJuIHJhbmRvbU5vcm1hbCQxKGUsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LHQsdGhpcy5zZWVkKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiUmFuZG9tTm9ybWFsXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSYW5kb21Ob3JtYWwpO3ZhciBUcnVuY2F0ZWROb3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9NRUFOPTAsbi5ERUZBVUxUX1NURERFVj0uMDUsbi5tZWFuPXQubWVhbnx8bi5ERUZBVUxUX01FQU4sbi5zdGRkZXY9dC5zdGRkZXZ8fG4uREVGQVVMVF9TVERERVYsbi5zZWVkPXQuc2VlZCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe2lmKFwiZmxvYXQzMlwiIT09KHQ9dHx8XCJmbG9hdDMyXCIpJiZcImludDMyXCIhPT10KXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwidHJ1bmNhdGVkTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgXCIrdCtcIi5cIik7cmV0dXJuIHRydW5jYXRlZE5vcm1hbChlLHRoaXMubWVhbix0aGlzLnN0ZGRldix0LHRoaXMuc2VlZCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttZWFuOnRoaXMubWVhbixzdGRkZXY6dGhpcy5zdGRkZXYsc2VlZDp0aGlzLnNlZWR9fSx0LmNsYXNzTmFtZT1cIlRydW5jYXRlZE5vcm1hbFwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVHJ1bmNhdGVkTm9ybWFsKTt2YXIgSWRlbnRpdHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZ2Fpbj1udWxsIT10LmdhaW4/dC5nYWluOjEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWUubGVuZ3RofHxlWzBdIT09ZVsxXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklkZW50aXR5IG1hdHJpeCBpbml0aWFsaXplciBjYW4gb25seSBiZSB1c2VkIGZvciAyRCBzcXVhcmUgbWF0cmljZXMuXCIpO3JldHVybiBtdWwobi5nYWluLGV5ZShlWzBdKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2dhaW46dGhpcy5nYWlufX0sdC5jbGFzc05hbWU9XCJJZGVudGl0eVwiLHR9KEluaXRpYWxpemVyKTtmdW5jdGlvbiBjb21wdXRlRmFucyhlLHQpe3ZhciBuLHI7aWYodm9pZCAwPT09dCYmKHQ9XCJjaGFubmVsc0xhc3RcIiksY2hlY2tEYXRhRm9ybWF0KHQpLDI9PT1lLmxlbmd0aCluPWVbMF0scj1lWzFdO2Vsc2UgaWYoLTEhPT1bMyw0LDVdLmluZGV4T2YoZS5sZW5ndGgpKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PXQpe3ZhciBpPWFycmF5UHJvZChlLDIpO249ZVsxXSppLHI9ZVswXSppfWVsc2UgaWYoXCJjaGFubmVsc0xhc3RcIj09PXQpe2k9YXJyYXlQcm9kKGUsMCxlLmxlbmd0aC0yKTtuPWVbZS5sZW5ndGgtMl0qaSxyPWVbZS5sZW5ndGgtMV0qaX19ZWxzZXt2YXIgYT1hcnJheVByb2QoZSk7bj1NYXRoLnNxcnQoYSkscj1NYXRoLnNxcnQoYSl9cmV0dXJuW24scl19c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKElkZW50aXR5KTt2YXIgVmFyaWFuY2VTY2FsaW5nPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKHQuc2NhbGU8MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNjYWxlIG11c3QgYmUgYSBwb3NpdGl2ZSBmbG9hdC4gR290OiBcIit0LnNjYWxlKTtyZXR1cm4gbi5zY2FsZT1udWxsPT10LnNjYWxlPzE6dC5zY2FsZSxuLm1vZGU9bnVsbD09dC5tb2RlP1wiZmFuSW5cIjp0Lm1vZGUsY2hlY2tGYW5Nb2RlKG4ubW9kZSksbi5kaXN0cmlidXRpb249bnVsbD09dC5kaXN0cmlidXRpb24/XCJub3JtYWxcIjp0LmRpc3RyaWJ1dGlvbixjaGVja0Rpc3RyaWJ1dGlvbihuLmRpc3RyaWJ1dGlvbiksbi5zZWVkPXQuc2VlZCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPWNvbXB1dGVGYW5zKGUpLHI9blswXSxpPW5bMV0sYT10aGlzLnNjYWxlO2lmKFwiZmFuSW5cIj09PXRoaXMubW9kZT9hLz1NYXRoLm1heCgxLHIpOlwiZmFuT3V0XCI9PT10aGlzLm1vZGU/YS89TWF0aC5tYXgoMSxpKTphLz1NYXRoLm1heCgxLChyK2kpLzIpLFwibm9ybWFsXCI9PT10aGlzLmRpc3RyaWJ1dGlvbil7dmFyIG89TWF0aC5zcXJ0KGEpO2lmKFwiZmxvYXQzMlwiIT09KHQ9dHx8XCJmbG9hdDMyXCIpJiZcImludDMyXCIhPT10KXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKHRoaXMuZ2V0Q2xhc3NOYW1lKCkrXCIgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIit0K1wiLlwiKTtyZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKGUsMCxvLHQsdGhpcy5zZWVkKX12YXIgcz1NYXRoLnNxcnQoMyphKTtyZXR1cm4gcmFuZG9tVW5pZm9ybShlLC1zLHMsdCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntzY2FsZTp0aGlzLnNjYWxlLG1vZGU6dGhpcy5tb2RlLGRpc3RyaWJ1dGlvbjp0aGlzLmRpc3RyaWJ1dGlvbixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiVmFyaWFuY2VTY2FsaW5nXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhWYXJpYW5jZVNjYWxpbmcpO3ZhciBHbG9yb3RVbmlmb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5BdmdcIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkdsb3JvdFVuaWZvcm1cIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9yb3RVbmlmb3JtKTt2YXIgR2xvcm90Tm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5BdmdcIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiR2xvcm90Tm9ybWFsXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvcm90Tm9ybWFsKTt2YXIgSGVOb3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjIsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkhlTm9ybWFsXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGVOb3JtYWwpO3ZhciBIZVVuaWZvcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjIsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwidW5pZm9ybVwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJIZVVuaWZvcm1cIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhIZVVuaWZvcm0pO3ZhciBMZUN1bk5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6MSxtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiTGVDdW5Ob3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZUN1bk5vcm1hbCk7dmFyIExlQ3VuVW5pZm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6MSxtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkxlQ3VuTm9ybWFsXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGVDdW5Vbmlmb3JtKTt2YXIgT3J0aG9nb25hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztpZihuLkRFRkFVTFRfR0FJTj0xLG4uZ2Fpbj1udWxsPT10LmdhaW4/bi5ERUZBVUxUX0dBSU46dC5nYWluLG4uc2VlZD10LnNlZWQsbnVsbCE9bi5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiUmFuZG9tIHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBPcnRob2dvbmFsIEluaXRpYWxpemVyIHlldC5cIik7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBPcnRob2dvbmFsIEluaXRpYWxpemVyIGRvZXMgbm90IHN1cHBvcnQgbm9uLTJEIHNoYXBlcyB5ZXQuXCIpO2VbMF0qZVsxXT4yZTMmJmNvbnNvbGUud2FybihcIk9ydGhvZ29uYWwgaW5pdGlhbGl6ZXIgaXMgYmVpbmcgY2FsbGVkIG9uIGEgbWF0cml4IHdpdGggbW9yZSB0aGFuIDIwMDAgKFwiK2VbMF0qZVsxXStcIikgZWxlbWVudHM6IFNsb3duZXNzIG1heSByZXN1bHQuXCIpO3ZhciB0PXJhbmRvbU5vcm1hbCQxKGVbMF0+ZVsxXT9bZVsxXSxlWzBdXTplLDAsMSxcImZsb2F0MzJcIikscj1saW5hbGcuZ3JhbVNjaG1pZHQodCk7cmV0dXJuIGVbMF0+ZVsxXSYmKHI9ci50cmFuc3Bvc2UoKSksbXVsKG4uZ2FpbixyKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57Z2Fpbjp0aGlzLmdhaW4sc2VlZDp0aGlzLnNlZWR9fSx0LmNsYXNzTmFtZT1cIk9ydGhvZ29uYWxcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE9ydGhvZ29uYWwpO3ZhciBJTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e2NvbnN0YW50OlwiQ29uc3RhbnRcIixnbG9yb3ROb3JtYWw6XCJHbG9yb3ROb3JtYWxcIixnbG9yb3RVbmlmb3JtOlwiR2xvcm90VW5pZm9ybVwiLGhlTm9ybWFsOlwiSGVOb3JtYWxcIixoZVVuaWZvcm06XCJIZVVuaWZvcm1cIixpZGVudGl0eTpcIklkZW50aXR5XCIsbGVDdW5Ob3JtYWw6XCJMZUN1bk5vcm1hbFwiLGxlQ3VuVW5pZm9ybTpcIkxlQ3VuVW5pZm9ybVwiLG9uZXM6XCJPbmVzXCIsb3J0aG9nb25hbDpcIk9ydGhvZ29uYWxcIixyYW5kb21Ob3JtYWw6XCJSYW5kb21Ob3JtYWxcIixyYW5kb21Vbmlmb3JtOlwiUmFuZG9tVW5pZm9ybVwiLHRydW5jYXRlZE5vcm1hbDpcIlRydW5jYXRlZE5vcm1hbFwiLHZhcmlhbmNlU2NhbGluZzpcIlZhcmlhbmNlU2NhbGluZ1wiLHplcm9zOlwiWmVyb3NcIn07ZnVuY3Rpb24gZGVzZXJpYWxpemVJbml0aWFsaXplcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImluaXRpYWxpemVyXCIpfWZ1bmN0aW9uIHNlcmlhbGl6ZUluaXRpYWxpemVyKGUpe3JldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChlKX1mdW5jdGlvbiBnZXRJbml0aWFsaXplcihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIHQ9ZSBpbiBJTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA/SU5JVElBTElaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2VdOmU7aWYoXCJHbG9yb3ROb3JtYWxcIj09PXQpcmV0dXJuIG5ldyBHbG9yb3ROb3JtYWw7aWYoXCJHbG9yb3RVbmlmb3JtXCI9PT10KXJldHVybiBuZXcgR2xvcm90VW5pZm9ybTtpZihcIkhlTm9ybWFsXCI9PT10KXJldHVybiBuZXcgSGVOb3JtYWw7aWYoXCJIZVVuaWZvcm1cIj09PXQpcmV0dXJuIG5ldyBIZVVuaWZvcm07aWYoXCJMZUN1bk5vcm1hbFwiPT09dClyZXR1cm4gbmV3IExlQ3VuTm9ybWFsO2lmKFwiTGVDdW5Vbmlmb3JtXCI9PT10KXJldHVybiBuZXcgTGVDdW5Vbmlmb3JtO3ZhciBuPXt9O3JldHVybiBuLmNsYXNzTmFtZT10LG4uY29uZmlnPXt9LGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIobil9cmV0dXJuIGUgaW5zdGFuY2VvZiBJbml0aWFsaXplcj9lOmRlc2VyaWFsaXplSW5pdGlhbGl6ZXIoZSl9ZnVuY3Rpb24gemVyb3MkMSgpe3JldHVybiBuZXcgWmVyb3N9ZnVuY3Rpb24gb25lcyQxKCl7cmV0dXJuIG5ldyBPbmVzfWZ1bmN0aW9uIGNvbnN0YW50KGUpe3JldHVybiBuZXcgQ29uc3RhbnQoZSl9ZnVuY3Rpb24gcmFuZG9tVW5pZm9ybSQxKGUpe3JldHVybiBuZXcgUmFuZG9tVW5pZm9ybShlKX1mdW5jdGlvbiByYW5kb21Ob3JtYWwkMihlKXtyZXR1cm4gbmV3IFJhbmRvbU5vcm1hbChlKX1mdW5jdGlvbiB0cnVuY2F0ZWROb3JtYWwkMShlKXtyZXR1cm4gbmV3IFRydW5jYXRlZE5vcm1hbChlKX1mdW5jdGlvbiBpZGVudGl0eShlKXtyZXR1cm4gbmV3IElkZW50aXR5KGUpfWZ1bmN0aW9uIHZhcmlhbmNlU2NhbGluZyhlKXtyZXR1cm4gbmV3IFZhcmlhbmNlU2NhbGluZyhlKX1mdW5jdGlvbiBnbG9yb3RVbmlmb3JtKGUpe3JldHVybiBuZXcgR2xvcm90VW5pZm9ybShlKX1mdW5jdGlvbiBnbG9yb3ROb3JtYWwoZSl7cmV0dXJuIG5ldyBHbG9yb3ROb3JtYWwoZSl9ZnVuY3Rpb24gaGVOb3JtYWwoZSl7cmV0dXJuIG5ldyBIZU5vcm1hbChlKX1mdW5jdGlvbiBoZVVuaWZvcm0oZSl7cmV0dXJuIG5ldyBIZVVuaWZvcm0oZSl9ZnVuY3Rpb24gbGVDdW5Ob3JtYWwoZSl7cmV0dXJuIG5ldyBMZUN1bk5vcm1hbChlKX1mdW5jdGlvbiBsZUN1blVuaWZvcm0oZSl7cmV0dXJuIG5ldyBMZUN1blVuaWZvcm0oZSl9ZnVuY3Rpb24gb3J0aG9nb25hbChlKXtyZXR1cm4gbmV3IE9ydGhvZ29uYWwoZSl9dmFyIGV4cG9ydHNfaW5pdGlhbGl6ZXJzPU9iamVjdC5mcmVlemUoe3plcm9zOnplcm9zJDEsb25lczpvbmVzJDEsY29uc3RhbnQ6Y29uc3RhbnQscmFuZG9tVW5pZm9ybTpyYW5kb21Vbmlmb3JtJDEscmFuZG9tTm9ybWFsOnJhbmRvbU5vcm1hbCQyLHRydW5jYXRlZE5vcm1hbDp0cnVuY2F0ZWROb3JtYWwkMSxpZGVudGl0eTppZGVudGl0eSx2YXJpYW5jZVNjYWxpbmc6dmFyaWFuY2VTY2FsaW5nLGdsb3JvdFVuaWZvcm06Z2xvcm90VW5pZm9ybSxnbG9yb3ROb3JtYWw6Z2xvcm90Tm9ybWFsLGhlTm9ybWFsOmhlTm9ybWFsLGhlVW5pZm9ybTpoZVVuaWZvcm0sbGVDdW5Ob3JtYWw6bGVDdW5Ob3JtYWwsbGVDdW5Vbmlmb3JtOmxlQ3VuVW5pZm9ybSxvcnRob2dvbmFsOm9ydGhvZ29uYWx9KSxfbmV4dFVuaXF1ZVRlbnNvcklkPTA7ZnVuY3Rpb24gZ2V0TmV4dFVuaXF1ZVRlbnNvcklkKCl7cmV0dXJuIF9uZXh0VW5pcXVlVGVuc29ySWQrK312YXIgX3VpZFByZWZpeGVzPXt9O2Z1bmN0aW9uIGdldFVpZChlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJcIiksZSBpbiBfdWlkUHJlZml4ZXN8fChfdWlkUHJlZml4ZXNbZV09MCksX3VpZFByZWZpeGVzW2VdKz0xLGUrX3VpZFByZWZpeGVzW2VdLnRvU3RyaW5nKCl9ZnVuY3Rpb24gaXNBcnJheU9mU2hhcGVzKGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpJiZBcnJheS5pc0FycmF5KGVbMF0pfWZ1bmN0aW9uIG5vcm1hbGl6ZVNoYXBlTGlzdChlKXtyZXR1cm4gMD09PWUubGVuZ3RoP1tdOkFycmF5LmlzQXJyYXkoZVswXSk/ZTpbZV19ZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVRlbnNvcihlKXt2YXIgdDtpZihBcnJheS5pc0FycmF5KGUpKXtpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFeHBlY3RlZCBUZW5zb3IgbGVuZ3RoIHRvIGJlIDE7IGdvdCBcIitlLmxlbmd0aCk7dD1lWzBdfWVsc2UgdD1lO3JldHVybiB0fWZ1bmN0aW9uIGdldEV4YWN0bHlPbmVTaGFwZShlKXtpZihBcnJheS5pc0FycmF5KGUpJiZBcnJheS5pc0FycmF5KGVbMF0pKXtpZigxPT09ZS5sZW5ndGgpcmV0dXJuKGU9ZSlbMF07dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFeHBlY3RlZCBleGFjdGx5IDEgU2hhcGU7IGdvdCBcIitlLmxlbmd0aCl9cmV0dXJuIGV9ZnVuY3Rpb24gY291bnRQYXJhbXNJbldlaWdodHMoZSl7Zm9yKHZhciB0PTAsbj0wLHI9ZTtuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTswPT09aS5zaGFwZS5sZW5ndGg/dCs9MTp0Kz1pLnNoYXBlLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlKnR9KX1yZXR1cm4gdH12YXIgREVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWD1cIlZhcmlhYmxlXCIsTGF5ZXJWYXJpYWJsZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4scixpKXt2b2lkIDA9PT10JiYodD1cImZsb2F0MzJcIiksdm9pZCAwPT09biYmKG49REVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWCksdm9pZCAwPT09ciYmKHI9ITApLHZvaWQgMD09PWkmJihpPW51bGwpLHRoaXMuZHR5cGU9bnVsbD09dD9cImZsb2F0MzJcIjp0LHRoaXMuc2hhcGU9ZS5zaGFwZSx0aGlzLmlkPWdldE5leHRVbmlxdWVUZW5zb3JJZCgpLG49bnVsbD09bj9ERUZBVUxUX1ZBUklBQkxFX05BTUVfUFJFRklYOm4sdGhpcy5vcmlnaW5hbE5hbWU9Z2V0U2NvcGVkVGVuc29yTmFtZShuKSx0aGlzLm5hbWU9Z2V0VW5pcXVlVGVuc29yTmFtZSh0aGlzLm9yaWdpbmFsTmFtZSksdGhpcy50cmFpbmFibGVfPXIsdGhpcy5jb25zdHJhaW50PWksdGhpcy52YWw9dmFyaWFibGUoZSx0aGlzLnRyYWluYWJsZV8sdGhpcy5uYW1lLHRoaXMuZHR5cGUpfXJldHVybiBlLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbH0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSxjaGVja1NoYXBlc01hdGNoKHRoaXMudmFsLGUpLHRoaXMudmFsLmlkIT09ZS5pZCYmKHRoaXMudmFsLmFzc2lnbihlKSxudWxsIT10aGlzLmNvbnN0cmFpbnQmJnRoaXMudmFsLmFzc2lnbih0aGlzLmNvbnN0cmFpbnQuYXBwbHkodGhpcy52YWwpKSksdGhpc30sZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbC5kaXNwb3NlKCl9LGUucHJvdG90eXBlLmFzc2VydE5vdERpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy52YWwuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJMYXllcnNWYXJpYWJsZSBcIit0aGlzLm5hbWUrXCIgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy50cmFpbmFibGVfPWUsdGhpcy52YWwudHJhaW5hYmxlPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZX0oKTtmdW5jdGlvbiBjaGVja1NoYXBlc01hdGNoKGUsdCl7aWYoZS5zaGFwZS50b1N0cmluZygpIT09dC5zaGFwZS50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG1pc21hdGNoOiBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKStcIiB2cy4gXCIrSlNPTi5zdHJpbmdpZnkodC5zaGFwZSkpfWZ1bmN0aW9uIGJhdGNoR2V0VmFsdWUoZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlYWQoKX0pfWZ1bmN0aW9uIGJhdGNoU2V0VmFsdWUoZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2VbMF0ud3JpdGUoZVsxXSl9KX12YXIgSW5wdXRTcGVjPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3RoaXMuZHR5cGU9ZS5kdHlwZSx0aGlzLnNoYXBlPWUuc2hhcGUsbnVsbCE9ZS5zaGFwZT90aGlzLm5kaW09ZS5zaGFwZS5sZW5ndGg6dGhpcy5uZGltPWUubmRpbSx0aGlzLm1heE5EaW09ZS5tYXhORGltLHRoaXMubWluTkRpbT1lLm1pbk5EaW0sdGhpcy5heGVzPWUuYXhlc3x8e319fSgpLFN5bWJvbGljVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxuLHIsaSxhLG8pe3RoaXMuZHR5cGU9ZSx0aGlzLnNoYXBlPXQsdGhpcy5zb3VyY2VMYXllcj1uLHRoaXMuaW5wdXRzPXIsdGhpcy5jYWxsQXJncz1pLHRoaXMub3V0cHV0VGVuc29ySW5kZXg9byx0aGlzLmlkPWdldE5leHRVbmlxdWVUZW5zb3JJZCgpLG51bGwhPWEmJih0aGlzLm9yaWdpbmFsTmFtZT1nZXRTY29wZWRUZW5zb3JOYW1lKGEpLHRoaXMubmFtZT1nZXRVbmlxdWVUZW5zb3JOYW1lKHRoaXMub3JpZ2luYWxOYW1lKSksdGhpcy5yYW5rPXQubGVuZ3RofX0oKSxfbmV4dE5vZGVJRD0wLE5vZGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dGhpcy5jYWxsQXJncz10LHRoaXMuaWQ9X25leHROb2RlSUQrKyx0aGlzLm91dGJvdW5kTGF5ZXI9ZS5vdXRib3VuZExheWVyLHRoaXMuaW5ib3VuZExheWVycz1lLmluYm91bmRMYXllcnMsdGhpcy5ub2RlSW5kaWNlcz1lLm5vZGVJbmRpY2VzLHRoaXMudGVuc29ySW5kaWNlcz1lLnRlbnNvckluZGljZXMsdGhpcy5pbnB1dFRlbnNvcnM9ZS5pbnB1dFRlbnNvcnMsdGhpcy5vdXRwdXRUZW5zb3JzPWUub3V0cHV0VGVuc29ycyx0aGlzLmlucHV0TWFza3M9ZS5pbnB1dE1hc2tzLHRoaXMub3V0cHV0TWFza3M9ZS5vdXRwdXRNYXNrcyx0aGlzLmlucHV0U2hhcGVzPWUuaW5wdXRTaGFwZXMsdGhpcy5vdXRwdXRTaGFwZXM9ZS5vdXRwdXRTaGFwZXM7Zm9yKHZhciBuPTAscj1lLmluYm91bmRMYXllcnM7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07bnVsbCE9aSYmaS5vdXRib3VuZE5vZGVzLnB1c2godGhpcyl9ZS5vdXRib3VuZExheWVyLmluYm91bmROb2Rlcy5wdXNoKHRoaXMpfXJldHVybiBlLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5pbmJvdW5kTGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO251bGwhPXI/ZS5wdXNoKHIubmFtZSk6ZS5wdXNoKG51bGwpfXJldHVybntvdXRib3VuZExheWVyOnRoaXMub3V0Ym91bmRMYXllcj90aGlzLm91dGJvdW5kTGF5ZXIubmFtZTpudWxsLGluYm91bmRMYXllcnM6ZSxub2RlSW5kaWNlczp0aGlzLm5vZGVJbmRpY2VzLHRlbnNvckluZGljZXM6dGhpcy50ZW5zb3JJbmRpY2VzfX0sZX0oKSxfbmV4dExheWVySUQ9MCxMYXllcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztuLl9jYWxsSG9vaz1udWxsLG4uX2FkZGVkV2VpZ2h0TmFtZXM9W10sbi5fc3RhdGVmdWw9ITEsbi5pZD1fbmV4dExheWVySUQrKyxuLmFjdGl2aXR5UmVndWxhcml6ZXI9bnVsbCxuLmlucHV0U3BlYz1udWxsLG4uc3VwcG9ydHNNYXNraW5nPSExLG4uX3RyYWluYWJsZVdlaWdodHM9W10sbi5fbm9uVHJhaW5hYmxlV2VpZ2h0cz1bXSxuLl9sb3NzZXM9W10sbi5fdXBkYXRlcz1bXSxuLl9idWlsdD0hMSxuLmluYm91bmROb2Rlcz1bXSxuLm91dGJvdW5kTm9kZXM9W107dmFyIHI9dC5uYW1lO2lmKCFyKXt2YXIgaT1uLmdldENsYXNzTmFtZSgpO3I9dG9TbmFrZUNhc2UoaSkrXCJfXCIrZ2V0VWlkKGkpfWlmKG4ubmFtZT1yLG4udHJhaW5hYmxlXz1udWxsPT10LnRyYWluYWJsZXx8dC50cmFpbmFibGUsbi51cGRhdGFibGU9bnVsbD09dC51cGRhdGFibGV8fHQudXBkYXRhYmxlLG51bGwhPXQuaW5wdXRTaGFwZXx8bnVsbCE9dC5iYXRjaElucHV0U2hhcGUpe3ZhciBhPXZvaWQgMDtpZihudWxsIT10LmJhdGNoSW5wdXRTaGFwZSlhPXQuYmF0Y2hJbnB1dFNoYXBlO2Vsc2UgaWYobnVsbCE9dC5pbnB1dFNoYXBlKXt2YXIgbz1udWxsO251bGwhPXQuYmF0Y2hTaXplJiYobz10LmJhdGNoU2l6ZSksYT1bb10uY29uY2F0KHQuaW5wdXRTaGFwZSl9bi5iYXRjaElucHV0U2hhcGU9YTt2YXIgcz10LmR0eXBlO251bGw9PXMmJihzPXQuaW5wdXREVHlwZSksbnVsbD09cyYmKHM9XCJmbG9hdDMyXCIpLG4uZHR5cGU9c31yZXR1cm4gbnVsbCE9dC53ZWlnaHRzP24uaW5pdGlhbFdlaWdodHM9dC53ZWlnaHRzOm4uaW5pdGlhbFdlaWdodHM9bnVsbCxuLl9yZWZDb3VudD1udWxsLG4uZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD0hMSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0Lm5vZGVLZXk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5uYW1lK1wiX2liLVwiK3QudG9TdHJpbmcoKX0sdC5wcm90b3R5cGUuZ2V0Tm9kZUF0SW5kZXg9ZnVuY3Rpb24oZSx0KXtpZigwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbGF5ZXIgaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBkZWZpbmVkIFwiK3QrXCIuXCIpO2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aDw9ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFza2VkIHRvIGdldCBcIit0K1wiIGF0IG5vZGUgXCIrZStcIiwgYnV0IHRoZSBsYXllciBoYXMgb25seSBcIit0aGlzLmluYm91bmROb2Rlcy5sZW5ndGgrXCIgaW5ib3VuZCBub2Rlcy5cIik7cmV0dXJuIHRoaXMuaW5ib3VuZE5vZGVzW2VdfSx0LnByb3RvdHlwZS5nZXRJbnB1dEF0PWZ1bmN0aW9uKGUpe3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcImlucHV0XCIpLmlucHV0VGVuc29ycyl9LHQucHJvdG90eXBlLmdldE91dHB1dEF0PWZ1bmN0aW9uKGUpe3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcIm91dHB1dFwiKS5vdXRwdXRUZW5zb3JzKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW5wdXRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPjEpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lKycgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsIGhlbmNlIHRoZSBub3Rpb24gb2YgXCJsYXllciBpbnB1dFwiIGlzIGlsbC1kZWZpbmVkLiBVc2UgYGdldElucHV0QXQobm9kZUluZGV4KWAgaW5zdGVhZC4nKTtpZigwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBpcyBub3QgY29ubmVjdGVkLCBubyBpbnB1dCB0byByZXR1cm4uXCIpO3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCxcImlucHV0XCIpLmlucHV0VGVuc29ycyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0XCIse2dldDpmdW5jdGlvbigpe2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGhhcyBubyBpbmJvdW5kIG5vZGVzLlwiKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg+MSl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrJyBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIG91dHB1dFwiIGlzIGlsbC1kZWZpbmVkLiBVc2UgYGdldE91dHB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuJyk7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCgwLFwib3V0cHV0XCIpLm91dHB1dFRlbnNvcnMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImxvc3Nlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9zc2VzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3Nlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvc3Nlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91cGRhdGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJ1aWx0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idWlsdH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2J1aWx0PWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZV99LHNldDpmdW5jdGlvbihlKXt0aGlzLl90cmFpbmFibGVXZWlnaHRzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhaW5hYmxlPWV9KSx0aGlzLnRyYWluYWJsZV89ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZV8/dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJhaW5hYmxlfSk6W119LHNldDpmdW5jdGlvbihlKXt0aGlzLl90cmFpbmFibGVXZWlnaHRzPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWUudHJhaW5hYmxlfSkuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpOnRoaXMuX3RyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdGF0ZWZ1bFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGVmdWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5zdGF0ZWZ1bCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCB0aGUgcmVzZXRTdGF0ZXMoKSBtZXRob2Qgb2YgYSBub24tc3RhdGVmdWwgTGF5ZXIgb2JqZWN0LlwiKX0sdC5wcm90b3R5cGUuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5PWZ1bmN0aW9uKGUpe2lmKGU9dG9MaXN0KGUpLG51bGwhPXRoaXMuaW5wdXRTcGVjJiYwIT09dGhpcy5pbnB1dFNwZWMubGVuZ3RoKXt2YXIgdD10b0xpc3QodGhpcy5pbnB1dFNwZWMpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCBpdCByZWNlaXZlZCBcIitlLmxlbmd0aCtcIiBpbnB1dCB0ZW5zb3JzLiBJbnB1dCByZWNlaXZlZDogXCIrZSk7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl0saT10W25dO2lmKG51bGwhPWkpe3ZhciBhPXIucmFuaztpZihudWxsIT1pLm5kaW0mJmEhPT1pLm5kaW0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgbmRpbT1cIitpLm5kaW0rXCIsIGZvdW5kIG5kaW09XCIrYSk7aWYobnVsbCE9aS5tYXhORGltJiZhPmkubWF4TkRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBtYXhfbmRpbT1cIitpLm1heE5EaW0rXCIsIGZvdW5kIG5kaW09XCIrYSk7aWYobnVsbCE9aS5taW5ORGltJiZhPGkubWluTkRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBtaW5fbmRpbT1cIitpLm1pbk5EaW0rXCIsIGZvdW5kIG5kaW09XCIrYStcIi5cIik7aWYobnVsbCE9aS5kdHlwZSYmci5kdHlwZSE9PWkuZHR5cGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIiA6IGV4cGVjdGVkIGR0eXBlPVwiK2kuZHR5cGUrXCIsIGZvdW5kIGR0eXBlPVwiK3IuZHR5cGUrXCIuXCIpO2lmKGkuYXhlcyl7dmFyIG89ci5zaGFwZTtmb3IodmFyIHMgaW4gaS5heGVzKXt2YXIgbD1OdW1iZXIocyksdT1pLmF4ZXNbc10sYz1sPj0wP29bbF06b1tvLmxlbmd0aCtsXTtpZihudWxsIT11JiYtMT09PVt1LG51bGxdLmluZGV4T2YoYykpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgYXhpcyBcIitsK1wiIG9mIGlucHV0IHNoYXBlIHRvIGhhdmUgdmFsdWUgXCIrdStcIiBidXQgZ290IHNoYXBlIFwiK28rXCIuXCIpfX1pZihudWxsIT1pLnNoYXBlKWZvcih2YXIgcD0wO3A8aS5zaGFwZS5sZW5ndGg7KytwKXt2YXIgaD1pLnNoYXBlW3BdLGQ9ci5zaGFwZVtwXTtpZihudWxsIT1oJiZudWxsIT1kJiZoIT09ZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBzaGFwZT1cIitpLnNoYXBlK1wiLCBmb3VuZCBzaGFwZT1cIityLnNoYXBlK1wiLlwiKX19fX19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuaW52b2tlQ2FsbEhvb2s9ZnVuY3Rpb24oZSx0KXtudWxsIT10aGlzLl9jYWxsSG9vayYmdGhpcy5fY2FsbEhvb2soZSx0KX0sdC5wcm90b3R5cGUuc2V0Q2FsbEhvb2s9ZnVuY3Rpb24oZSl7dGhpcy5fY2FsbEhvb2s9ZX0sdC5wcm90b3R5cGUuY2xlYXJDYWxsSG9vaz1mdW5jdGlvbigpe3RoaXMuX2NhbGxIb29rPW51bGx9LHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpczt0PXR8fHt9LHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtmb3IodmFyIHI9dG9MaXN0KGUpLGk9ITAsYT0wLG89cjthPG8ubGVuZ3RoO2ErKyl7aWYoIShvW2FdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcikpe2k9ITE7YnJlYWt9fWZvcih2YXIgcz0hMCxsPTAsdT1yO2w8dS5sZW5ndGg7bCsrKXtpZih1W2xdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcil7cz0hMTticmVha319aWYoaT09PXMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBcmd1bWVudHMgdG8gYXBwbHkoKSBtdXN0IGJlIGFsbCBTeW1ib2xpY1RlbnNvcnMgb3IgYWxsIFRlbnNvcnNcIik7cmV0dXJuIG5hbWVTY29wZSh0aGlzLm5hbWUsZnVuY3Rpb24oKXtpZighbi5idWlsdCl7bi5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoZSk7Zm9yKHZhciBpPVtdLGE9MCxvPXRvTGlzdChlKTthPG8ubGVuZ3RoO2ErKyl7dmFyIGw9b1thXTtpLnB1c2gobC5zaGFwZSl9bi5idWlsZChzaW5nbGV0b25PckFycmF5KGkpKSxuLmJ1aWx0PSEwLG4uaW5pdGlhbFdlaWdodHMmJm4uc2V0V2VpZ2h0cyhuLmluaXRpYWxXZWlnaHRzKSxudWxsPT09bi5fcmVmQ291bnQmJnMmJihuLl9yZWZDb3VudD0xKX1pZihuLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShlKSxzKXtmb3IodmFyIHU9W10sYz0wLHA9dG9MaXN0KGc9bi5jYWxsKGUsdCkpO2M8cC5sZW5ndGg7YysrKXt2YXIgaD1wW2NdOy0xIT09ci5pbmRleE9mKGgpJiYoaD1oLmNsb25lKCkpLHUucHVzaChoKX1pZihnPXNpbmdsZXRvbk9yQXJyYXkodSksbnVsbCE9bi5hY3Rpdml0eVJlZ3VsYXJpemVyKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTGF5ZXIgaW52b2NhdGlvbiBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3JldHVybiBnfXZhciBkPWNvbGxlY3RJbnB1dFNoYXBlKGUpLGY9bi5jb21wdXRlT3V0cHV0U2hhcGUoZCksZz12b2lkIDAsbT1ndWVzc091dHB1dERUeXBlKGUpO2lmKG4ud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZShBcnJheS5pc0FycmF5KGUpP2RbMF06ZCksZz1udWxsIT1mJiZmLmxlbmd0aD4wJiZBcnJheS5pc0FycmF5KGZbMF0pP2YubWFwKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIG5ldyBTeW1ib2xpY1RlbnNvcihtLHIsbix0b0xpc3QoZSksdCxuLm5hbWUsaSl9KTpuZXcgU3ltYm9saWNUZW5zb3IobSxmLG4sdG9MaXN0KGUpLHQsbi5uYW1lKSxuLmFkZEluYm91bmROb2RlKGUsZyxudWxsLG51bGwsZCxmLHQpLG4uX3JlZkNvdW50KyssbnVsbCE9bi5hY3Rpdml0eVJlZ3VsYXJpemVyKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTGF5ZXIgaW52b2NhdGlvbiBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3JldHVybiBnfSl9LHQucHJvdG90eXBlLndhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGU9ZnVuY3Rpb24oZSl7aWYobnVsbCE9dGhpcy5iYXRjaElucHV0U2hhcGUpaWYoZS5sZW5ndGghPT10aGlzLmJhdGNoSW5wdXRTaGFwZS5sZW5ndGgpY29uc29sZS53YXJuKFwiVGhlIHJhbmsgb2YgdGhlIGlucHV0IHRlbnNvciBwcm92aWRlZCAoc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGF0IG9mIHRoZSBiYXRjaElucHV0U2hhcGUgKFwiK0pTT04uc3RyaW5naWZ5KHRoaXMuYmF0Y2hJbnB1dFNoYXBlKStcIikgb2YgdGhlIGxheWVyIFwiK3RoaXMubmFtZSk7ZWxzZXt2YXIgdD0hMTt0aGlzLmJhdGNoSW5wdXRTaGFwZS5mb3JFYWNoKGZ1bmN0aW9uKG4scil7bnVsbCE9biYmbnVsbCE9ZVtyXSYmZVtyXSE9PW4mJih0PSEwKX0pLHQmJmNvbnNvbGUud2FybihcIlRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdGVuc29yIChcIitKU09OLnN0cmluZ2lmeShlKStcIikgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGF0aW9uIG9mIGxheWVyIFwiK3RoaXMubmFtZStcIjogXCIrSlNPTi5zdHJpbmdpZnkodGhpcy5iYXRjaElucHV0U2hhcGUpKX19LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm91dHB1dFNoYXBlXCIse2dldDpmdW5jdGlvbigpe2lmKG51bGw9PXRoaXMuaW5ib3VuZE5vZGVzfHwwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIlRoZSBsYXllciBcIit0aGlzLm5hbWUrXCIgaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBkZWZpbmVkIG91dHB1dCBzaGFwZS5cIik7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuaW5ib3VuZE5vZGVzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdLGk9SlNPTi5zdHJpbmdpZnkoci5vdXRwdXRTaGFwZXMpOy0xPT09ZS5pbmRleE9mKGkpJiZlLnB1c2goaSl9aWYoMT09PWUubGVuZ3RoKXt2YXIgYT10aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSkmJkFycmF5LmlzQXJyYXkoYVswXSkmJjE9PT1hLmxlbmd0aD9hWzBdOmF9dGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiVGhlIGxheWVyIFwiK3RoaXMubmFtZSsnIGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzIHdpdGggZGlmZmVyZW50IG91dHB1dCBzaGFwZXMuIEhlbmNlIHRoZSBub3Rpb24gb2YgXCJvdXR1dCBzaGFwZVwiIGlzIGlsbC1kZWZpbmVkIGZvciB0aGUgbGF5ZXIuJyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuY291bnRQYXJhbXM9ZnVuY3Rpb24oKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiWW91IHRyaWVkIHRvIGNhbGwgY291bnRQYXJhbXMoKSBvbiBcIit0aGlzLm5hbWUrXCIsIGJ1dCB0aGUgbGF5ZXIgaXMgbm90IGJ1aWx0IHlldC4gQnVpbGQgaXQgZmlyc3QgYnkgY2FsbGluZyBidWlsZChiYXRjaElucHV0U2hhcGUpLlwiKTtyZXR1cm4gY291bnRQYXJhbXNJbldlaWdodHModGhpcy53ZWlnaHRzKX0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLGJhdGNoR2V0VmFsdWUoZT90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3RpZHkoZnVuY3Rpb24oKXt2YXIgbj10LndlaWdodHM7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcignWW91IGNhbGxlZCBzZXRXZWlnaHRzKHdlaWdodHMpIG9uIGxheWVyIFwiJyt0Lm5hbWUrJ1wiIHdpdGggYSB3ZWlnaHQgbGlzdCBvZiBsZW5ndGggJytlLmxlbmd0aCtcIiwgYnV0IHRoZSBsYXllciB3YXMgZXhwZWN0aW5nIFwiK24ubGVuZ3RoK1wiIHdlaWdodHMuIFByb3ZpZGVkIHdlaWdodHM6IFwiK2UrXCIuLi5cIik7aWYoMCE9PW4ubGVuZ3RoKXtmb3IodmFyIHI9W10saT1iYXRjaEdldFZhbHVlKG4pLGE9MDthPGkubGVuZ3RoOysrYSl7dmFyIG89aVthXSxzPW5bYV0sbD1lW2FdO2lmKCF1dGlsLmFycmF5c0VxdWFsKG8uc2hhcGUsbC5zaGFwZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciB3ZWlnaHQgc2hhcGUgXCIrby5zaGFwZStcIiBub3QgY29tcGF0aWJsZSB3aXRoIHByb3ZpZGVkIHdlaWdodCBzaGFwZSBcIitsLnNoYXBlKTtyLnB1c2goW3MsbF0pfWJhdGNoU2V0VmFsdWUocil9fSl9LHQucHJvdG90eXBlLmFkZFdlaWdodD1mdW5jdGlvbihlLHQsbixyLGksYSxvKXtpZigtMSE9PXRoaXMuX2FkZGVkV2VpZ2h0TmFtZXMuaW5kZXhPZihlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZSBcIitlK1wiIGZvciBsYXllciBcIit0aGlzLm5hbWUpO3RoaXMuX2FkZGVkV2VpZ2h0TmFtZXMucHVzaChlKSxudWxsPT1uJiYobj1cImZsb2F0MzJcIiksdGhpcy5mYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkJiYocj1nZXRJbml0aWFsaXplcihcInplcm9zXCIpKTt2YXIgcz1yLmFwcGx5KHQsbiksbD1uZXcgTGF5ZXJWYXJpYWJsZShzLG4sZSxhLG8pO3JldHVybiBzLmRpc3Bvc2UoKSxudWxsIT1pJiZ0aGlzLmFkZExvc3MoZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseShsLnJlYWQoKSl9KSxudWxsPT1hJiYoYT0hMCksYT90aGlzLl90cmFpbmFibGVXZWlnaHRzLnB1c2gobCk6dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cy5wdXNoKGwpLGx9LHQucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZnVuY3Rpb24oZSl7dGhpcy5mYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPWV9LHQucHJvdG90eXBlLmFkZExvc3M9ZnVuY3Rpb24oZSl7dmFyIHQ7bnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmMD09PWUubGVuZ3RofHwoZT10b0xpc3QoZSksdm9pZCAwIT09dGhpcy5fbG9zc2VzJiZudWxsIT09dGhpcy5fbG9zc2VzJiYodD10aGlzLmxvc3NlcykucHVzaC5hcHBseSh0LGUpKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYoIXRoaXMuc3VwcG9ydHNNYXNraW5nKXtpZihudWxsIT10KXtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGRvZXMgbm90IHN1cHBvcnQgbWFza2luZywgYnV0IHdhcyBwYXNzZWQgYW4gaW5wdXRNYXNrLlwiKTt0LmZvckVhY2goZnVuY3Rpb24oZSl7aWYobnVsbCE9ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGF5ZXIgXCIrbi5uYW1lK1wiIGRvZXMgbm90IHN1cHBvcnQgbWFza2luZywgYnV0IHdhcyBwYXNzZWQgYW4gaW5wdXRNYXNrLlwiKX0pfXJldHVybiBudWxsfXJldHVybiB0fSx0LnByb3RvdHlwZS5hZGRJbmJvdW5kTm9kZT1mdW5jdGlvbihlLHQsbixyLGksYSxvKXt2b2lkIDA9PT1vJiYobz1udWxsKTt2YXIgcz10b0xpc3QoZSk7dD10b0xpc3QodCksbj10b0xpc3Qobikscj10b0xpc3QociksaT1ub3JtYWxpemVTaGFwZUxpc3QoaSksYT1ub3JtYWxpemVTaGFwZUxpc3QoYSk7Zm9yKHZhciBsPVtdLHU9W10sYz1bXSxwPTAsaD1zO3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO2wucHVzaChkLnNvdXJjZUxheWVyKSx1LnB1c2goZC5ub2RlSW5kZXgpLGMucHVzaChkLnRlbnNvckluZGV4KX1uZXcgTm9kZSh7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6bCxub2RlSW5kaWNlczp1LHRlbnNvckluZGljZXM6YyxpbnB1dFRlbnNvcnM6cyxvdXRwdXRUZW5zb3JzOnQsaW5wdXRNYXNrczpuLG91dHB1dE1hc2tzOnIsaW5wdXRTaGFwZXM6aSxvdXRwdXRTaGFwZXM6YX0sbyk7Zm9yKHZhciBmPTA7Zjx0Lmxlbmd0aDtmKyspdFtmXS5zb3VyY2VMYXllcj10aGlzLHRbZl0ubm9kZUluZGV4PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aC0xLHRbZl0udGVuc29ySW5kZXg9Zn0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9e25hbWU6dGhpcy5uYW1lLHRyYWluYWJsZTp0aGlzLnRyYWluYWJsZX07cmV0dXJuIG51bGwhPXRoaXMuYmF0Y2hJbnB1dFNoYXBlJiYoZS5iYXRjaElucHV0U2hhcGU9dGhpcy5iYXRjaElucHV0U2hhcGUpLG51bGwhPXRoaXMuZHR5cGUmJihlLmR0eXBlPXRoaXMuZHR5cGUpLGV9LHQucHJvdG90eXBlLmRpc3Bvc2VXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRpc3Bvc2UoKX0pLHRoaXMud2VpZ2h0cy5sZW5ndGh9LHQucHJvdG90eXBlLmFzc2VydE5vdERpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuX3JlZkNvdW50KXRocm93IG5ldyBFcnJvcihcIkxheWVyICdcIit0aGlzLm5hbWUrXCInIGlzIGFscmVhZHkgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpc3Bvc2UgTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIGJ1aWx0IHlldC5cIik7aWYobnVsbD09PXRoaXMuX3JlZkNvdW50KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXNwb3NlIExheWVyIFwiK3RoaXMubmFtZStcIiBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiB1c2VkIHlldC5cIik7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO3ZhciBlPTA7cmV0dXJuIDA9PS0tdGhpcy5fcmVmQ291bnQmJihlPXRoaXMuZGlzcG9zZVdlaWdodHMoKSkse3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOmV9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSk7ZnVuY3Rpb24gY29sbGVjdElucHV0U2hhcGUoZSl7Zm9yKHZhciB0PVtdLG49MCxyPWU9dG9MaXN0KGUpO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO3QucHVzaChpLnNoYXBlKX1yZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0KX1mdW5jdGlvbiBndWVzc091dHB1dERUeXBlKGUpe3JldHVyblwiZmxvYXQzMlwifWZ1bmN0aW9uIGdldFNvdXJjZUlucHV0cyhlLHQsbil7aWYoKG51bGw9PXR8fG51bGwhPW4mJm4+MCkmJih0PWUuc291cmNlTGF5ZXIsbj1lLm5vZGVJbmRleCksMD09PXQuaW5ib3VuZE5vZGVzLmxlbmd0aClyZXR1cm5bZV07dmFyIHI9dC5pbmJvdW5kTm9kZXNbbl07aWYoMD09PXIuaW5ib3VuZExheWVycy5sZW5ndGgpcmV0dXJuIHIuaW5wdXRUZW5zb3JzO2Zvcih2YXIgaT1bXSxhPTA7YTxyLmluYm91bmRMYXllcnMubGVuZ3RoO2ErKylmb3IodmFyIG89MCxzPWdldFNvdXJjZUlucHV0cyhyLmlucHV0VGVuc29yc1thXSxyLmluYm91bmRMYXllcnNbYV0sci5ub2RlSW5kaWNlc1thXSk7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107LTE9PT1pLmluZGV4T2YobCkmJmkucHVzaChsKX1yZXR1cm4gaX12YXIgTW9kZWxMb2dnaW5nVmVyYm9zaXR5LElucHV0TGF5ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx7ZHR5cGU6dC5kdHlwZSxuYW1lOm51bGwhPXQubmFtZT90Lm5hbWU6Z2V0VWlkKFwiaW5wdXRcIikudG9TdHJpbmcoKX0pfHx0aGlzO2lmKG51bGw9PXQuYmF0Y2hTaXplJiYodC5iYXRjaFNpemU9bnVsbCksbnVsbD09dC5zcGFyc2UmJih0LnNwYXJzZT0hMSksbi50cmFpbmFibGU9ITEsbi5idWlsdD0hMCxuLnNwYXJzZT10LnNwYXJzZSxudWxsIT10LmlucHV0U2hhcGUmJm51bGwhPXQuYmF0Y2hJbnB1dFNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiT25seSBwcm92aWRlIHRoZSBpbnB1dFNoYXBlIE9SIGJhdGNoSW5wdXRTaGFwZSBhcmd1bWVudCB0byBpbnB1dExheWVyLCBub3QgYm90aCBhdCB0aGUgc2FtZSB0aW1lLlwiKTt2YXIgcj10LmJhdGNoSW5wdXRTaGFwZTtpZihudWxsPT1yKXtpZihudWxsPT10LmlucHV0U2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbiBJbnB1dExheWVyIHNob3VsZCBiZSBwYXNzZWQgZWl0aGVyIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3IgYW4gYGlucHV0U2hhcGVgLlwiKTtyPVt0LmJhdGNoU2l6ZV0uY29uY2F0KHQuaW5wdXRTaGFwZSl9ZWxzZSBpZihudWxsIT10LmJhdGNoU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJhdGNoU2l6ZSBpZiBiYXRjaElucHV0U2hhcGUgaXMgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgYW4gSW5wdXRMYXllci5cIik7dmFyIGk9dC5kdHlwZXx8XCJmbG9hdDMyXCI7bi5iYXRjaElucHV0U2hhcGU9cixuLmR0eXBlPWksbi5pbnB1dFNwZWM9W3tzaGFwZTpyfV07dmFyIGE9bmV3IFN5bWJvbGljVGVuc29yKG4uZHR5cGUsbi5iYXRjaElucHV0U2hhcGUsbixbXSx7fSxuLm5hbWUpO3JldHVybiBhLm5vZGVJbmRleD0wLGEudGVuc29ySW5kZXg9MCxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjpuLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6W2FdLG91dHB1dFRlbnNvcnM6W2FdLGlucHV0TWFza3M6W251bGxdLG91dHB1dE1hc2tzOltudWxsXSxpbnB1dFNoYXBlczpbcl0sb3V0cHV0U2hhcGVzOltyXX0pLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgcGFzcyBhbnkgaW5wdXQgdG8gYW4gSW5wdXRMYXllcidzIGFwcGx5KCkgbWV0aG9kLiBJbnB1dExheWVyIG5hbWU6IFwiK3RoaXMubmFtZSl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm57cmVmQ291bnRBZnRlckRpc3Bvc2U6dGhpcy5fcmVmQ291bnQsbnVtRGlzcG9zZWRWYXJpYWJsZXM6MH19LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntiYXRjaElucHV0U2hhcGU6dGhpcy5iYXRjaElucHV0U2hhcGUsZHR5cGU6dGhpcy5kdHlwZSxzcGFyc2U6dGhpcy5zcGFyc2UsbmFtZTp0aGlzLm5hbWV9fSx0LmNsYXNzTmFtZT1cIklucHV0TGF5ZXJcIix0fShMYXllcik7ZnVuY3Rpb24gSW5wdXQoZSl7aWYobnVsbD09ZS5iYXRjaFNoYXBlJiZudWxsPT1lLnNoYXBlKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRvIElucHV0IGVpdGhlciBhIGBzaGFwZWAgb3IgYSBgYmF0Y2hTaGFwZWAgYXJndW1lbnQuIE5vdGUgdGhhdCBgc2hhcGVgIGRvZXMgbm90IGluY2x1ZGUgdGhlIGJhdGNoIGRpbWVuc2lvbi5cIik7aWYobnVsbCE9ZS5iYXRjaFNoYXBlJiZudWxsIT1lLnNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHNoYXBlYCBvciBgYmF0Y2hTaGFwZWAgYXJndW1lbnQgdG8gSW5wdXQsIGJ1dCBub3QgYm90aC5cIik7dmFyIHQ9ZS5iYXRjaFNoYXBlO251bGwhPWUuc2hhcGUmJm51bGw9PXQmJih0PVtudWxsXS5jb25jYXQoZS5zaGFwZSkpO3ZhciBuPWUuZHR5cGU7cmV0dXJuIG51bGw9PW4mJihuPVwiZmxvYXQzMlwiKSxuZXcgSW5wdXRMYXllcih7YmF0Y2hJbnB1dFNoYXBlOnQsbmFtZTplLm5hbWUsZHR5cGU6bixzcGFyc2U6ZS5zcGFyc2V9KS5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXX1mdW5jdGlvbiByZXNvbHZlU2NhbGFyc0luTG9ncyhlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG4scixpLGEsbyxzLGw7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDppZihudWxsPT1lKXJldHVyblsyXTtmb3IoaSBpbiB0PVtdLG49W10scj1bXSxlKVwibnVtYmVyXCIhPXR5cGVvZihhPWVbaV0pJiYobz1hLHQucHVzaChvLmRhdGEoKSksbi5wdXNoKGkpLHIucHVzaChvKSk7cmV0dXJuIHQubGVuZ3RoPjA/WzQsUHJvbWlzZS5hbGwodCldOlszLDJdO2Nhc2UgMTpmb3Iocz11LnNlbnQoKSxsPTA7bDxzLmxlbmd0aDsrK2wpZVtuW2xdXT1zW2xdWzBdO2Rpc3Bvc2UociksdS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl19fSl9KX1mdW5jdGlvbiBkaXNwb3NlVGVuc29yc0luTG9ncyhlKXtpZihudWxsIT1lKWZvcih2YXIgdCBpbiBlKXt2YXIgbj1lW3RdO1wibnVtYmVyXCIhPXR5cGVvZiBuJiZuLmRpc3Bvc2UoKX19c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKElucHV0TGF5ZXIpLGZ1bmN0aW9uKGUpe2VbZS5TSUxFTlQ9MF09XCJTSUxFTlRcIixlW2UuVkVSQk9TRT0xXT1cIlZFUkJPU0VcIn0oTW9kZWxMb2dnaW5nVmVyYm9zaXR5fHwoTW9kZWxMb2dnaW5nVmVyYm9zaXR5PXt9KSk7dmFyIERFRkFVTFRfWUlFTERfRVZFUllfTVM9MTI1LEJhc2VDYWxsYmFjaz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLnZhbGlkYXRpb25EYXRhPW51bGx9cmV0dXJuIGUucHJvdG90eXBlLnNldFBhcmFtcz1mdW5jdGlvbihlKXt0aGlzLnBhcmFtcz1lfSxlLnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKGUpe30sZX0oKSxDYWxsYmFja0xpc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dm9pZCAwPT09dCYmKHQ9MTApLG51bGw9PWUmJihlPVtdKSx0aGlzLmNhbGxiYWNrcz1lLHRoaXMucXVldWVMZW5ndGg9dH1yZXR1cm4gZS5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKGUpe3RoaXMuY2FsbGJhY2tzLnB1c2goZSl9LGUucHJvdG90eXBlLnNldFBhcmFtcz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPXRoaXMuY2FsbGJhY2tzO3Q8bi5sZW5ndGg7dCsrKXtuW3RdLnNldFBhcmFtcyhlKX19LGUucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49dGhpcy5jYWxsYmFja3M7dDxuLmxlbmd0aDt0Kyspe25bdF0uc2V0TW9kZWwoZSl9fSxlLnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpudWxsPT10JiYodD17fSksbj0wLHI9dGhpcy5jYWxsYmFja3MsaS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD9bNCxyW25dLm9uRXBvY2hCZWdpbihlLHQpXTpbMyw0XTtjYXNlIDI6aS5zZW50KCksaS5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOm51bGw9PXQmJih0PXt9KSxuPTAscj10aGlzLmNhbGxiYWNrcyxpLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoP1s0LHJbbl0ub25FcG9jaEVuZChlLHQpXTpbMyw0XTtjYXNlIDI6aS5zZW50KCksaS5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUub25CYXRjaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6bnVsbD09dCYmKHQ9e30pLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkJhdGNoQmVnaW4oZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpudWxsPT10JiYodD17fSksbj0wLHI9dGhpcy5jYWxsYmFja3MsaS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD9bNCxyW25dLm9uQmF0Y2hFbmQoZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpudWxsPT1lJiYoZT17fSksdD0wLG49dGhpcy5jYWxsYmFja3Msci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gdDxuLmxlbmd0aD9bNCxuW3RdLm9uVHJhaW5CZWdpbihlKV06WzMsNF07Y2FzZSAyOnIuc2VudCgpLHIubGFiZWw9MztjYXNlIDM6cmV0dXJuIHQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6bnVsbD09ZSYmKGU9e30pLHQ9MCxuPXRoaXMuY2FsbGJhY2tzLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHQ8bi5sZW5ndGg/WzQsblt0XS5vblRyYWluRW5kKGUpXTpbMyw0XTtjYXNlIDI6ci5zZW50KCksci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gdCsrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZX0oKSxCYXNlTG9nZ2VyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gZS5jYWxsKHRoaXMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZWVuPTAsdGhpcy50b3RhbHM9e30sWzJdfSl9KX0sdC5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGksYT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG8pe2ZvcihpIGluIG51bGw9PXQmJih0PXt9KSxlPW51bGw9PXQuc2l6ZT8wOnQuc2l6ZSx0aGlzLnNlZW4rPWUsbj1mdW5jdGlvbihuKXt2YXIgaT10W25dO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpKXIudG90YWxzLmhhc093blByb3BlcnR5KG4pfHwoci50b3RhbHNbbl09MCksci50b3RhbHNbbl09ci50b3RhbHNbbl0raSplO2Vsc2V7dmFyIG89dm9pZCAwO24gaW4gci50b3RhbHM/bz1yLnRvdGFsc1tuXTpyLnRvdGFsc1tuXT0wLHIudG90YWxzW25dPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gYWRkKGEudG90YWxzW25dLG11bChpLGUpKX0pLG51bGwhPW8mJm8uZGlzcG9zZSgpfX0scj10aGlzLHQpbihpKTtyZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsaSxhLG89dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihzKXtpZihudWxsIT10KWZvcihlPWZ1bmN0aW9uKGUpe2lmKG51bGw9PW4udG90YWxzW2VdKXJldHVyblwiY29udGludWVcIjtcIm51bWJlclwiPT10eXBlb2Ygbi50b3RhbHNbZV0/dFtlXT1uLnRvdGFsc1tlXS9uLnNlZW46dGlkeShmdW5jdGlvbigpe3RbZV09bXVsKGRpdigxLG8uc2Vlbiksby50b3RhbHNbZV0pLG8udG90YWxzW2VdLmRpc3Bvc2UoKSxrZWVwKHRbZV0pfSl9LG49dGhpcyxyPTAsaT10aGlzLnBhcmFtcy5tZXRyaWNzO3I8aS5sZW5ndGg7cisrKWE9aVtyXSxlKGEpO3JldHVyblsyXX0pfSl9LHR9KEJhc2VDYWxsYmFjayksSGlzdG9yeT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZXBvY2g9W10sdGhpcy5oaXN0b3J5PXt9LFsyXX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe2ZvcihuIGluIG51bGw9PXQmJih0PXt9KSx0aGlzLmVwb2NoLnB1c2goZSksdCludWxsPT10aGlzLmhpc3Rvcnlbbl0mJih0aGlzLmhpc3Rvcnlbbl09W10pLHRoaXMuaGlzdG9yeVtuXS5wdXNoKHRbbl0pO3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLnN5bmNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSx0LG4scixpLGEsbyxzLGw7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpmb3IociBpbiBlPVtdLHQ9W10sbj1bXSx0aGlzLmhpc3RvcnkpZm9yKGk9dGhpcy5oaXN0b3J5W3JdLGE9MDthPGkubGVuZ3RoOysrYSlcIm51bWJlclwiIT10eXBlb2YgaVthXSYmKG89aVthXSxlLnB1c2goby5kYXRhKCkpLHQucHVzaChyKSxuLnB1c2goYSkpO3JldHVybls0LFByb21pc2UuYWxsKGUpXTtjYXNlIDE6Zm9yKHM9dS5zZW50KCksbD0wO2w8cy5sZW5ndGg7KytsKXRoaXMuaGlzdG9yeVt0W2xdXVtuW2xdXS5kaXNwb3NlKCksdGhpcy5oaXN0b3J5W3RbbF1dW25bbF1dPXNbbF1bMF07cmV0dXJuWzJdfX0pfSl9LHR9KEJhc2VDYWxsYmFjayksQ3VzdG9tQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4pe3ZhciByPWUuY2FsbCh0aGlzKXx8dGhpcztpZihyLmN1cnJlbnRFcG9jaD0wLHIueWllbGRFdmVyeT1ufHxcImF1dG9cIixcImF1dG9cIj09PXIueWllbGRFdmVyeSYmKHIueWllbGRFdmVyeT1ERUZBVUxUX1lJRUxEX0VWRVJZX01TKSxcIm5ldmVyXCI9PT1yLnlpZWxkRXZlcnkmJm51bGwhPXQub25ZaWVsZCl0aHJvdyBuZXcgRXJyb3IoXCJ5aWVsZEV2ZXJ5IGlzIGBuZXZlcmAgYnV0IHlvdSBwcm92aWRlZCBhbiBgb25ZaWVsZGAgY2FsbGJhY2suIEVpdGhlciBjaGFuZ2UgYHlpZWxkRXZlcnlgIG9yIHJlbW92ZSB0aGUgY2FsbGJhY2tcIik7cmV0dXJuIHV0aWwuaXNOdW1iZXIoci55aWVsZEV2ZXJ5KSYmKHIubWF5YmVXYWl0PWRlYm91bmNlKHIubWF5YmVXYWl0LmJpbmQociksci55aWVsZEV2ZXJ5KSksci50cmFpbkJlZ2luPXQub25UcmFpbkJlZ2luLHIudHJhaW5FbmQ9dC5vblRyYWluRW5kLHIuZXBvY2hCZWdpbj10Lm9uRXBvY2hCZWdpbixyLmVwb2NoRW5kPXQub25FcG9jaEVuZCxyLmJhdGNoQmVnaW49dC5vbkJhdGNoQmVnaW4sci5iYXRjaEVuZD10Lm9uQmF0Y2hFbmQsci55aWVsZD10Lm9uWWllbGQscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWF5YmVXYWl0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHI9W10sbnVsbD09dGhpcy55aWVsZD9bMywyXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhuKV07Y2FzZSAxOmkuc2VudCgpLHIucHVzaCh0aGlzLnlpZWxkKGUsdCxuKSksaS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gci5wdXNoKG5leHRGcmFtZSgpKSxbNCxQcm9taXNlLmFsbChyKV07Y2FzZSAzOnJldHVybiBpLnNlbnQoKSxbMl19fSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmN1cnJlbnRFcG9jaD1lLG51bGw9PXRoaXMuZXBvY2hCZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbNCx0aGlzLmVwb2NoQmVnaW4oZSx0KV07Y2FzZSAyOm4uc2VudCgpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49W10sbnVsbD09dGhpcy5lcG9jaEVuZD9bMywyXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnIuc2VudCgpLG4ucHVzaCh0aGlzLmVwb2NoRW5kKGUsdCkpLHIubGFiZWw9MjtjYXNlIDI6cmV0dXJuXCJlcG9jaFwiPT09dGhpcy55aWVsZEV2ZXJ5JiZuLnB1c2gobmV4dEZyYW1lKCkpLFs0LFByb21pc2UuYWxsKG4pXTtjYXNlIDM6cmV0dXJuIHIuc2VudCgpLFsyXX19KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMuYmF0Y2hCZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbNCx0aGlzLmJhdGNoQmVnaW4oZSx0KV07Y2FzZSAyOm4uc2VudCgpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49W10sbnVsbD09dGhpcy5iYXRjaEVuZD9bMywyXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnIuc2VudCgpLG4ucHVzaCh0aGlzLmJhdGNoRW5kKGUsdCkpLHIubGFiZWw9MjtjYXNlIDI6cmV0dXJuXCJiYXRjaFwiPT09dGhpcy55aWVsZEV2ZXJ5P24ucHVzaChuZXh0RnJhbWUoKSk6dXRpbC5pc051bWJlcih0aGlzLnlpZWxkRXZlcnkpJiZuLnB1c2godGhpcy5tYXliZVdhaXQodGhpcy5jdXJyZW50RXBvY2gsZSx0KSksWzQsUHJvbWlzZS5hbGwobildO2Nhc2UgMzpyZXR1cm4gci5zZW50KCksWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMudHJhaW5CZWdpbj9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhlKV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbNCx0aGlzLnRyYWluQmVnaW4oZSldO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5vblRyYWluRW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy50cmFpbkVuZD9bMywzXTpbNCxyZXNvbHZlU2NhbGFyc0luTG9ncyhlKV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbNCx0aGlzLnRyYWluRW5kKGUpXTtjYXNlIDI6dC5zZW50KCksdC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdH0oQmFzZUNhbGxiYWNrKTtmdW5jdGlvbiBzdGFuZGFyZGl6ZUNhbGxiYWNrcyhlLHQpe3JldHVybiBudWxsPT1lJiYoZT17fSksZSBpbnN0YW5jZW9mIEJhc2VDYWxsYmFjaz9bZV06QXJyYXkuaXNBcnJheShlKSYmZVswXWluc3RhbmNlb2YgQmFzZUNhbGxiYWNrP2U6dG9MaXN0KGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEN1c3RvbUNhbGxiYWNrKGUsdCl9KX12YXIgQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5yZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3I9ZnVuY3Rpb24odCxuKXt1dGlsLmFzc2VydCh0Pj0wJiZOdW1iZXIuaXNJbnRlZ2VyKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJWZXJib3NpdHkgbGV2ZWwgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlciA+PSAwLCBidXQgZ290IFwiK3R9KSxlLmNoZWNrRm9yRHVwbGljYXRlKG4pLG51bGw9PWUuY29uc3RydWN0b3JzW3RdJiYoZS5jb25zdHJ1Y3RvcnNbdF09W10pLGUuY29uc3RydWN0b3JzW3RdLnB1c2gobil9LGUuY2hlY2tGb3JEdXBsaWNhdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBuIGluIGUuY29uc3RydWN0b3JzKXtlLmNvbnN0cnVjdG9yc1srbl0uZm9yRWFjaChmdW5jdGlvbihlKXtpZihlPT09dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSBjYWxsYmFjayBjb25zdHJ1Y3Rvci5cIil9KX19LGUuY2xlYXI9ZnVuY3Rpb24oKXtlLmNvbnN0cnVjdG9ycz17fX0sZS5jcmVhdGVDYWxsYmFja3M9ZnVuY3Rpb24odCl7dmFyIG49W107Zm9yKHZhciByIGluIGUuY29uc3RydWN0b3JzKXt2YXIgaT0rcjt0Pj1pJiZuLnB1c2guYXBwbHkobixlLmNvbnN0cnVjdG9yc1tpXSl9cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgZX0pfSxlLmNvbnN0cnVjdG9ycz17fSxlfSgpO2Z1bmN0aW9uIGNvbmZpZ3VyZUNhbGxiYWNrcyhlLHQsbixyLGksYSxvLHMsbCl7dmFyIHU9bmV3IEhpc3RvcnksYz1bbmV3IEJhc2VMb2dnZXJdLmNvbmNhdChDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkuY3JlYXRlQ2FsbGJhY2tzKHQpKTtudWxsIT1lJiZjLnB1c2guYXBwbHkoYyxlKSxjLnB1c2godSk7dmFyIHA9bmV3IENhbGxiYWNrTGlzdChjKTtyZXR1cm4gcC5zZXRQYXJhbXMoe2Vwb2NoczpuLGluaXRpYWxFcG9jaDpyLHNhbXBsZXM6aSxzdGVwczphLGJhdGNoU2l6ZTpvLHZlcmJvc2U6dCxkb1ZhbGlkYXRpb246cyxtZXRyaWNzOmx9KSx7Y2FsbGJhY2tMaXN0OnAsaGlzdG9yeTp1fX1mdW5jdGlvbiBsMk5vcm1hbGl6ZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7XCJmbG9hdDMyXCIhPT1lLmR0eXBlJiYoZT1lLmFzVHlwZShcImZsb2F0MzJcIikpO3ZhciBuPXN1bShzcXVhcmUoZSksdCwhMCkscj1maWxsKG4uc2hhcGUsZXBzaWxvbigpKSxpPXNxcnQobWF4aW11bShuLHIpKTtyZXR1cm4gZGl2KGUsaSl9KX1mdW5jdGlvbiBtZWFuU3F1YXJlZEVycm9yKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbWVhbihzcXVhcmUoc3ViKHQsZSkpLC0xKX0pfWZ1bmN0aW9uIG1lYW5BYnNvbHV0ZUVycm9yKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbWVhbihhYnMoc3ViKHQsZSkpLC0xKX0pfWZ1bmN0aW9uIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49c3ViKGUsdCkscj1jbGlwQnlWYWx1ZShhYnMoZSksZXBzaWxvbigpLE51bWJlci5NQVhfVkFMVUUpLGk9YWJzKGRpdihuLHIpKTtyZXR1cm4gbXVsKDEwMCxtZWFuKGksLTEpKX0pfWZ1bmN0aW9uIG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSkscj1sb2coYWRkKDEsbikpLGk9Y2xpcEJ5VmFsdWUoZSxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSksYT1sb2coYWRkKDEsaSkpO3JldHVybiBtZWFuKHNxdWFyZShzdWIocixhKSksLTEpfSl9ZnVuY3Rpb24gc3F1YXJlZEhpbmdlKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1tYXhpbXVtKDAsc3ViKDEsbXVsKGUsdCkpKTtyZXR1cm4gbWVhbihzcXVhcmUobiksLTEpfSl9ZnVuY3Rpb24gaGluZ2UoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPW1heGltdW0oMCxzdWIoMSxtdWwoZSx0KSkpO3JldHVybiBtZWFuKG4sLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxIaW5nZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49c3VtKG11bChlLHQpLC0xKSxyPW1heChtdWwoc3ViKDEsZSksdCksLTEpO3JldHVybiBtYXhpbXVtKDAsYWRkKDEsc3ViKHIsbikpKX0pfWZ1bmN0aW9uIGxvZ2Nvc2goZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPU1hdGgubG9nKDIpLHI9c3ViKHQsZSksaT1zdWIoYWRkKHIsc29mdHBsdXMobXVsKC0yLHIpKSksbik7cmV0dXJuIG1lYW4oaSwtMSl9KX1mdW5jdGlvbiBjYXRlZ29yaWNhbENyb3NzZW50cm9weShlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSx0aWR5KGZ1bmN0aW9uKCl7aWYobil0PXNvZnRtYXgodCk7ZWxzZXt2YXIgcj1zdW0odCx0LnNoYXBlLmxlbmd0aC0xLCEwKTt0PWRpdih0LHIpfXJldHVybiB0PWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLDEtZXBzaWxvbigpKSxuZWcoc3VtKG11bChlLnRvRmxvYXQoKSxsb2codCkpLHQuc2hhcGUubGVuZ3RoLTEpKX0pfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1mbG9vcihmbGF0dGVuKGUpKS50b0ludCgpLHI9KHQ9Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksMS1lcHNpbG9uKCkpKS5zaGFwZTtyZXR1cm4gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkob25lSG90KG4scltyLmxlbmd0aC0xXSkucmVzaGFwZShyKSx0LCExKX0pfWZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKGUsdCl7aWYoIXV0aWwuYXJyYXlzRXF1YWwoZS5zaGFwZSx0LnNoYXBlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImxvZ2l0cyBhbmQgbGFiZWxzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZSwgYnV0IGdvdCBzaGFwZXMgXCIrSlNPTi5zdHJpbmdpZnkoZS5zaGFwZSkrXCIgYW5kIFwiK0pTT04uc3RyaW5naWZ5KHQuc2hhcGUpKTtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXQucmVsdSgpLHI9dC5hYnMoKS5uZWcoKTtyZXR1cm4gbi5zdWIodC5tdWwoZSkpLmFkZChyLmV4cCgpLmxvZzFwKCkpfSl9ZnVuY3Rpb24gYmluYXJ5Q3Jvc3NlbnRyb3B5KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxLWVwc2lsb24oKSksbj1sb2coZGl2KG4sc3ViKDEsbikpKSxtZWFuKHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKGUsbiksLTEpfSl9ZnVuY3Rpb24ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2xpcEJ5VmFsdWUoZSxlcHNpbG9uKCksMSkscj1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxKTtyZXR1cm4gc3VtKG11bChlLGxvZyhkaXYobixyKSkpLC0xKX0pfWZ1bmN0aW9uIHBvaXNzb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWxvZyhhZGQoZXBzaWxvbigpLHQpKTtyZXR1cm4gbWVhbihzdWIodCxtdWwoZSxuKSksLTEpfSl9ZnVuY3Rpb24gY29zaW5lUHJveGltaXR5KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1sMk5vcm1hbGl6ZShlLC0xKSxyPWwyTm9ybWFsaXplKHQsLTEpLGk9bXVsKG4scik7cmV0dXJuIG5lZyhzdW0oaSwtMSkpfSl9ZnVuY3Rpb24gZ2V0KGUpe3ZhciB0PXttZWFuU3F1YXJlZEVycm9yOm1lYW5TcXVhcmVkRXJyb3IsbWVhbkFic29sdXRlRXJyb3I6bWVhbkFic29sdXRlRXJyb3IsbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I6bWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yLHNxdWFyZWRIaW5nZTpzcXVhcmVkSGluZ2UsaGluZ2U6aGluZ2UsY2F0ZWdvcmljYWxIaW5nZTpjYXRlZ29yaWNhbEhpbmdlLGxvZ2Nvc2g6bG9nY29zaCxjYXRlZ29yaWNhbENyb3NzZW50cm9weTpjYXRlZ29yaWNhbENyb3NzZW50cm9weSxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTpzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSxiaW5hcnlDcm9zc2VudHJvcHk6YmluYXJ5Q3Jvc3NlbnRyb3B5LGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2U6a3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZSxwb2lzc29uOnBvaXNzb24sY29zaW5lUHJveGltaXR5OmNvc2luZVByb3hpbWl0eX07aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKGUgaW4gdClyZXR1cm4gdFtlXTt2YXIgbj1cIlVua25vd24gbG9zcyBcIitlO3Rocm93IGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNvZnRtYXhjcm9zc2VudHJvcHlcIikmJihuPVwiVW5rbm93biBsb3NzIFwiK2UrJy4gVXNlIFwiY2F0ZWdvcmljYWxDcm9zc2VudHJvcHlcIiBhcyB0aGUgc3RyaW5nIG5hbWUgZm9yIHRmLmxvc3Nlcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5JyksbmV3IFZhbHVlRXJyb3Iobil9cmV0dXJuIGV9ZnVuY3Rpb24gYmluYXJ5QWNjdXJhY3koZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPW11bCguNSxvbmVzTGlrZSh0KSkscj1jYXN0JDEoZ3JlYXRlcih0LG4pLGUuZHR5cGUpO3JldHVybiBtZWFuKGVxdWFsKGUsciksLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxBY2N1cmFjeShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNhc3QkMShlcXVhbChhcmdNYXgoZSwtMSksYXJnTWF4KHQsLTEpKSxcImZsb2F0MzJcIil9KX1mdW5jdGlvbiB0cnVlUG9zaXRpdmVzKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbG9naWNhbEFuZChlLmVxdWFsKDEpLHQuZXF1YWwoMSkpLnN1bSgpLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gZmFsc2VOZWdhdGl2ZXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwoMSksdC5lcXVhbCgwKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZVBvc2l0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGxvZ2ljYWxBbmQoZS5lcXVhbCgwKSx0LmVxdWFsKDEpKS5zdW0oKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIHByZWNpc2lvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49dHJ1ZVBvc2l0aXZlcyhlLHQpLHI9ZmFsc2VQb3NpdGl2ZXMoZSx0KSxpPW4uYWRkKHIpO3JldHVybiB3aGVyZShncmVhdGVyKGksMCksbi5kaXYoaSksMCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiByZWNhbGwoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXRydWVQb3NpdGl2ZXMoZSx0KSxyPWZhbHNlTmVnYXRpdmVzKGUsdCksaT1uLmFkZChyKTtyZXR1cm4gd2hlcmUoZ3JlYXRlcihpLDApLG4uZGl2KGkpLDApLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gYmluYXJ5Q3Jvc3NlbnRyb3B5JDEoZSx0KXtyZXR1cm4gYmluYXJ5Q3Jvc3NlbnRyb3B5KGUsdCl9ZnVuY3Rpb24gc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeShlLHQpe3JldHVybiBlLnJhbms9PT10LnJhbmsmJihlPWUuc3F1ZWV6ZShbZS5yYW5rLTFdKSksKHQ9dC5hcmdNYXgoLTEpKS5kdHlwZSE9PWUuZHR5cGUmJih0PXQuYXNUeXBlKGUuZHR5cGUpKSxlcXVhbChlLHQpLmFzVHlwZShcImZsb2F0MzJcIil9dmFyIG1zZSQxPW1lYW5TcXVhcmVkRXJyb3IsTVNFJDE9bWVhblNxdWFyZWRFcnJvcixtYWUkMT1tZWFuQWJzb2x1dGVFcnJvcixNQUUkMT1tZWFuQWJzb2x1dGVFcnJvcixtYXBlJDE9bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLE1BUEUkMT1tZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMT1jYXRlZ29yaWNhbENyb3NzZW50cm9weSxjb3NpbmUkMT1jb3NpbmVQcm94aW1pdHksc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTtmdW5jdGlvbiBnZXQkMShlKXt2YXIgdD17YmluYXJ5QWNjdXJhY3k6YmluYXJ5QWNjdXJhY3ksY2F0ZWdvcmljYWxBY2N1cmFjeTpjYXRlZ29yaWNhbEFjY3VyYWN5LHByZWNpc2lvbjpwcmVjaXNpb24sY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTpzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSQxLG1zZTptc2UkMSxNU0U6TVNFJDEsbWFlOm1hZSQxLE1BRTpNQUUkMSxtYXBlOm1hcGUkMSxNQVBFOk1BUEUkMSxjb3NpbmU6Y29zaW5lJDF9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZlIGluIHQpcmV0dXJuIHRbZV07aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUmJm51bGwhPWUpcmV0dXJuIGU7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIG1ldHJpYyBcIitlKX1mdW5jdGlvbiBnZXRPcHRpbWl6ZXIoZSl7dmFyIHQ9e0FkYWdyYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhZ3JhZCguMDEpfSxBZGFkZWx0YTpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFkZWx0YSgxLC45NSxlcHNpbG9uKCkpfSxBZGFtOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYW0oLjAwMSwuOSwuOTk5LGVwc2lsb24oKSl9LEFkYW1heDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFtYXgoLjAwMiwuOSwuOTk5LGVwc2lsb24oKSwwKX0sUk1TUHJvcDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5ybXNwcm9wKC4wMDEsLjksMCxlcHNpbG9uKCkpfSxTR0Q6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uc2dkKC4wMSl9fTtpZih0LmFkYWdyYWQ9dC5BZGFncmFkLHQuYWRhZGVsdGE9dC5BZGFkZWx0YSx0LmFkYW09dC5BZGFtLHQuYWRhbWF4PXQuQWRhbWF4LHQucm1zcHJvcD10LlJNU1Byb3AsdC5zZ2Q9dC5TR0QsZSBpbiB0KXJldHVybiB0W2VdKCk7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIE9wdGltaXplciBcIitlKX1mdW5jdGlvbiBwcmludFN1bW1hcnkoZSx0LG4scil7dm9pZCAwPT09ciYmKHI9Y29uc29sZS5sb2cpO3ZhciBpLGE9aXNNb2RlbFNlcXVlbnRpYWxMaWtlKGUpLG89W1wiTGF5ZXIgKHR5cGUpXCIsXCJPdXRwdXQgc2hhcGVcIixcIlBhcmFtICNcIl07aWYoYT8odD10fHw2NSxuPW58fFsuNDUsLjg1LDFdKToodD10fHw5OCxuPW58fFsuMzMsLjU1LC42NywxXSksbltuLmxlbmd0aC0xXTw9MSYmKG49bi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIE1hdGguZmxvb3IodCplKX0pKSwhYSlmb3IodmFyIHMgaW4gby5wdXNoKFwiUmVjZWl2ZXMgaW5wdXRzXCIpLGk9W10sZS5ub2Rlc0J5RGVwdGgpaS5wdXNoLmFwcGx5KGksZS5ub2Rlc0J5RGVwdGhbc10pO3IoXCJfXCIucmVwZWF0KHQpKSxwcmludFJvdyhvLG4scikscihcIj1cIi5yZXBlYXQodCkpO2Zvcih2YXIgbD1lLmxheWVycyx1PTA7dTxsLmxlbmd0aDsrK3UpYT9wcmludExheWVyU3VtbWFyeShsW3VdLG4scik6cHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMobFt1XSxuLGkscikscigodT09PWwubGVuZ3RoLTE/XCI9XCI6XCJfXCIpLnJlcGVhdCh0KSk7ZS5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpO3ZhciBjPWNvdW50VHJhaW5hYmxlUGFyYW1zKGUpLHA9Y291bnRQYXJhbXNJbldlaWdodHMoZS5ub25UcmFpbmFibGVXZWlnaHRzKTtyKFwiVG90YWwgcGFyYW1zOiBcIisoYytwKSkscihcIlRyYWluYWJsZSBwYXJhbXM6IFwiK2MpLHIoXCJOb24tdHJhaW5hYmxlIHBhcmFtczogXCIrcCkscihcIl9cIi5yZXBlYXQodCkpfWZ1bmN0aW9uIGNvdW50VHJhaW5hYmxlUGFyYW1zKGUpe3JldHVybiBudWxsIT1lLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHM/Y291bnRQYXJhbXNJbldlaWdodHMoZS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzKTpjb3VudFBhcmFtc0luV2VpZ2h0cyhlLnRyYWluYWJsZVdlaWdodHMpfWZ1bmN0aW9uIGlzTW9kZWxTZXF1ZW50aWFsTGlrZShlKXt2YXIgdD0hMCxuPVtdLHI9W107Zm9yKHZhciBpIGluIGUubm9kZXNCeURlcHRoKW4ucHVzaChlLm5vZGVzQnlEZXB0aFtpXSk7Zm9yKHZhciBhPTAsbz1uO2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdO2lmKHMubGVuZ3RoPjF8fDE9PT1zLmxlbmd0aCYmc1swXS5pbmJvdW5kTGF5ZXJzLmxlbmd0aD4xKXt0PSExO2JyZWFrfXIucHVzaC5hcHBseShyLHMpfWlmKHQpZm9yKHZhciBsPTAsdT1lLmxheWVycztsPHUubGVuZ3RoO2wrKyl7Zm9yKHZhciBjPSExLHA9MCxoPXVbbF0uaW5ib3VuZE5vZGVzO3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO2lmKC0xIT09ci5pbmRleE9mKGQpKXtpZihjKXt0PSExO2JyZWFrfWM9ITB9fWlmKCF0KWJyZWFrfXJldHVybiB0fWZ1bmN0aW9uIHByaW50Um93KGUsdCxuKXt2b2lkIDA9PT1uJiYobj1jb25zb2xlLmxvZyk7Zm9yKHZhciByPVwiXCIsaT0wO2k8ZS5sZW5ndGg7KytpKWk+MCYmKHI9ci5zbGljZSgwLHIubGVuZ3RoLTEpK1wiIFwiKSxyPShyKz1lW2ldKS5zbGljZSgwLHRbaV0pLHIrPVwiIFwiLnJlcGVhdCh0W2ldLXIubGVuZ3RoKTtuKHIpfWZ1bmN0aW9uIHByaW50TGF5ZXJTdW1tYXJ5KGUsdCxuKXt2YXIgcjt0cnl7cj1KU09OLnN0cmluZ2lmeShlLm91dHB1dFNoYXBlKX1jYXRjaChlKXtyPVwibXVsdGlwbGVcIn1wcmludFJvdyhbZS5uYW1lK1wiIChcIitlLmdldENsYXNzTmFtZSgpK1wiKVwiLHIsZS5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCldLHQsbil9ZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoZSx0LG4scil7dmFyIGk7dHJ5e2k9SlNPTi5zdHJpbmdpZnkoZS5vdXRwdXRTaGFwZSl9Y2F0Y2goZSl7aT1cIm11bHRpcGxlXCJ9Zm9yKHZhciBhPVtdLG89MCxzPWUuaW5ib3VuZE5vZGVzO288cy5sZW5ndGg7bysrKXt2YXIgbD1zW29dO2lmKCEobnVsbCE9biYmbi5sZW5ndGg+MCYmLTE9PT1uLmluZGV4T2YobCkpKWZvcih2YXIgdT0wO3U8bC5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsrK3Upe3ZhciBjPWwuaW5ib3VuZExheWVyc1t1XS5uYW1lLHA9bC5ub2RlSW5kaWNlc1t1XSxoPWwudGVuc29ySW5kaWNlc1t1XTthLnB1c2goYytcIltcIitwK1wiXVtcIitoK1wiXVwiKX19dmFyIGQ9ZS5uYW1lLGY9ZS5nZXRDbGFzc05hbWUoKSxnPTA9PT1hLmxlbmd0aD9cIlwiOmFbMF07cHJpbnRSb3coW2QrXCIgKFwiK2YrXCIpXCIsaSxlLmNvdW50UGFyYW1zKCkudG9TdHJpbmcoKSxnXSx0LHIpO2Zvcih1PTE7dTxhLmxlbmd0aDsrK3UpcHJpbnRSb3coW1wiXCIsXCJcIixcIlwiLGFbdV1dLHQscil9dmFyIHZlcnNpb249XCIxLjEuMlwiO2Z1bmN0aW9uIGRlc2VyaWFsaXplKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLHZvaWQgMD09PW4mJihuPSExKSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwibGF5ZXJcIixuKX1mdW5jdGlvbiBpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKGUsdCxuKXtyZXR1cm4oXCJpbmJvdW5kTm9kZXNcIj09PWV8fFwib3V0cHV0TGF5ZXJzXCI9PT1lfHxcImlucHV0TGF5ZXJzXCI9PT1lKSYmMD09PXQmJlwic3RyaW5nXCI9PXR5cGVvZiBufWZ1bmN0aW9uIGNvbnZlcnRQeXRob25pY1RvVHMoZSx0KXtpZihudWxsPT09ZSlyZXR1cm4gbnVsbDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdG9DYW1lbENhc2UoZSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZSlyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgbj1bXSxyPWUubGVuZ3RoLGk9MDtpPHI7KytpKXt2YXIgYT1lW2ldO2lzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUodCxpLGEpP24ucHVzaChhKTpuLnB1c2goY29udmVydFB5dGhvbmljVG9UcyhhLHQpKX1yZXR1cm4gbn1mb3IodmFyIG89e30scz0wLGw9T2JqZWN0LmtleXMoZSk7czxsLmxlbmd0aDtzKyspe3ZhciB1PWxbc10sYz1lW3VdO2lmKFwibmFtZVwiPT09dSYmXCJzdHJpbmdcIj09dHlwZW9mIGMpb1t1XT1jO2Vsc2V7dmFyIHA9dG9DYW1lbENhc2UodSk7b1twXT1jb252ZXJ0UHl0aG9uaWNUb1RzKGMscCl9fXJldHVybiBvfWZ1bmN0aW9uIGNvbnZlcnRUc1RvUHl0aG9uaWMoZSx0KXtpZihudWxsPT09ZXx8dm9pZCAwPT09ZSlyZXR1cm4gbnVsbDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdG9TbmFrZUNhc2UoZSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZSlyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgbj1bXSxyPWUubGVuZ3RoLGk9MDtpPHI7KytpKXt2YXIgYT1lW2ldO2lzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUodCxpLGEpP24ucHVzaChhKTpuLnB1c2goY29udmVydFRzVG9QeXRob25pYyhhLHQpKX1yZXR1cm4gbn1mb3IodmFyIG89e30scz0wLGw9T2JqZWN0LmtleXMoZSk7czxsLmxlbmd0aDtzKyspe3ZhciB1PWxbc10sYz1lW3VdLHA9dG9TbmFrZUNhc2UodSk7b1twXT1cIm5hbWVcIiE9PXUmJlwiY2xhc3NOYW1lXCIhPT11fHxcInN0cmluZ1wiIT10eXBlb2YgYz9jb252ZXJ0VHNUb1B5dGhvbmljKGMsdSk6Y31yZXR1cm4gb31mdW5jdGlvbiBhc3NlcnRGZWVkQ29tcGF0aWJpbGl0eShlLHQpe2lmKG51bGw9PWUuZHR5cGV8fGUuZHR5cGU9PT10LmR0eXBlKXJldHVybiB0O3RyeXtyZXR1cm4gY2FzdCh0LGUuZHR5cGUpfWNhdGNoKG4pe3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGR0eXBlIG9mIHRoZSBmZWVkIChcIit0LmR0eXBlK1wiKSBjYW4gbm90IGJlIGNhc3QgdG8gdGhlIGR0eXBlIG9mIHRoZSBrZXkgJ1wiK2UubmFtZStcIicgKFwiK2UuZHR5cGUrXCIpLlwiKX19dmFyIEZlZWREaWN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtpZih0aGlzLmlkMlZhbHVlPXt9LHRoaXMuaWQyTWFzaz17fSx0aGlzLm5hbWUySWQ9e30sdCBpbnN0YW5jZW9mIGUpZm9yKHZhciBuIGluIHQuaWQyVmFsdWUpdGhpcy5pZDJWYWx1ZVtuXT10LmlkMlZhbHVlW25dLG4gaW4gdC5pZDJNYXNrJiYodGhpcy5pZDJNYXNrW25dPXQuaWQyTWFza1tuXSk7ZWxzZXtpZihudWxsPT10KXJldHVybjtmb3IodmFyIHI9MCxpPXQ7cjxpLmxlbmd0aDtyKyspe3ZhciBhPWlbcl07dGhpcy5hZGQoYS5rZXksYS52YWx1ZSl9fX1yZXR1cm4gZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCxuKXtpZihudWxsIT10aGlzLmlkMlZhbHVlW2UuaWRdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIGtleTogbmFtZT1cIitlLm5hbWUrXCIsIGlkPVwiK2UuaWQpO3JldHVybiB0aGlzLmlkMlZhbHVlW2UuaWRdPWFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGUsdCksdGhpcy5uYW1lMklkW2UubmFtZV09ZS5pZCxudWxsIT1uJiYodGhpcy5pZDJNYXNrW2UuaWRdPW4pLHRoaXN9LGUucHJvdG90eXBlLmFkZEZlZWQ9ZnVuY3Rpb24oZSl7dGhpcy5hZGQoZS5rZXksZS52YWx1ZSl9LGUucHJvdG90eXBlLmhhc0tleT1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9dGhpcy5pZDJWYWx1ZVtlLmlkXX0sZS5wcm90b3R5cGUubmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lMklkKX0sZS5wcm90b3R5cGUuZ2V0VmFsdWU9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXtpZihudWxsPT10aGlzLmlkMlZhbHVlW2UuaWRdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm9uZXhpc3RlbnQga2V5OiBcIitlLm5hbWUpO3JldHVybiB0aGlzLmlkMlZhbHVlW2UuaWRdfXZhciB0PXRoaXMubmFtZTJJZFtlXTtpZihudWxsPT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRmVlZCBkaWN0IGhhcyBubyBTeW1ib2xpY1RlbnNvciBuYW1lOiBcIitlKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVt0XX0sZS5wcm90b3R5cGUuZ2V0TWFzaz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe2lmKG51bGw9PXRoaXMuaWQyVmFsdWVbZS5pZF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJOb25leGlzdGVudCBrZXk6IFwiK2UubmFtZSk7cmV0dXJuIHRoaXMuaWQyTWFza1tlLmlkXX12YXIgdD10aGlzLm5hbWUySWRbZV07aWYobnVsbD09dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZlZWQgZGljdCBoYXMgbm8gU3ltYm9saWNUZW5zb3IgbmFtZTogXCIrZSk7cmV0dXJuIHRoaXMuaWQyTWFza1t0XX0sZS5wcm90b3R5cGUuZGlzcG9zZU1hc2tzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5pZDJNYXNrJiZkaXNwb3NlKHRoaXMuaWQyTWFzayl9LGV9KCksY2FjaGVkU29ydGVkPXt9LGNhY2hlZFJlY2lwaWVudENvdW50cz17fTtmdW5jdGlvbiBleGVjdXRlKGUsdCxuLHIpe2Zvcih2YXIgaT1udWxsIT1uJiZuLnRyYWluaW5nLGE9QXJyYXkuaXNBcnJheShlKSxvPWE/ZTpbZV0scz1vLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSksbD1bXSx1PXQubmFtZXMoKSxjPTAscD1zO2M8cC5sZW5ndGg7YysrKXt2YXIgaD1wW2NdOy0xIT09dS5pbmRleE9mKGgpP2wucHVzaCh0LmdldFZhbHVlKGgpKTpsLnB1c2gobnVsbCl9bnVsbCE9ciYmKHIubWF4TnVtVGVuc29ycz0tMS8wLHIubWluTnVtVGVuc29ycz0xLzApO3ZhciBkLGYsZz1zLmpvaW4oXCIsXCIpK1wifFwiK3QubmFtZXMoKS5qb2luKFwiLFwiKTtpZihudWxsPT1jYWNoZWRTb3J0ZWRbZ10pe3ZhciBtPWdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50cyhvLHQpO2Q9bS5zb3J0ZWQsZj1tLnJlY2lwaWVudENvdW50cyxjYWNoZWRTb3J0ZWRbZ109ZCxjYWNoZWRSZWNpcGllbnRDb3VudHNbZ109Zn1kPWNhY2hlZFNvcnRlZFtnXSxmPXt9LGl8fE9iamVjdC5hc3NpZ24oZixjYWNoZWRSZWNpcGllbnRDb3VudHNbZ10pO2Zvcih2YXIgeT1uZXcgRmVlZERpY3QodCksdj0wO3Y8ZC5sZW5ndGg7Kyt2KXtpZihudWxsIT1yKXt2YXIgYj1tZW1vcnkoKS5udW1UZW5zb3JzO2I+ci5tYXhOdW1UZW5zb3JzJiYoci5tYXhOdW1UZW5zb3JzPWIpLGI8ci5taW5OdW1UZW5zb3JzJiYoci5taW5OdW1UZW5zb3JzPWIpfXZhciB3PWRbdl0sej13LnNvdXJjZUxheWVyO2lmKCEoeiBpbnN0YW5jZW9mIElucHV0TGF5ZXIpKXtmb3IodmFyIFM9W10sST1bXSxBPVtdLF89ITEsQz0wLE49dy5pbnB1dHM7QzxOLmxlbmd0aDtDKyspe3ZhciBFPU5bQ10saz15LmdldFZhbHVlKEUpLEw9eS5nZXRNYXNrKEUpO1MucHVzaChrKSxJLnB1c2goTCksbnVsbCE9TCYmKF89ITApLGl8fChmW0UubmFtZV0tLSwwIT09ZltFLm5hbWVdfHx0Lmhhc0tleShFKXx8LTEhPT1zLmluZGV4T2YoRS5uYW1lKXx8ay5pc0Rpc3Bvc2VkfHwhMD09PUUuc291cmNlTGF5ZXIuc3RhdGVmdWx8fEEucHVzaChrKSl9XyYmKChuPW58fHt9KS5tYXNrPUlbMF0pO3ZhciB4PXRvTGlzdCh6LmFwcGx5KFMsbikpLFQ9bnVsbDt6LnN1cHBvcnRzTWFza2luZyYmKFQ9ei5jb21wdXRlTWFzayhTLEkpKTtmb3IodmFyIEQ9Z2V0Tm9kZU91dHB1dHModyksTz1BcnJheS5pc0FycmF5KEQpP0Q6W0RdLFI9MDtSPE8ubGVuZ3RoOysrUil7eS5oYXNLZXkoT1tSXSl8fHkuYWRkKE9bUl0seFtSXSxBcnJheS5pc0FycmF5KFQpP1RbMF06VCk7dmFyIE09cy5pbmRleE9mKE9bUl0ubmFtZSk7LTEhPT1NJiYobFtNXT14W1JdKX1pfHxkaXNwb3NlKEEpfX1yZXR1cm4geS5kaXNwb3NlTWFza3MoKSxhP2w6bFswXX1mdW5jdGlvbiBnZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHMoZSx0KXt1dGlsLmFzc2VydChudWxsIT1lJiZlLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgZmV0Y2gsIGdvdCBub25lXCJ9KTt2YXIgbj1bXSxyPXt9O2lmKDE9PT1lLmxlbmd0aCl7dmFyIGk9Z2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzRm9yT25lRmV0Y2goZVswXSx0KTtuPWkuc29ydGVkLHI9aS5yZWNpcGllbnRNYXB9ZWxzZSBmb3IodmFyIGE9bmV3IFNldCxvPTAscz1lO288cy5sZW5ndGg7bysrKXtmb3IodmFyIGw9Z2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzRm9yT25lRmV0Y2goc1tvXSx0KSx1PWwuc29ydGVkLGM9bC5yZWNpcGllbnRNYXAscD0wLGg9dTtwPGgubGVuZ3RoO3ArKyl7dmFyIGQ9aFtwXTthLmhhcyhkLm5hbWUpfHwobi5wdXNoKGQpLGEuYWRkKGQubmFtZSkpfXZhciBmPWZ1bmN0aW9uKGUpe251bGw9PXJbZV0mJihyW2VdPW5ldyBTZXQpLGNbZV0uZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gcltlXS5hZGQodCl9KX07Zm9yKHZhciBnIGluIGMpZihnKX1yZXR1cm57c29ydGVkOm4scmVjaXBpZW50Q291bnRzOnJlY2lwaWVudE1hcDJDb3VudHMocil9fWZ1bmN0aW9uIHJlY2lwaWVudE1hcDJDb3VudHMoZSl7dmFyIHQ9e307Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dLnNpemU7cmV0dXJuIHR9ZnVuY3Rpb24gZ2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzRm9yT25lRmV0Y2goZSx0KXtmb3IodmFyIG49bmV3IFNldCxyPVtdLGk9e30sYT0wLG89dC5uYW1lcygpO2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdO24uYWRkKHMpfXZhciBsPVtdLHU9W107Zm9yKGwucHVzaChlKTtsLmxlbmd0aD4wOyl7dmFyIGM9bFtsLmxlbmd0aC0xXTtpZihuLmhhcyhjLm5hbWUpKWwucG9wKCk7ZWxzZXt2YXIgcD11W3UubGVuZ3RoLTFdPT09bC5sZW5ndGgtMTtpZigwPT09Yy5pbnB1dHMubGVuZ3RofHxwKWwucG9wKCksci5wdXNoKGMpLG4uYWRkKGMubmFtZSkscCYmdS5wb3AoKTtlbHNle3UucHVzaChsLmxlbmd0aC0xKTtmb3IodmFyIGg9MCxkPWMuaW5wdXRzO2g8ZC5sZW5ndGg7aCsrKXt2YXIgZj1kW2hdO251bGw9PWlbZi5uYW1lXSYmKGlbZi5uYW1lXT1uZXcgU2V0KSxpW2YubmFtZV0uYWRkKGMubmFtZSksbi5oYXMoZi5uYW1lKXx8bC5wdXNoKGYpfX19fXJldHVybntzb3J0ZWQ6cixyZWNpcGllbnRNYXA6aX19ZnVuY3Rpb24gZ2V0Tm9kZU91dHB1dHMoZSl7dmFyIHQ7aWYoMT09PWUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCl0PWUuc291cmNlTGF5ZXIub3V0cHV0O2Vsc2V7Zm9yKHZhciBuPW51bGwscj0wO3I8ZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOysrcilmb3IodmFyIGk9MCxhPWUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzW3JdLm91dHB1dFRlbnNvcnM7aTxhLmxlbmd0aDtpKyspe2lmKGFbaV0uaWQ9PT1lLmlkKXtuPXI7YnJlYWt9fXQ9ZS5zb3VyY2VMYXllci5nZXRPdXRwdXRBdChuKX1yZXR1cm4gdH12YXIgQ29udGFpbmVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMse30pfHx0aGlzO2lmKHIuY29udGFpbmVyTm9kZXM9bmV3IFNldCxyLm5hbWU9bi5uYW1lLG51bGw9PXIubmFtZSl7dmFyIGk9ci5nZXRDbGFzc05hbWUoKS50b0xvd2VyQ2FzZSgpO3IubmFtZT1nZXRVaWQoaSl9aWYoci5zdXBwb3J0c01hc2tpbmc9ITEsci50cmFpbmFibGVfPSEwLHIudXBkYXRhYmxlPSEwLEFycmF5LmlzQXJyYXkobi5pbnB1dHMpP3IuaW5wdXRzPW4uaW5wdXRzLnNsaWNlKCk6ci5pbnB1dHM9W24uaW5wdXRzXSxBcnJheS5pc0FycmF5KG4ub3V0cHV0cyk/ci5vdXRwdXRzPW4ub3V0cHV0cy5zbGljZSgpOnIub3V0cHV0cz1bbi5vdXRwdXRzXSx1bmlxdWUoci5pbnB1dHMpLmxlbmd0aCE9PXIuaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBsaXN0IG9mIGlucHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gQWxsIGlucHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6IFwiK3IuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkpO3VuaXF1ZShyLm91dHB1dHMpLmxlbmd0aCE9PXIub3V0cHV0cy5sZW5ndGgmJmNvbnNvbGUud2FybihcIlRoZSBsaXN0IG9mIG91dHB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuIEFsbCBvdXRwdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogXCIrci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkpLHIuaW5wdXRMYXllcnM9W10sci5pbnB1dExheWVyc05vZGVJbmRpY2VzPVtdLHIuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHIub3V0cHV0TGF5ZXJzPVtdLHIub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM9W10sci5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHIubGF5ZXJzPVtdO2Zvcih2YXIgYT0wLG89ci5vdXRwdXRzO2E8by5sZW5ndGg7YSsrKXt2YXIgcz0oQz1vW2FdKS5zb3VyY2VMYXllcixsPUMubm9kZUluZGV4LHU9Qy50ZW5zb3JJbmRleDtyLm91dHB1dExheWVycy5wdXNoKHMpLHIub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChsKSxyLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh1KX1mb3IodmFyIGM9MCxwPXIuaW5wdXRzO2M8cC5sZW5ndGg7YysrKXtzPShDPXBbY10pLnNvdXJjZUxheWVyLGw9Qy5ub2RlSW5kZXgsdT1DLnRlbnNvckluZGV4O2Fzc2VydCgwPT09bCxcImlucHV0IGxheWVyIGhhcyA+MSBub2Rlc1wiKSxhc3NlcnQoMD09PXUsXCJpbnB1dCBsYXllciBoYXMgPjEgdGVuc29yc1wiKSxyLmlucHV0TGF5ZXJzLnB1c2gocyksci5pbnB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gobCksci5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh1KX1yLmlucHV0TmFtZXM9W10sci5vdXRwdXROYW1lcz1bXSxyLmZlZWRJbnB1dFNoYXBlcz1bXSxyLmZlZWRJbnB1dE5hbWVzPVtdLHIuZmVlZE91dHB1dE5hbWVzPVtdO2Zvcih2YXIgaD0wO2g8ci5pbnB1dExheWVycy5sZW5ndGg7aCsrKXtpZighKChzPXIuaW5wdXRMYXllcnNbaF0paW5zdGFuY2VvZiBJbnB1dExheWVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW5wdXQgbGF5ZXJzIHRvIGEgTGF5ZXJzTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuIFJlY2VpdmVkIGlucHV0czogXCIrbi5pbnB1dHMrXCIuIElucHV0IFwiK2grXCIgKDAtYmFzZWQpIG9yaWdpbmF0ZXMgZnJvbSBsYXllciB0eXBlIFwiK3MuZ2V0Q2xhc3NOYW1lKCkrXCIuXCIpO3IuaW5wdXROYW1lcy5wdXNoKHMubmFtZSksci5mZWVkSW5wdXRTaGFwZXMucHVzaChzLmJhdGNoSW5wdXRTaGFwZSksci5mZWVkSW5wdXROYW1lcy5wdXNoKHMubmFtZSl9Zm9yKHZhciBkPTAsZj1yLm91dHB1dExheWVycztkPGYubGVuZ3RoO2QrKyl7cz1mW2RdO3Iub3V0cHV0TmFtZXMucHVzaChzLm5hbWUpfXIuaW50ZXJuYWxJbnB1dFNoYXBlcz1yLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSxyLmludGVybmFsT3V0cHV0U2hhcGVzPXIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KTtmb3IodmFyIGc9e30sbT17fSx5PXt9LHY9e30sYj17fSx3PVtdLHo9ZnVuY3Rpb24oZSxuLGksYSxvLHMpe251bGwhPWEmJm51bGwhPW8mJm51bGwhPXN8fChhPWUuc291cmNlTGF5ZXIsbz1lLm5vZGVJbmRleCxzPWUudGVuc29ySW5kZXgpO3ZhciBsPWEuaW5ib3VuZE5vZGVzW29dO2lmKC0xIT09aS5pbmRleE9mKGwpKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgdGVuc29yIFwiK2UubmFtZSsnIGF0IGxheWVyIFwiJythLm5hbWUrJ1wiIGlzIHBhcnQgb2YgYSBjeWNsZS4nKTtpZigtMT09PW4uaW5kZXhPZihsKSl7ci5jb250YWluZXJOb2Rlcy5hZGQodC5ub2RlS2V5KGEsbykpLGEuaWQgaW4gYnx8KGJbYS5pZF09T2JqZWN0LmtleXMoYikubGVuZ3RoKSwtMT09PWkuaW5kZXhPZihsKSYmaS5wdXNoKGwpO2Zvcih2YXIgdT1sLmluYm91bmRMYXllcnMubGVuZ3RoLGM9MDtjPHU7YysrKXt2YXIgcD1sLmlucHV0VGVuc29yc1tjXSxoPWwuaW5ib3VuZExheWVyc1tjXSxkPWwubm9kZUluZGljZXNbY10sZj1sLnRlbnNvckluZGljZXNbY107eihwLG4saSxoLGQsZil9Zm9yKG4ucHVzaChsKTtpLmluZGV4T2YobCk+PTA7KWkuc3BsaWNlKGkuaW5kZXhPZihsKSwxKTt3LnB1c2gobCl9fSxTPVtdLEk9W10sQT0wLF89ci5vdXRwdXRzO0E8Xy5sZW5ndGg7QSsrKXt2YXIgQz1fW0FdO3ooQyxTLEkpfWZvcih2YXIgTj0wLEU9dy5zbGljZSgpLnJldmVyc2UoKTtOPEUubGVuZ3RoO04rKyl7bVsoSz1FW05dKS5pZF09SyxLLmlkIGluIGd8fChnW0suaWRdPTApO3ZhciBrPWdbSy5pZF0sTD1udWxsPT15W0sub3V0Ym91bmRMYXllci5pZF0/MDp5W0sub3V0Ym91bmRMYXllci5pZF07az1NYXRoLm1heChrLEwpLHlbSy5vdXRib3VuZExheWVyLmlkXT1rLHZbSy5vdXRib3VuZExheWVyLmlkXT1LLm91dGJvdW5kTGF5ZXIsZ1tLLmlkXT1rO2ZvcihoPTA7aDxLLmluYm91bmRMYXllcnMubGVuZ3RoO2grKyl7dmFyIHg9Sy5pbmJvdW5kTGF5ZXJzW2hdLFQ9KGw9Sy5ub2RlSW5kaWNlc1toXSx4LmluYm91bmROb2Rlc1tsXSksRD1udWxsPT1nW1QuaWRdPzA6Z1tULmlkXTtnW1QuaWRdPU1hdGgubWF4KGsrMSxEKSxtW1QuaWRdPVR9fXZhciBPPXt9O2Zvcih2YXIgUiBpbiBnKXsoaz1nW1JdKWluIE98fChPW2tdPVtdKSxPW2tdLnB1c2gobVtSXSl9dmFyIE09e307Zm9yKHZhciBQIGluIHkpeyhrPXlbUF0paW4gTXx8KE1ba109W10pLE1ba10ucHVzaCh2W1BdKX12YXIgRj1PYmplY3Qua2V5cyhNKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7ci5sYXllcnM9W107Zm9yKHZhciBWPTAsQj1GO1Y8Qi5sZW5ndGg7VisrKXt2YXIgVT1NW2s9QltWXV07VS5zb3J0KGZ1bmN0aW9uKGUsdCl7dmFyIG49YltlLmlkXSxyPWJbdC5pZF07cmV0dXJuIG48cj8tMTpuPnI/MTowfSk7Zm9yKHZhciBqPTAsVz1VO2o8Vy5sZW5ndGg7aisrKXtzPVdbal07ci5sYXllcnMucHVzaChzKX19ci5sYXllcnNCeURlcHRoPU0sRj1PYmplY3Qua2V5cyhPKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7Zm9yKHZhciAkPXIuaW5wdXRzLnNsaWNlKCkscT1bXSxHPTAsSD1GO0c8SC5sZW5ndGg7RysrKWZvcih2YXIgSj0wLFo9T1trPUhbR11dO0o8Wi5sZW5ndGg7SisrKXt2YXIgSztpZihudWxsIT0ocz0oSz1aW0pdKS5vdXRib3VuZExheWVyKSl7Zm9yKHZhciBZPTAsWD1LLmlucHV0VGVuc29ycztZPFgubGVuZ3RoO1krKyl7Qz1YW1ldO2lmKC0xPT09JC5pbmRleE9mKEMpKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJHcmFwaCBkaXNjb25uZWN0ZWQ6IGNhbm5vdCBvYnRhaW4gdmFsdWUgZm9yIHRlbnNvciBcIitDKycgYXQgbGF5ZXIgXCInK3MubmFtZSsnXCIuIFRoZSBmb2xsb3dpbmcgcHJldmlvdXMgbGF5ZXJzIHdlcmUgYWNjZXNzZWQgd2l0aG91dCBpc3N1ZTogJytxKX1mb3IodmFyIFE9MCxlZT1LLm91dHB1dFRlbnNvcnM7UTxlZS5sZW5ndGg7USsrKXtDPWVlW1FdOyQucHVzaChDKX1xLnB1c2gocy5uYW1lKX19ci5ub2Rlc0J5RGVwdGg9Tztmb3IodmFyIHRlPXIubGF5ZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSksbmU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZX0pLmxlbmd0aDtpZigxIT09dCl0aHJvdyBuZXcgUnVudGltZUVycm9yKCdUaGUgbmFtZSBcIicrZSsnXCIgaXMgdXNlZCAnK3QrXCIgdGltZXMgaW4gdGhlIG1vZGVsLiBBbGwgbGF5ZXIgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZS4gTGF5ZXIgbmFtZXM6IFwiK0pTT04uc3RyaW5naWZ5KHRlKSl9LHJlPTAsaWU9dGU7cmU8aWUubGVuZ3RoO3JlKyspe25lKGllW3JlXSl9cmV0dXJuIHIub3V0Ym91bmROb2Rlcz1bXSxyLmluYm91bmROb2Rlcz1bXSxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjpyLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6ci5pbnB1dHMsb3V0cHV0VGVuc29yczpyLm91dHB1dHMsaW5wdXRNYXNrczpyLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KSxvdXRwdXRNYXNrczpyLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSksaW5wdXRTaGFwZXM6ci5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSksb3V0cHV0U2hhcGVzOnIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KX0pLHIuYnVpbHQ9ITAsci5fcmVmQ291bnQ9MSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJDb250YWluZXIgJ1wiK3RoaXMubmFtZStcIicgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7dmFyIGU9e3JlZkNvdW50QWZ0ZXJEaXNwb3NlOm51bGwsbnVtRGlzcG9zZWRWYXJpYWJsZXM6MH07aWYoMD09LS10aGlzLl9yZWZDb3VudClmb3IodmFyIHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UubnVtRGlzcG9zZWRWYXJpYWJsZXMrPXIuZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzfXJldHVybiBlLnJlZkNvdW50QWZ0ZXJEaXNwb3NlPXRoaXMuX3JlZkNvdW50LGV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5sYXllcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0Ll90cmFpbmFibGVXZWlnaHRzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhaW5hYmxlPWV9KX0pLHRoaXMudHJhaW5hYmxlXz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGg+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuVGhlIHRyYWluYWJsZSB3ZWlnaHRzIG9mIGEgQ29udGFpbmVyIGFyZSBhIHVuaW9uIG9mIHRoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBpdHMgY29uc2l0dWVudCBMYXllcnMuIEl0cyBvd24gX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuXCIpO2lmKCF0aGlzLnRyYWluYWJsZSlyZXR1cm5bXTtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZT1lLmNvbmNhdChyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIubm9uVHJhaW5hYmxlV2VpZ2h0cyl9aWYoIXRoaXMudHJhaW5hYmxlKXtmb3IodmFyIGk9W10sYT0wLG89dGhpcy5sYXllcnM7YTxvLmxlbmd0aDthKyspe3I9b1thXTtpLnB1c2guYXBwbHkoaSxyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBpLmNvbmNhdChlKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ3ZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUubG9hZFdlaWdodHM9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMCk7Zm9yKHZhciBuPXt9LHI9MCxpPTAsYT10aGlzLmxheWVycztpPGEubGVuZ3RoO2krKylmb3IodmFyIG89MCxzPWFbaV0ud2VpZ2h0cztvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXTtpZihudWxsIT1uW2wub3JpZ2luYWxOYW1lXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZTogXCIrbC5vcmlnaW5hbE5hbWUpO25bbC5vcmlnaW5hbE5hbWVdPWwscisrfXZhciB1PVtdO2Zvcih2YXIgYyBpbiBlKXtpZihudWxsIT1uW2NdKXUucHVzaChbbltjXSxlW2NdXSk7ZWxzZSBpZih0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUHJvdmlkZWQgd2VpZ2h0IGRhdGEgaGFzIG5vIHRhcmdldCB2YXJpYWJsZTogXCIrYyk7ZGVsZXRlIG5bY119aWYodCl7dmFyIHA9W107Zm9yKHZhciBoIGluIG4pcC5wdXNoKGgpO2lmKHAubGVuZ3RoPjApdGhyb3cgbmV3IFZhbHVlRXJyb3IocC5sZW5ndGgrXCIgb2YgXCIrcitcIiB3ZWlnaHRzIGFyZSBub3Qgc2V0OiBcIitwKX1iYXRjaFNldFZhbHVlKHUpfSx0LnByb3RvdHlwZS51cGRhdGVkQ29uZmlnPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXRDb25maWcoKSx0PXt9O3JldHVybiB0LmNsYXNzTmFtZT10aGlzLmdldENsYXNzTmFtZSgpLHQuY29uZmlnPWUsdC5rZXJhc1ZlcnNpb249XCJ0ZmpzLWxheWVycyBcIit2ZXJzaW9uLHQuYmFja2VuZD1cIlRlbnNvckZsb3cuanNcIix0fSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMCk7dmFyIG49Y29udmVydFRzVG9QeXRob25pYyh0aGlzLnVwZGF0ZWRDb25maWcoKSk7cmV0dXJuIHQ/SlNPTi5zdHJpbmdpZnkobik6bn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtlPXRvTGlzdChlKTtmb3IodmFyIHI9bmV3IEZlZWREaWN0LGk9MDtpPG4uaW5wdXRzLmxlbmd0aDsrK2kpci5hZGQobi5pbnB1dHNbaV0sZVtpXSk7cmV0dXJuIGV4ZWN1dGUobi5vdXRwdXRzLHIsdCl9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIGU9dG9MaXN0KGUpLHI9bnVsbD09dD9weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCk6dG9MaXN0KHQpLG4ucnVuSW50ZXJuYWxHcmFwaChlLHIpWzFdfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1ub3JtYWxpemVTaGFwZUxpc3QoZSk7aWYodC5sZW5ndGghPT10aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCBcIitlK1wiOiBtb2RlbCBoYXMgXCIrdGhpcy5pbnB1dExheWVycy5sZW5ndGgrXCIgdGVuc29yIGlucHV0cy5cIik7Zm9yKHZhciBuPXt9LHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGk9dGhpcy5pbnB1dExheWVyc1tyXSxhPXRbcl07bltJPWkubmFtZStcIl8wXzBcIl09YX12YXIgbz1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO2lmKG8ubGVuZ3RoPjEpZm9yKHZhciBzPTAsbD1vO3M8bC5sZW5ndGg7cysrKWZvcih2YXIgdT1sW3NdLGM9MCxwPXRoaXMubm9kZXNCeURlcHRoW3VdO2M8cC5sZW5ndGg7YysrKXt2YXIgaD1wW2NdO2k9aC5vdXRib3VuZExheWVyO2lmKC0xPT09dGhpcy5pbnB1dExheWVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KS5pbmRleE9mKGkuaWQpKXtmb3IodmFyIGQ9W10sZj0wO2Y8aC5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtmKyspe3ZhciBnPWguaW5ib3VuZExheWVyc1tmXSxtPWgubm9kZUluZGljZXNbZl0seT1oLnRlbnNvckluZGljZXNbZl0sdj1uW0k9Zy5uYW1lK1wiX1wiK20rXCJfXCIreV07ZC5wdXNoKHYpfXZhciBiPW5vcm1hbGl6ZVNoYXBlTGlzdChpLmNvbXB1dGVPdXRwdXRTaGFwZShzaW5nbGV0b25PckFycmF5KGQpKSksdz1pLmluYm91bmROb2Rlcy5pbmRleE9mKGgpO2ZvcihmPTA7ZjxiLmxlbmd0aDtmKyspe25bST1pLm5hbWUrXCJfXCIrdytcIl9cIitmXT1iW2ZdfX19dmFyIHo9W10sUz1bXTtmb3Iocj0wO3I8dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO3IrKyl7aT10aGlzLm91dHB1dExheWVyc1tyXSx3PXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbcl0seT10aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbcl07dmFyIEk9aS5uYW1lK1wiX1wiK3crXCJfXCIreTtTLnB1c2goSSl9Zm9yKHI9MDtyPFMubGVuZ3RoO3IrKyl7dmFyIEE9U1tyXTthc3NlcnQoQSBpbiBuKSx6LnB1c2gobltBXSl9cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkoeil9LHQucHJvdG90eXBlLnJ1bkludGVybmFsR3JhcGg9ZnVuY3Rpb24oZSx0KXtudWxsPT10JiYodD1weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCkpO2Zvcih2YXIgbj17fSxyPTA7cjx0aGlzLmlucHV0cy5sZW5ndGg7KytyKXt2YXIgaT10aGlzLmlucHV0c1tyXSxhPWVbcl0sbz10W3JdO25baS5pZF09W2Esb119Zm9yKHZhciBzPTAsbD1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO3M8bC5sZW5ndGg7cysrKWZvcih2YXIgdT1sW3NdLGM9MCxwPXRoaXMubm9kZXNCeURlcHRoW3VdO2M8cC5sZW5ndGg7YysrKXtmb3IodmFyIGg9cFtjXSxkPWgub3V0Ym91bmRMYXllcixmPWguaW5wdXRUZW5zb3JzLGc9aC5vdXRwdXRUZW5zb3JzLG09bmV3IEFycmF5LHk9MCx2PWY7eTx2Lmxlbmd0aDt5KyspeyhpPXZbeV0pLmlkIGluIG4mJm0ucHVzaChuW2kuaWRdKX1pZihtLmxlbmd0aD09PWYubGVuZ3RoKXt2YXIgYj17fSx3PXZvaWQgMCx6PXZvaWQgMCxTPXZvaWQgMCxJPXZvaWQgMDtpZihudWxsIT1oLmNhbGxBcmdzJiYoYj1oLmNhbGxBcmdzKSwxPT09bS5sZW5ndGgpe3ZhciBBPW1bMF0sXz1BWzBdLEM9QVsxXTtudWxsPT1iLm1hc2smJihiLm1hc2s9QyksUz10b0xpc3QoZC5jYWxsKF8sYikpLEk9dG9MaXN0KGQuY29tcHV0ZU1hc2soXyxDKSksdz1bX10sej1bQ119ZWxzZSB3PW0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlWzBdfSksej1tLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVsxXX0pLG51bGw9PWIubWFzayYmKGIubWFzaz16KSxTPXRvTGlzdChkLmNhbGwodyxiKSksST10b0xpc3QoZC5jb21wdXRlTWFzayh3LHopKTtpZihkLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllcnNNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7Zm9yKHI9MDtyPGcubGVuZ3RoOysrcil7aT1nW3JdLGE9U1tyXSxvPUlbcl07bltpLmlkXT1bYSxvXX19fWZvcih2YXIgTj1bXSxFPVtdLGs9W10sTD0wLHg9dGhpcy5vdXRwdXRzO0w8eC5sZW5ndGg7TCsrKXthc3NlcnQoKGk9eFtMXSkuaWQgaW4gbixcIkNvdWxkIG5vdCBjb21wdXRlIG91dHB1dCBcIitpLm5hbWUrXCIgOiBcIitpLmlkKTt2YXIgVD1uW2kuaWRdLEQ9VFswXTtvPVRbMV07ay5wdXNoKEQuc2hhcGUpLE4ucHVzaChEKSxFLnB1c2gobyl9cmV0dXJuW04sRSxrXX0sdC5wcm90b3R5cGUuYnVpbGROb2RlQ29udmVyc2lvbk1hcD1mdW5jdGlvbihlKXtmb3IodmFyIG4scj17fSxpPTAsYT10aGlzLmxheWVycztpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtuPW8gaW5zdGFuY2VvZiB0PzE6MDtmb3IodmFyIHM9MDtzPG8uaW5ib3VuZE5vZGVzLmxlbmd0aDtzKyspe3ZhciBsPXQubm9kZUtleShvLHMpO3RoaXMuY29udGFpbmVyTm9kZXMuaGFzKGwpJiYocltsXT1uLG4rPTEpfX1yZXR1cm4gcn0sdC5wcm90b3R5cGUuZ2V0TGF5ZXI9ZnVuY3Rpb24oZSx0KXtpZihudWxsIT10KXtpZih0aGlzLmxheWVycy5sZW5ndGg8PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXYXMgYXNrZWQgdG8gcmV0cmlldmUgbGF5ZXIgYXQgaW5kZXggXCIrdCtcIiwgYnV0IG1vZGVsIG9ubHkgaGFzIFwiK3RoaXMubGF5ZXJzLmxlbmd0aCtcIiBsYXllcihzKS5cIik7cmV0dXJuIHRoaXMubGF5ZXJzW3RdfWlmKG51bGw9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQcm92aWRlIGVpdGhlciBhIGxheWVyIG5hbWUgb3IgbGF5ZXIgaW5kZXhcIik7Zm9yKHZhciBuPTAscj10aGlzLmxheWVycztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtpZihpLm5hbWU9PT1lKXJldHVybiBpfXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm8gc3VjaCBsYXllcjogXCIrZSl9LHQucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3Nlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIG49W10scj0wLGk9ZS5sYXllcnM7cjxpLmxlbmd0aDtyKyspZm9yKHZhciBhPWlbcl0sbz0wO288YS5pbmJvdW5kTm9kZXMubGVuZ3RoOysrbyl7dmFyIHM9dC5ub2RlS2V5KGEsbyk7ZS5jb250YWluZXJOb2Rlcy5oYXMocykmJm4ucHVzaC5hcHBseShuLGEuY2FsY3VsYXRlTG9zc2VzKCkpfXJldHVybiBufSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgZT17bmFtZTp0aGlzLm5hbWV9LG49dGhpcy5idWlsZE5vZGVDb252ZXJzaW9uTWFwKHRoaXMubGF5ZXJzKSxyPVtdLGk9MCxhPXRoaXMubGF5ZXJzO2k8YS5sZW5ndGg7aSsrKXtmb3IodmFyIG89KHc9YVtpXSkuZ2V0Q2xhc3NOYW1lKCkscz13LmdldENvbmZpZygpLGw9W10sdT0wO3U8dy5pbmJvdW5kTm9kZXMubGVuZ3RoO3UrKyl7dmFyIGM9dy5pbmJvdW5kTm9kZXNbdV0scD10Lm5vZGVLZXkodyx1KSxoPXt9O2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHApKXtpZihjLmNhbGxBcmdzKXRyeXtKU09OLnN0cmluZ2lmeShjLmNhbGxBcmdzKSxoPWMuY2FsbEFyZ3N9Y2F0Y2goZSl7Y29uc29sZS53YXJuKFwiTGF5ZXIgXCIrdy5uYW1lK1wiIHdhcyBwYXNzZWQgbm9uLXNlcmlhbGl6YWJsZSBrZXl3b3JkIGFyZ3VtZW50czogXCIrYy5jYWxsQXJncytcIi4gVGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXplZCBtb2RlbCAoYW5kIHRodXMgd2lsbCBiZSBtaXNzaW5nIGF0IGRlc2VyaWFsaXphdGlvbiB0aW1lKS5cIiksaD17fX1pZihjLmluYm91bmRMYXllcnMubGVuZ3RoPjApe2Zvcih2YXIgZD1bXSxmPTA7ZjxjLmluYm91bmRMYXllcnMubGVuZ3RoO2YrKyl7dmFyIGc9Yy5pbmJvdW5kTGF5ZXJzW2ZdLG09Yy5ub2RlSW5kaWNlc1tmXSx5PWMudGVuc29ySW5kaWNlc1tmXTtudWxsPT0oUz1uW3Qubm9kZUtleShnLG0pXSkmJihTPTApLGQucHVzaChbZy5uYW1lLFMseSxoXSl9bC5wdXNoKGQpfX19dmFyIHY9e307di5uYW1lPXcubmFtZSx2LmNsYXNzTmFtZT1vLHYuY29uZmlnPXMsdi5pbmJvdW5kTm9kZXM9bCxyLnB1c2godil9ZS5sYXllcnM9cjt2YXIgYj1bXTtmb3IoZj0wO2Y8dGhpcy5pbnB1dExheWVycy5sZW5ndGg7ZisrKXt2YXIgdz10aGlzLmlucHV0TGF5ZXJzW2ZdO209dGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzW2ZdLHA9dC5ub2RlS2V5KHcsbSk7aWYodGhpcy5jb250YWluZXJOb2Rlcy5oYXMocCkpe251bGwhPT0oUz1uW3BdKSYmdm9pZCAwIT09U3x8KFM9MCk7eT10aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tmXTtiLnB1c2goW3cubmFtZSxTLHldKX19ZS5pbnB1dExheWVycz1iO3ZhciB6PVtdO2ZvcihmPTA7Zjx0aGlzLm91dHB1dExheWVycy5sZW5ndGg7ZisrKXt3PXRoaXMub3V0cHV0TGF5ZXJzW2ZdLG09dGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlc1tmXSxwPXQubm9kZUtleSh3LG0pO2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHApKXt2YXIgUztudWxsIT09KFM9bltwXSkmJnZvaWQgMCE9PVN8fChTPTApO3k9dGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ZdO3oucHVzaChbdy5uYW1lLFMseV0pfX1yZXR1cm4gZS5vdXRwdXRMYXllcnM9eixlfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09biYmKG49e30pLHZvaWQgMD09PXImJihyPSExKTt2YXIgaT17fSxhPXt9O2Z1bmN0aW9uIG8oZSx0KXtlLm5hbWUgaW4gYT9hW2UubmFtZV0ucHVzaCh0KTphW2UubmFtZV09W3RdfWZ1bmN0aW9uIHMoZSx0KXtmb3IodmFyIG4scj1bXSxhPTAscz10O2E8cy5sZW5ndGg7YSsrKXt2YXIgbD1zW2FdLHU9bFswXSxjPWxbMV0scD1sWzJdO2lmKG49bnVsbD09bFszXT97fTpsWzNdLCEodSBpbiBpKSlyZXR1cm4gdm9pZCBvKGUsdCk7dmFyIGg9aVt1XTtpZihoLmluYm91bmROb2Rlcy5sZW5ndGg8PWMpcmV0dXJuIHZvaWQgbyhlLHQpO3ZhciBkPWguaW5ib3VuZE5vZGVzW2NdO3IucHVzaChkLm91dHB1dFRlbnNvcnNbcF0pfXIubGVuZ3RoPjAmJmUuYXBwbHkoc2luZ2xldG9uT3JBcnJheShyKSxuKX1mdW5jdGlvbiBsKGUpe3ZhciBuPWUubmFtZSxhPWRlc2VyaWFsaXplKGUsbnVsbCE9dC5jdXN0b21PYmplY3RzP3QuY3VzdG9tT2JqZWN0czp7fSk7YS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHIpLGlbbl09YSxlLmluYm91bmROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFycmF5KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvcnJ1cHRlZCBjb25maWd1cmF0aW9uLCBleHBlY3RlZCBhcnJheSBmb3Igbm9kZURhdGE6IFwiK2UpO28oYSxlKX0pfWZvcih2YXIgdT10Lm5hbWUsYz10LmxheWVycyxwPTAsaD1jO3A8aC5sZW5ndGg7cCsrKXtsKGc9aFtwXSl9Zm9yKDshaXNPYmplY3RFbXB0eShhKTspZm9yKHZhciBkPTAsZj1jO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgZz1mW2RdO2lmKChrPWlbZy5uYW1lXSkubmFtZSBpbiBhKXt2YXIgbT1hW2submFtZV07ZGVsZXRlIGFbay5uYW1lXTtmb3IodmFyIHk9MCx2PW07eTx2Lmxlbmd0aDt5Kyspe3Moayx2W3ldKX19fWZvcih2YXIgYj1bXSx3PVtdLHo9MCxTPXQuaW5wdXRMYXllcnM7ejxTLmxlbmd0aDt6Kyspe3ZhciBJPShnPVNbel0pWzBdLEE9Z1sxXSxfPWdbMl07YXNzZXJ0KEkgaW4gaSk7dmFyIEM9KGs9aVtJXSkuaW5ib3VuZE5vZGVzW0FdLm91dHB1dFRlbnNvcnM7Yi5wdXNoKENbX10pfWZvcih2YXIgTj0wLEU9dC5vdXRwdXRMYXllcnM7TjxFLmxlbmd0aDtOKyspe0k9KGc9RVtOXSlbMF0sQT1nWzFdLF89Z1syXTthc3NlcnQoSSBpbiBpKTt2YXIgaztDPShrPWlbSV0pLmluYm91bmROb2Rlc1tBXS5vdXRwdXRUZW5zb3JzO3cucHVzaChDW19dKX1yZXR1cm4gbmV3IGUoe2lucHV0czpiLG91dHB1dHM6dyxuYW1lOnV9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RhdGVmdWxcIix7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fc3RhdGVmdWwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGhhcyBfc3RhdGVmdWwgPSB0cnVlLiBUaGUgc3RhdGVmdWxuZXNzIG9mIGEgQ29udGFpbmVyIGlzIGRldGVybWluZWQgYnkgdGhlIExheWVycyBpdCBjb250YWlucy4gSXRzIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBtdXN0IHJlbWFpbiB0aGUgZGVmYXVsdCBmYWxzZS5cIik7Zm9yKHZhciBlPTAsdD10aGlzLmxheWVycztlPHQubGVuZ3RoO2UrKyl7aWYodFtlXS5zdGF0ZWZ1bClyZXR1cm4hMH1yZXR1cm4hMX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGlkeShmdW5jdGlvbigpe2UubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zdGF0ZWZ1bCYmZS5yZXNldFN0YXRlcygpfSl9KX0sdH0oTGF5ZXIpLERFRkFVTFRfVkFMSURBVElPTl9CQVRDSF9TSVpFPTMyO2Z1bmN0aW9uIHN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KGUsdCl7dmFyIG4scixpPXQ7bj1pLnhzLHI9aS55cyx1dGlsLmFzc2VydChudWxsIT1uJiZudWxsIT1yLGZ1bmN0aW9uKCl7cmV0dXJuXCJBIERhdGFzZXQgaXRlcmF0b3IgZm9yIGZpdERhdGFzZXQoKSBpcyBleHBlY3RlZCB0byBnZW5lcmF0ZSBvYmplY3RzIG9mIHRoZSBmb3JtIGB7eHM6IHhWYWwsIHlzOiB5VmFsfWAsIHdoZXJlIHRoZSB0d28gdmFsdWVzIG1heSBiZSBgdGYuVGVuc29yYCwgYW4gYXJyYXkgb2YgVGVuc29ycywgb3IgYSBtYXAgb2Ygc3RyaW5nIHRvIFRlbnNvci4gIFRoZSBwcm92aWRlZCBEYXRhc2V0IGluc3RlYWQgZ2VuZXJhdGVzIFwiK3R9KTt2YXIgYT1mbGF0dGVuVGVuc29yT3JBcnJheU9yTWFwKFwiaW5wdXRcIixlLmlucHV0TmFtZXMsbiksbz1mbGF0dGVuVGVuc29yT3JBcnJheU9yTWFwKFwib3V0cHV0XCIsZS5vdXRwdXROYW1lcyxyKSxzPWFbMF0uc2hhcGVbMF07dXRpbC5hc3NlcnQoYS5sZW5ndGg9PT1lLmlucHV0cy5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkxheWVyc01vZGVsIGhhcyBcIitlLmlucHV0cy5sZW5ndGgrXCIgaW5wdXRzLCBidXQgdGhlIGRhdGFzZXQgcHJvdmlkZXMgXCIrYS5sZW5ndGgrXCIgaW5wdXRzLiAgKEV4cGVjdGVkIGlucHV0IGtleXM6IFwiK0pTT04uc3RyaW5naWZ5KGUuaW5wdXROYW1lcykrXCIpXCJ9KSx1dGlsLmFzc2VydChvLmxlbmd0aD09PWUub3V0cHV0cy5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkxheWVyc01vZGVsIGhhcyBcIitlLm91dHB1dHMubGVuZ3RoK1wiIG91dHB1dHMsIGJ1dCB0aGUgZGF0YXNldCBwcm92aWRlcyBcIitvLmxlbmd0aCtcIiBvdXRwdXRzLiAgKEV4cGVjdGVkIG91dHB1dCBrZXlzOiBcIitKU09OLnN0cmluZ2lmeShlLm91dHB1dE5hbWVzKStcIilcIn0pO3ZhciBsPWZ1bmN0aW9uKHQpe3V0aWwuYXNzZXJ0KGFbdF0uc2hhcGVbMF09PT1zLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBzaXplIG1pc21hdGNoOiBpbnB1dCBcIitlLmlucHV0TmFtZXNbdF0rXCIgaGFzIFwiK2FbdF0uc2hhcGVbMF0rXCI7IGV4cGVjdGVkICBcIitzK1wiIGJhc2VkIG9uIGlucHV0IFwiK2UuaW5wdXROYW1lc1swXStcIi5cIn0pfTtmb3IodmFyIHUgaW4gYSlsKHUpO3ZhciBjPWZ1bmN0aW9uKHQpe3V0aWwuYXNzZXJ0KG9bdF0uc2hhcGVbMF09PT1zLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBzaXplIG1pc21hdGNoOiBvdXRwdXQgXCIrZS5vdXRwdXROYW1lc1t0XStcIiBoYXMgXCIrb1t0XS5zaGFwZVswXStcIjsgZXhwZWN0ZWQgIFwiK3MrXCIgYmFzZWQgb24gaW5wdXQgXCIrZS5pbnB1dE5hbWVzWzBdK1wiLlwifSl9O2Zvcih2YXIgcCBpbiBvKWMocCk7cmV0dXJuIGEuY29uY2F0KG8pfWZ1bmN0aW9uIGZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoZSx0LG4pe2lmKG4gaW5zdGFuY2VvZiBUZW5zb3IpcmV0dXJuW25dO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIHV0aWwuYXNzZXJ0KG4ubGVuZ3RoPT09dC5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIlJlY2VpdmVkIGFuIGFycmF5IG9mIFwiK24ubGVuZ3RoK1wiIFRlbnNvcnMsIGJ1dCBleHBlY3RlZCBcIit0Lmxlbmd0aCtcIiB0byBtYXRjaCB0aGUgXCIrZStcIiBrZXlzIFwiK3QrXCIuXCJ9KSxuO2Zvcih2YXIgcj1bXSxpPTAsYT10O2k8YS5sZW5ndGg7aSsrKXt2YXIgbz1hW2ldO2lmKG51bGw9PW5bb10pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgZmVhdHVyZSBkYXRhIGdlbmVyYXRlZCBieSB0aGUgZGF0YXNldCBsYWNrcyB0aGUgcmVxdWlyZWQgXCIrZStcIiBrZXkgJ1wiK28rXCInLlwiKTtyLnB1c2gobltvXSl9cmV0dXJuIHJ9ZnVuY3Rpb24gc3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YShlKXtpZigzPT09ZS5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWYWxpZGF0aW9uIHdpdGggc2FtcGxlIHdlaWdodHMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJue3hzOmVbMF0seXM6ZVsxXX19ZnVuY3Rpb24gZml0RGF0YXNldChlLHQsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixpLGEsbyxzLGwsdSxjLHAsaCxkLGYsZyxtLHksdixiLHcseixTLEksQSxfLEMsTixFLGs7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oTCl7c3dpdGNoKEwubGFiZWwpe2Nhc2UgMDppZihyPW51bGwhPW4uYmF0Y2hlc1BlckVwb2NoLHV0aWwuYXNzZXJ0KG51bGwhPWUub3B0aW1pemVyLGZ1bmN0aW9uKCl7cmV0dXJuXCJZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSBMYXllcnNNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUNvbmZpZykuXCJ9KSx1dGlsLmFzc2VydChudWxsIT1uLGZ1bmN0aW9uKCl7cmV0dXJuXCJGb3IgZml0RGF0YXNldCgpLCB0aGUgMm5kIGFyZ3VtZW50IChjb25maWcpIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgbm90IHByb3ZpZGVkIGluIHRoaXMgY2FsbC5cIn0pLHV0aWwuYXNzZXJ0KG51bGwhPW4uZXBvY2hzJiZuLmVwb2Nocz4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uZXBvY2hzKSxmdW5jdGlvbigpe3JldHVyblwiRm9yIGZpdERhdGFzZXQoKSwgY29uZmlnLmVwb2NocyBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbi5lcG9jaHN9KSx1dGlsLmFzc2VydCghcnx8bi5iYXRjaGVzUGVyRXBvY2g+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmJhdGNoZXNQZXJFcG9jaCksZnVuY3Rpb24oKXtyZXR1cm5cIkZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5iYXRjaGVzUGVyRXBvY2ggaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCwgYnV0IGdvdCBcIituLmJhdGNoZXNQZXJFcG9jaH0pLHV0aWwuYXNzZXJ0KG51bGw9PW4udmFsaWRhdGlvblNwbGl0LGZ1bmN0aW9uKCl7cmV0dXJuXCJgdmFsaWRhdGlvblNwbGl0YCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGBmaXREYXRhc2V0KClgLiBVc2UgdmFsaWRhdGlvbkRhdGEgaW5zdGVhZC5cIn0pLGUuaXNUcmFpbmluZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy5cIik7ZS5pc1RyYWluaW5nPSEwLEwubGFiZWw9MTtjYXNlIDE6cmV0dXJuIEwudHJ5cy5wdXNoKFsxLCwyMiwyM10pLGk9bnVsbCE9bi52YWxpZGF0aW9uRGF0YSxhPXZvaWQgMCxvPXZvaWQgMCxpJiYoaXNEYXRhc2V0T2JqZWN0KG4udmFsaWRhdGlvbkRhdGEpP3V0aWwuYXNzZXJ0KG51bGw9PW4udmFsaWRhdGlvbkJhdGNoZXN8fG4udmFsaWRhdGlvbkJhdGNoZXM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLnZhbGlkYXRpb25CYXRjaGVzKSxmdW5jdGlvbigpe3JldHVyblwiRm9yIGZpdERhdGFzZXQoKSB3aXRoIGRhdGFzZXQtYmFzZWQgdmFsaWRhdGlvbiwgY29uZmlnLnZhbGlkYXRpb25CYXRjaGVzIGlzIGV4cGVjdGVkIG5vdCB0byBiZSBwcm92aWRlZCwgb3IgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK24udmFsaWRhdGlvbkJhdGNoZXN9KToocz1zdGFuZGFyZGl6ZVRlbnNvclZhbGlkYXRpb25EYXRhKG4udmFsaWRhdGlvbkRhdGEpLGE9cy54cyxvPXMueXMpKSxsPWUubWFrZVRyYWluRnVuY3Rpb24oKSx1PWUuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLGM9dm9pZCAwLGM9aT91LnNsaWNlKCkuY29uY2F0KHUubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwidmFsX1wiK2V9KSk6dS5zbGljZSgpLHA9c3RhbmRhcmRpemVDYWxsYmFja3Mobi5jYWxsYmFja3Msbi55aWVsZEV2ZXJ5KSxoPW51bGw9PW4udmVyYm9zZT8xOm4udmVyYm9zZSxkPWNvbmZpZ3VyZUNhbGxiYWNrcyhwLGgsbi5lcG9jaHMsbnVsbCxudWxsLGdldFN0ZXBzUGVyRXBvY2godCxuKSxudWxsLGksYyksZj1kLmNhbGxiYWNrTGlzdCxnPWQuaGlzdG9yeSxmLnNldE1vZGVsKGUpLGUuaGlzdG9yeT1nLFs0LGYub25UcmFpbkJlZ2luKCldO2Nhc2UgMjpyZXR1cm4gTC5zZW50KCksZS5zdG9wVHJhaW5pbmdfPSExLG09bnVsbD09bi5pbml0aWFsRXBvY2g/MDpuLmluaXRpYWxFcG9jaCxbNCx0Lml0ZXJhdG9yKCldO2Nhc2UgMzp5PUwuc2VudCgpLEwubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIG08bi5lcG9jaHM/KHY9e30sWzQsZi5vbkVwb2NoQmVnaW4obSldKTpbMywxOV07Y2FzZSA1OnJldHVybiBMLnNlbnQoKSxiPTAsdz0wLHI/WzMsN106WzQsdC5pdGVyYXRvcigpXTtjYXNlIDY6eT1MLnNlbnQoKSxMLmxhYmVsPTc7Y2FzZSA3OnJldHVybiFyfHxiPG4uYmF0Y2hlc1BlckVwb2NoP1s0LHkubmV4dCgpXTpbMywxN107Y2FzZSA4OnJldHVybiB6PUwuc2VudCgpLHImJnouZG9uZT8oY29uc29sZS53YXJuKFwiWW91IHByb3ZpZGVkIGBiYXRjaGVzUGVyRXBvY2hgIGFzIFwiK24uYmF0Y2hlc1BlckVwb2NoK1wiLCBidXQgeW91ciBkYXRhc2V0IGl0ZXJhdG9yIHJhbiBvdXQgb2YgZGF0YSBhZnRlciBcIitiK1wiIGJhdGNoZXM7IGludGVycnVwdGluZyB0cmFpbmluZy4gTWFrZSBzdXJlIHRoYXQgeW91ciBkYXRhc2V0IGNhbiBnZW5lcmF0ZSBhdCBsZWFzdCBgYmF0Y2hlc1BlckVwb2NoICogZXBvY2hzYCBiYXRjaGVzIChpbiB0aGlzIGNhc2UsIFwiK24uYmF0Y2hlc1BlckVwb2NoKm4uZXBvY2hzK1wiIGJhdGNoZXMpLiBZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nIHlvdXIgZGF0YXNldC5cIiksWzMsMTddKTpudWxsPT16LnZhbHVlP1szLDExXTooUz1zdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChlLHoudmFsdWUpLChJPXt9KS5iYXRjaD13LEkuc2l6ZT1TWzBdLnNoYXBlWzBdLFs0LGYub25CYXRjaEJlZ2luKHcsSSldKTtjYXNlIDk6Zm9yKEwuc2VudCgpLEE9bChTKSxkaXNwb3NlKFMpLGs9MDtrPHUubGVuZ3RoOysraylfPXVba10sQz1BW2tdLElbX109QyxrZWVwKEMpO3JldHVybls0LGYub25CYXRjaEVuZCh3LEkpXTtjYXNlIDEwOkwuc2VudCgpLGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKEkpLHcrKyxiKyssTC5sYWJlbD0xMTtjYXNlIDExOnJldHVybihyP2I+PW4uYmF0Y2hlc1BlckVwb2NoOnouZG9uZSk/aT8oTj12b2lkIDAsaXNEYXRhc2V0T2JqZWN0KG4udmFsaWRhdGlvbkRhdGEpPyhFPXRvTGlzdCxbNCxlLmV2YWx1YXRlRGF0YXNldChuLnZhbGlkYXRpb25EYXRhLHtiYXRjaGVzOm4udmFsaWRhdGlvbkJhdGNoZXN9KV0pOlszLDEzXSk6WzMsMTVdOlszLDE2XTtjYXNlIDEyOnJldHVybiBOPUUuYXBwbHkodm9pZCAwLFtMLnNlbnQoKV0pLFszLDE0XTtjYXNlIDEzOk49dG9MaXN0KGUuZXZhbHVhdGUoYSxvLHtiYXRjaFNpemU6bnVsbD09bi52YWxpZGF0aW9uQmF0Y2hTaXplP0RFRkFVTFRfVkFMSURBVElPTl9CQVRDSF9TSVpFOm4udmFsaWRhdGlvbkJhdGNoU2l6ZSx2ZXJib3NlOjB9KSksTC5sYWJlbD0xNDtjYXNlIDE0OmZvcihrPTA7azxlLm1ldHJpY3NOYW1lcy5sZW5ndGg7KytrKXZbXCJ2YWxfXCIrZS5tZXRyaWNzTmFtZXNba11dPU5ba107TC5sYWJlbD0xNTtjYXNlIDE1OnJldHVyblszLDE3XTtjYXNlIDE2OnJldHVybiBlLnN0b3BUcmFpbmluZ18/WzMsMTddOlszLDddO2Nhc2UgMTc6cmV0dXJuWzQsZi5vbkVwb2NoRW5kKG0sdildO2Nhc2UgMTg6cmV0dXJuIEwuc2VudCgpLG0rKyxlLnN0b3BUcmFpbmluZ18/WzMsMTldOlszLDRdO2Nhc2UgMTk6cmV0dXJuWzQsZi5vblRyYWluRW5kKCldO2Nhc2UgMjA6cmV0dXJuIEwuc2VudCgpLFs0LGUuaGlzdG9yeS5zeW5jRGF0YSgpXTtjYXNlIDIxOnJldHVybiBMLnNlbnQoKSxbMixlLmhpc3RvcnldO2Nhc2UgMjI6cmV0dXJuIGUuaXNUcmFpbmluZz0hMSxbN107Y2FzZSAyMzpyZXR1cm5bMl19fSl9KX1mdW5jdGlvbiBnZXRTdGVwc1BlckVwb2NoKGUsdCl7dmFyIG49bnVsbDtyZXR1cm4gbnVsbCE9dC5iYXRjaGVzUGVyRXBvY2g/bj10LmJhdGNoZXNQZXJFcG9jaDpOdW1iZXIuaXNGaW5pdGUoZS5zaXplKSYmKG49ZS5zaXplKSxufWZ1bmN0aW9uIGlzRGF0YXNldE9iamVjdChlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLml0ZXJhdG9yfWZ1bmN0aW9uIGlzTGF6eUl0ZXJhdG9yT2JqZWN0KGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUubmV4dH1mdW5jdGlvbiBldmFsdWF0ZURhdGFzZXQoZSx0LG4pe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsaSxhLG8scyxsLHUsYyxwLGg7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZCl7c3dpdGNoKGQubGFiZWwpe2Nhc2UgMDppZihyPW51bGwhPShuPW58fHt9KS5iYXRjaGVzLGk9ZS50ZXN0RnVuY3Rpb24sYT1bXSxuLnZlcmJvc2U+MCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gdXRpbC5hc3NlcnQoIXJ8fG4uYmF0Y2hlcz4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uYmF0Y2hlcyksZnVuY3Rpb24oKXtyZXR1cm5cIlRlc3QgbG9vcCBleHBlY3RzIGBiYXRjaGVzYCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShuLmJhdGNoZXMpfSksaXNMYXp5SXRlcmF0b3JPYmplY3QodCk/KHM9dCxbMywzXSk6WzMsMV07Y2FzZSAxOnJldHVybls0LHQuaXRlcmF0b3IoKV07Y2FzZSAyOnM9ZC5zZW50KCksZC5sYWJlbD0zO2Nhc2UgMzpvPXMsbD0wLHU9MCxjPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7c3dpdGNoKHMubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxvLm5leHQoKV07Y2FzZSAxOnJldHVybiB0PXMuc2VudCgpLGE9dGlkeShmdW5jdGlvbigpe2lmKHQudmFsdWUpe3ZhciBuPXN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KGUsdC52YWx1ZSkscj10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGkobil9KTtpZihkaXNwb3NlKG4pLDA9PT11KWZvcih2YXIgbz0wO288ci5sZW5ndGg7KytvKWEucHVzaChzY2FsYXIoMCkpO3ZhciBzPW5bMF0uc2hhcGVbMF0sYz1mdW5jdGlvbihlKXt2YXIgdD1yW2VdLG49YVtlXTthW2VdPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gYWRkKGFbZV0sbXVsKHMsdCkpfSksdT4wJiZkaXNwb3NlKG4pfTtmb3Iobz0wO288ci5sZW5ndGg7KytvKWMobyk7ZGlzcG9zZShyKSxsKz1zLCsrdX1yZXR1cm4gYX0pLHQuZG9uZT8ociYmY29uc29sZS53YXJuKFwiWW91ciBkYXRhc2V0IGl0ZXJhdG9yIHJhbiBvdXQgb2YgZGF0YSBkdXJpbmcgZXZhbHVhdGVEYXRhc2V0KCkuIEludGVycnVwdGluZyBldmFsdXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNgIGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgXCIrbi5iYXRjaGVzK1wiIGJhdGNoZXMpLiBZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nIHlvdXIgZGF0YXNldC5cIiksWzIsXCJicmVha1wiXSk6WzJdfX0pfSxkLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiFyfHx1PG4uYmF0Y2hlcz9bNSxjKCldOlszLDZdO2Nhc2UgNTpyZXR1cm5cImJyZWFrXCI9PT1kLnNlbnQoKT9bMyw2XTpbMyw0XTtjYXNlIDY6Zm9yKHA9MDtwPGEubGVuZ3RoOysrcCloPWFbcF0sYVtwXT1kaXYoYVtwXSxsKSxkaXNwb3NlKGgpO3JldHVyblsyLHNpbmdsZXRvbk9yQXJyYXkoYSldfX0pfSl9ZnVuY3Rpb24gY2hlY2tCYXRjaFNpemUoZSl7dXRpbC5hc3NlcnQoZT4wJiZOdW1iZXIuaXNJbnRlZ2VyKGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaFNpemUgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK2V9KX1mdW5jdGlvbiBzbGljZUFycmF5cyhlLHQsbil7cmV0dXJuIG51bGw9PWU/W251bGxdOkFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4tdCl9KTpzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuLXQpfWZ1bmN0aW9uIHNsaWNlQXJyYXlzQnlJbmRpY2VzKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09ZT9udWxsOkFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHNsaWNlQXJyYXlzQnlJbmRpY2VzKGUsdCl9KTpnYXRoZXIkMShlLFwiaW50MzJcIj09PXQuZHR5cGU/dDp0LnRvSW50KCkpfSl9ZnVuY3Rpb24gbWFrZUJhdGNoZXMoZSx0KXtmb3IodmFyIG49W10scj0wLGk9bnVsbDtyPGU7KShpPXIrdCk+PWUmJihpPWUpLG4ucHVzaChbcixpXSkscj1pO3JldHVybiBufWZ1bmN0aW9uIGZpdExvb3AoZSx0LG4scixpLGEsbyxzLGwsdSxjLHAsaCxkLGYpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGcsbSx5LHYsYix3LHosUztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihJKXtzd2l0Y2goSS5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PWkmJihpPTMyKSxudWxsPT1hJiYoYT0xKSxudWxsPT1jJiYoYz0hMCksbnVsbD09aCYmKGg9MCksZz0hMSxudWxsIT1sJiZudWxsIT11JiYoZz0hMCksbnVsbCE9ZiYmKGc9ITAsbnVsbD09ZCkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW4gb25seSB1c2UgYHZhbGlkYXRpb25TdGVwc2Agd2hlbiBkb2luZyBzdGVwLXdpc2UgdHJhaW5pbmcsIGkuZS4sIGBzdGVwc1BlckVwb2NoYCBtdXN0IGJlIHNldC5cIik7cmV0dXJuIG51bGwhPShtPWUuY2hlY2tOdW1TYW1wbGVzKG4saSxkLFwic3RlcHNfcGVyX2Vwb2NoXCIpKSYmKHk9cmFuZ2UoMCxtKSksbnVsbD09byYmKG89MSksdj1jb25maWd1cmVDYWxsYmFja3MocyxvLGEsaCxtLGQsaSxnLHApLGI9di5jYWxsYmFja0xpc3Qsdz12Lmhpc3RvcnksYi5zZXRNb2RlbChlKSxlLmhpc3Rvcnk9dyxbNCxiLm9uVHJhaW5CZWdpbigpXTtjYXNlIDE6SS5zZW50KCksZS5zdG9wVHJhaW5pbmdfPSExLHo9ZnVuY3Rpb24oYSl7dmFyIG8scyxwLGgsZjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih2KXtzd2l0Y2godi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGIub25FcG9jaEJlZ2luKGEpXTtjYXNlIDE6aWYodi5zZW50KCksbz17fSxudWxsPT1kKXJldHVyblszLDJdO3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic3RlcHNQZXJFcG9jaCBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Nhc2UgMjppZihcImJhdGNoXCI9PT1jKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2ggc2h1ZmZsaW5nIGlzIG5vdCBpbXBsZW1uZXRlZCB5ZXRcIik7YyYmdXRpbC5zaHVmZmxlKHkpLHM9dGVuc29yMWQoeSkscD1tYWtlQmF0Y2hlcyhtLGkpLGg9ZnVuY3Rpb24oYSl7dmFyIGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaCl7c3dpdGNoKGgubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYz17fSxbNCxiLm9uQmF0Y2hCZWdpbihhLGMpXTtjYXNlIDE6cmV0dXJuIGguc2VudCgpLHRpZHkoZnVuY3Rpb24oKXt2YXIgaD1wW2FdWzBdLGQ9cFthXVsxXSxmPXNsaWNlQWxvbmdGaXJzdEF4aXMocyxoLGQtaCk7Yy5iYXRjaD1hLGMuc2l6ZT1kLWg7Zm9yKHZhciBtPXNsaWNlQXJyYXlzQnlJbmRpY2VzKG4sZikseT10KG0pLHY9MDt2PHIubGVuZ3RoOysrdil7dmFyIGI9clt2XSx3PXlbdl07Y1tiXT13LGtlZXAodyl9aWYoYT09PXAubGVuZ3RoLTEmJmcpe3ZhciB6PWUudGVzdExvb3AobCx1LGkpO2Zvcih2PTA7djxyLmxlbmd0aDsrK3Ype2I9clt2XSx3PXpbdl07a2VlcCh3KSxvW1widmFsX1wiK2JdPXd9fX0pLFs0LGIub25CYXRjaEVuZChhLGMpXTtjYXNlIDI6cmV0dXJuIGguc2VudCgpLGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGMpLGUuc3RvcFRyYWluaW5nXz9bMixcImJyZWFrXCJdOlsyXX19KX0sZj0wLHYubGFiZWw9MztjYXNlIDM6cmV0dXJuIGY8cC5sZW5ndGg/WzUsaChmKV06WzMsNl07Y2FzZSA0OmlmKFwiYnJlYWtcIj09PXYuc2VudCgpKXJldHVyblszLDZdO3YubGFiZWw9NTtjYXNlIDU6cmV0dXJuKytmLFszLDNdO2Nhc2UgNjpzLmRpc3Bvc2UoKSx2LmxhYmVsPTc7Y2FzZSA3OnJldHVybls0LGIub25FcG9jaEVuZChhLG8pXTtjYXNlIDg6cmV0dXJuIHYuc2VudCgpLGUuc3RvcFRyYWluaW5nXz9bMixcImJyZWFrXCJdOlsyXX19KX0sUz1oLEkubGFiZWw9MjtjYXNlIDI6cmV0dXJuIFM8YT9bNSx6KFMpXTpbMyw1XTtjYXNlIDM6aWYoXCJicmVha1wiPT09SS5zZW50KCkpcmV0dXJuWzMsNV07SS5sYWJlbD00O2Nhc2UgNDpyZXR1cm4rK1MsWzMsMl07Y2FzZSA1OnJldHVybls0LGIub25UcmFpbkVuZCgpXTtjYXNlIDY6cmV0dXJuIEkuc2VudCgpLFs0LGUuaGlzdG9yeS5zeW5jRGF0YSgpXTtjYXNlIDc6cmV0dXJuIEkuc2VudCgpLFsyLGUuaGlzdG9yeV19fSl9KX1mdW5jdGlvbiBmaXRUZW5zb3JzKGUsdCxuLHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBpLGEsbyxzLGwsdSxjLHAsaCxkLGYsZyxtLHksdixiLHcseixTO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKEkpe3N3aXRjaChJLmxhYmVsKXtjYXNlIDA6aWYoZS5pc1RyYWluaW5nKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdGFydCB0cmFpbmluZyBiZWNhdXNlIGFub3RoZXIgZml0KCkgY2FsbCBpcyBvbmdvaW5nLlwiKTtlLmlzVHJhaW5pbmc9ITAsSS5sYWJlbD0xO2Nhc2UgMTppZihJLnRyeXMucHVzaChbMSwsMyw0XSksY2hlY2tCYXRjaFNpemUoYz1udWxsPT1yLmJhdGNoU2l6ZT8zMjpyLmJhdGNoU2l6ZSkscD1lLnN0YW5kYXJkaXplVXNlckRhdGEodCxuLCExLGMpLGk9cFswXSxhPXBbMV0saD0hMSxkPXZvaWQgMCxudWxsIT1yLnZhbGlkYXRpb25EYXRhJiZyLnZhbGlkYXRpb25EYXRhLmxlbmd0aD4wKXtpZihoPSEwLDIhPT1yLnZhbGlkYXRpb25EYXRhLmxlbmd0aCl0aHJvdyAzPT09ci52YWxpZGF0aW9uRGF0YS5sZW5ndGg/bmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ2YWxpZGF0aW9uRGF0YSBpbmNsdWRpbmcgc2FtcGxlIHdlaWdodHMgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpOm5ldyBWYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIHZhbGlkYXRpb24gZGF0YSwgaXQgbXVzdCBjb250YWluIDIgKHZhbFgsIHZhbFkpIG9yIDMgKHZhbFgsIHZhbFksIHZhbFNhbXBsZVdlaWdodCkgaXRlbXM7IFwiK3IudmFsaWRhdGlvbkRhdGErXCIgaXMgaW52YWxpZC5cIik7bz1yLnZhbGlkYXRpb25EYXRhWzBdLHM9ci52YWxpZGF0aW9uRGF0YVsxXSxmPWUuc3RhbmRhcmRpemVVc2VyRGF0YShvLHMsITAsYyksbD1mWzBdLHU9ZlsxXSxkPWwuY29uY2F0KHUpfWVsc2UgbnVsbCE9ci52YWxpZGF0aW9uU3BsaXQmJnIudmFsaWRhdGlvblNwbGl0PjAmJnIudmFsaWRhdGlvblNwbGl0PDE/KGg9ITAsZz1NYXRoLmZsb29yKGlbMF0uc2hhcGVbMF0qKDEtci52YWxpZGF0aW9uU3BsaXQpKSxtPWlbMF0uc2hhcGVbMF0sbD1zbGljZUFycmF5cyhpLGcsbSksaT1zbGljZUFycmF5cyhpLDAsZyksdT1zbGljZUFycmF5cyhhLGcsbSksYT1zbGljZUFycmF5cyhhLDAsZyksZD1sLmNvbmNhdCh1KSk6bnVsbCE9ci52YWxpZGF0aW9uU3RlcHMmJihoPSEwKTtyZXR1cm4geT1pLmNvbmNhdChhKSxlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCksdj1lLm1ha2VUcmFpbkZ1bmN0aW9uKCksYj1lLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKSx3PXZvaWQgMCx6PXZvaWQgMCxoPyhlLm1ha2VUZXN0RnVuY3Rpb24oKSx3PWUudGVzdEZ1bmN0aW9uLHo9Yi5zbGljZSgpLmNvbmNhdChiLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cInZhbF9cIitlfSkpKToodz1udWxsLGQ9W10sej1iLnNsaWNlKCkpLFM9c3RhbmRhcmRpemVDYWxsYmFja3Moci5jYWxsYmFja3Msci55aWVsZEV2ZXJ5KSxbNCxmaXRMb29wKGUsdix5LGIsYyxyLmVwb2NocyxyLnZlcmJvc2UsUyx3LGQsci5zaHVmZmxlLHosci5pbml0aWFsRXBvY2gsbnVsbCxudWxsKV07Y2FzZSAyOnJldHVyblsyLEkuc2VudCgpXTtjYXNlIDM6cmV0dXJuIGUuaXNUcmFpbmluZz0hMSxkaXNwb3NlTmV3VGVuc29ycyhpLHQpLGRpc3Bvc2VOZXdUZW5zb3JzKGEsbiksZGlzcG9zZU5ld1RlbnNvcnMobCxvKSxkaXNwb3NlTmV3VGVuc29ycyh1LHMpLFs3XTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9ZnVuY3Rpb24gZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIoZSl7dmFyIHQ9W107ZSBpbnN0YW5jZW9mIFRlbnNvciYmKGU9W2VdKTtmb3IodmFyIG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZVtuXTtpZigxPT09ci5yYW5rKXQucHVzaChleHBhbmREaW1zJDEociwxKSk7ZWxzZXtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRlbnNvciB0byBiZSBhdCBsZWFzdCAxRCwgYnV0IHJlY2VpdmVkIGEgMEQgdGVuc29yIChzY2FsYXIpLlwiKTt0LnB1c2gocil9fXJldHVybiB0fWZ1bmN0aW9uIGRpc3Bvc2VOZXdUZW5zb3JzKGUsdCl7aWYobnVsbCE9ZSl7dmFyIG49W107aWYodCBpbnN0YW5jZW9mIFRlbnNvciluLnB1c2godC5pZCk7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpKXQuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5wdXNoKGUuaWQpfSk7ZWxzZSBpZihudWxsIT10KWZvcih2YXIgciBpbiB0KXt2YXIgaT10W3JdO24ucHVzaChpLmlkKX12YXIgYT1bXTtpZihlIGluc3RhbmNlb2YgVGVuc29yKS0xPT09bi5pbmRleE9mKGUuaWQpJiZhLnB1c2goZSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKWUuZm9yRWFjaChmdW5jdGlvbihlKXstMT09PW4uaW5kZXhPZihlLmlkKSYmYS5wdXNoKGUpfSk7ZWxzZSBpZihudWxsIT1lKWZvcih2YXIgbyBpbiBlKXt2YXIgcz1lW29dOy0xPT09bi5pbmRleE9mKHMuaWQpJiZhLnB1c2gocyl9YS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaXNEaXNwb3NlZHx8ZS5kaXNwb3NlKCl9KX19ZnVuY3Rpb24gaXNEYXRhVGVuc29yKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVGVuc29yfWZ1bmN0aW9uIGlzRGF0YUFycmF5KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpfWZ1bmN0aW9uIGlzRGF0YURpY3QoZSl7cmV0dXJuIWlzRGF0YVRlbnNvcihlKSYmIWlzRGF0YUFycmF5KGUpfWZ1bmN0aW9uIHN0YW5kYXJkaXplSW5wdXREYXRhKGUsdCxuLHIsaSl7aWYodm9pZCAwPT09ciYmKHI9ITApLHZvaWQgMD09PWkmJihpPVwiXCIpLG51bGw9PXR8fDA9PT10Lmxlbmd0aCl7aWYobnVsbCE9ZSl7dmFyIGE9ITE7aWYoaXNEYXRhQXJyYXkoZSkmJmUubGVuZ3RoPjApYT0hMDtlbHNlIGlmKGlzRGF0YURpY3QoZSkpe2Zvcih2YXIgbyBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkobykpe2E9ITA7YnJlYWt9fWVsc2UgYT0hMDtpZihhKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIitpK1wiIGV4cGVjdGVkIG5vIGRhdGEsIGJ1dCBnb3QgXCIrZSl9cmV0dXJuW119aWYobnVsbD09ZSlyZXR1cm4gdC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KTt2YXIgcztpZihpc0RhdGFEaWN0KGUpKXtlPWUscz1bXTtmb3IodmFyIGw9MCx1PXQ7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPXVbbF07aWYobnVsbD09ZVtjXSl0aHJvdyBuZXcgVmFsdWVFcnJvcignTm8gZGF0YSBwcm92aWRlZCBmb3IgXCInK2MrJ1wiLiBOZWVkIGRhdGEgZm9yIGVhY2gga2V5IGluOiAnK3QpO3MucHVzaChlW2NdKX19ZWxzZSBpZihpc0RhdGFBcnJheShlKSl7aWYoKGU9ZSkubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiK2krXCI6IHRoZSBBcnJheSBvZiBUZW5zb3JzIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRvIHlvdXIgbW9kZWwgaXMgbm90IHRoZSBzaXplIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiK3QubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290IHRoZSBmb2xsb3dpbmcgbGlzdCBvZiBUZW5zb3Iocyk6IFwiK2UpO3M9ZX1lbHNle2lmKGU9ZSx0Lmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG1vZGVsIFwiK2krXCIgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBUZW5zb3IocyksIGJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBUZW5zb3Igd2l0aCBzaGFwZSBcIitlLnNoYXBlKTtzPVtlXX1pZihzPWVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKHMpLG51bGwhPW4pZm9yKHZhciBwPTA7cDx0Lmxlbmd0aDsrK3ApaWYobnVsbCE9bltwXSl7dmFyIGg9c1twXTtpZihoLnNoYXBlLmxlbmd0aCE9PW5bcF0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W3BdK1wiIHRvIGhhdmUgXCIrbltwXS5sZW5ndGgrXCIgZGltZW5zaW9uKHMpLiBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgXCIraC5zaGFwZSk7Zm9yKHZhciBkPTA7ZDxuW3BdLmxlbmd0aDsrK2QpaWYoMCE9PWR8fHIpe3ZhciBmPWguc2hhcGVbZF0sZz1uW3BdW2RdO2lmKG51bGwhPWcmJmc+PTAmJmYhPT1nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W3BdK1wiIHRvIGhhdmUgc2hhcGUgW1wiK25bcF0rXCJdLCBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgW1wiK2guc2hhcGUrXCJdLlwiKX19cmV0dXJuIHN9ZnVuY3Rpb24gY2hlY2tBcnJheUxlbmd0aHMoZSx0LG4pe3ZhciByPXVuaXF1ZShlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZVswXX0pKTtyLnNvcnQoKTt2YXIgaT11bmlxdWUodC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbMF19KSk7aWYoaS5zb3J0KCksci5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBpbnB1dCBUZW5zb3JzICh4KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gR290IGFycmF5IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSkpO2lmKGkubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgdGFyZ2V0IFRlbnNvcnMgKHkpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBHb3QgYXJyYXkgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeSh0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pKSk7aWYoci5sZW5ndGg+MCYmaS5sZW5ndGg+MCYmIXV0aWwuYXJyYXlzRXF1YWwocixpKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMgYXMgdGFyZ2V0IFRlbnNvcnMuIEZvdW5kIFwiK3JbMF0rXCIgaW5wdXQgc2FtcGxlKHMpIGFuZCBcIitpWzBdK1wiIHRhcmdldCBzYW1wbGUocykuXCIpfWZ1bmN0aW9uIGNoZWNrTG9zc0FuZFRhcmdldENvbXBhdGliaWxpdHkoZSx0LG4pe2Zvcih2YXIgcj1bbWVhblNxdWFyZWRFcnJvcixiaW5hcnlDcm9zc2VudHJvcHksY2F0ZWdvcmljYWxDcm9zc2VudHJvcHldLGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIGE9ZVtpXSxvPXRbaV0scz1uW2ldO2lmKG51bGwhPW8pe2lmKG89PT1jYXRlZ29yaWNhbENyb3NzZW50cm9weSYmMT09PWEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJZb3UgYXJlIHBhc3NpbmcgYSB0YXJnZXQgYXJyYXkgb2Ygc2hhcGUgXCIrYS5zaGFwZStcIiB3aGlsZSB1c2luZyBhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknZXhwZWN0cyB0YXJnZXRzIHRvIGJlIGJpbmFyeSBtYXRyaWNlcyAoMXMgYW5kIDBzKSBvZiBzaGFwZSBbc2FtcGxlcywgY2xhc3Nlc10uXCIpO2lmKC0xIT09ci5pbmRleE9mKG8pKWZvcih2YXIgbD1hLnNoYXBlLnNsaWNlKDEpLHU9cy5zbGljZSgxKSxjPTA7YzxsLmxlbmd0aDsrK2Mpe3ZhciBwPWxbY10saD11W2NdO2lmKG51bGwhPWgmJnAhPT1oKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgXCIrYS5zaGFwZStcIiB3YXMgcGFzc2VkIGZvciBhbiBvdXRwdXQgb2Ygc2hhcGUgXCIrcytcIiwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0YXJnZXRzIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIG91dHB1dC5cIil9fX19ZnVuY3Rpb24gY2hlY2tJbnB1dERhdGEoZSx0LG4scixpKXt2YXIgYTtpZih2b2lkIDA9PT1yJiYocj0hMCksdm9pZCAwPT09aSYmKGk9XCJcIiksQXJyYXkuaXNBcnJheShlKSl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIraStcIjogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiK3QubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290IFwiK2UubGVuZ3RoK1wiIFRlbnNvcnMocykuXCIpO2E9ZX1lbHNle2lmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgZXhwZWN0cyBcIit0Lmxlbmd0aCtcIiBcIitpK1wiIFRlbnNvcnMsIGJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpK1wiLlwiKTthPVtlXX1pZihudWxsIT1uKWZvcih2YXIgbz0wO288dC5sZW5ndGg7KytvKWlmKG51bGwhPW5bb10pe3ZhciBzPWFbb107aWYocy5zaGFwZS5sZW5ndGghPT1uW29dLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIraStcIjogZXhwZWN0ZWQgXCIrdFtvXStcIiB0byBoYXZlIFwiK25bb10ubGVuZ3RoK1wiIGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHMuc2hhcGUpKTtmb3IodmFyIGw9MDtsPG5bb10ubGVuZ3RoOysrbClpZigwIT09bHx8cil7dmFyIHU9cy5zaGFwZVtsXSxjPW5bb11bbF07aWYobnVsbCE9YyYmYyE9PXUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiK2krXCI6IGV4cGVjdGVkIFwiK3Rbb10rXCIgdG8gaGF2ZSBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShuW29dKStcIiBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkocy5zaGFwZSkrXCIuXCIpfX19ZnVuY3Rpb24gY29sbGVjdE1ldHJpY3MoZSx0KXtpZihudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgpcmV0dXJuIHQubWFwKGZ1bmN0aW9uKGUpe3JldHVybltdfSk7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGV9KTtpZihudWxsIT1lKXtmb3IodmFyIG49W10scj0wLGk9dDtyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aVtyXSxvPWUuaGFzT3duUHJvcGVydHkoYSk/ZVthXTpbXTtBcnJheS5pc0FycmF5KG8pfHwobz1bb10pLG4ucHVzaChvKX1yZXR1cm4gbn10aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZSBvZiBtZXRyaWNzIGFyZ3VtZW50IG5vdCB1bmRlcnN0b29kLiBFeHBlY3RlZCBhbiBBcnJheSBvciBPYmplY3QsIGZvdW5kOiBcIitlKX12YXIgTEFZRVJTX01PREVMX0ZPUk1BVF9OQU1FPVwibGF5ZXJzLW1vZGVsXCIsTGF5ZXJzTW9kZWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5pc1RyYWluaW5nPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PW4mJihuPWNvbnNvbGUubG9nKSwhdGhpcy5idWlsdCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoaXMgbW9kZWwgaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCB0aHVzIGl0cyB3ZWlnaHRzIGhhdmUgbm90IGJlZW4gY3JlYXRlZCB5ZXQuIFNvIG5vIHN1bW1hcnkgY2FuIGJlIGRpc3BsYXllZC4gQnVpbGQgdGhlIG1vZGVsIGZpcnN0IChlLmcuLCBieSBjYWxsaW5nIGl0IG9uIHNvbWUgdGVzdCBkYXRhKS5cIik7cHJpbnRTdW1tYXJ5KHRoaXMsZSx0LG4pfSx0LnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYobnVsbD09ZS5sb3NzJiYoZS5sb3NzPVtdKSx0aGlzLmxvc3M9ZS5sb3NzLFwic3RyaW5nXCI9PXR5cGVvZiBlLm9wdGltaXplcil0aGlzLm9wdGltaXplcl89Z2V0T3B0aW1pemVyKGUub3B0aW1pemVyKSx0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITA7ZWxzZXtpZighKGUub3B0aW1pemVyIGluc3RhbmNlb2YgT3B0aW1pemVyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVzZXItZGVmaW5lZCBvcHRpbWl6ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB0Zi5PcHRpbWl6ZXIuXCIpO3RoaXMub3B0aW1pemVyXz1lLm9wdGltaXplcix0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITF9dmFyIG49W107aWYoQXJyYXkuaXNBcnJheShlLmxvc3MpfHxcInN0cmluZ1wiPT10eXBlb2YgZS5sb3NzfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmxvc3MpaWYoQXJyYXkuaXNBcnJheShlLmxvc3MpKXtpZihlLmxvc3MubGVuZ3RoIT09dGhpcy5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyBhbiBBcnJheSBhcyBsb3NzLCBpdCBzaG91bGQgaGF2ZSBvbmUgZW50cnkgcGVyIG1vZGVsIG91dHB1dC4gVGhlIG1vZGVsIGhhcyBcIit0aGlzLm91dHB1dHMubGVuZ3RoK1wiIG91dHB1dChzKSwgYnV0IHlvdSBwYXNzZWQgbG9zcz1cIitlLmxvc3MrXCIuXCIpO3ZhciByPWUubG9zcztuPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBnZXQoZSl9KX1lbHNle3ZhciBpPWdldChlLmxvc3MpO3RoaXMub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe24ucHVzaChpKX0pfWVsc2V7Zm9yKHZhciBhIGluIGUubG9zcz1lLmxvc3MsZS5sb3NzKWlmKC0xPT09dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKGEpKXRocm93IG5ldyBWYWx1ZUVycm9yKCdVbmtub3duIGVudHJ5IGluIGxvc3MgZGljdGlvbmFyeTogXCInK2ErJ1wiLiBPbmx5IGV4cGVjdGVkIHRoZSBmb2xsb3dpbmcga2V5czogJyt0aGlzLm91dHB1dE5hbWVzKTtmb3IodmFyIG89MCxzPXRoaXMub3V0cHV0TmFtZXM7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107bnVsbD09ZS5sb3NzW2xdJiZjb25zb2xlLndhcm4oJ091dHB1dCBcIicrbCsnXCIgaXMgbWlzc2luZyBmcm9tIGxvc3MgZGljdGlvbmFyeS4gV2UgYXNzdW1lIHRoaXMgd2FzIGRvbmUgb24gcHVycG9zZSwgYW5kIHdlIHdpbGwgbm90IGJlIGV4cGVjdGluZyBkYXRhIHRvIGJlIHBhc3NlZCB0byAnK2wrXCIgZHVyaW5nIHRyYWluaW5nXCIpLG4ucHVzaChnZXQoZS5sb3NzW2xdKSl9fXRoaXMubG9zc0Z1bmN0aW9ucz1uLHRoaXMuZmVlZE91dHB1dE5hbWVzPVtdLHRoaXMuZmVlZE91dHB1dFNoYXBlcz1bXSx0aGlzLmZlZWRMb3NzRm5zPVtdO2Zvcih2YXIgdT0wO3U8dGhpcy5vdXRwdXRzLmxlbmd0aDsrK3Upe3ZhciBjPXRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbdV0scD10aGlzLm91dHB1dE5hbWVzW3VdO3RoaXMuZmVlZE91dHB1dE5hbWVzLnB1c2gocCksdGhpcy5mZWVkT3V0cHV0U2hhcGVzLnB1c2goYyksdGhpcy5mZWVkTG9zc0Zucy5wdXNoKHRoaXMubG9zc0Z1bmN0aW9uc1t1XSl9dmFyIGg9W107dGhpcy5tZXRyaWNzPWUubWV0cmljcyx0aGlzLm1ldHJpY3NOYW1lcz1bXCJsb3NzXCJdLHRoaXMubWV0cmljc1RlbnNvcnM9W10sbmFtZVNjb3BlKFwibG9zc1wiLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTx0Lm91dHB1dHMubGVuZ3RoOysrZSlpZigtMT09PWguaW5kZXhPZihlKSl7dmFyIG49dC5sb3NzRnVuY3Rpb25zW2VdO3Qub3V0cHV0cy5sZW5ndGg+MSYmKHQubWV0cmljc1RlbnNvcnMucHVzaChbbixlXSksdC5tZXRyaWNzTmFtZXMucHVzaCh0Lm91dHB1dE5hbWVzW2VdK1wiX2xvc3NcIikpfX0pO3ZhciBkPWNvbGxlY3RNZXRyaWNzKGUubWV0cmljcyx0aGlzLm91dHB1dE5hbWVzKTtuYW1lU2NvcGUoXCJtZXRyaWNcIixmdW5jdGlvbigpe2Zvcih2YXIgZT1mdW5jdGlvbihlKXtpZigtMSE9PWguaW5kZXhPZihlKSlyZXR1cm5cImNvbnRpbnVlXCI7IWZ1bmN0aW9uKG4pe2Zvcih2YXIgcixpLGEsbz1mdW5jdGlvbihuKXtpZigtMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIixcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSl7dmFyIG89dC5pbnRlcm5hbE91dHB1dFNoYXBlc1tlXTsxPT09b1tvLmxlbmd0aC0xXXx8dC5sb3NzRnVuY3Rpb25zW2VdPT09YmluYXJ5Q3Jvc3NlbnRyb3B5Py0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP2k9YmluYXJ5QWNjdXJhY3k6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihpPWJpbmFyeUNyb3NzZW50cm9weSQxKTp0Lmxvc3NGdW5jdGlvbnNbZV09PT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weT8tMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihuKT9pPXNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3k6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihpPXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEpOi0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP2k9Y2F0ZWdvcmljYWxBY2N1cmFjeTotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKGk9Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSk7dmFyIHM9dm9pZCAwOy0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP3M9XCJhY2NcIjotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKHM9XCJjZVwiKSxhPWkscj1cIlwiK3N9ZWxzZXt2YXIgbD1nZXQkMShuKTthPWwscj1cIlwiK259dmFyIHU7bmFtZVNjb3BlKHIsZnVuY3Rpb24oKXt1PWF9KSxmdW5jdGlvbihlLG4scil7dC5vdXRwdXROYW1lcy5sZW5ndGg+MSYmKG49dC5vdXRwdXROYW1lc1tlXStcIl9cIituKSx0Lm1ldHJpY3NOYW1lcy5wdXNoKG4pLHQubWV0cmljc1RlbnNvcnMucHVzaChbcixlXSl9KGUscix1KX0scz0wLGw9bjtzPGwubGVuZ3RoO3MrKylvKGxbc10pfShkW2VdKX0sbj0wO248dC5vdXRwdXRzLmxlbmd0aDsrK24pZShuKX0pLHRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz10aGlzLnRyYWluYWJsZVdlaWdodHN9LHQucHJvdG90eXBlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzJiZ0aGlzLnRyYWluYWJsZVdlaWdodHMubGVuZ3RoIT09dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiRGlzY3JlcGFuY3kgYmV0d2VlbiB0cmFpbmFibGV3ZWlnaHRzIGFuZCBjb2xsZWN0ZWQgdHJhaW5hYmxlIHdlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyBgbW9kZWwuY29tcGlsZSgpYCBhZnRlcndhcmRzP1wiKX0sdC5wcm90b3R5cGUuZXZhbHVhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcj1udWxsPT1uLmJhdGNoU2l6ZT8zMjpuLmJhdGNoU2l6ZTtjaGVja0JhdGNoU2l6ZShyKTt2YXIgaT10aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoZSx0LCEwLHIpO3RyeXt2YXIgYT1pWzBdLmNvbmNhdChpWzFdKTt0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTt2YXIgbz10aGlzLnRlc3RGdW5jdGlvbjtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLnRlc3RMb29wKG8sYSxyLG4udmVyYm9zZSxuLnN0ZXBzKSl9ZmluYWxseXtkaXNwb3NlTmV3VGVuc29ycyhpWzBdLGUpLGRpc3Bvc2VOZXdUZW5zb3JzKGlbMV0sdCl9fSx0LnByb3RvdHlwZS5ldmFsdWF0ZURhdGFzZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKSxbMixldmFsdWF0ZURhdGFzZXQodGhpcyxlLHQpXX0pfSl9LHQucHJvdG90eXBlLmNoZWNrTnVtU2FtcGxlcz1mdW5jdGlvbihlLHQsbixyKXt2YXIgaTtpZih2b2lkIDA9PT1yJiYocj1cInN0ZXBzXCIpLG51bGwhPW4pe2lmKGk9bnVsbCxudWxsIT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgXCIrcitcIiBpcyBzZXQsIGJhdGNoU2l6ZSBtdXN0IGJlIG51bGwgb3IgdW5kZWZpbmVkLkdvdCBiYXRjaFNpemUgPSBcIit0KX1lbHNle2lmKG51bGw9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFaXRoZXIgdGhlIGlucHV0IGRhdGEgc2hvdWxkIGhhdmUgYSBkZWZpbmVkIHNoYXBlLCBvciBcIityK1wiIHNob3VkIGJlIHNwZWNpZmllZC5cIik7aT1BcnJheS5pc0FycmF5KGUpP2VbMF0uc2hhcGVbMF06ZS5zaGFwZVswXX1yZXR1cm4gaX0sdC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkodCkmJjA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBvdXRwdXRzYCBpcyBhbiBlbXB0eSBBcnJheSwgd2hpY2ggaXMgbm90IGFsbG93ZWQuXCIpO3ZhciBuPUFycmF5LmlzQXJyYXkodCkscj1uP3Q6W3RdLGk9dGhpcy5yZXRyaWV2ZVN5bWJvbGljVGVuc29ycyhyKSxhPW5ldyBGZWVkRGljdDtpZihlIGluc3RhbmNlb2YgVGVuc29yJiYoZT1bZV0pLEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dGhpcy5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG51bWJlciBvZiBpbnB1dHMgcHJvdmlkZWQgKFwiK2UubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyBvZiB0aGlzIG1vZGVsIChcIit0aGlzLmlucHV0cy5sZW5ndGgrXCIpLlwiKTtmb3IodmFyIG89MDtvPHRoaXMuaW5wdXRzLmxlbmd0aDsrK28pYS5hZGQodGhpcy5pbnB1dHNbb10sZVtvXSl9ZWxzZSBmb3IodmFyIHM9MCxsPXRoaXMuaW5wdXRzO3M8bC5sZW5ndGg7cysrKXt2YXIgdT1sW3NdLGM9ZVt1Lm5hbWVdO2lmKG51bGw9PWMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJObyB2YWx1ZSBpcyBwcm92aWRlZCBmb3IgdGhlIG1vZGVsJ3MgaW5wdXQgXCIrdS5uYW1lKTthLmFkZCh1LGMpfXZhciBwPWV4ZWN1dGUoaSxhKTtyZXR1cm4gbj9wOnBbMF19LHQucHJvdG90eXBlLnJldHJpZXZlU3ltYm9saWNUZW5zb3JzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1weUxpc3RSZXBlYXQobnVsbCxlLmxlbmd0aCksbj1lLmxlbmd0aCxyPTAsaT10aGlzLmxheWVycztyPGkubGVuZ3RoO3IrKyl7Zm9yKHZhciBhPWlbcl0sbz1BcnJheS5pc0FycmF5KGEub3V0cHV0KT9hLm91dHB1dDpbYS5vdXRwdXRdLHM9by5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLGw9MDtsPGUubGVuZ3RoOysrbCl7dmFyIHU9cy5pbmRleE9mKGVbbF0pO2lmKC0xIT09dSYmKHRbbF09b1t1XSxuLS0pLDA9PT1uKWJyZWFrfWlmKDA9PT1uKWJyZWFrfWlmKG4+MCl7dmFyIGM9W107dGhyb3cgdC5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7bnVsbD09dCYmYy5wdXNoKGVbbl0pfSksbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgZmluZCBTeW1ib2xpY1RlbnNvcnMgZm9yIG91dHB1dCBuYW1lKHMpOiBcIitKU09OLnN0cmluZ2lmeShjKSl9cmV0dXJuIHR9LHQucHJvdG90eXBlLnByZWRpY3RMb29wPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzO3JldHVybiB2b2lkIDA9PT10JiYodD0zMiksdm9pZCAwPT09biYmKG49ITEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgaT1yLmNoZWNrTnVtU2FtcGxlcyhlKTtpZihuKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVmVyYm9zZSBwcmVkaWN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Zvcih2YXIgYT1tYWtlQmF0Y2hlcyhpLHQpLG89ci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm5bXX0pLHM9ZnVuY3Rpb24odCl7dGlkeShmdW5jdGlvbigpe3ZhciBuPWFbdF1bMF0saT1hW3RdWzFdLG89c2xpY2VBcnJheXMoZSxuLGkpLHM9W107aWYoQXJyYXkuaXNBcnJheShvKSlmb3IodmFyIGw9MDtsPG8ubGVuZ3RoOysrbClzLnB1c2goe2tleTpyLmlucHV0c1tsXSx2YWx1ZTpvW2xdfSk7ZWxzZSBzLnB1c2goe2tleTpyLmlucHV0c1swXSx2YWx1ZTpvfSk7dmFyIHU9bmV3IEZlZWREaWN0KHMpO3JldHVybiBleGVjdXRlKHIub3V0cHV0cyx1KX0pLmZvckVhY2goZnVuY3Rpb24oZSx0KXtyZXR1cm4gb1t0XS5wdXNoKGUpfSl9LGw9MDtsPGEubGVuZ3RoOysrbClzKGwpO3JldHVybiBzaW5nbGV0b25PckFycmF5KG8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBjb25jYXQoZSwwKX0pKX0pfSx0LnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciBuPWVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKGUpO2NoZWNrSW5wdXREYXRhKG4sdGhpcy5pbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCExKTt0cnl7dmFyIHI9bnVsbD09dC5iYXRjaFNpemU/MzI6dC5iYXRjaFNpemU7cmV0dXJuIGNoZWNrQmF0Y2hTaXplKHIpLHRoaXMucHJlZGljdExvb3AobixyKX1maW5hbGx5e2Rpc3Bvc2VOZXdUZW5zb3JzKG4sZSl9fSx0LnByb3RvdHlwZS5wcmVkaWN0T25CYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gY2hlY2tJbnB1dERhdGEoZSx0aGlzLmlucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITApLHRoaXMucHJlZGljdExvb3AoZSxlLnNoYXBlWzBdKX0sdC5wcm90b3R5cGUuc3RhbmRhcmRpemVVc2VyRGF0YT1mdW5jdGlvbihlLHQsbixyKXtpZih2b2lkIDA9PT1uJiYobj0hMCksbnVsbD09dGhpcy5vcHRpbWl6ZXJfKXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSBMYXllcnNNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUFyZ3MpLlwiKTtmb3IodmFyIGk9W10sYT0wO2E8dGhpcy5mZWVkT3V0cHV0U2hhcGVzLmxlbmd0aDsrK2Epe3ZhciBvPXRoaXMuZmVlZE91dHB1dFNoYXBlc1thXTt0aGlzLmZlZWRMb3NzRm5zW2FdPT09c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk/aS5wdXNoKG8uc2xpY2UoMCxvLmxlbmd0aC0xKS5jb25jYXQoWzFdKSk6aS5wdXNoKG8pfWlmKGNoZWNrQXJyYXlMZW5ndGhzKGU9c3RhbmRhcmRpemVJbnB1dERhdGEoZSx0aGlzLmZlZWRJbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCExLFwiaW5wdXRcIiksdD1zdGFuZGFyZGl6ZUlucHV0RGF0YSh0LHRoaXMuZmVlZE91dHB1dE5hbWVzLGksITEsXCJ0YXJnZXRcIiksbnVsbCksY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eSh0LHRoaXMuZmVlZExvc3NGbnMsdGhpcy5mZWVkT3V0cHV0U2hhcGVzKSx0aGlzLnN0YXRlZnVsJiZudWxsIT1yJiZyPjAmJmVbMF0uc2hhcGVbMF0lciE9MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkluIGEgc3RhdGVmdWwgbmV0d29yaywgeW91IHNob3VsZCBvbmx5IHBhc3MgaW5wdXRzIHdpdGggYSBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIGRpdmlzaWJsZSBieSB0aGUgYmF0Y2ggc2l6ZSBcIityK1wiLiBGb3VuZDogXCIrZVswXS5zaGFwZVswXStcIiBzYW1wbGUocykuXCIpO3JldHVybltlLHQsbnVsbF19LHQucHJvdG90eXBlLnRlc3RMb29wPWZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIGE9dGhpcztyZXR1cm4gdm9pZCAwPT09ciYmKHI9MCksdGlkeShmdW5jdGlvbigpe3ZhciBvPWEuY2hlY2tOdW1TYW1wbGVzKHQsbixpLFwic3RlcHNcIikscz1bXTtpZihyPjApdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7aWYobnVsbCE9aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInN0ZXBzIG1vZGUgaW4gdGVzdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO2Zvcih2YXIgbD1tYWtlQmF0Y2hlcyhvLG4pLHU9dGVuc29yMWQocmFuZ2UoMCxvKSksYz0wO2M8bC5sZW5ndGg7KytjKXt2YXIgcD1sW2NdWzBdLGg9bFtjXVsxXSxkPXNsaWNlQWxvbmdGaXJzdEF4aXModSxwLGgtcCksZj1zbGljZUFycmF5c0J5SW5kaWNlcyh0LGQpLGc9ZShmKTtpZigwPT09Yylmb3IodmFyIG09MDttPGcubGVuZ3RoOysrbSlzLnB1c2goc2NhbGFyKDApKTtmb3IobT0wO208Zy5sZW5ndGg7KyttKXt2YXIgeT1nW21dO3NbbV09YWRkKHNbbV0sbXVsKGgtcCx5KSl9fWZvcihtPTA7bTxzLmxlbmd0aDsrK20pc1ttXT1kaXYoc1ttXSxvKTtyZXR1cm4gc30pfSx0LnByb3RvdHlwZS5nZXREZWR1cGVkTWV0cmljc05hbWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMubWV0cmljc05hbWVzLHQ9W10sbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lW25dLGk9cjtpZihjb3VudChlLHIpPjEpaSs9XCJfXCIrY291bnQoZS5zbGljZSgwLG4pLHIpO3QucHVzaChpKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUubWFrZVRyYWluRnVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10LnNsaWNlKDAsZS5pbnB1dHMubGVuZ3RoKSxyPXQuc2xpY2UoZS5pbnB1dHMubGVuZ3RoLGUuaW5wdXRzLmxlbmd0aCtlLm91dHB1dHMubGVuZ3RoKSxpPVtdLGE9ZS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWFkKCl9KTtyZXR1cm5bZS5vcHRpbWl6ZXJfLm1pbmltaXplKGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGE9MDthPGUuaW5wdXRzLmxlbmd0aDsrK2EpdC5wdXNoKHtrZXk6ZS5pbnB1dHNbYV0sdmFsdWU6blthXX0pO3ZhciBvLHM9bmV3IEZlZWREaWN0KHQpLGw9ZXhlY3V0ZShlLm91dHB1dHMscyx7dHJhaW5pbmc6ITB9KTtmb3IoYT0wO2E8ZS5sb3NzRnVuY3Rpb25zLmxlbmd0aDsrK2Epe3ZhciB1PSgwLGUubG9zc0Z1bmN0aW9uc1thXSkoclthXSxsW2FdKTttZWFuKHUpLG89MD09PWE/dTphZGQobyx1KX1mb3IoYT0wO2E8ZS5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KythKXt2YXIgYz1lLm1ldHJpY3NUZW5zb3JzW2FdWzBdLHA9ZS5tZXRyaWNzVGVuc29yc1thXVsxXSxoPW1lYW4oYyhyW3BdLGxbcF0pKTtrZWVwKGgpLGkucHVzaChoKX1yZXR1cm4gbz1tZWFuKG8pLGUuY2FsY3VsYXRlTG9zc2VzKCkuZm9yRWFjaChmdW5jdGlvbihlKXtvPWFkZChvLGUpfSksb30sITAsYSldLmNvbmNhdChpKX19LHQucHJvdG90eXBlLm1ha2VUZXN0RnVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMudGVzdEZ1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBuLHI9W10saT10LnNsaWNlKDAsZS5pbnB1dHMubGVuZ3RoKSxhPXQuc2xpY2UoZS5pbnB1dHMubGVuZ3RoLGUuaW5wdXRzLmxlbmd0aCtlLm91dHB1dHMubGVuZ3RoKSxvPVtdLHM9MDtzPGUuaW5wdXRzLmxlbmd0aDsrK3Mpby5wdXNoKHtrZXk6ZS5pbnB1dHNbc10sdmFsdWU6aVtzXX0pO3ZhciBsPW5ldyBGZWVkRGljdChvKSx1PWV4ZWN1dGUoZS5vdXRwdXRzLGwpO2ZvcihzPTA7czxlLmxvc3NGdW5jdGlvbnMubGVuZ3RoOysrcyl7dmFyIGM9ZS5sb3NzRnVuY3Rpb25zW3NdLHA9bWVhbihjKGFbc10sdVtzXSkpO249MD09PXM/cDphZGQobixwKSxyLnB1c2gobil9Zm9yKHM9MDtzPGUubWV0cmljc1RlbnNvcnMubGVuZ3RoOysrcyl7dmFyIGg9ZS5tZXRyaWNzVGVuc29yc1tzXVswXSxkPWUubWV0cmljc1RlbnNvcnNbc11bMV0sZj1tZWFuKGgoYVtkXSx1W2RdKSk7ci5wdXNoKGYpfXJldHVybiByfSl9fSx0LnByb3RvdHlwZS5maXQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3JldHVyblsyLGZpdFRlbnNvcnModGhpcyxlLHQsbildfSl9KX0sdC5wcm90b3R5cGUuZml0RGF0YXNldD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuWzIsZml0RGF0YXNldCh0aGlzLGUsdCldfSl9KX0sdC5wcm90b3R5cGUudHJhaW5PbkJhdGNoPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGksYSxvLHMsbCx1LGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocCl7c3dpdGNoKHAubGFiZWwpe2Nhc2UgMDpuPXRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YShlLHQpLHI9blswXSxpPW5bMV0sYT10aGlzLm1ha2VUcmFpbkZ1bmN0aW9uKCksbz1hKHIuY29uY2F0KGkpKSxzPVtdLGw9MCx1PW8scC5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbDx1Lmxlbmd0aD9bNCx1W2xdLmRhdGEoKV06WzMsNF07Y2FzZSAyOmM9cC5zZW50KCkscy5wdXNoKGNbMF0pLHAubGFiZWw9MztjYXNlIDM6cmV0dXJuIGwrKyxbMywxXTtjYXNlIDQ6cmV0dXJuIGRpc3Bvc2UobyksWzIsc2luZ2xldG9uT3JBcnJheShzKV19fSl9KX0sdC5wcm90b3R5cGUuZ2V0TmFtZWRXZWlnaHRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxuPW51bGwhPWUmJmUudHJhaW5hYmxlT25seSxyPW4/dGhpcy50cmFpbmFibGVXZWlnaHRzOnRoaXMud2VpZ2h0cyxpPXRoaXMuZ2V0V2VpZ2h0cyhuKSxhPTA7YTxyLmxlbmd0aDsrK2EpbiYmIXJbYV0udHJhaW5hYmxlfHwodFtyW2FdLm9yaWdpbmFsTmFtZV09aVthXSk7cmV0dXJuIHR9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0b3BUcmFpbmluZ1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdG9wVHJhaW5pbmdffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5zdG9wVHJhaW5pbmdfPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3B0aW1pemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGltaXplcl99LHNldDpmdW5jdGlvbihlKXt0aGlzLm9wdGltaXplcl8hPT1lJiYodGhpcy5vcHRpbWl6ZXJfPWUsdGhpcy5pc09wdGltaXplck93bmVkPSExKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO2lmKDA9PT10LnJlZkNvdW50QWZ0ZXJEaXNwb3NlJiZudWxsIT10aGlzLm9wdGltaXplciYmdGhpcy5pc09wdGltaXplck93bmVkKXt2YXIgbj1tZW1vcnkoKS5udW1UZW5zb3JzO3RoaXMub3B0aW1pemVyXy5kaXNwb3NlKCksdC5udW1EaXNwb3NlZFZhcmlhYmxlcys9bi1tZW1vcnkoKS5udW1UZW5zb3JzfXJldHVybiB0fSx0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGksYSxvO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKDA9PT0obj1pby5nZXRTYXZlSGFuZGxlcnMoZSkpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBmaW5kIGFueSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2lmKG4ubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIitlK1wiJ1wiKTtlPW5bMF19aWYobnVsbD09ZS5zYXZlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXJzTW9kZWwuc2F2ZSgpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuXCIpO3JldHVybls0LGlvLmVuY29kZVdlaWdodHModGhpcy5nZXROYW1lZFdlaWdodHModCkpXTtjYXNlIDE6cmV0dXJuIHI9cy5zZW50KCksaT0hMSxhPW51bGwsbz10aGlzLnRvSlNPTihhLGkpLFsyLGUuc2F2ZSh7bW9kZWxUb3BvbG9neTpvLHdlaWdodERhdGE6ci5kYXRhLHdlaWdodFNwZWNzOnIuc3BlY3MsZm9ybWF0OkxBWUVSU19NT0RFTF9GT1JNQVRfTkFNRSxnZW5lcmF0ZWRCeTpcIlRlbnNvckZsb3cuanMgdGZqcy1sYXllcnMgdlwiK3ZlcnNpb24sY29udmVydGVkQnk6bnVsbH0pXX19KX0pfSx0LmNsYXNzTmFtZT1cIk1vZGVsXCIsdH0oQ29udGFpbmVyKTtmdW5jdGlvbiBtb2RlbEZyb21KU09OKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGksYSxvLHMsbCx1O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGMpe3N3aXRjaChjLmxhYmVsKXtjYXNlIDA6cmV0dXJuXCJtb2RlbFRvcG9sb2d5XCJpbiBlfHwoZT17bW9kZWxUb3BvbG9neTplfSksbnVsbCE9KG49KGU9ZSkubW9kZWxUb3BvbG9neSkubW9kZWxfY29uZmlnJiYobj1uLm1vZGVsX2NvbmZpZykscj1jb252ZXJ0UHl0aG9uaWNUb1RzKG4pLGk9ZGVzZXJpYWxpemUocix0KSxudWxsPT1lLndlaWdodHNNYW5pZmVzdD9bMywyXTpbNCxpby5sb2FkV2VpZ2h0cyhlLndlaWdodHNNYW5pZmVzdCxlLnBhdGhQcmVmaXgsaS53ZWlnaHRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5vcmlnaW5hbE5hbWV9KSldO2Nhc2UgMTpmb3IoYT1jLnNlbnQoKSxvPXt9LHM9MCxsPWkud2VpZ2h0cztzPGwubGVuZ3RoO3MrKyl1PWxbc10sb1t1Lm9yaWdpbmFsTmFtZV09YVt1Lm9yaWdpbmFsTmFtZV07aS5sb2FkV2VpZ2h0cyhvKSxkaXNwb3NlKGEpLGMubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzIsaV19fSl9KX1mdW5jdGlvbiBsb2FkTGF5ZXJzTW9kZWxJbnRlcm5hbChlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7aWYobnVsbD09dCYmKHQ9e30pLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZigwPT09KG49aW8uZ2V0TG9hZEhhbmRsZXJzKGUpKS5sZW5ndGgpbi5wdXNoKGlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHQpKTtlbHNlIGlmKG4ubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3IgVVJMICdcIitlK1wiJ1wiKTtlPW5bMF19cmV0dXJuWzIsbG9hZExheWVyc01vZGVsRnJvbUlPSGFuZGxlcihlLHZvaWQgMCx0KV19KX0pfWZ1bmN0aW9uIGxvYWRMYXllcnNNb2RlbEZyb21JT0hhbmRsZXIoZSx0LG4pe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsaSxhLG8scyxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6aWYobnVsbD09biYmKG49e30pLG51bGw9PWUubG9hZCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7cmV0dXJuWzQsZS5sb2FkKCldO2Nhc2UgMTppZihyPXUuc2VudCgpLG51bGwhPShpPXIubW9kZWxUb3BvbG9neSkubW9kZWxfY29uZmlnJiYoaT1pLm1vZGVsX2NvbmZpZyksYT1udWxsPT1uLnN0cmljdHx8bi5zdHJpY3Qsbz1udWxsIT1yLndlaWdodERhdGEmJm51bGwhPXIud2VpZ2h0U3BlY3MmJmEscz1kZXNlcmlhbGl6ZShjb252ZXJ0UHl0aG9uaWNUb1RzKGkpLHQsbyksbnVsbCE9ci53ZWlnaHREYXRhKXtpZihudWxsPT1yLndlaWdodFNwZWNzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXJzTW9kZWwgYXJ0aWZhY3RzIGNvbnRhaW5zIHdlaWdodCBkYXRhLCBidXQgbm90IHdlaWdodCBzcGVjcy4gVGhlcmVmb3JlIGxvYWRpbmcgb2Ygd2VpZ2h0cyBjYW5ub3QgcHJvY2VlZC5cIik7bD1pby5kZWNvZGVXZWlnaHRzKHIud2VpZ2h0RGF0YSxyLndlaWdodFNwZWNzKSxzLmxvYWRXZWlnaHRzKGwsYSksZGlzcG9zZShsKX1yZXR1cm5bMixzXX19KX0pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMYXllcnNNb2RlbCk7dmFyIFNlcXVlbnRpYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx7aW5wdXRzOltdLG91dHB1dHM6W119KXx8dGhpcztpZih0PXR8fHt9LG4udHJhaW5hYmxlPSEwLG4uX3VwZGF0YWJsZT0hMCxuLmJ1aWx0PSExLG4ubmFtZT1udWxsIT10Lm5hbWU/dC5uYW1lOmdldFVpZChcInNlcXVlbnRpYWxfXCIpLG51bGwhPXQubGF5ZXJzKWZvcih2YXIgcj0wLGk9dC5sYXllcnM7cjxpLmxlbmd0aDtyKyspe3ZhciBhPWlbcl07bi5hZGQoYSl9cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNoZWNrU2hhcGU9ZnVuY3Rpb24oZSl7aWYoZS5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXS5zaGFwZS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlPDB9KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBhZGRpbmcgbGF5ZXIgXCIrZS5uYW1lK1wiIHdpdGggaW5wdXQgc2hhcGUgW1wiK2UuaW5ib3VuZE5vZGVzWzBdLmlucHV0VGVuc29yc1swXS5zaGFwZStcIl1cIil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgbixyPWUgaW5zdGFuY2VvZiB0fHxlIGluc3RhbmNlb2YgTGF5ZXJzTW9kZWw7aWYocil7aWYoMSE9PShuPWUpLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO2lmKDEhPT1uLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBpbnB1dCB0ZW5zb3IuIEZvciBtdWx0aS1pbnB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpfWlmKDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXtpZigwPT09ZS5pbmJvdW5kTm9kZXMubGVuZ3RoKXtpZihudWxsPT1lLmJhdGNoSW5wdXRTaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCBnZXQgYW4gYGlucHV0U2hhcGVgIG9yIGBiYXRjaElucHV0U2hhcGVgIGFyZ3VtZW50LlwiKTt2YXIgaT1JbnB1dCh7YmF0Y2hTaGFwZTplLmJhdGNoSW5wdXRTaGFwZSxkdHlwZTplLmR0eXBlLG5hbWU6ZS5uYW1lK1wiX2lucHV0XCJ9KTtlLmFwcGx5KGkpfWlmKHIpdGhpcy5vdXRwdXRzPW4ub3V0cHV0cyx0aGlzLmlucHV0cz1uLmlucHV0cztlbHNle2lmKDEhPT1lLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGxheWVyIGFkZGVkIHRvIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IG5vdCBhbHJlYWR5IGJlIGNvbm5lY3RlZCBzb21ld2hlcmUgZWxzZS4gTGF5ZXJzTW9kZWwgcmVjZWl2ZWQgbGF5ZXIgXCIrZS5uYW1lK1wiIHdoaWNoIGhhcyBcIitlLmluYm91bmROb2Rlcy5sZW5ndGgrXCIgcHJlLWV4aXN0aW5nIGluYm91bmQgY29ubmVjdGlvbnMuXCIpO2lmKDEhPT1lLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTt0aGlzLmNoZWNrU2hhcGUoZSksdGhpcy5vdXRwdXRzPVtlLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdXSx0aGlzLmlucHV0cz1nZXRTb3VyY2VJbnB1dHModGhpcy5vdXRwdXRzWzBdKX10aGlzLmluYm91bmROb2Rlcz1bXSxuZXcgTm9kZSh7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6dGhpcy5pbnB1dHMsb3V0cHV0VGVuc29yczp0aGlzLm91dHB1dHMsaW5wdXRNYXNrczpweUxpc3RSZXBlYXQobnVsbCx0aGlzLmlucHV0cy5sZW5ndGgpLG91dHB1dE1hc2tzOltudWxsXSxpbnB1dFNoYXBlczp0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSxvdXRwdXRTaGFwZXM6dGhpcy5vdXRwdXRzWzBdLnNoYXBlfSl9ZWxzZXt2YXIgYT1lLmFwcGx5KHRoaXMub3V0cHV0c1swXSk7aWYoQXJyYXkuaXNBcnJheShhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO3RoaXMuY2hlY2tTaGFwZShlKSx0aGlzLm91dHB1dHM9W2FdLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnM9dGhpcy5vdXRwdXRzLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcz1bdGhpcy5vdXRwdXRzWzBdLnNoYXBlXX10aGlzLmxheWVycy5wdXNoKGUpLHRoaXMuYnVpbHQ9ITF9LHQucHJvdG90eXBlLnBvcD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmxheWVycy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLlwiKTtpZih0aGlzLmxheWVycy5wb3AoKSwwPT09dGhpcy5sYXllcnMubGVuZ3RoKXRoaXMub3V0cHV0cz1bXSx0aGlzLmluYm91bmROb2Rlcz1bXSx0aGlzLm91dGJvdW5kTm9kZXM9W107ZWxzZXt2YXIgZT10aGlzLmxheWVycy5sZW5ndGgtMTt0aGlzLmxheWVyc1tlXS5vdXRib3VuZE5vZGVzPVtdLHRoaXMub3V0cHV0cz1bdGhpcy5sYXllcnNbZV0ub3V0cHV0XSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19fSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNhbGwoZSx0KX0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoZ2V0RXhhY3RseU9uZVNoYXBlKGUpLDA9PT10aGlzLmlucHV0cy5sZW5ndGh8fDA9PT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTZXF1ZW50aWFsIG1vZGVsIGNhbm5vdCBiZSBidWlsdDogbW9kZWwgaXMgZW1wdHkuIEFkZCBzb21lIGxheWVycyBmaXJzdC5cIik7dGhpcy5tb2RlbD1uZXcgTGF5ZXJzTW9kZWwoe2lucHV0czp0aGlzLmlucHV0cyxvdXRwdXRzOnRoaXMub3V0cHV0c1swXSxuYW1lOnRoaXMubmFtZStcIl9tb2RlbFwifSksdGhpcy5tb2RlbC50cmFpbmFibGU9dGhpcy50cmFpbmFibGUsdGhpcy5tb2RlbC51cGRhdGFibGU9dGhpcy51cGRhdGFibGUsdGhpcy5zdXBwb3J0c01hc2tpbmc9dGhpcy5tb2RlbC5zdXBwb3J0c01hc2tpbmcsdGhpcy5pbnB1dExheWVycz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzLHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXMsdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5vdXRwdXRMYXllcnM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnMsdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5ub2Rlc0J5RGVwdGg9dGhpcy5tb2RlbC5ub2Rlc0J5RGVwdGgsdGhpcy5jb250YWluZXJOb2Rlcz10aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzLHRoaXMub3V0cHV0TmFtZXM9dGhpcy5tb2RlbC5vdXRwdXROYW1lcyx0aGlzLmlucHV0TmFtZXM9dGhpcy5tb2RlbC5pbnB1dE5hbWVzLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNvdW50UGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxlLnByb3RvdHlwZS5jb3VudFBhcmFtcy5jYWxsKHRoaXMpfSx0LnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKHQsbixyKXt2b2lkIDA9PT1yJiYocj1jb25zb2xlLmxvZyksdGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLGUucHJvdG90eXBlLnN1bW1hcnkuY2FsbCh0aGlzLHQsbixyKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXtudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5zZXRXZWlnaHRzKGUpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0YWJsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuYnVpbHQmJih0aGlzLm1vZGVsLnVwZGF0YWJsZT1lKSx0aGlzLl91cGRhdGFibGU9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5ldmFsdWF0ZT1mdW5jdGlvbihlLHQsbil7aWYodm9pZCAwPT09biYmKG49e30pLCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLmV2YWx1YXRlKGUsdCxuKX0sdC5wcm90b3R5cGUuZXZhbHVhdGVEYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmV2YWx1YXRlRGF0YXNldChlLHQpXX0pfSl9LHQucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3QoZSx0KX0sdC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKGUpfSx0LnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUpe3RoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNvbXBpbGUoZSksdGhpcy5vcHRpbWl6ZXJfPXRoaXMubW9kZWwub3B0aW1pemVyLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD10aGlzLm1vZGVsLmlzT3B0aW1pemVyT3duZWQsdGhpcy5sb3NzPXRoaXMubW9kZWwubG9zcyx0aGlzLm1ldHJpY3M9dGhpcy5tb2RlbC5tZXRyaWNzLHRoaXMubWV0cmljc1RlbnNvcnM9dGhpcy5tb2RlbC5tZXRyaWNzVGVuc29ycyx0aGlzLm1ldHJpY3NOYW1lcz10aGlzLm1vZGVsLm1ldHJpY3NOYW1lc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3B0aW1pemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsLm9wdGltaXplcn0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMubW9kZWwub3B0aW1pemVyPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmZpdChlLHQsbildfSl9KX0sdC5wcm90b3R5cGUuZml0RGF0YXNldD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuWzIsdGhpcy5tb2RlbC5maXREYXRhc2V0KGUsdCldfSl9KX0sdC5wcm90b3R5cGUudHJhaW5PbkJhdGNoPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMix0aGlzLm1vZGVsLnRyYWluT25CYXRjaChlLHQpXX0pfSl9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLG4scixpKXt2YXIgYTt2b2lkIDA9PT1yJiYocj17fSksdm9pZCAwPT09aSYmKGk9ITEpO3ZhciBvPXt9O2lmKG4gaW5zdGFuY2VvZiBBcnJheSl7aWYobnVsbD09blswXS5jbGFzc05hbWV8fFwiTWVyZ2VcIj09PW5bMF0uY2xhc3NOYW1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGVnYWN5IHNlcmlhbGl6YXRpb24gZm9ybWF0IG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTthPW59ZWxzZSB1dGlsLmFzc2VydChudWxsIT1uLmxheWVycyxmdW5jdGlvbigpe3JldHVyblwiV2hlbiB0aGUgY29uZmlnIGRhdGEgZm9yIGEgU2VxdWVudGlhbCBtb2RlbCBpcyBub3QgYW4gQXJyYXksIGl0IG11c3QgYmUgYW4gT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlICdsYXllcnMnIGZpZWxkLlwifSksYT1uLmxheWVycyxkZWxldGUgbi5sYXllcnMsbz1uO3ZhciBzPW5ldyBlKG8pO2lmKCEocyBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiU2VxdWVudGlhbC5mcm9tQ29uZmlnIGNhbGxlZCBvbiBub24tU2VxdWVudGlhbCBpbnB1dDogXCIrcyk7Zm9yKHZhciBsPTAsdT1hO2w8dS5sZW5ndGg7bCsrKXt2YXIgYz1kZXNlcmlhbGl6ZSh1W2xdLHZvaWQgMCxpKTtpJiZjLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoITApLHMuYWRkKGMpfXJldHVybiBzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdG9wVHJhaW5pbmdcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5tb2RlbCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHN0b3BUcmFpbmluZyBwcm9wZXJ0eSBvZiBhIHNlcXVlbnRpYWwgbW9kZWwgYmVmb3JlIGl0IGlzIGNvbXBpbGVkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5zdG9wVHJhaW5pbmd9LHNldDpmdW5jdGlvbihlKXtpZihudWxsPT10aGlzLm1vZGVsKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IHNldCB0aGUgc3RvcFRyYWluaW5nIHByb3BlcnR5IG9mIGEgc2VxdWVudGlhbCBtb2RlbCBiZWZvcmUgaXQgaXMgY29tcGlsZWQuXCIpO3RoaXMubW9kZWwuc3RvcFRyYWluaW5nPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdLGk9e307aS5jbGFzc05hbWU9ci5nZXRDbGFzc05hbWUoKSxpLmNvbmZpZz1yLmdldENvbmZpZygpLGUucHVzaChpKX1yZXR1cm4gZX0sdC5jbGFzc05hbWU9XCJTZXF1ZW50aWFsXCIsdH0oTGF5ZXJzTW9kZWwpO2Z1bmN0aW9uIG1vZGVsKGUpe3JldHVybiBuZXcgTGF5ZXJzTW9kZWwoZSl9ZnVuY3Rpb24gc2VxdWVudGlhbChlKXtyZXR1cm4gbmV3IFNlcXVlbnRpYWwoZSl9ZnVuY3Rpb24gbG9hZExheWVyc01vZGVsKGUsdCl7cmV0dXJuIG51bGw9PXQmJih0PXt9KSxsb2FkTGF5ZXJzTW9kZWxJbnRlcm5hbChlLHQpfWZ1bmN0aW9uIGlucHV0KGUpe3JldHVybiBJbnB1dChlKX1mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IoZSx0KXtDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkucmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yKGUsdCl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlcXVlbnRpYWwpO3ZhciBBY3RpdmF0aW9uPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLEVsdT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MSksZWx1JDEoZSx0KX0sdC5jbGFzc05hbWU9XCJlbHVcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRWx1KTt2YXIgU2VsdT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHNlbHUoZSl9LHQuY2xhc3NOYW1lPVwic2VsdVwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZWx1KTt2YXIgUmVsdT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlbHUoZSl9LHQuY2xhc3NOYW1lPVwicmVsdVwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZWx1KTt2YXIgUmVsdTY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG1pbmltdW0oNixyZWx1KGUpKX0pfSx0LmNsYXNzTmFtZT1cInJlbHU2XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlbHU2KTt2YXIgTGluZWFyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5jbGFzc05hbWU9XCJsaW5lYXJcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGluZWFyKTt2YXIgU2lnbW9pZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHNpZ21vaWQoZSl9LHQuY2xhc3NOYW1lPVwic2lnbW9pZFwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTaWdtb2lkKTt2YXIgSGFyZFNpZ21vaWQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBoYXJkU2lnbW9pZChlKX0sdC5jbGFzc05hbWU9XCJoYXJkU2lnbW9pZFwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhIYXJkU2lnbW9pZCk7dmFyIFNvZnRwbHVzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gc29mdHBsdXMoZSl9LHQuY2xhc3NOYW1lPVwic29mdHBsdXNcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdHBsdXMpO3ZhciBTb2Z0c2lnbj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHNvZnRzaWduKGUpfSx0LmNsYXNzTmFtZT1cInNvZnRzaWduXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRzaWduKTt2YXIgVGFuaD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRhbmgoZSl9LHQuY2xhc3NOYW1lPVwidGFuaFwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUYW5oKTt2YXIgU29mdG1heD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHNvZnRtYXgoZSx0KX0sdC5jbGFzc05hbWU9XCJzb2Z0bWF4XCIsdH0oQWN0aXZhdGlvbik7ZnVuY3Rpb24gc2VyaWFsaXplQWN0aXZhdGlvbihlKXtyZXR1cm4gZS5nZXRDbGFzc05hbWUoKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUFjdGl2YXRpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJhY3RpdmF0aW9uXCIpfWZ1bmN0aW9uIGdldEFjdGl2YXRpb24oZSl7dmFyIHQ7cmV0dXJuIG51bGw9PWU/ZGVzZXJpYWxpemVBY3RpdmF0aW9uKHQ9e2NsYXNzTmFtZTpcImxpbmVhclwiLGNvbmZpZzp7fX0pOlwic3RyaW5nXCI9PXR5cGVvZiBlPygodD17fSkuY2xhc3NOYW1lPWUsdC5jb25maWc9e30sZGVzZXJpYWxpemVBY3RpdmF0aW9uKHQpKTplIGluc3RhbmNlb2YgQWN0aXZhdGlvbj9lOmRlc2VyaWFsaXplQWN0aXZhdGlvbihlKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdG1heCk7dmFyIFJlZ3VsYXJpemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksTDFMMj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5sMT1udWxsPT10fHxudWxsPT10LmwxPy4wMTp0LmwxLG4ubDI9bnVsbD09dHx8bnVsbD09dC5sMj8uMDE6dC5sMixuLmhhc0wxPTAhPT1uLmwxLG4uaGFzTDI9MCE9PW4ubDIsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXplcm9zKFsxXSk7cmV0dXJuIHQuaGFzTDEmJihuPWFkZChuLHN1bShtdWwodC5sMSxhYnMoZSkpKSkpLHQuaGFzTDImJihuPWFkZChuLHN1bShtdWwodC5sMixzcXVhcmUoZSkpKSkpLG4uYXNTY2FsYXIoKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bDE6dGhpcy5sMSxsMjp0aGlzLmwyfX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBlKHtsMTp0LmwxLGwyOnQubDJ9KX0sdC5jbGFzc05hbWU9XCJMMUwyXCIsdH0oUmVndWxhcml6ZXIpO2Z1bmN0aW9uIGwxKGUpe3JldHVybiBuZXcgTDFMMih7bDE6bnVsbCE9ZT9lLmwxOm51bGwsbDI6MH0pfWZ1bmN0aW9uIGwyKGUpe3JldHVybiBuZXcgTDFMMih7bDI6bnVsbCE9ZT9lLmwyOm51bGwsbDE6MH0pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMMUwyKTt2YXIgUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQPXtsMWwyOlwiTDFMMlwifTtmdW5jdGlvbiBzZXJpYWxpemVSZWd1bGFyaXplcihlKXtyZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoZSl9ZnVuY3Rpb24gZGVzZXJpYWxpemVSZWd1bGFyaXplcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcInJlZ3VsYXJpemVyXCIpfWZ1bmN0aW9uIGdldFJlZ3VsYXJpemVyKGUpe3JldHVybiBudWxsPT1lP251bGw6XCJzdHJpbmdcIj09dHlwZW9mIGU/ZGVzZXJpYWxpemVSZWd1bGFyaXplcih7Y2xhc3NOYW1lOmUgaW4gUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQP1JFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtlXTplLGNvbmZpZzp7fX0pOmUgaW5zdGFuY2VvZiBSZWd1bGFyaXplcj9lOmRlc2VyaWFsaXplUmVndWxhcml6ZXIoZSl9dmFyIFJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxudWxsIT10JiYobi5tYXhWYWx1ZT10Lm1heFZhbHVlKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7ZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3ZhciBuPXJlbHUoZSk7cmV0dXJuIG51bGwhPXRoaXMubWF4VmFsdWUmJihuPWNsaXBCeVZhbHVlKG4sMCx0aGlzLm1heFZhbHVlKSksbn0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17bWF4VmFsdWU6dGhpcy5tYXhWYWx1ZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVMVSk7dmFyIExlYWt5UmVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BTFBIQT0uMyxudWxsPT10JiYodD17fSksbi5hbHBoYT1udWxsPT10LmFscGhhP24uREVGQVVMVF9BTFBIQTp0LmFscGhhLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBsZWFreVJlbHUobix0aGlzLmFscGhhKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWxwaGE6dGhpcy5hbHBoYX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiTGVha3lSZUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZWFreVJlTFUpO3ZhciBQUmVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7aWYobi5ERUZBVUxUX0FMUEhBX0lOSVRJQUxJWkVSPVwiemVyb3NcIixudWxsPT10JiYodD17fSksbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5hbHBoYUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYWxwaGFJbml0aWFsaXplcnx8bi5ERUZBVUxUX0FMUEhBX0lOSVRJQUxJWkVSKSxuLmFscGhhUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5hbHBoYVJlZ3VsYXJpemVyKSxuLmFscGhhQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYWxwaGFDb25zdHJhaW50KSxudWxsPT10LnNoYXJlZEF4ZXMpbi5zaGFyZWRBeGVzPW51bGw7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQuc2hhcmVkQXhlcykpbi5zaGFyZWRBeGVzPXQuc2hhcmVkQXhlcztlbHNle2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0LnNoYXJlZEF4ZXMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFeHBlY3RlZCBzaGFyZWRBeGVzIHRvIGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIG51bWJlcnMsIGJ1dCBnb3QgXCIrdC5zaGFyZWRBeGVzKTtuLnNoYXJlZEF4ZXM9W3Quc2hhcmVkQXhlc119cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoMSk7aWYobnVsbCE9dGhpcy5zaGFyZWRBeGVzKWZvcih2YXIgbj0wLHI9dGhpcy5zaGFyZWRBeGVzO248ci5sZW5ndGg7bisrKXt0WyhhPXJbbl0pLTFdPTF9dGhpcy5hbHBoYT10aGlzLmFkZFdlaWdodChcImFscGhhXCIsdCxcImZsb2F0MzJcIix0aGlzLmFscGhhSW5pdGlhbGl6ZXIsdGhpcy5hbHBoYVJlZ3VsYXJpemVyLCEwLHRoaXMuYWxwaGFDb25zdHJhaW50KTt2YXIgaT17fTtpZihudWxsIT10aGlzLnNoYXJlZEF4ZXMpZm9yKHZhciBhPTE7YTxlLmxlbmd0aDsrK2EpaVthXT1lW2FdO3RoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOmUubGVuZ3RoLGF4ZXM6aX0pXSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxwcmVsdShlLHRoaXMuYWxwaGEucmVhZCgpKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2FscGhhSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5hbHBoYUluaXRpYWxpemVyKSxhbHBoYVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWxwaGFSZWd1bGFyaXplciksYWxwaGFDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5hbHBoYUNvbnN0cmFpbnQpLHNoYXJlZEF4ZXM6dGhpcy5zaGFyZWRBeGVzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJQUmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUFJlTFUpO3ZhciBFTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO2lmKG4uREVGQVVMVF9BTFBIQT0xLG51bGw9PXQmJih0PXt9KSxudWxsIT10LmFscGhhJiZ0LmFscGhhIT09bi5ERUZBVUxUX0FMUEhBKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgYWxwaGEgdmFsdWUgKFwiK3QuYWxwaGErXCIpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEVMVSBsYXllciB5ZXQuXCIpO3JldHVybiBuLmFscGhhPW51bGw9PXQuYWxwaGE/bi5ERUZBVUxUX0FMUEhBOnQuYWxwaGEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIGVsdShuKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWxwaGE6dGhpcy5hbHBoYX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFTFUpO3ZhciBUaHJlc2hvbGRlZFJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfVEhFVEE9MSxudWxsPT10JiYodD17fSksbi50aGV0YT1udWxsPT10LnRoZXRhP24uREVGQVVMVF9USEVUQTp0LnRoZXRhLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBuLm11bChjYXN0JDEobi5ncmVhdGVyKHRoaXMudGhldGEpLFwiZmxvYXQzMlwiKSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3RoZXRhOnRoaXMudGhldGF9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlRocmVzaG9sZGVkUmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGhyZXNob2xkZWRSZUxVKTt2YXIgU29mdG1heCQxPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FYSVM9MSxudWxsPT10JiYodD17fSksbi5zb2Z0bWF4PShuZXcgU29mdG1heCkuYXBwbHksbi5heGlzPW51bGw9PXQuYXhpcz9uLkRFRkFVTFRfQVhJUzp0LmF4aXMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIHRoaXMuc29mdG1heChuLHRoaXMuYXhpcyl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJTb2Z0bWF4XCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGUsdCxuKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gcHlMaXN0UmVwZWF0KGUsdCk7aWYoZS5sZW5ndGghPT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK24rXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIHR1cGxlIG9mIFwiK3QrXCIgaW50ZWdlcnMuIFJlY2VpdmVkOiBcIitlLmxlbmd0aCtcIiBlbGVtZW50cy5cIik7Zm9yKHZhciByPTA7cjx0Oysrcil7dmFyIGk9ZVtyXTtpZighaXNJbnRlZ2VyKGkpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFwiK24rXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIHR1cGxlIG9mIFwiK3QrXCIgaW50ZWdlcnMuIFJlY2VpdmVkOiBcIitKU09OLnN0cmluZ2lmeShlKStcIiBpbmNsdWRpbmcgYSBub24taW50ZWdlciBudW1iZXIgXCIraSl9cmV0dXJuIGV9ZnVuY3Rpb24gY29udk91dHB1dExlbmd0aChlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0xKSxudWxsPT1lP2U6KGE9XCJzYW1lXCI9PT1uP2U6ZS0odCsodC0xKSooaS0xKSkrMSxNYXRoLmZsb29yKChhK3ItMSkvcikpO3ZhciBhfWZ1bmN0aW9uIGRlY29udkxlbmd0aChlLHQsbixyKXtpZihudWxsPT1lKXJldHVybiBudWxsO2lmKFwidmFsaWRcIj09PXIpZT1lKnQrbWF4JDEoW24tdCwwXSk7ZWxzZXtpZihcInNhbWVcIiE9PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbnN1cHBvcnQgcGFkZGluZyBtb2RlOiBcIityK1wiLlwiKTtlKj10fXJldHVybiBlfWZ1bmN0aW9uIHByZXByb2Nlc3NDb252MkRJbnB1dChlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdCh0KSxcImNoYW5uZWxzRmlyc3RcIj09PXQ/dHJhbnNwb3NlKGUsWzAsMiwzLDFdKTplfSl9ZnVuY3Rpb24gcHJlcHJvY2Vzc0NvbnYzRElucHV0KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KHQpLFwiY2hhbm5lbHNGaXJzdFwiPT09dD90cmFuc3Bvc2UoZSxbMCwyLDMsNCwxXSk6ZX0pfWZ1bmN0aW9uIGNvbnYxZFdpdGhCaWFzKGUsdCxuLHIsaSxhLG8pe3JldHVybiB2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1pJiYoaT1cInZhbGlkXCIpLHZvaWQgMD09PW8mJihvPTEpLHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1hJiYoYT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGEpLDMhPT1lLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBpbnB1dCBvZiBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIFwiK2Uuc2hhcGUubGVuZ3RoK1wiIGluc3RlYWQuXCIpO2lmKDMhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBrZXJuZWwgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgXCIrdC5zaGFwZS5sZW5ndGgrXCIgaW5zdGVhZFwiKTtpZihudWxsIT1uJiYxIT09bi5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYmlhcyBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDEsIGJ1dCBpcyBcIit0LnNoYXBlLmxlbmd0aCtcIiBpbnN0ZWFkXCIpO2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09YSYmKGU9dHJhbnNwb3NlKGUsWzAsMiwxXSkpLFwiY2F1c2FsXCI9PT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7dmFyIHM9Y29udjFkKGUsdCxyLFwic2FtZVwiPT09aT9cInNhbWVcIjpcInZhbGlkXCIsXCJOV0NcIixvKTtyZXR1cm4gbnVsbCE9biYmKHM9Ymlhc0FkZChzLG4pKSxzfSl9ZnVuY3Rpb24gY29udjJkV2l0aEJpYXMoZSx0LG4scixpLGEsbyl7cmV0dXJuIHZvaWQgMD09PXImJihyPVsxLDFdKSx2b2lkIDA9PT1pJiYoaT1cInZhbGlkXCIpLHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1hJiYoYT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGEpLDMhPT1lLnJhbmsmJjQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgXCIrZS5yYW5rK1wiLlwiKTtpZigzIT09dC5yYW5rJiY0IT09dC5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29udjJkV2l0aEJpYXMgZXhwZWN0cyBrZXJuZWwgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCBcIitlLnJhbmsrXCIuXCIpO3ZhciBzPXByZXByb2Nlc3NDb252MkRJbnB1dChlLGEpO2lmKFwiY2F1c2FsXCI9PT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIHM9Y29udjJkKHMsdCxyLFwic2FtZVwiPT09aT9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIsbyksbnVsbCE9biYmKHM9Ymlhc0FkZChzLG4pKSxcImNoYW5uZWxzRmlyc3RcIj09PWEmJihzPXRyYW5zcG9zZShzLFswLDMsMSwyXSkpLHN9KX1mdW5jdGlvbiBjb252M2RXaXRoQmlhcyhlLHQsbixyLGksYSxvKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9WzEsMSwxXSksdm9pZCAwPT09aSYmKGk9XCJ2YWxpZFwiKSx0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbD09YSYmKGE9aW1hZ2VEYXRhRm9ybWF0KCkpLGNoZWNrRGF0YUZvcm1hdChhKSw0IT09ZS5yYW5rJiY1IT09ZS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29udjNkV2l0aEJpYXMgZXhwZWN0cyBpbnB1dCB0byBiZSBvZiByYW5rIDQgb3IgNSwgYnV0IHJlY2VpdmVkIFwiK2UucmFuaytcIi5cIik7aWYoNCE9PXQucmFuayYmNSE9PXQucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbnYzZFdpdGhCaWFzIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgNCBvciA1LCBidXQgcmVjZWl2ZWQgXCIrZS5yYW5rK1wiLlwiKTt2YXIgcz1wcmVwcm9jZXNzQ29udjNESW5wdXQoZSxhKTtpZihcImNhdXNhbFwiPT09aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYzZFdpdGhCaWFzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiBzPWNvbnYzZChzLHQscixcInNhbWVcIj09PWk/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTkRIV0NcIixvKSxudWxsIT1uJiYocz1iaWFzQWRkKHMsbikpLFwiY2hhbm5lbHNGaXJzdFwiPT09YSYmKHM9dHJhbnNwb3NlKHMsWzAsNCwxLDIsM10pKSxzfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRtYXgkMSk7dmFyIEJhc2VDb252PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobixyKXt2YXIgaT1lLmNhbGwodGhpcyxyKXx8dGhpcztpZihpLmJpYXM9bnVsbCxpLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsaS5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLHQudmVyaWZ5QXJncyhyKSxpLnJhbms9bixhc3NlcnRQb3NpdGl2ZUludGVnZXIoaS5yYW5rLFwicmFua1wiKSwxIT09aS5yYW5rJiYyIT09aS5yYW5rJiYzIT09aS5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiQ29udm9sdXRpb24gbGF5ZXIgZm9yIHJhbmsgb3RoZXIgdGhhbiAxLCAyLCBvciAzIChcIitpLnJhbmsrXCIpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2lmKGkua2VybmVsU2l6ZT1ub3JtYWxpemVBcnJheShyLmtlcm5lbFNpemUsbixcImtlcm5lbFNpemVcIiksaS5zdHJpZGVzPW5vcm1hbGl6ZUFycmF5KG51bGw9PXIuc3RyaWRlcz8xOnIuc3RyaWRlcyxuLFwic3RyaWRlc1wiKSxpLnBhZGRpbmc9bnVsbD09ci5wYWRkaW5nP1widmFsaWRcIjpyLnBhZGRpbmcsY2hlY2tQYWRkaW5nTW9kZShpLnBhZGRpbmcpLGkuZGF0YUZvcm1hdD1udWxsPT1yLmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjpyLmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KGkuZGF0YUZvcm1hdCksaS5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24oci5hY3RpdmF0aW9uKSxpLnVzZUJpYXM9bnVsbD09ci51c2VCaWFzfHxyLnVzZUJpYXMsaS5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoci5iaWFzSW5pdGlhbGl6ZXJ8fGkuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxpLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQoci5iaWFzQ29uc3RyYWludCksaS5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoci5iaWFzUmVndWxhcml6ZXIpLGkuYWN0aXZpdHlSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihyLmFjdGl2aXR5UmVndWxhcml6ZXIpLGkuZGlsYXRpb25SYXRlPW5vcm1hbGl6ZUFycmF5KG51bGw9PXIuZGlsYXRpb25SYXRlPzE6ci5kaWxhdGlvblJhdGUsbixcImRpbGF0aW9uUmF0ZVwiKSwxPT09aS5yYW5rJiZBcnJheS5pc0FycmF5KGkuZGlsYXRpb25SYXRlKSYmMSE9PWkuZGlsYXRpb25SYXRlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGEgc2luZ2xlIG51bWJlciBmb3IgMUQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShpLmRpbGF0aW9uUmF0ZSkpO2lmKDI9PT1pLnJhbmspe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpLmRpbGF0aW9uUmF0ZSlpLmRpbGF0aW9uUmF0ZT1baS5kaWxhdGlvblJhdGUsaS5kaWxhdGlvblJhdGVdO2Vsc2UgaWYoMiE9PWkuZGlsYXRpb25SYXRlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIHR3byBudW1iZXJzIGZvciAyRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGkuZGlsYXRpb25SYXRlKSl9ZWxzZSBpZigzPT09aS5yYW5rKWlmKFwibnVtYmVyXCI9PXR5cGVvZiBpLmRpbGF0aW9uUmF0ZSlpLmRpbGF0aW9uUmF0ZT1baS5kaWxhdGlvblJhdGUsaS5kaWxhdGlvblJhdGUsaS5kaWxhdGlvblJhdGVdO2Vsc2UgaWYoMyE9PWkuZGlsYXRpb25SYXRlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIHRocmVlIG51bWJlcnMgZm9yIDNEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoaS5kaWxhdGlvblJhdGUpKTtyZXR1cm4gaX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC52ZXJpZnlBcmdzPWZ1bmN0aW9uKGUpe2lmKGFzc2VydChcImtlcm5lbFNpemVcImluIGUsXCJyZXF1aXJlZCBrZXkgJ2tlcm5lbFNpemUnIG5vdCBpbiBjb25maWdcIiksXCJudW1iZXJcIiE9dHlwZW9mIGUua2VybmVsU2l6ZSYmIWNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKGUua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMykpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJCYXNlQ29udiBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxLCAyLCBvciAzLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZS5rZXJuZWxTaXplKStcIi5cIil9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtrZXJuZWxTaXplOnRoaXMua2VybmVsU2l6ZSxzdHJpZGVzOnRoaXMuc3RyaWRlcyxwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdCxkaWxhdGlvblJhdGU6dGhpcy5kaWxhdGlvblJhdGUsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdH0oTGF5ZXIpLENvbnY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuLHIpe3ZhciBpPWUuY2FsbCh0aGlzLG4scil8fHRoaXM7cmV0dXJuIGkua2VybmVsPW51bGwsdC52ZXJpZnlBcmdzKHIpLGkuZmlsdGVycz1yLmZpbHRlcnMsYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGkuZmlsdGVycyxcImZpbHRlcnNcIiksaS5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihyLmtlcm5lbEluaXRpYWxpemVyfHxpLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxpLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChyLmtlcm5lbENvbnN0cmFpbnQpLGkua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoci5rZXJuZWxSZWd1bGFyaXplciksaX1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7dmFyIG49XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTplLmxlbmd0aC0xO2lmKG51bGw9PWVbbl0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0IHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCBcIitlW25dKTt2YXIgcj1lW25dLGk9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbcix0aGlzLmZpbHRlcnNdKTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLGksbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMuZmlsdGVyc10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSksdGhpcy5pbnB1dFNwZWM9W3tuZGltOnRoaXMucmFuaysyLGF4ZXM6KHQ9e30sdFtuXT1yLHQpfV0sdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdDtlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7dmFyIHI9bnVsbD09bi5iaWFzP251bGw6bi5iaWFzLnJlYWQoKTtpZigxPT09bi5yYW5rKXQ9Y29udjFkV2l0aEJpYXMoZSxuLmtlcm5lbC5yZWFkKCkscixuLnN0cmlkZXNbMF0sbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCxuLmRpbGF0aW9uUmF0ZVswXSk7ZWxzZSBpZigyPT09bi5yYW5rKXQ9Y29udjJkV2l0aEJpYXMoZSxuLmtlcm5lbC5yZWFkKCkscixuLnN0cmlkZXMsbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCxuLmRpbGF0aW9uUmF0ZSk7ZWxzZXtpZigzIT09bi5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiY29udm9sdXRpb25zIGdyZWF0ZXIgdGhhbiAzRCBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cIik7dD1jb252M2RXaXRoQmlhcyhlLG4ua2VybmVsLnJlYWQoKSxyLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG4uZGlsYXRpb25SYXRlKX1yZXR1cm4gbnVsbCE9bi5hY3RpdmF0aW9uJiYodD1uLmFjdGl2YXRpb24uYXBwbHkodCkpLHR9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO2Zvcih2YXIgdD1bXSxuPVwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZS5zbGljZSgxLGUubGVuZ3RoLTEpOmUuc2xpY2UoMikscj0wO3I8bi5sZW5ndGg7KytyKXt2YXIgaT1jb252T3V0cHV0TGVuZ3RoKG5bcl0sdGhpcy5rZXJuZWxTaXplW3JdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbcl0sXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlP3RoaXMuZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlW3JdKTt0LnB1c2goaSl9dmFyIGE9W2VbMF1dO3JldHVyblwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KGE9YS5jb25jYXQodCkpLnB1c2godGhpcy5maWx0ZXJzKTooYS5wdXNoKHRoaXMuZmlsdGVycyksYT1hLmNvbmNhdCh0KSksYX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2ZpbHRlcnM6dGhpcy5maWx0ZXJzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC52ZXJpZnlBcmdzPWZ1bmN0aW9uKGUpe2lmKCEoXCJmaWx0ZXJzXCJpbiBlKXx8XCJudW1iZXJcIiE9dHlwZW9mIGUuZmlsdGVyc3x8ZS5maWx0ZXJzPDEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252b2x1dGlvbiBsYXllciBleHBlY3RlZCBjb25maWcuZmlsdGVycyB0byBiZSBhICdudW1iZXInID4gMCBidXQgZ290IFwiK0pTT04uc3RyaW5naWZ5KGUuZmlsdGVycykpfSx0fShCYXNlQ29udiksQ29udjJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsMixuKXx8dGhpcztyZXR1cm4gdC52ZXJpZnlBcmdzKG4pLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5yYW5rLHR9LHQudmVyaWZ5QXJncz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZS5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYyRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxIG9yIDIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLmtlcm5lbFNpemUpK1wiLlwiKX0sdC5jbGFzc05hbWU9XCJDb252MkRcIix0fShDb252KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjJEKTt2YXIgQ29udjNEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsMyxuKXx8dGhpcztyZXR1cm4gdC52ZXJpZnlBcmdzKG4pLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5yYW5rLHR9LHQudmVyaWZ5QXJncz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYoIUFycmF5LmlzQXJyYXkoZS5rZXJuZWxTaXplKXx8MSE9PWUua2VybmVsU2l6ZS5sZW5ndGgmJjMhPT1lLmtlcm5lbFNpemUubGVuZ3RoKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYzRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLmtlcm5lbFNpemUpK1wiLlwiKX0sdC5jbGFzc05hbWU9XCJDb252M0RcIix0fShDb252KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjNEKTt2YXIgQ29udjJEVHJhbnNwb3NlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSxcInNhbWVcIiE9PW4ucGFkZGluZyYmXCJ2YWxpZFwiIT09bi5wYWRkaW5nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXMgJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgcGFkZGluZyBtb2RlIFwiK24ucGFkZGluZyk7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2lmKDQhPT0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IHNob3VsZCBoYXZlIHJhbmsgNDsgUmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTt2YXIgbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmUubGVuZ3RoLTE7aWYobnVsbD09ZVtuXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCBgTm9uZWAuXCIpO3ZhciByPWVbbl0saT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFt0aGlzLmZpbHRlcnMscl0pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsaSxcImZsb2F0MzJcIix0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMuZmlsdGVyc10sXCJmbG9hdDMyXCIsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjQsYXhlczoodD17fSx0W25dPXIsdCl9KV0sdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO2lmKDQhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYyRFRyYW5zcG9zZS5jYWxsKCkgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgcmFuay00LCBidXQgcmVjZWl2ZWQgYSB0ZW5zb3Igb2YgcmFuay1cIit0LnNoYXBlLmxlbmd0aCk7dmFyIHIsaSxhPXQuc2hhcGUsbz1hWzBdO1wiY2hhbm5lbHNGaXJzdFwiPT09bi5kYXRhRm9ybWF0PyhyPTIsaT0zKToocj0xLGk9Mik7dmFyIHM9YVtyXSxsPWFbaV0sdT1uLmtlcm5lbFNpemVbMF0sYz1uLmtlcm5lbFNpemVbMV0scD1uLnN0cmlkZXNbMF0saD1uLnN0cmlkZXNbMV0sZD1bbyxkZWNvbnZMZW5ndGgocyxwLHUsbi5wYWRkaW5nKSxkZWNvbnZMZW5ndGgobCxoLGMsbi5wYWRkaW5nKSxuLmZpbHRlcnNdO1wiY2hhbm5lbHNMYXN0XCIhPT1uLmRhdGFGb3JtYXQmJih0PXRyYW5zcG9zZSh0LFswLDIsMywxXSkpO3ZhciBmPWNvbnYyZFRyYW5zcG9zZSh0LG4ua2VybmVsLnJlYWQoKSxkLG4uc3RyaWRlcyxuLnBhZGRpbmcpO3JldHVyblwiY2hhbm5lbHNMYXN0XCIhPT1uLmRhdGFGb3JtYXQmJihmPXRyYW5zcG9zZShmLFswLDMsMSwyXSkpLG51bGwhPW4uYmlhcyYmKGY9Ymlhc0FkZChmLG4uYmlhcy5yZWFkKCksbi5kYXRhRm9ybWF0KSksbnVsbCE9bi5hY3RpdmF0aW9uJiYoZj1uLmFjdGl2YXRpb24uYXBwbHkoZikpLGZ9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoKTtcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8odD0xLG49MixyPTMpOih0PTMsbj0xLHI9Mik7dmFyIGE9dGhpcy5rZXJuZWxTaXplWzBdLG89dGhpcy5rZXJuZWxTaXplWzFdLHM9dGhpcy5zdHJpZGVzWzBdLGw9dGhpcy5zdHJpZGVzWzFdO3JldHVybiBpW3RdPXRoaXMuZmlsdGVycyxpW25dPWRlY29udkxlbmd0aChpW25dLHMsYSx0aGlzLnBhZGRpbmcpLGlbcl09ZGVjb252TGVuZ3RoKGlbcl0sbCxvLHRoaXMucGFkZGluZyksaX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LmRpbGF0aW9uUmF0ZSx0fSx0LmNsYXNzTmFtZT1cIkNvbnYyRFRyYW5zcG9zZVwiLHR9KENvbnYyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYyRFRyYW5zcG9zZSk7dmFyIFNlcGFyYWJsZUNvbnY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4pe3ZhciByPWUuY2FsbCh0aGlzLHQsbil8fHRoaXM7aWYoci5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUj1cImdsb3JvdFVuaWZvcm1cIixyLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSPVwiZ2xvcm90VW5pZm9ybVwiLHIuZGVwdGh3aXNlS2VybmVsPW51bGwsci5wb2ludHdpc2VLZXJuZWw9bnVsbCxudWxsPT1uLmZpbHRlcnMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYGZpbHRlcnNgIGNvbmZpZ3VyYXRpb24gZmllbGQgaXMgcmVxdWlyZWQgYnkgU2VwYXJhYmxlQ29udiwgYnV0IGlzIHVuc3BlY2lmaWVkLlwiKTtpZihudWxsIT1uLmtlcm5lbEluaXRpYWxpemVyfHxudWxsIT1uLmtlcm5lbFJlZ3VsYXJpemVyfHxudWxsIT1uLmtlcm5lbENvbnN0cmFpbnQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGaWVsZHMga2VybmVsSW5pdGlhbGl6ZXIsIGtlcm5lbFJlZ3VsYXJpemVyIGFuZCBrZXJuZWxDb25zdHJhaW50IGFyZSBpbnZhbGlkIGZvciBTZXBhcmFibGVDb252MkQuIFVzZSBkZXB0aHdpc2VJbml0aWFsaXplciwgZGVwdGh3aXNlUmVndWxhcml6ZXIsIGRlcHRod2lzZUNvbnN0cmFpbnQsIHBvaW50d2lzZUluaXRpYWxpemVyLCBwb2ludHdpc2VSZWd1bGFyaXplciBhbmQgcG9pbnR3aXNlQ29uc3RyYWludCBpbnN0ZWFkLlwiKTtpZihudWxsIT1uLnBhZGRpbmcmJlwic2FtZVwiIT09bi5wYWRkaW5nJiZcInZhbGlkXCIhPT1uLnBhZGRpbmcpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJTZXBhcmFibGVDb252XCIrci5yYW5rK1wiRCBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXM6ICdzYW1lJyBhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KG4ucGFkZGluZykpO3JldHVybiByLmRlcHRoTXVsdGlwbGllcj1udWxsPT1uLmRlcHRoTXVsdGlwbGllcj8xOm4uZGVwdGhNdWx0aXBsaWVyLHIuZGVwdGh3aXNlSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIobi5kZXB0aHdpc2VJbml0aWFsaXplcnx8ci5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUiksci5kZXB0aHdpc2VSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihuLmRlcHRod2lzZVJlZ3VsYXJpemVyKSxyLmRlcHRod2lzZUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChuLmRlcHRod2lzZUNvbnN0cmFpbnQpLHIucG9pbnR3aXNlSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIobi5kZXB0aHdpc2VJbml0aWFsaXplcnx8ci5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUiksci5wb2ludHdpc2VSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihuLnBvaW50d2lzZVJlZ3VsYXJpemVyKSxyLnBvaW50d2lzZUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChuLnBvaW50d2lzZUNvbnN0cmFpbnQpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2lmKChlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkubGVuZ3RoPHRoaXMucmFuaysyKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXRzIHRvIFNlcGFyYWJsZUNvbnZcIit0aGlzLnJhbmsrXCJEIHNob3VsZCBoYXZlIHJhbmsgXCIrKHRoaXMucmFuaysyKStcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKSk7dmFyIG49XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTplLmxlbmd0aC0xO2lmKG51bGw9PWVbbl18fGVbbl08MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLCBidXQgZm91bmQgXCIrSlNPTi5zdHJpbmdpZnkoZVtuXSkpO2Zvcih2YXIgcj1lW25dLGk9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbcix0aGlzLmRlcHRoTXVsdGlwbGllcl0pLGE9W10sbz0wO288dGhpcy5yYW5rOysrbylhLnB1c2goMSk7YS5wdXNoKHIqdGhpcy5kZXB0aE11bHRpcGxpZXIsdGhpcy5maWx0ZXJzKTt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixpLFwiZmxvYXQzMlwiLHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIsdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciwhMCx0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMucG9pbnR3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicG9pbnR3aXNlX2tlcm5lbFwiLGEsXCJmbG9hdDMyXCIsdGhpcy5wb2ludHdpc2VJbml0aWFsaXplcix0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTp0aGlzLnJhbmsrMixheGVzOih0PXt9LHRbbl09cix0KX0pXSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0O2lmKGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSwxPT09bi5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiMUQgc2VwYXJhYmxlIGNvbnZvbHV0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiAyPT09bi5yYW5rJiYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQmJihlPXRyYW5zcG9zZShlLFswLDIsMywxXSkpLHQ9c2VwYXJhYmxlQ29udjJkKGUsbi5kZXB0aHdpc2VLZXJuZWwucmVhZCgpLG4ucG9pbnR3aXNlS2VybmVsLnJlYWQoKSxuLnN0cmlkZXMsbi5wYWRkaW5nLG4uZGlsYXRpb25SYXRlLFwiTkhXQ1wiKSksbi51c2VCaWFzJiYodD1iaWFzQWRkKHQsbi5iaWFzLnJlYWQoKSxuLmRhdGFGb3JtYXQpKSxudWxsIT1uLmFjdGl2YXRpb24mJih0PW4uYWN0aXZhdGlvbi5hcHBseSh0KSksXCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQmJih0PXRyYW5zcG9zZSh0LFswLDMsMSwyXSkpLHR9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssZGVsZXRlIHQua2VybmVsSW5pdGlhbGl6ZXIsZGVsZXRlIHQua2VybmVsUmVndWxhcml6ZXIsZGVsZXRlIHQua2VybmVsQ29uc3RyYWludCx0LmRlcHRod2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLHQucG9pbnR3aXNlSW5pdGlhbGl6ZXI9c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5wb2ludHdpc2VJbml0aWFsaXplciksdC5kZXB0aHdpc2VSZWd1bGFyaXplcj1zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSx0LnBvaW50d2lzZVJlZ3VsYXJpemVyPXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIpLHQuZGVwdGh3aXNlQ29uc3RyYWludD1zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdC5wb2ludHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSx0fSx0LmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnZcIix0fShDb252KSxTZXBhcmFibGVDb252MkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsMix0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5jbGFzc05hbWU9XCJTZXBhcmFibGVDb252MkRcIix0fShTZXBhcmFibGVDb252KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2VwYXJhYmxlQ29udjJEKTt2YXIgQ29udjFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsMSxuKXx8dGhpcztyZXR1cm4gdC52ZXJpZnlBcmdzKG4pLHIuaW5wdXRTcGVjPVt7bmRpbTozfV0scn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssZGVsZXRlIHQuZGF0YUZvcm1hdCx0fSx0LnZlcmlmeUFyZ3M9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUua2VybmVsU2l6ZSYmIWNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKGUua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MUQgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBsZW5ndGggMSwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LmNsYXNzTmFtZT1cIkNvbnYxRFwiLHR9KENvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MUQpO3ZhciBDcm9wcGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQuY3JvcHBpbmc/bi5jcm9wcGluZz1bW3QuY3JvcHBpbmcsdC5jcm9wcGluZ10sW3QuY3JvcHBpbmcsdC5jcm9wcGluZ11dOlwibnVtYmVyXCI9PXR5cGVvZiB0LmNyb3BwaW5nWzBdP24uY3JvcHBpbmc9W1t0LmNyb3BwaW5nWzBdLHQuY3JvcHBpbmdbMF1dLFt0LmNyb3BwaW5nWzFdLHQuY3JvcHBpbmdbMV1dXTpuLmNyb3BwaW5nPXQuY3JvcHBpbmcsbi5kYXRhRm9ybWF0PXZvaWQgMD09PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxuLmlucHV0U3BlYz1be25kaW06NH1dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxlWzFdLGVbMl0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLGVbM10tdGhpcy5jcm9wcGluZ1sxXVswXS10aGlzLmNyb3BwaW5nWzFdWzFdXTpbZVswXSxlWzFdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSxlWzJdLXRoaXMuY3JvcHBpbmdbMV1bMF0tdGhpcy5jcm9wcGluZ1sxXVsxXSxlWzNdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLFwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQ/c2xpY2VBbG9uZ0F4aXMoc2xpY2VBbG9uZ0F4aXMoZSxuLmNyb3BwaW5nWzBdWzBdLGUuc2hhcGVbMV0tbi5jcm9wcGluZ1swXVswXS1uLmNyb3BwaW5nWzBdWzFdLDIpLG4uY3JvcHBpbmdbMV1bMF0sZS5zaGFwZVsyXS1uLmNyb3BwaW5nWzFdWzFdLW4uY3JvcHBpbmdbMV1bMF0sMyk6c2xpY2VBbG9uZ0F4aXMoc2xpY2VBbG9uZ0F4aXMoZSxuLmNyb3BwaW5nWzBdWzBdLGUuc2hhcGVbMl0tbi5jcm9wcGluZ1swXVswXS1uLmNyb3BwaW5nWzBdWzFdLDMpLG4uY3JvcHBpbmdbMV1bMF0sZS5zaGFwZVszXS1uLmNyb3BwaW5nWzFdWzFdLW4uY3JvcHBpbmdbMV1bMF0sNCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2Nyb3BwaW5nOnRoaXMuY3JvcHBpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkNyb3BwaW5nMkRcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENyb3BwaW5nMkQpO3ZhciBVcFNhbXBsaW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX1NJWkU9WzIsMl0sbi5pbnB1dFNwZWM9W3tuZGltOjR9XSxuLnNpemU9bnVsbD09dC5zaXplP24uREVGQVVMVF9TSVpFOnQuc2l6ZSxuLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdCl7dmFyIHQ9bnVsbD09ZVsyXT9udWxsOnRoaXMuc2l6ZVswXSplWzJdLG49bnVsbD09ZVszXT9udWxsOnRoaXMuc2l6ZVsxXSplWzNdO3JldHVybltlWzBdLGVbMV0sdCxuXX10PW51bGw9PWVbMV0/bnVsbDp0aGlzLnNpemVbMF0qZVsxXSxuPW51bGw9PWVbMl0/bnVsbDp0aGlzLnNpemVbMV0qZVsyXTtyZXR1cm5bZVswXSx0LG4sZVszXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxyPXQuc2hhcGU7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQpe3Q9dHJhbnNwb3NlKHQsWzAsMiwzLDFdKTt2YXIgaT1uLnNpemVbMF0qclsyXSxhPW4uc2l6ZVsxXSpyWzNdLG89dC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2ksYV0pO3JldHVybiB0cmFuc3Bvc2UobyxbMCwzLDEsMl0pfWk9bi5zaXplWzBdKnJbMV0sYT1uLnNpemVbMV0qclsyXTtyZXR1cm4gdC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2ksYV0pfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtzaXplOnRoaXMuc2l6ZSxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiVXBTYW1wbGluZzJEXCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIGRlcHRod2lzZUNvbnYyZCQxKGUsdCxuLHIsaSxhKXtyZXR1cm4gdm9pZCAwPT09biYmKG49WzEsMV0pLHZvaWQgMD09PXImJihyPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe251bGw9PWkmJihpPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoaSk7dmFyIG89cHJlcHJvY2Vzc0NvbnYyRElucHV0KGUsaSk7aWYoNCE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IGZvciBkZXB0aHdpc2VDb252MmQgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCBcIitlLnJhbmsrXCItRFwiKTtpZig0IT09dC5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGVwdGh3aXNlS2VybmVsIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIrdC5yYW5rK1wiLURcIik7cmV0dXJuIG89ZGVwdGh3aXNlQ29udjJkKG8sdCxuLFwic2FtZVwiPT09cj9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIsYSksXCJjaGFubmVsc0ZpcnN0XCI9PT1pJiYobz10cmFuc3Bvc2UobyxbMCwzLDEsMl0pKSxvfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFVwU2FtcGxpbmcyRCk7dmFyIERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLDIsdCl8fHRoaXM7cmV0dXJuIG4uZGVwdGh3aXNlS2VybmVsPW51bGwsbi5kZXB0aE11bHRpcGxpZXI9bnVsbD09dC5kZXB0aE11bHRpcGxpZXI/MTp0LmRlcHRoTXVsdGlwbGllcixuLmRlcHRod2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4uZGVwdGh3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuZGVwdGh3aXNlQ29uc3RyYWludCksbi5kZXB0aHdpc2VSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmRlcHRod2lzZVJlZ3VsYXJpemVyKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZigoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aDw0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgaGF2ZSByYW5rIDQuIFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKStcIi5cIik7dmFyIHQ9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTozO2lmKG51bGw9PWVbdF18fGVbdF08MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGlzIG5vdCAoXCIrZVt0XStcIikuXCIpO3ZhciBuPWVbdF0scj1bdGhpcy5rZXJuZWxTaXplWzBdLHRoaXMua2VybmVsU2l6ZVsxXSxuLHRoaXMuZGVwdGhNdWx0aXBsaWVyXTt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixyLG51bGwsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbbip0aGlzLmRlcHRoTXVsdGlwbGllcl0sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWRlcHRod2lzZUNvbnYyZCQxKGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQsbnVsbCk7cmV0dXJuIG4udXNlQmlhcyYmKHQ9Ymlhc0FkZCh0LG4uYmlhcy5yZWFkKCksbi5kYXRhRm9ybWF0KSksbnVsbCE9bi5hY3RpdmF0aW9uJiYodD1uLmFjdGl2YXRpb24uYXBwbHkodCkpLHR9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO3ZhciB0PVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbMl06ZVsxXSxuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbM106ZVsyXSxyPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbMV0qdGhpcy5kZXB0aE11bHRpcGxpZXI6ZVszXSp0aGlzLmRlcHRoTXVsdGlwbGllcixpPWNvbnZPdXRwdXRMZW5ndGgodCx0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksYT1jb252T3V0cHV0TGVuZ3RoKG4sdGhpcy5rZXJuZWxTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tlWzBdLHIsaSxhXTpbZVswXSxpLGEscl19LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiB0LmRlcHRoTXVsdGlwbGllcj10aGlzLmRlcHRoTXVsdGlwbGllcix0LmRlcHRod2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLHQuZGVwdGh3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksdC5kZXB0aHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksdH0sdC5jbGFzc05hbWU9XCJEZXB0aHdpc2VDb252MkRcIix0fShCYXNlQ29udik7ZnVuY3Rpb24gbWFwQWN0aXZhdGlvblRvRnVzZWRLZXJuZWwoZSl7cmV0dXJuXCJyZWx1XCI9PT1lP1wicmVsdVwiOlwibGluZWFyXCI9PT1lP1wibGluZWFyXCI6bnVsbH1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRGVwdGh3aXNlQ29udjJEKTt2YXIgRHJvcG91dD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG4ucmF0ZT1NYXRoLm1heChNYXRoLm1pbih0LnJhdGUsMSksMCksbi5ub2lzZVNoYXBlPXQubm9pc2VTaGFwZSxuLnNlZWQ9dC5zZWVkLG51bGwhPW4uc2VlZCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGluIERyb3BvdXQgbGF5ZXIgeWV0OiBcIituLnNlZWQpO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXROb2lzZVNoYXBlPWZ1bmN0aW9uKGUpe2lmKG51bGw9PXRoaXMubm9pc2VTaGFwZSlyZXR1cm4gdGhpcy5ub2lzZVNoYXBlO2Zvcih2YXIgdD1lLnNoYXBlLG49W10scj0wO3I8dGhpcy5ub2lzZVNoYXBlLmxlbmd0aDsrK3Ipbi5wdXNoKG51bGw9PXRoaXMubm9pc2VTaGFwZVtyXT90W3JdOnRoaXMubm9pc2VTaGFwZVtyXSk7cmV0dXJuIG59LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7aWYobnVsbCE9bi5ub2lzZVNoYXBlJiYhdXRpbC5hcnJheXNFcXVhbChyLnNoYXBlLG4ubm9pc2VTaGFwZSkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24tZGVmYXVsdCBub2lzZSBzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCBsYXllciB5ZXQ6IFwiK0pTT04uc3RyaW5naWZ5KG4ubm9pc2VTaGFwZSkpO2lmKDA8bi5yYXRlJiZuLnJhdGU8MSl7dmFyIGk9bnVsbCE9dC50cmFpbmluZyYmdC50cmFpbmluZyxhPW4uZ2V0Tm9pc2VTaGFwZShyKTtyZXR1cm4gaW5UcmFpblBoYXNlKGZ1bmN0aW9uKCl7cmV0dXJuIGRyb3BvdXQocixuLnJhdGUsYSxuLnNlZWQpfSxmdW5jdGlvbigpe3JldHVybiByfSxpKX1yZXR1cm4gZX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cmF0ZTp0aGlzLnJhdGUsbm9pc2VTaGFwZTp0aGlzLm5vaXNlU2hhcGUsc2VlZDp0aGlzLnNlZWR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKX0sdC5jbGFzc05hbWU9XCJEcm9wb3V0XCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEcm9wb3V0KTt2YXIgRGVuc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLmFjdGl2YXRpb249bnVsbCxuLnVzZUJpYXM9ITAsbi5rZXJuZWw9bnVsbCxuLmJpYXM9bnVsbCxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG51bGw9PXQuYmF0Y2hJbnB1dFNoYXBlJiZudWxsPT10LmlucHV0U2hhcGUmJm51bGwhPXQuaW5wdXREaW0pe3ZhciByPW51bGw7bnVsbCE9dC5iYXRjaFNpemUmJihyPXQuYmF0Y2hTaXplKSxuLmJhdGNoSW5wdXRTaGFwZT1bcix0LmlucHV0RGltXX1yZXR1cm4gbi51bml0cz10LnVuaXRzLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnVuaXRzLFwidW5pdHNcIiksbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odC5hY3RpdmF0aW9uKSxudWxsIT10LnVzZUJpYXMmJihuLnVzZUJpYXM9dC51c2VCaWFzKSxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4uYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmlhc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksbi5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5rZXJuZWxDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5rZXJuZWxSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0Lmtlcm5lbFJlZ3VsYXJpemVyKSxuLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJpYXNSZWd1bGFyaXplciksbi5hY3Rpdml0eVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYWN0aXZpdHlSZWd1bGFyaXplciksbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5pbnB1dFNwZWM9W3ttaW5ORGltOjJ9XSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdCxuPShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbZS5sZW5ndGgtMV07bnVsbD09dGhpcy5rZXJuZWwmJih0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtuLHRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLnVuaXRzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSksdGhpcy5pbnB1dFNwZWM9W3ttaW5ORGltOjIsYXhlczoodD17fSx0Wy0xXT1uLHQpfV0sdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoKTtyZXR1cm4gdFt0Lmxlbmd0aC0xXT10aGlzLnVuaXRzLHR9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByLGk9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxhPW1hcEFjdGl2YXRpb25Ub0Z1c2VkS2VybmVsKG4uYWN0aXZhdGlvbi5nZXRDbGFzc05hbWUoKSk7cmV0dXJuIG51bGwhPWE/cj1kb3QoaSxuLmtlcm5lbC5yZWFkKCksYSxuLmJpYXM/bi5iaWFzLnJlYWQoKTpudWxsKToocj1kb3QoaSxuLmtlcm5lbC5yZWFkKCkpLG51bGwhPW4uYmlhcyYmKHI9Ymlhc0FkZChyLG4uYmlhcy5yZWFkKCkpKSxudWxsIT1uLmFjdGl2YXRpb24mJihyPW4uYWN0aXZhdGlvbi5hcHBseShyKSkpLHJ9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJEZW5zZVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRGVuc2UpO3ZhciBGbGF0dGVuPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdHx8e30pfHx0aGlzO3JldHVybiBuLmlucHV0U3BlYz1be21pbk5EaW06M31dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoMSk7dDxuLmxlbmd0aDt0Kyspe2lmKG51bGw9PW5bdF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1RoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdG8gXCJGbGF0dGVuXCIgaXMgbm90IGZ1bGx5IGRlZmluZWQgKGdvdCAnK2Uuc2xpY2UoMSkrJykuIE1ha2Ugc3VyZSB0byBwYXNzIGEgY29tcGxldGUgXCJpbnB1dF9zaGFwZVwiIG9yIFwiYmF0Y2hfaW5wdXRfc2hhcGVcIiBhcmd1bWVudCB0byB0aGUgZmlyc3QgbGF5ZXIgaW4geW91ciBtb2RlbC4nKX1yZXR1cm5bZVswXSxhcnJheVByb2QoZSwxKV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG4uaW52b2tlQ2FsbEhvb2soZSx0KSxiYXRjaEZsYXR0ZW4oZ2V0RXhhY3RseU9uZVRlbnNvcihlKSl9KX0sdC5jbGFzc05hbWU9XCJGbGF0dGVuXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhGbGF0dGVuKTt2YXIgQWN0aXZhdGlvbiQxPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHQuYWN0aXZhdGlvbiksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbi5hY3RpdmF0aW9uLmFwcGx5KHIpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXthY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiQWN0aXZhdGlvblwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQWN0aXZhdGlvbiQxKTt2YXIgUmVwZWF0VmVjdG9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4ubj10Lm4sbi5pbnB1dFNwZWM9W3tuZGltOjJ9XSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuW2VbMF0sdGhpcy5uLGVbMV1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiByZXBlYXQoZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLG4ubil9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e246dGhpcy5ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJSZXBlYXRWZWN0b3JcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlcGVhdFZlY3Rvcik7dmFyIFJlc2hhcGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztuLnRhcmdldFNoYXBlPXQudGFyZ2V0U2hhcGU7Zm9yKHZhciByPTA7cjxuLnRhcmdldFNoYXBlLmxlbmd0aDsrK3Ipbi5pc1Vua25vd24obi50YXJnZXRTaGFwZVtyXSkmJihuLnRhcmdldFNoYXBlW3JdPW51bGwpO3JldHVybiBufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5pc1Vua25vd249ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MHx8bnVsbD09ZX0sdC5wcm90b3R5cGUuZml4VW5rbm93bkRpbWVuc2lvbj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1cIlRvdGFsIHNpemUgb2YgbmV3IGFycmF5IG11c3QgYmUgdW5jaGFuZ2VkLlwiLHI9dC5zbGljZSgpLGk9MSxhPW51bGwsbz0wO288ci5sZW5ndGg7KytvKXt2YXIgcz1yW29dO2lmKHRoaXMuaXNVbmtub3duKHMpKXtpZihudWxsIT09YSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbiBvbmx5IHNwZWNpZml5IG9uZSB1bmtub3duIGRpbWVuc2lvbi5cIik7YT1vfWVsc2UgaSo9c312YXIgbD1hcnJheVByb2QoZSk7aWYobnVsbCE9PWEpe2lmKDA9PT1pfHxsJWkhPTApdGhyb3cgbmV3IFZhbHVlRXJyb3Iobik7clthXT1sL2l9ZWxzZSBpZihsIT09aSl0aHJvdyBuZXcgVmFsdWVFcnJvcihuKTtyZXR1cm4gcn0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0hMSxuPTA7bjxlLmxlbmd0aDsrK24paWYodGhpcy5pc1Vua25vd24oZVtuXSkpe3Q9ITA7YnJlYWt9cmV0dXJuIHQ/ZS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLnRhcmdldFNoYXBlKTplLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMuZml4VW5rbm93bkRpbWVuc2lvbihlLnNsaWNlKDEpLHRoaXMudGFyZ2V0U2hhcGUpKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxpPXIuc2hhcGUsYT1pLnNsaWNlKDAsMSkuY29uY2F0KG4uZml4VW5rbm93bkRpbWVuc2lvbihpLnNsaWNlKDEpLG4udGFyZ2V0U2hhcGUpKTtyZXR1cm4gci5yZXNoYXBlKGEpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt0YXJnZXRTaGFwZTp0aGlzLnRhcmdldFNoYXBlfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJSZXNoYXBlXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZXNoYXBlKTt2YXIgUGVybXV0ZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG51bGw9PXQuZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkIGBkaW1zYCBpcyBtaXNzaW5nIGR1cmluZyBQZXJtdXRlIGNvbnN0cnVjdG9yIGNhbGwuXCIpO2lmKCFBcnJheS5pc0FycmF5KHQuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiUGVybXV0ZSBjb25zdHJ1Y3RvciByZXF1aXJlcyBgZGltc2AgdG8gYmUgYW4gQXJyYXksIGJ1dCByZWNlaXZlZCBcIit0LmRpbXMrXCIgaW5zdGVhZC5cIik7dmFyIHI9cmFuZ2UoMSx0LmRpbXMubGVuZ3RoKzEpO2lmKCF1dGlsLmFycmF5c0VxdWFsKHQuZGltcy5zbGljZSgpLnNvcnQoKSxyKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBlcm11dGF0aW9uIGBkaW1zYDogXCIrSlNPTi5zdHJpbmdpZnkodC5kaW1zKStcIiBgZGltc2AgbXVzdCBjb250YWluIGNvbnNlY3V0aXZlIGludGVnZXJzIHN0YXJ0aW5nIGZyb20gMS5cIik7cmV0dXJuIG4uZGltcz10LmRpbXMsbi5kaW1zSW5jbHVkaW5nQmF0Y2g9WzBdLmNvbmNhdChuLmRpbXMpLG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOm4uZGltcy5sZW5ndGgrMX0pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgpO3JldHVybiB0aGlzLmRpbXMuZm9yRWFjaChmdW5jdGlvbihuLHIpe3RbcisxXT1lW25dfSksdH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiB0cmFuc3Bvc2UoZ2V0RXhhY3RseU9uZVRlbnNvcihlKSx0aGlzLmRpbXNJbmNsdWRpbmdCYXRjaCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtkaW1zOnRoaXMuZGltc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUGVybXV0ZVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUGVybXV0ZSk7dmFyIE1hc2tpbmc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLm1hc2tWYWx1ZT1udWxsIT10P251bGw9PXQubWFza1ZhbHVlPzA6dC5tYXNrVmFsdWU6MCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpLG49e21hc2tWYWx1ZTp0aGlzLm1hc2tWYWx1ZX07cmV0dXJuIE9iamVjdC5hc3NpZ24obix0KSxufSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIGFueShub3RFcXVhbChuLHRoaXMubWFza1ZhbHVlKSwtMSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksaT1hbnkobm90RXF1YWwocixuLm1hc2tWYWx1ZSksLTEsITApO3JldHVybiByLm11bChpLmFzVHlwZShyLmR0eXBlKSl9KX0sdC5jbGFzc05hbWU9XCJNYXNraW5nXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXNraW5nKTt2YXIgRW1iZWRkaW5nPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5lbWJlZGRpbmdzPW51bGwsbi5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVI9XCJyYW5kb21Vbmlmb3JtXCIsbnVsbD09dC5iYXRjaElucHV0U2hhcGUmJm51bGw9PXQuaW5wdXRTaGFwZSl7dmFyIHI9bnVsbDtudWxsIT10LmJhdGNoU2l6ZSYmKHI9dC5iYXRjaFNpemUpLG51bGw9PXQuaW5wdXRMZW5ndGg/bi5iYXRjaElucHV0U2hhcGU9W3IsbnVsbF06bi5iYXRjaElucHV0U2hhcGU9W3JdLmNvbmNhdCh0b0xpc3QodC5pbnB1dExlbmd0aCkpfXJldHVybiBuLmlucHV0RGltPXQuaW5wdXREaW0sYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4uaW5wdXREaW0sXCJpbnB1dERpbVwiKSxuLm91dHB1dERpbT10Lm91dHB1dERpbSxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5vdXRwdXREaW0sXCJvdXRwdXREaW1cIiksbi5lbWJlZGRpbmdzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5lbWJlZGRpbmdzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSKSxuLmVtYmVkZGluZ3NSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmVtYmVkZGluZ3NSZWd1bGFyaXplciksbi5hY3Rpdml0eVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYWN0aXZpdHlSZWd1bGFyaXplciksbi5lbWJlZGRpbmdzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLG4ubWFza1plcm89dC5tYXNrWmVybyxuLnN1cHBvcnRzTWFza2luZz10Lm1hc2taZXJvLG4uaW5wdXRMZW5ndGg9dC5pbnB1dExlbmd0aCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt0aGlzLmVtYmVkZGluZ3M9dGhpcy5hZGRXZWlnaHQoXCJlbWJlZGRpbmdzXCIsW3RoaXMuaW5wdXREaW0sdGhpcy5vdXRwdXREaW1dLHRoaXMuZHR5cGUsdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIsdGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIsITAsdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZT1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBuLm1hc2taZXJvPyhlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksbm90RXF1YWwoZSx6ZXJvc0xpa2UoZSkpKTpudWxsfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpZihlPWdldEV4YWN0bHlPbmVTaGFwZShlKSxudWxsPT10aGlzLmlucHV0TGVuZ3RoKXJldHVybiBlLmNvbmNhdChbdGhpcy5vdXRwdXREaW1dKTt2YXIgdD10b0xpc3QodGhpcy5pbnB1dExlbmd0aCk7aWYodC5sZW5ndGghPT1lLmxlbmd0aC0xKXRocm93IG5ldyBWYWx1ZUVycm9yKCdcImlucHV0TGVuZ3RoXCIgaXMgJyt0aGlzLmlucHV0TGVuZ3RoK1wiLCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgaGFzIHNoYXBlIFwiK2UpO2Zvcih2YXIgbj0wLHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIGk9dFtyXSxhPWVbcisxXTtpZihudWxsIT1pJiZudWxsIT1hJiZpIT09YSl0aHJvdyBuZXcgVmFsdWVFcnJvcignXCJpbnB1dExlbmd0aFwiIGlzICcrdGhpcy5pbnB1dExlbmd0aCtcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIitlKTtudWxsPT1pJiYodFtuXT1hKSxuKyt9cmV0dXJuW2VbMF1dLmNvbmNhdCh0LFt0aGlzLm91dHB1dERpbV0pfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVyblwiaW50MzJcIiE9PXIuZHR5cGUmJihyPWNhc3QkMShyLFwiaW50MzJcIikpLGdhdGhlciQxKG4uZW1iZWRkaW5ncy5yZWFkKCksci5hczFEKCkpLnJlc2hhcGUoZ2V0RXhhY3RseU9uZVNoYXBlKG4uY29tcHV0ZU91dHB1dFNoYXBlKHIuc2hhcGUpKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2lucHV0RGltOnRoaXMuaW5wdXREaW0sb3V0cHV0RGltOnRoaXMub3V0cHV0RGltLGVtYmVkZGluZ3NJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciksZW1iZWRkaW5nc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksZW1iZWRkaW5nc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSxtYXNrWmVybzp0aGlzLm1hc2taZXJvLGlucHV0TGVuZ3RoOnRoaXMuaW5wdXRMZW5ndGh9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkVtYmVkZGluZ1wiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRW1iZWRkaW5nKTt2YXIgTWVyZ2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0fHx7fSl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3J9LHQucHJvdG90eXBlLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lfHxudWxsPT10KXJldHVybiBudWxsO2lmKGUubGVuZ3RoPHQubGVuZ3RoKXJldHVybiB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUodCxlKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGU7Zm9yKHZhciBuPWUuc2xpY2UoMCxlLmxlbmd0aC10Lmxlbmd0aCkscj0wO3I8dC5sZW5ndGg7KytyKXt2YXIgaT1lW2UubGVuZ3RoLXQubGVuZ3RoK3JdLGE9dFtyXTtpZihudWxsPT1pfHxudWxsPT1hfHxpPDB8fGE8MCluLnB1c2gobnVsbCk7ZWxzZSBpZigxPT09aSluLnB1c2goYSk7ZWxzZSBpZigxPT09YSluLnB1c2goaSk7ZWxzZXtpZihpIT09YSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIgXCIrSlNPTi5zdHJpbmdpZnkodCkpO24ucHVzaChpKX19cmV0dXJuIG59LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkmJiFBcnJheS5pc0FycmF5KGVbMF0pJiYoZT1bZ2V0RXhhY3RseU9uZVNoYXBlKGUpXSksKGU9ZSkubGVuZ3RoPDIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIG1lcmdlIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYW4gQXJyYXkgb2YgYXQgbGVhc3QgMiBpbnB1dHMuIEdvdCBcIitlLmxlbmd0aCtcIiBpbnB1dChzKS5cIik7Zm9yKHZhciB0PVtdLG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe251bGwhPShvPXJbbl0pJiZudWxsIT09b1swXSYmdC5wdXNoKG9bMF0pfWlmKCh0PXVuaXF1ZSh0KSkubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW4gbm90IG1lcmdlIHRlbnNvcnMgd2l0aCBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMuIEdvdCB0ZW5zb3JzIHdpdGggc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShlKStcIi5cIik7Zm9yKHZhciBpPW51bGw9PWVbMF0/bnVsbDplWzBdLnNsaWNlKDEpLGE9MTthPGUubGVuZ3RoOysrYSl7dmFyIG89bnVsbD09ZVthXT9udWxsOmVbYV0uc2xpY2UoMSk7aT10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUoaSxvKX12YXIgcz1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGh9KTstMT09PWUuaW5kZXhPZihudWxsKSYmMT09PXVuaXF1ZShzKS5sZW5ndGg/dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITE6dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoZT1lLG4ucmVzaGFwZVJlcXVpcmVkKXt2YXIgdD1bXSxyPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJhbmt9KTtpZigtMT09PXIuaW5kZXhPZihudWxsKSl7Zm9yKHZhciBpPW1heCQxKHIpLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe2Zvcih2YXIgcz0oaD1vW2FdKS5yYW5rLGw9MDtsPGktczsrK2wpaD1leHBhbmREaW1zJDEoaCwxKTt0LnB1c2goaCl9cmV0dXJuIG4ubWVyZ2VGdW5jdGlvbih0KX1mb3IodmFyIHU9ITEsYz0wLHA9ZTtjPHAubGVuZ3RoO2MrKyl7dmFyIGg7aWYobnVsbD09KHM9KGg9cFtjXSkucmFuaykpe3ZhciBkPWguc2hhcGUsZj1kWzBdLGc9ZC5zbGljZSgxKS5jb25jYXQoW2ZdKSxtPWgucmVzaGFwZShbZl0uY29uY2F0KGFycmF5UHJvZChkLnNsaWNlKDEpKSkpO209KG09dHJhbnNwb3NlKG0sWzEsMF0pKS5yZXNoYXBlKGcpLHQucHVzaChtKSx1PSEwfWVsc2UgaWYocz4xKXt2YXIgeT1yYW5nZSgxLHMpLmNvbmNhdChbMF0pO3QucHVzaCh0cmFuc3Bvc2UoaCx5KSksdT0hMH1lbHNlIHQucHVzaChoKX12YXIgdj1uLm1lcmdlRnVuY3Rpb24odCksYj12LnJhbms7aWYodSlpZihudWxsPT1iKXt2YXIgdz12LnNoYXBlO2c9W2Y9d1t3Lmxlbmd0aC0xXV0uY29uY2F0KHcuc2xpY2UoMCx3Lmxlbmd0aC0xKSk7dj10cmFuc3Bvc2Uodi5yZXNoYXBlKFstMSxmXSksWzEsMF0pLnJlc2hhcGUoZyl9ZWxzZSBpZihiPjEpe3k9W2ItMV0uY29uY2F0KHJhbmdlKDAsYi0xKSk7dj10cmFuc3Bvc2Uodix5KX1yZXR1cm4gdn1yZXR1cm4gbi5tZXJnZUZ1bmN0aW9uKGUpfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdDt0PW51bGw9PShlPWUpWzBdP251bGw6ZVswXS5zbGljZSgxKTtmb3IodmFyIG49MTtuPGUubGVuZ3RoOysrbil7dmFyIHI9bnVsbD09ZVtuXT9udWxsOmVbbl0uc2xpY2UoMSk7dD10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUodCxyKX1mb3IodmFyIGk9W10sYT0wLG89ZTthPG8ubGVuZ3RoO2ErKyl7bnVsbCE9KHI9b1thXSkmJm51bGwhPT1yWzBdJiZpLnB1c2goclswXSl9cmV0dXJuIHQ9MT09PShpPXVuaXF1ZShpKSkubGVuZ3RoP2kuY29uY2F0KHQpOltudWxsXS5jb25jYXQodCl9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT10KXJldHVybiBudWxsO2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYG1hc2tgIHNob3VsZCBiZSBhbiBBcnJheVwiKTtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBpbnB1dHNgIHNob3VsZCBiZSBhbiBBcnJheVwiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIEFycmF5ICdpbnB1dHMnIGFuZCAnbWFzaycgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLCBidXQgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyAoXCIrZS5sZW5ndGgrXCIgdnMgXCIrdC5sZW5ndGgrXCIpXCIpO2lmKHQuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWV9KSlyZXR1cm4gbnVsbDtmb3IodmFyIG49KHQ9dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/ZTpleHBhbmREaW1zKGUsMCl9KSlbMF0scj0xO3I8dC5sZW5ndGgtMTsrK3Ipbj1sb2dpY2FsQW5kKG4sdFtyXSk7cmV0dXJuIG59KX0sdH0oTGF5ZXIpLEFkZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLmNsb25lKCksbj0xO248ZS5sZW5ndGg7KytuKXQ9YWRkKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJBZGRcIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEFkZCk7dmFyIE11bHRpcGx5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0uY2xvbmUoKSxuPTE7bjxlLmxlbmd0aDsrK24pdD1tdWwodCxlW25dKTtyZXR1cm4gdH0pfSx0LmNsYXNzTmFtZT1cIk11bHRpcGx5XCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNdWx0aXBseSk7dmFyIEF2ZXJhZ2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXS5jbG9uZSgpLG49MTtuPGUubGVuZ3RoOysrbil0PWFkZCh0LGVbbl0pO3JldHVybiBtdWwoMS9lLmxlbmd0aCx0KX0pfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VcIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2UpO3ZhciBNYXhpbXVtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0sbj0xO248ZS5sZW5ndGg7KytuKXQ9bWF4aW11bSh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiTWF4aW11bVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4aW11bSk7dmFyIE1pbmltdW09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXSxuPTE7bjxlLmxlbmd0aDsrK24pdD1taW5pbXVtKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJNaW5pbXVtXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNaW5pbXVtKTt2YXIgQ29uY2F0ZW5hdGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FYSVM9LTEsbnVsbD09dCYmKHQ9e30pLG4uYXhpcz1udWxsPT10LmF4aXM/bi5ERUZBVUxUX0FYSVM6dC5heGlzLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ucmVzaGFwZVJlcXVpcmVkPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKCFBcnJheS5pc0FycmF5KGUpfHwhQXJyYXkuaXNBcnJheShlWzBdKXx8MT09PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGF0IGxlYXN0IDIgaW5wdXRzXCIpO2Zvcih2YXIgdD0hMCxuPTAscj1lPWU7bjxyLmxlbmd0aDtuKyspe2lmKG51bGwhPShjPXJbbl0pKXt0PSExO2JyZWFrfX1pZighdCl7Zm9yKHZhciBpPVtdLGE9MDthPGUubGVuZ3RoOysrYSl7dmFyIG89ZVthXS5zbGljZSgpO28uc3BsaWNlKHRoaXMuYXhpcywxKTtmb3IodmFyIHM9ITEsbD0wLHU9aTtsPHUubGVuZ3RoO2wrKyl7dmFyIGM9dVtsXTtpZih1dGlsLmFycmF5c0VxdWFsKGMsbykpe3M9ITA7YnJlYWt9fXN8fGkucHVzaChvKX1pZihpLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHJlcXVpcmVzIGlucHV0cyB3aXRoIG1hdGNoaW5nIHNoYXBlcyBleGNlcHQgZm9yIHRoZSBjb25jYXQgYXhpcy4gR290IGlucHV0IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX0sdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNvbmNhdGVuYXRlKGUsdC5heGlzKX0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aWYoIUFycmF5LmlzQXJyYXkoZSl8fCFBcnJheS5pc0FycmF5KGVbMF0pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGlucHV0cy5cIik7Zm9yKHZhciB0PWUsbj10WzBdLnNsaWNlKCkscj10aGlzLmF4aXM8MD9uLmxlbmd0aCt0aGlzLmF4aXM6dGhpcy5heGlzLGk9MCxhPXQuc2xpY2UoMSk7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07aWYobnVsbD09bltyXXx8bnVsbD09b1tyXSl7bltyXT1udWxsO2JyZWFrfW5bcl0rPW9bcl19cmV0dXJuIG59LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztpZihudWxsPT10KXJldHVybiBudWxsO2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYG1hc2tgIHNob3VsZCBiZSBhbiBhcnJheSBmb3IgQ29uY2F0ZW5hdGVcIik7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJgaW5wdXRzYCBzaG91bGQgYmUgYW4gYXJyYXkgZm9yIENvbmNhdGVuYXRlXCIpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJNaXNtYXRjaCBpbiB0aGUgbGVuZ3RoIG9mIG1hc2sgKFwiK3QubGVuZ3RoK1wiKSBhbmQgdGhlIGxlZ250aCBvZiBpbnB1dHMgKFwiK2UubGVuZ3RoK1wiKVwiKTtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPSEwO2lmKHQuZm9yRWFjaChmdW5jdGlvbihlKXtudWxsPT1lfHwocj0hMSl9KSxyKXJldHVybiBudWxsO2Zvcih2YXIgaT1bXSxhPTA7YTxlLmxlbmd0aDsrK2EpbnVsbD09dFthXT9pLnB1c2gob25lc0xpa2UoZVthXSkuYXNUeXBlKFwiYm9vbFwiKSk6dFthXS5yYW5rPGVbYV0ucmFuaz9pLnB1c2goZXhwYW5kRGltcyh0W2FdLC0xKSk6aS5wdXNoKHRbYV0pO3ZhciBvPWNvbmNhdChpLG4uYXhpcyk7cmV0dXJuIGFsbChvLC0xLCExKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YXhpczp0aGlzLmF4aXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkNvbmNhdGVuYXRlXCIsdH0oTWVyZ2UpO2Z1bmN0aW9uIGludGVycHJldEF4aXMoZSx0KXtmb3IoO2U8MDspZSs9dDtyZXR1cm4gZX1mdW5jdGlvbiBiYXRjaERvdChlLHQsbil7aWYoZS5zaGFwZS5sZW5ndGg+M3x8dC5zaGFwZS5sZW5ndGg+Myl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImJhdGNoRG90IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXRcIik7aWYodXRpbC5hc3NlcnQoZS5zaGFwZS5sZW5ndGg+PTIsZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHggdG8gYmUgPj0gMiwgYnV0IGdvdCBcIitlLnNoYXBlLmxlbmd0aH0pLHV0aWwuYXNzZXJ0KGUuc2hhcGUubGVuZ3RoPj0yLGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaERvdCByZXF1aXJlcyB0aGUgcmFuayBvZiB5IHRvIGJlID49IDIsIGJ1dCBnb3QgXCIrdC5zaGFwZS5sZW5ndGh9KSxcIm51bWJlclwiPT10eXBlb2YgbiYmKG49W24sbl0pLFwiY29tcGxleDY0XCI9PT1lLmR0eXBlfHxcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImJhdGNoRG90IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgY29tcGxleDY0LXR5cGUgVGVuc29ycyB5ZXQuXCIpO3ZhciByPWUuc2hhcGUubGVuZ3RoLGk9dC5zaGFwZS5sZW5ndGg7bnVsbD09biYmKG49W3ItMSxpLTJdKTt2YXIgYT1uO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG4sbztpZihyPmkpe249ci1pO2Zvcih2YXIgcz1bXSxsPTA7bDxuOysrbClzLnB1c2goMSk7dD10LnJlc2hhcGUodC5zaGFwZS5jb25jYXQocykpfWVsc2UgaWYoaT5yKXtuPWktcjtmb3Iocz1bXSxsPTA7bDxuOysrbClzLnB1c2goMSk7ZT1lLnJlc2hhcGUoZS5zaGFwZS5jb25jYXQocykpfWVsc2Ugbj0wO2lmKDI9PT1lLnNoYXBlLmxlbmd0aCYmMj09PXQuc2hhcGUubGVuZ3RoKW89YVswXT09PWFbMV0/ZS5tdWxTdHJpY3QodCkuc3VtKGFbMF0pOmUudHJhbnNwb3NlKFsxLDBdKS5tdWxTdHJpY3QodCkuc3VtKGFbMV0pO2Vsc2V7dmFyIHU9YVswXSE9PWUuc2hhcGUubGVuZ3RoLTEsYz1hWzFdPT09dC5zaGFwZS5sZW5ndGgtMTtvPWUubWF0TXVsKHQsdSxjKX1pZihuPjApe3ZhciBwPXZvaWQgMCxoPVtdO2ZvcihsPXA9cj5pP3IraS0zOnItMTtsPHArbjsrK2wpaC5wdXNoKGwpO289by5zcXVlZXplKGgpfXJldHVybiAxPT09by5zaGFwZS5sZW5ndGgmJihvPW8uZXhwYW5kRGltcygxKSksb30pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb25jYXRlbmF0ZSk7dmFyIERvdD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmF4ZXM9dC5heGVzLG4ubm9ybWFsaXplPW51bGwhPXQubm9ybWFsaXplJiZ0Lm5vcm1hbGl6ZSxuLnN1cHBvcnRzTWFza2luZz0hMCxuLnJlc2hhcGVSZXF1aXJlZD0hMSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGUpJiYyPT09ZS5sZW5ndGgmJkFycmF5LmlzQXJyYXkoZVswXSkmJkFycmF5LmlzQXJyYXkoZVsxXSksZnVuY3Rpb24oKXtyZXR1cm5cIkEgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy5cIn0pO3ZhciB0PWVbMF0sbj1lWzFdO2lmKHQubGVuZ3RoPjN8fG4ubGVuZ3RoPjMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJEb3QgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldC5cIik7dmFyIHI9dGhpcy5pbnRlcnByZXRBeGVzKHQsbik7aWYodFtyWzBdXSE9PW5bclsxXV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEaW1lbnNpb24gaW5jb21wYXRpYmlsaXR5OiBcIit0W3JbMF1dK1wiICE9PSBcIituW3JbMV1dKX0sdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtpZigyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBEb3RgIGxheWVyIG11c3QgYmUgY2FsbGVkIG9uIGV4YWN0bHkgMiBpbnB1dHMsIGJ1dCByZWNlaXZlZCBcIitlLmxlbmd0aCtcIiBpbnB1dChzKS5cIik7dmFyIHQsbj1lWzBdLHI9ZVsxXTtyZXR1cm4gdD1BcnJheS5pc0FycmF5KHRoaXMuYXhlcyk/dGhpcy5heGVzLm1hcChmdW5jdGlvbih0LG4pe3JldHVybiBpbnRlcnByZXRBeGlzKHQsZVtuXS5zaGFwZS5sZW5ndGgpfSk6W2ludGVycHJldEF4aXModGhpcy5heGVzLG4uc2hhcGUubGVuZ3RoKSxpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxyLnNoYXBlLmxlbmd0aCldLHRoaXMubm9ybWFsaXplJiYobj1sMk5vcm1hbGl6ZShuLHRbMF0pLHI9bDJOb3JtYWxpemUocix0WzFdKSksYmF0Y2hEb3QobixyLHQpfSx0LnByb3RvdHlwZS5pbnRlcnByZXRBeGVzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5heGVzKT90aGlzLmF4ZXM6W2ludGVycHJldEF4aXModGhpcy5heGVzLGUubGVuZ3RoKSxpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyx0Lmxlbmd0aCldfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShlKSYmMj09PWUubGVuZ3RoJiZBcnJheS5pc0FycmF5KGVbMF0pJiZBcnJheS5pc0FycmF5KGVbMV0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBIGBEb3RgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGV4YWN0bHkgMiBpbnB1dHMuXCJ9KTt2YXIgdD1lWzBdLnNsaWNlKCksbj1lWzFdLnNsaWNlKCk7aWYodC5sZW5ndGg+M3x8bi5sZW5ndGg+Myl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkRvdCBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0LlwiKTt2YXIgcj10aGlzLmludGVycHJldEF4ZXModCxuKTt0LnNwbGljZShyWzBdLDEpLG4uc3BsaWNlKHJbMV0sMSksbi5zcGxpY2UoMCwxKTt2YXIgaT10LmNvbmNhdChuKTtyZXR1cm4gMT09PWkubGVuZ3RoJiZpLnB1c2goMSksaX0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbH0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4ZXM6dGhpcy5heGVzLG5vcm1hbGl6ZTp0aGlzLm5vcm1hbGl6ZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRG90XCIsdH0oTWVyZ2UpO2Z1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbihlLHQsbixyLGksYSl7dmFyIG87aWYodm9pZCAwPT09YSYmKGE9LjAwMSksMj09PWUucmFuaylvPWJhdGNoTm9ybTJkKGUsdCxuLHIsaSxhKTtlbHNlIGlmKDM9PT1lLnJhbmspbz1iYXRjaE5vcm0zZChlLHQsbixyLGksYSk7ZWxzZXtpZig0IT09ZS5yYW5rKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hOb3JtYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgYXJyYXkgb2YgcmFuayBcIitlLnJhbmsrXCIgeWV0XCIpO289YmF0Y2hOb3JtNGQoZSx0LG4scixpLGEpfXJldHVybiBvfWZ1bmN0aW9uIHJlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LjAwMSksdGlkeShmdW5jdGlvbigpe3ZhciBhPW1vbWVudHMoZSxyKSxvPWEubWVhbixzPWEudmFyaWFuY2U7cmV0dXJuW2JhdGNoTm9ybWFsaXphdGlvbihlLG8scyxuLHQsaSksbyxzXX0pfWZ1bmN0aW9uIGJyb2FkY2FzdE5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0uMDAxKSx0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBhPW1vbWVudHMoZSxyKSxvPWEubWVhbixzPWEudmFyaWFuY2UsbD1bXSx1PTAsYz1yYW5nZSgwLGUucmFuayk7dTxjLmxlbmd0aDt1Kyspe3ZhciBwPWNbdV07LTEhPT1yLmluZGV4T2YocCk/bC5wdXNoKDEpOmwucHVzaChlLnNoYXBlW3BdKX12YXIgaD1vLnJlc2hhcGUobCksZD1zLnJlc2hhcGUobCksZj1udWxsPT10P251bGw6dC5yZXNoYXBlKGwpLGc9bnVsbD09bj9udWxsOm4ucmVzaGFwZShsKTtyZXR1cm5bYmF0Y2hOb3JtYWxpemF0aW9uKGUsaCxkLGcsZixpKSxvLHNdfSl9ZnVuY3Rpb24gbm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPS4wMDEpLHV0aWwuYXJyYXlzRXF1YWwoci5zbGljZSgpLnNvcnQoKSxyYW5nZSgwLGUucmFuay0xKSk/cmVndWxhck5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpOmJyb2FkY2FzdE5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEb3QpO3ZhciBCYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj10aGlzO3JldHVybiBudWxsPT10JiYodD17fSksKG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMpLnN1cHBvcnRzTWFza2luZz0hMCxuLmF4aXM9bnVsbD09dC5heGlzPy0xOnQuYXhpcyxuLm1vbWVudHVtPW51bGw9PXQubW9tZW50dW0/Ljk5OnQubW9tZW50dW0sbi5lcHNpbG9uPW51bGw9PXQuZXBzaWxvbj8uMDAxOnQuZXBzaWxvbixuLmNlbnRlcj1udWxsPT10LmNlbnRlcnx8dC5jZW50ZXIsbi5zY2FsZT1udWxsPT10LnNjYWxlfHx0LnNjYWxlLG4uYmV0YUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmV0YUluaXRpYWxpemVyfHxcInplcm9zXCIpLG4uZ2FtbWFJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmdhbW1hSW5pdGlhbGl6ZXJ8fFwib25lc1wiKSxuLm1vdmluZ01lYW5Jbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lm1vdmluZ01lYW5Jbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSxuLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyfHxcIm9uZXNcIiksbi5iZXRhQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYmV0YUNvbnN0cmFpbnQpLG4uZ2FtbWFDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5nYW1tYUNvbnN0cmFpbnQpLG4uYmV0YVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmV0YVJlZ3VsYXJpemVyKSxuLmdhbW1hUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5nYW1tYVJlZ3VsYXJpemVyKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdDtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgbj10aGlzLmF4aXM+PTA/dGhpcy5heGlzOnRoaXMuYXhpcytlLmxlbmd0aCxyPWVbbl07aWYobnVsbD09cil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkF4aXMgXCIrbitcIiBvZiBpbnB1dCB0ZW5zb3Igc2hvdWxkIGhhdmUgYSBkZWZpbmVkIGRpbWVuc2lvbiBidXQgdGhlIGxheWVyIHJlY2VpdmVkIGFuIGlucHV0IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIuXCIpO3RoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOmUubGVuZ3RoLGF4ZXM6KHQ9e30sdFtuXT1yLHQpfSldO3ZhciBpPVtyXTt0aGlzLnNjYWxlJiYodGhpcy5nYW1tYT10aGlzLmFkZFdlaWdodChcImdhbW1hXCIsaSxudWxsLHRoaXMuZ2FtbWFJbml0aWFsaXplcix0aGlzLmdhbW1hUmVndWxhcml6ZXIsITAsdGhpcy5nYW1tYUNvbnN0cmFpbnQpKSx0aGlzLmNlbnRlciYmKHRoaXMuYmV0YT10aGlzLmFkZFdlaWdodChcImJldGFcIixpLG51bGwsdGhpcy5iZXRhSW5pdGlhbGl6ZXIsdGhpcy5iZXRhUmVndWxhcml6ZXIsITAsdGhpcy5iZXRhQ29uc3RyYWludCkpLHRoaXMubW92aW5nTWVhbj10aGlzLmFkZFdlaWdodChcIm1vdmluZ19tZWFuXCIsaSxudWxsLHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyLG51bGwsITEpLHRoaXMubW92aW5nVmFyaWFuY2U9dGhpcy5hZGRXZWlnaHQoXCJtb3ZpbmdfdmFyaWFuY2VcIixpLG51bGwsdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyLG51bGwsITEpLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9bnVsbCE9dC50cmFpbmluZyYmdC50cmFpbmluZyxpPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksYT1pLnNoYXBlLG89YS5sZW5ndGgscz1yYW5nZSgwLG8pLGw9bi5heGlzPj0wP24uYXhpczpuLmF4aXMrbztzLnNwbGljZShsLDEpO3ZhciB1PXB5TGlzdFJlcGVhdCgxLG8pO3VbbF09YVtsXTt2YXIgYz1zLnNsaWNlKCk7Yy5zb3J0KCk7dmFyIHA9IXV0aWwuYXJyYXlzRXF1YWwoYyxyYW5nZSgwLG8pLnNsaWNlKDAsby0xKSk7aWYoIXIpcmV0dXJuIGZ1bmN0aW9uKCl7aWYocCl7dmFyIGU9bi5tb3ZpbmdNZWFuLnJlYWQoKS5yZXNoYXBlKHUpLHQ9bi5tb3ZpbmdWYXJpYW5jZS5yZWFkKCkucmVzaGFwZSh1KSxyPW4uY2VudGVyP24uYmV0YS5yZWFkKCkucmVzaGFwZSh1KTpudWxsLGE9bi5zY2FsZT9uLmdhbW1hLnJlYWQoKS5yZXNoYXBlKHUpOm51bGw7cmV0dXJuIGJhdGNoTm9ybWFsaXphdGlvbihpLGUsdCxyLGEsbi5lcHNpbG9uKX1yZXR1cm4gYmF0Y2hOb3JtYWxpemF0aW9uKGksbi5tb3ZpbmdNZWFuLnJlYWQoKSxuLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKSxudWxsPT1uLmJldGE/bnVsbDpuLmJldGEucmVhZCgpLG51bGw9PW4uZ2FtbWE/bnVsbDpuLmdhbW1hLnJlYWQoKSxuLmVwc2lsb24pfSgpO3ZhciBoPW5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhpLG4uZ2FtbWEucmVhZCgpLG4uYmV0YS5yZWFkKCkscyxuLmVwc2lsb24pLGQ9aFswXSxmPWhbMV0sZz1oWzJdLG09ZnVuY3Rpb24oZSx0LG4pe3RpZHkoZnVuY3Rpb24oKXt2YXIgcj0xLW4saT1lLnJlYWQoKSxhPWkuc3ViKHQpLm11bChyKTtlLndyaXRlKGkuc3ViKGEpKX0pfTtyZXR1cm4gbShuLm1vdmluZ01lYW4sZixuLm1vbWVudHVtKSxtKG4ubW92aW5nVmFyaWFuY2UsZyxuLm1vbWVudHVtKSxkfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtheGlzOnRoaXMuYXhpcyxtb21lbnR1bTp0aGlzLm1vbWVudHVtLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcjp0aGlzLmNlbnRlcixzY2FsZTp0aGlzLnNjYWxlLGJldGFJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJldGFJbml0aWFsaXplciksZ2FtbWFJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmdhbW1hSW5pdGlhbGl6ZXIpLG1vdmluZ01lYW5Jbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLm1vdmluZ01lYW5Jbml0aWFsaXplciksbW92aW5nVmFyaWFuY2VJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIpLGJldGFSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJldGFSZWd1bGFyaXplciksZ2FtbWFSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmdhbW1hUmVndWxhcml6ZXIpLGJldGFDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iZXRhQ29uc3RyYWludCksZ2FtbWFDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5nYW1tYUNvbnN0cmFpbnQpfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJCYXRjaE5vcm1hbGl6YXRpb25cIix0fShMYXllcik7ZnVuY3Rpb24gc3BhdGlhbDJkUGFkZGluZyhlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZig0IT09ZS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwidGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIDQtRCwgYnV0IHJlY2VpdmVkIGEgXCIrZS5yYW5rK1wiLUQgdGVuc29yLlwiKTtpZihudWxsPT10JiYodD1bWzEsMV0sWzEsMV1dKSwyIT09dC5sZW5ndGh8fDIhPT10WzBdLmxlbmd0aHx8MiE9PXRbMV0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwic3BhdGlhbDJkUGFkZGluZyBleHBlY3RzIGBwYWRkaW5nYCB0byBiZSBhbiBBcnJheSBvZiB0d28gQXJyYXlzLCBlYWNoIG9mIHdoaWNoIGlzIGFuIEFycmF5IG9mIHR3byBpbnRlZ2Vycy5cIik7aWYobnVsbD09biYmKG49aW1hZ2VEYXRhRm9ybWF0KCkpLFwiY2hhbm5lbHNMYXN0XCIhPT1uJiZcImNoYW5uZWxzRmlyc3RcIiE9PW4pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIGRhdGEgZm9ybWF0OiBcIituK1wiLiBTdXBwb3J0ZWQgZGF0YSBmb3JtYXRzIGFyZSAnY2hhbm5lbHNMYXN0JyBhbmQgJ2NoYW5uZWxzRmlyc3QuXCIpO3ZhciByO3JldHVybiByPVwiY2hhbm5lbHNGaXJzdFwiPT09bj9bWzAsMF0sWzAsMF0sdFswXSx0WzFdXTpbWzAsMF0sdFswXSx0WzFdLFswLDBdXSxwYWQoZSxyKX0pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhCYXRjaE5vcm1hbGl6YXRpb24pO3ZhciBaZXJvUGFkZGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztpZihudWxsPT10JiYodD17fSksKG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMpLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P2ltYWdlRGF0YUZvcm1hdCgpOnQuZGF0YUZvcm1hdCxudWxsPT10LnBhZGRpbmcpbi5wYWRkaW5nPVtbMSwxXSxbMSwxXV07ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgdC5wYWRkaW5nKW4ucGFkZGluZz1bW3QucGFkZGluZyx0LnBhZGRpbmddLFt0LnBhZGRpbmcsdC5wYWRkaW5nXV07ZWxzZXtpZih0LnBhZGRpbmc9dC5wYWRkaW5nLDIhPT10LnBhZGRpbmcubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLVwiK3QucGFkZGluZy5sZW5ndGgrXCIgYXJyYXkuXCIpO3ZhciByPXZvaWQgMCxpPXZvaWQgMDtpZihcIm51bWJlclwiPT10eXBlb2YgdC5wYWRkaW5nWzBdKXI9W3QucGFkZGluZ1swXSx0LnBhZGRpbmdbMF1dLGk9W3QucGFkZGluZ1sxXSx0LnBhZGRpbmdbMV1dO2Vsc2V7aWYodC5wYWRkaW5nPXQucGFkZGluZywyIT09dC5wYWRkaW5nWzBdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyBoZWlnaHQgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIrdC5wYWRkaW5nWzBdLmxlbmd0aCtcIiBhcnJheS5cIik7aWYocj10LnBhZGRpbmdbMF0sMiE9PXQucGFkZGluZ1sxXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgd2lkdGggcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIrdC5wYWRkaW5nWzFdLmxlbmd0aCtcIiBhcnJheS5cIik7aT10LnBhZGRpbmdbMV19bi5wYWRkaW5nPVtyLGldfXJldHVybiBuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdCxuO3JldHVybiBlPWdldEV4YWN0bHlPbmVTaGFwZShlKSxcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8odD1udWxsIT1lWzJdJiZlWzJdPj0wP2VbMl0rdGhpcy5wYWRkaW5nWzBdWzBdK3RoaXMucGFkZGluZ1swXVsxXTpudWxsLG49bnVsbCE9ZVszXSYmZVszXT49MD9lWzNdK3RoaXMucGFkZGluZ1sxXVswXSt0aGlzLnBhZGRpbmdbMV1bMV06bnVsbCxbZVswXSxlWzFdLHQsbl0pOih0PW51bGwhPWVbMV0mJmVbMV0+PTA/ZVsxXSt0aGlzLnBhZGRpbmdbMF1bMF0rdGhpcy5wYWRkaW5nWzBdWzFdOm51bGwsbj1udWxsIT1lWzJdJiZlWzJdPj0wP2VbMl0rdGhpcy5wYWRkaW5nWzFdWzBdK3RoaXMucGFkZGluZ1sxXVsxXTpudWxsLFtlWzBdLHQsbixlWzNdXSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHNwYXRpYWwyZFBhZGRpbmcoZ2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0KX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cGFkZGluZzp0aGlzLnBhZGRpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlplcm9QYWRkaW5nMkRcIix0fShMYXllcik7ZnVuY3Rpb24gcG9vbDJkKGUsdCxuLHIsaSxhKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBvO2NoZWNrRGF0YUZvcm1hdChpKSxjaGVja1Bvb2xNb2RlKGEpLGNoZWNrUGFkZGluZ01vZGUociksbnVsbD09biYmKG49WzEsMV0pLG51bGw9PXImJihyPVwidmFsaWRcIiksbnVsbD09aSYmKGk9aW1hZ2VEYXRhRm9ybWF0KCkpLG51bGw9PWEmJihhPVwibWF4XCIpLGU9cHJlcHJvY2Vzc0NvbnYyRElucHV0KGUsaSk7dmFyIHM9XCJzYW1lXCI9PT1yP1wic2FtZVwiOlwidmFsaWRcIjtyZXR1cm4gbz1cIm1heFwiPT09YT9tYXhQb29sKGUsdCxuLHMpOmF2Z1Bvb2woZSx0LG4scyksXCJjaGFubmVsc0ZpcnN0XCI9PT1pJiYobz10cmFuc3Bvc2UobyxbMCwzLDEsMl0pKSxvfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFplcm9QYWRkaW5nMkQpO3ZhciBQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj10aGlzO2lmKG51bGw9PXQucG9vbFNpemUmJih0LnBvb2xTaXplPTIpLG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMsXCJudW1iZXJcIj09dHlwZW9mIHQucG9vbFNpemUpbi5wb29sU2l6ZT1bdC5wb29sU2l6ZV07ZWxzZXtpZighQXJyYXkuaXNBcnJheSh0LnBvb2xTaXplKXx8MSE9PXQucG9vbFNpemUubGVuZ3RofHxcIm51bWJlclwiIT10eXBlb2YgdC5wb29sU2l6ZVswXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInBvb2xTaXplIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodC5wb29sU2l6ZSkpO24ucG9vbFNpemU9dC5wb29sU2l6ZX1pZihhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5wb29sU2l6ZSxcInBvb2xTaXplXCIpLG51bGw9PXQuc3RyaWRlcyluLnN0cmlkZXM9bi5wb29sU2l6ZTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnN0cmlkZXMpbi5zdHJpZGVzPVt0LnN0cmlkZXNdO2Vsc2V7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpZGVzKXx8MSE9PXQuc3RyaWRlcy5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiB0LnN0cmlkZXNbMF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzdHJpZGVzIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodC5zdHJpZGVzKSk7bi5zdHJpZGVzPXQuc3RyaWRlc31yZXR1cm4gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4uc3RyaWRlcyxcInN0cmlkZXNcIiksbi5wYWRkaW5nPW51bGw9PXQucGFkZGluZz9cInZhbGlkXCI6dC5wYWRkaW5nLGNoZWNrUGFkZGluZ01vZGUobi5wYWRkaW5nKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTozfSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1jb252T3V0cHV0TGVuZ3RoKChlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbMV0sdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKTtyZXR1cm5bZVswXSx0LGVbMl1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KSxlPWV4cGFuZERpbXMkMShnZXRFeGFjdGx5T25lVGVuc29yKGUpLDIpO3ZhciByPW4ucG9vbGluZ0Z1bmN0aW9uKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksW24ucG9vbFNpemVbMF0sMV0sW24uc3RyaWRlc1swXSwxXSxuLnBhZGRpbmcsXCJjaGFubmVsc0xhc3RcIik7cmV0dXJuIHNxdWVlemUocixbMl0pfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtwb29sU2l6ZTp0aGlzLnBvb2xTaXplLHBhZGRpbmc6dGhpcy5wYWRkaW5nLHN0cmlkZXM6dGhpcy5zdHJpZGVzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdH0oTGF5ZXIpLE1heFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChpKSxjaGVja1BhZGRpbmdNb2RlKHIpLHBvb2wyZChlLHQsbixyLGksXCJtYXhcIil9LHQuY2xhc3NOYW1lPVwiTWF4UG9vbGluZzFEXCIsdH0oUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4UG9vbGluZzFEKTt2YXIgQXZlcmFnZVBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChpKSxjaGVja1BhZGRpbmdNb2RlKHIpLHBvb2wyZChlLHQsbixyLGksXCJhdmdcIil9LHQuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmcxRFwiLHR9KFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2VQb29saW5nMUQpO3ZhciBQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj10aGlzO2lmKG51bGw9PXQucG9vbFNpemUmJih0LnBvb2xTaXplPVsyLDJdKSwobj1lLmNhbGwodGhpcyx0KXx8dGhpcykucG9vbFNpemU9QXJyYXkuaXNBcnJheSh0LnBvb2xTaXplKT90LnBvb2xTaXplOlt0LnBvb2xTaXplLHQucG9vbFNpemVdLG51bGw9PXQuc3RyaWRlcyluLnN0cmlkZXM9bi5wb29sU2l6ZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkodC5zdHJpZGVzKSl7aWYoMiE9PXQuc3RyaWRlcy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZiB0aGUgc3RyaWRlcyBwcm9wZXJ0eSBvZiBhIDJEIHBvb2xpbmcgbGF5ZXIgaXMgYW4gQXJyYXksIGl0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBsZW5ndGggb2YgMiwgYnV0IHJlY2VpdmVkIGxlbmd0aCBcIit0LnN0cmlkZXMubGVuZ3RoK1wiLlwiKTtuLnN0cmlkZXM9dC5zdHJpZGVzfWVsc2Ugbi5zdHJpZGVzPVt0LnN0cmlkZXMsdC5zdHJpZGVzXTtyZXR1cm4gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4ucG9vbFNpemUsXCJwb29sU2l6ZVwiKSxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5zdHJpZGVzLFwic3RyaWRlc1wiKSxuLnBhZGRpbmc9bnVsbD09dC5wYWRkaW5nP1widmFsaWRcIjp0LnBhZGRpbmcsbi5kYXRhRm9ybWF0PW51bGw9PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxjaGVja0RhdGFGb3JtYXQobi5kYXRhRm9ybWF0KSxjaGVja1BhZGRpbmdNb2RlKG4ucGFkZGluZyksbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7dmFyIHQ9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZVsyXTplWzFdLG49XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZVszXTplWzJdO3JldHVybiB0PWNvbnZPdXRwdXRMZW5ndGgodCx0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pLG49Y29udk91dHB1dExlbmd0aChuLHRoaXMucG9vbFNpemVbMV0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1sxXSksXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2VbMF0sZVsxXSx0LG5dOltlWzBdLHQsbixlWzNdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbi5pbnZva2VDYWxsSG9vayhlLHQpLG4ucG9vbGluZ0Z1bmN0aW9uKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksbi5wb29sU2l6ZSxuLnN0cmlkZXMsbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXMsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0fShMYXllciksTWF4UG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4scixpKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUGFkZGluZ01vZGUocikscG9vbDJkKGUsdCxuLHIsaSxcIm1heFwiKX0sdC5jbGFzc05hbWU9XCJNYXhQb29saW5nMkRcIix0fShQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhQb29saW5nMkQpO3ZhciBBdmVyYWdlUG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4scixpKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUGFkZGluZ01vZGUocikscG9vbDJkKGUsdCxuLHIsaSxcImF2Z1wiKX0sdC5jbGFzc05hbWU9XCJBdmVyYWdlUG9vbGluZzJEXCIsdH0oUG9vbGluZzJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQXZlcmFnZVBvb2xpbmcyRCk7dmFyIEdsb2JhbFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTozfSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm5bZVswXSxlWzJdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yfSx0fShMYXllciksR2xvYmFsQXZlcmFnZVBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0fHx7fSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIG1lYW4odCwxKX0pfSx0LmNsYXNzTmFtZT1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMURcIix0fShHbG9iYWxQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxBdmVyYWdlUG9vbGluZzFEKTt2YXIgR2xvYmFsTWF4UG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHR8fHt9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbWF4KHQsMSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxNYXhQb29saW5nMURcIix0fShHbG9iYWxQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxNYXhQb29saW5nMUQpO3ZhciBHbG9iYWxQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5kYXRhRm9ybWF0PW51bGw9PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxjaGVja0RhdGFGb3JtYXQobi5kYXRhRm9ybWF0KSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLFwiY2hhbm5lbHNMYXN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2VbMF0sZVszXV06W2VbMF0sZVsxXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2RhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdH0oTGF5ZXIpLEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0P21lYW4odCxbMSwyXSk6bWVhbih0LFsyLDNdKX0pfSx0LmNsYXNzTmFtZT1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMkRcIix0fShHbG9iYWxQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxBdmVyYWdlUG9vbGluZzJEKTt2YXIgR2xvYmFsTWF4UG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdD9tYXgodCxbMSwyXSk6bWF4KHQsWzIsM10pfSl9LHQuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzJEXCIsdH0oR2xvYmFsUG9vbGluZzJEKTtmdW5jdGlvbiBzdGFuZGFyZGl6ZUFyZ3MoZSx0LG4scil7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYobnVsbCE9dHx8bnVsbCE9bil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldoZW4gaW5wdXRzIGlzIGFuIGFycmF5LCBuZWl0aGVyIGluaXRpYWxTdGF0ZSBvciBjb25zdGFudHMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO251bGwhPXImJihuPWUuc2xpY2UoZS5sZW5ndGgtcixlLmxlbmd0aCksZT1lLnNsaWNlKDAsZS5sZW5ndGgtcikpLGUubGVuZ3RoPjEmJih0PWUuc2xpY2UoMSxlLmxlbmd0aCkpLGU9ZVswXX1mdW5jdGlvbiBpKGUpe3JldHVybiBudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpP2U6W2VdfXJldHVybntpbnB1dHM6ZSxpbml0aWFsU3RhdGU6dD1pKHQpLGNvbnN0YW50czpuPWkobil9fWZ1bmN0aW9uIHJubihlLHQsbixyLGksYSxvLHMpe3JldHVybiB2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09byYmKG89ITEpLHZvaWQgMD09PXMmJihzPSExKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIGw9dC5zaGFwZS5sZW5ndGg7aWYobDwzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgc2hvdWxkIGJlIGF0IGxlYXN0IDNELCBidXQgaXMgXCIrbCtcIkQuXCIpO3ZhciB1PVsxLDBdLmNvbmNhdChyYW5nZSgyLGwpKTtpZih0PXRyYW5zcG9zZSh0LHUpLG51bGwhPWEpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgcm5uKCkgZnVuY3RvaW4gb2YgdGhlIGRlZXBsZWFybi5qcyBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgY29uc3RhbnRzIHlldC5cIik7byYmY29uc29sZS53YXJuKFwiQmFja2VuZCBybm4oKTogdGhlIHVucm9sbCA9IHRydWUgb3B0aW9uIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSBpbXBlcmF0aXZlIGRlZXBsZWFybi5qcyBiYWNrZW5kLlwiKSxudWxsIT1pJiYoKGk9aS5hc1R5cGUoXCJib29sXCIpLmFzVHlwZShcImZsb2F0MzJcIikpLnJhbms9PT1sLTEmJihpPWV4cGFuZERpbXMoaSwtMSkpLGk9dHJhbnNwb3NlKGksdSkpLHImJih0PXJldmVyc2UodCwwKSxudWxsIT1pJiYoaT1yZXZlcnNlKGksMCkpKTt2YXIgYyxwLGg9W10sZD1uLGY9dC5zaGFwZVswXSxnPXVuc3RhY2sodCk7bnVsbCE9aSYmKHA9dW5zdGFjayhpKSk7Zm9yKHZhciBtLHk9ZnVuY3Rpb24odCl7dmFyIG49Z1t0XSxyPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZShuLGQpfSk7aWYobnVsbD09aSljPXJbMF0sZD1yWzFdO2Vsc2V7dmFyIGE9dGlkeShmdW5jdGlvbigpe3ZhciBlPXBbdF0sbj1vbmVzTGlrZShlKS5zdWIoZSk7cmV0dXJue291dHB1dDpyWzBdLm11bChlKS5hZGRTdHJpY3QoZFswXS5tdWwobikpLG5ld1N0YXRlczpkLm1hcChmdW5jdGlvbih0LGkpe3JldHVybiByWzFdW2ldLm11bChlKS5hZGRTdHJpY3QodC5tdWwobikpfSl9fSk7Yz1hLm91dHB1dCxkPWEubmV3U3RhdGVzfXMmJmgucHVzaChjKX0sdj0wO3Y8ZjsrK3YpeSh2KTtpZihzKXttPXN0YWNrKGgsMSl9cmV0dXJuW2MsbSxkXX0pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxNYXhQb29saW5nMkQpO3ZhciBSTk49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbixyPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG51bGw9PXQuY2VsbCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNlbGwgcHJvcGVydHkgaXMgbWlzc2luZyBmb3IgdGhlIGNvbnN0cnVjdG9yIG9mIFJOTi5cIik7aWYobnVsbD09KG49QXJyYXkuaXNBcnJheSh0LmNlbGwpP25ldyBTdGFja2VkUk5OQ2VsbHMoe2NlbGxzOnQuY2VsbH0pOnQuY2VsbCkuc3RhdGVTaXplKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIFJOTiBjZWxsIHNob3VsZCBoYXZlIGFuIGF0dHJpYnV0ZSBgc3RhdGVTaXplYCAodHVwbGUgb2YgaW50ZWdlcnMsIG9uZSBpbnRlZ2VyIHBlciBSTk4gc3RhdGUpLlwiKTtyZXR1cm4gci5jZWxsPW4sci5yZXR1cm5TZXF1ZW5jZXM9bnVsbCE9dC5yZXR1cm5TZXF1ZW5jZXMmJnQucmV0dXJuU2VxdWVuY2VzLHIucmV0dXJuU3RhdGU9bnVsbCE9dC5yZXR1cm5TdGF0ZSYmdC5yZXR1cm5TdGF0ZSxyLmdvQmFja3dhcmRzPW51bGwhPXQuZ29CYWNrd2FyZHMmJnQuZ29CYWNrd2FyZHMsci5fc3RhdGVmdWw9bnVsbCE9dC5zdGF0ZWZ1bCYmdC5zdGF0ZWZ1bCxyLnVucm9sbD1udWxsIT10LnVucm9sbCYmdC51bnJvbGwsci5zdXBwb3J0c01hc2tpbmc9ITAsci5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06M30pXSxyLnN0YXRlU3BlYz1udWxsLHIuc3RhdGVzXz1udWxsLHIubnVtQ29uc3RhbnRzPW51bGwsci5rZXB0U3RhdGVzPVtdLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldFN0YXRlcz1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLnN0YXRlc18/cmFuZ2UoMCxBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjEpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbH0pOnRoaXMuc3RhdGVzX30sdC5wcm90b3R5cGUuc2V0U3RhdGVzPWZ1bmN0aW9uKGUpe3RoaXMuc3RhdGVzXz1lfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aXNBcnJheU9mU2hhcGVzKGUpJiYoZT1lWzBdKSxlPWU7dmFyIHQ9dGhpcy5jZWxsLnN0YXRlU2l6ZTtBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pO3ZhciBuLHI9dFswXTtpZihuPXRoaXMucmV0dXJuU2VxdWVuY2VzP1tlWzBdLGVbMV0scl06W2VbMF0scl0sdGhpcy5yZXR1cm5TdGF0ZSl7Zm9yKHZhciBpPVtdLGE9MCxvPXQ7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07aS5wdXNoKFtlWzBdLHNdKX1yZXR1cm5bbl0uY29uY2F0KGkpfXJldHVybiBufSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtBcnJheS5pc0FycmF5KHQpJiYodD10WzBdKTt2YXIgZT1uLnJldHVyblNlcXVlbmNlcz90Om51bGw7aWYobi5yZXR1cm5TdGF0ZSl7dmFyIHI9bi5zdGF0ZXMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSk7cmV0dXJuW2VdLmNvbmNhdChyKX1yZXR1cm4gZX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdGF0ZXNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5zdGF0ZXNfKXtmb3IodmFyIGU9QXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplLmxlbmd0aDoxLHQ9W10sbj0wO248ZTsrK24pdC5wdXNoKG51bGwpO3JldHVybiB0fXJldHVybiB0aGlzLnN0YXRlc199LHNldDpmdW5jdGlvbihlKXt0aGlzLnN0YXRlc189ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZihudWxsIT10aGlzLm51bUNvbnN0YW50cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LlwiKTtpc0FycmF5T2ZTaGFwZXMoZSkmJihlPWVbMF0pLGU9ZTt2YXIgdD10aGlzLnN0YXRlZnVsP2VbMF06bnVsbCxuPWVbZS5sZW5ndGgtMV07dGhpcy5pbnB1dFNwZWNbMF09bmV3IElucHV0U3BlYyh7c2hhcGU6W3QsbnVsbCxuXX0pO3ZhciByLGk9W2VbMF1dLmNvbmNhdChlLnNsaWNlKDIpKTtpZih0aGlzLmNlbGwuYnVpbGQoaSkscj1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemU6W3RoaXMuY2VsbC5zdGF0ZVNpemVdLG51bGwhPXRoaXMuc3RhdGVTcGVjKXtpZighdXRpbC5hcnJheXNFcXVhbCh0aGlzLnN0YXRlU3BlYy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV19KSxyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFuIGluaXRpYWxTdGF0ZSB3YXMgcGFzc2VkIHRoYXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBjZWxsLnN0YXRlU2l6ZS4gUmVjZWl2ZWQgc3RhdGVTcGVjPVwiK3RoaXMuc3RhdGVTcGVjK1wiOyBIb3dldmVyIGNlbGwuc3RhdGVTaXplIGlzIFwiK3RoaXMuY2VsbC5zdGF0ZVNpemUpfWVsc2UgdGhpcy5zdGF0ZVNwZWM9ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBJbnB1dFNwZWMoe3NoYXBlOltudWxsLGVdfSl9KTt0aGlzLnN0YXRlZnVsJiZ0aGlzLnJlc2V0U3RhdGVzKCl9LHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpczt2b2lkIDA9PT10JiYodD0hMSksdGlkeShmdW5jdGlvbigpe2lmKCFuLnN0YXRlZnVsKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkNhbm5vdCBjYWxsIHJlc2V0U3RhdGVzKCkgb24gYW4gUk5OIExheWVyIHRoYXQgaXMgbm90IHN0YXRlZnVsLlwiKTt2YXIgcj1uLmlucHV0U3BlY1swXS5zaGFwZVswXTtpZihudWxsPT1yKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgYW4gUk5OIGlzIHN0YXRlZnVsLCBpdCBuZWVkcyB0byBrbm93IGl0cyBiYXRjaCBzaXplLiBTcGVjaWZ5IHRoZSBiYXRjaCBzaXplIG9mIHlvdXIgaW5wdXQgdGVuc29yczogXFxuLSBJZiB1c2luZyBhIFNlcXVlbnRpYWwgbW9kZWwsIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaElucHV0U2hhcGVgIG9wdGlvbiB0byB5b3VyIGZpcnN0IGxheWVyLlxcbi0gSWYgdXNpbmcgdGhlIGZ1bmN0aW9uYWwgQVBJLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hTaGFwZWAgb3B0aW9uIHRvIHlvdXIgSW5wdXQgbGF5ZXIuXCIpO2lmKG51bGw9PW4uc3RhdGVzXylBcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uc3RhdGVzXz1uLmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gemVyb3MoW3IsZV0pfSk6bi5zdGF0ZXNfPVt6ZXJvcyhbcixuLmNlbGwuc3RhdGVTaXplXSldO2Vsc2UgaWYobnVsbD09ZSlkaXNwb3NlKG4uc3RhdGVzXyksbnVsbCE9bi5rZXB0U3RhdGVzJiYoZGlzcG9zZShuLmtlcHRTdGF0ZXMpLG4ua2VwdFN0YXRlcz1bXSksQXJyYXkuaXNBcnJheShuLmNlbGwuc3RhdGVTaXplKT9uLnN0YXRlc189bi5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHplcm9zKFtyLGVdKX0pOm4uc3RhdGVzX1swXT16ZXJvcyhbcixuLmNlbGwuc3RhdGVTaXplXSk7ZWxzZXtpZihBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGUubGVuZ3RoIT09bi5zdGF0ZXNfLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyIFwiK24ubmFtZStcIiBleHBlY3RzIFwiK24uc3RhdGVzXy5sZW5ndGgrXCIgc3RhdGUocyksIGJ1dCBpdCByZWNlaXZlZCBcIitlLmxlbmd0aCtcIiBzdGF0ZSB2YWx1ZShzKS4gSW5wdXQgcmVjZWl2ZWQ6IFwiK2UpOyEwPT09dD9uLmtlcHRTdGF0ZXMucHVzaChuLnN0YXRlc18uc2xpY2UoKSk6ZGlzcG9zZShuLnN0YXRlc18pO2Zvcih2YXIgaT0wO2k8bi5zdGF0ZXNfLmxlbmd0aDsrK2kpe3ZhciBhPWVbaV0sbz1BcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uY2VsbC5zdGF0ZVNpemVbaV06bi5jZWxsLnN0YXRlU2l6ZSxzPVtyLG9dO2lmKCF1dGlsLmFycmF5c0VxdWFsKGEuc2hhcGUscykpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJTdGF0ZSBcIitpK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK24ubmFtZStcIjogZXhwZWN0ZWQgc2hhcGU9XCIrcytcIiwgcmVjZWl2ZWQgc2hhcGU9XCIrYS5zaGFwZSk7bi5zdGF0ZXNfW2ldPWF9fW4uc3RhdGVzXz1uLnN0YXRlc18ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBrZWVwKGUuY2xvbmUoKSl9KX0pfSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0LG4pe3ZhciByPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZSxpPW51bGw9PW4/bnVsbDpuLmNvbnN0YW50cztudWxsPT1uJiYobj17fSk7dmFyIGE9c3RhbmRhcmRpemVBcmdzKHQscixpLHRoaXMubnVtQ29uc3RhbnRzKTt0PWEuaW5wdXRzLHI9YS5pbml0aWFsU3RhdGUsaT1hLmNvbnN0YW50czt2YXIgbz1bXSxzPVtdO2lmKG51bGwhPXIpe24uaW5pdGlhbFN0YXRlPXIsbz1vLmNvbmNhdChyKSx0aGlzLnN0YXRlU3BlYz1bXTtmb3IodmFyIGw9MCx1PXI7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPXVbbF07dGhpcy5zdGF0ZVNwZWMucHVzaChuZXcgSW5wdXRTcGVjKHtzaGFwZTpjLnNoYXBlfSkpfXM9cy5jb25jYXQodGhpcy5zdGF0ZVNwZWMpfWlmKG51bGwhPWkmJihuLmNvbnN0YW50cz1pLG89by5jb25jYXQoaSksdGhpcy5udW1Db25zdGFudHM9aS5sZW5ndGgpLG9bMF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXt2YXIgcD1bdF0uY29uY2F0KG8pLGg9dGhpcy5pbnB1dFNwZWMuY29uY2F0KHMpLGQ9dGhpcy5pbnB1dFNwZWM7dGhpcy5pbnB1dFNwZWM9aDt2YXIgZj1lLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMscCxuKTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9ZCxmfXJldHVybiBlLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsdCxuKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsPT10P251bGw6dC5tYXNrLGk9bnVsbD09dD9udWxsOnQudHJhaW5pbmcsYT1udWxsPT10P251bGw6dC5pbml0aWFsU3RhdGU7ZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLG51bGw9PWEmJihhPW4uc3RhdGVmdWw/bi5zdGF0ZXNfOm4uZ2V0SW5pdGlhbFN0YXRlKGUpKTt2YXIgbz1BcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjE7aWYoYS5sZW5ndGghPT1vKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUk5OIExheWVyIGhhcyBcIitvK1wiIHN0YXRlKHMpIGJ1dCB3YXMgcGFzc2VkIFwiK2EubGVuZ3RoK1wiIGluaXRpYWwgc3RhdGUocykuXCIpO24udW5yb2xsJiZjb25zb2xlLndhcm4oXCJJZ25vcmluZyB1bnJvbGwgPSB0cnVlIGZvciBSTk4gbGF5ZXIsIGR1ZSB0byBpbXBlcmF0aXZlIGJhY2tlbmQuXCIpO3ZhciBzPXt0cmFpbmluZzppfSxsPXJubihmdW5jdGlvbihlLHQpe3ZhciByPW4uY2VsbC5jYWxsKFtlXS5jb25jYXQodCkscyk7cmV0dXJuW3JbMF0sci5zbGljZSgxKV19LGUsYSxuLmdvQmFja3dhcmRzLHIsbnVsbCxuLnVucm9sbCxuLnJldHVyblNlcXVlbmNlcyksdT1sWzBdLGM9bFsxXSxwPWxbMl07bi5zdGF0ZWZ1bCYmbi5yZXNldFN0YXRlcyhwLGkpO3ZhciBoPW4ucmV0dXJuU2VxdWVuY2VzP2M6dTtyZXR1cm4gbi5yZXR1cm5TdGF0ZT9baF0uY29uY2F0KHApOmh9KX0sdC5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj16ZXJvcyhlLnNoYXBlKTtyZXR1cm4gbj1leHBhbmREaW1zJDEobj1zdW0obixbMSwyXSkpLEFycmF5LmlzQXJyYXkodC5jZWxsLnN0YXRlU2l6ZSk/dC5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGU+MT90aWxlJDEobixbMSxlXSk6bn0pOnQuY2VsbC5zdGF0ZVNpemU+MT9bdGlsZSQxKG4sWzEsdC5jZWxsLnN0YXRlU2l6ZV0pXTpbbl19KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5jZWxsLnRyYWluYWJsZVdlaWdodHM6W119LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5jZWxsLm5vblRyYWluYWJsZVdlaWdodHM6dGhpcy5jZWxsLndlaWdodHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1mdW5jdGlvbih0KXtlLnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkLmNhbGwodGhpcyx0KSxudWxsIT10aGlzLmNlbGwmJnRoaXMuY2VsbC5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cmV0dXJuU2VxdWVuY2VzOnRoaXMucmV0dXJuU2VxdWVuY2VzLHJldHVyblN0YXRlOnRoaXMucmV0dXJuU3RhdGUsZ29CYWNrd2FyZHM6dGhpcy5nb0JhY2t3YXJkcyxzdGF0ZWZ1bDp0aGlzLnN0YXRlZnVsLHVucm9sbDp0aGlzLnVucm9sbH07bnVsbCE9dGhpcy5udW1Db25zdGFudHMmJih0Lm51bUNvbnN0YW50cz10aGlzLm51bUNvbnN0YW50cyk7dmFyIG49dGhpcy5jZWxsLmdldENvbmZpZygpO3QuY2VsbD17Y2xhc3NOYW1lOnRoaXMuY2VsbC5nZXRDbGFzc05hbWUoKSxjb25maWc6bn07dmFyIHI9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxyKSx0fSx0LmNsYXNzTmFtZT1cIlJOTlwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUk5OKTt2YXIgUk5OQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oTGF5ZXIpLFNpbXBsZVJOTkNlbGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsbi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVI9XCJvcnRob2dvbmFsXCIsbi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG4udW5pdHM9dC51bml0cyxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi51bml0cyxcInVuaXRzXCIpLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKG51bGw9PXQuYWN0aXZhdGlvbj9uLkRFRkFVTFRfQUNUSVZBVElPTjp0LmFjdGl2YXRpb24pLG4udXNlQmlhcz1udWxsPT10LnVzZUJpYXN8fHQudXNlQmlhcyxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4ucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5yZWN1cnJlbnRJbml0aWFsaXplcnx8bi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4ucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5yZWN1cnJlbnRSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5yZWN1cnJlbnRDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQuZHJvcG91dD8wOnQuZHJvcG91dF0pXSksbi5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQucmVjdXJyZW50RHJvcG91dD8wOnQucmVjdXJyZW50RHJvcG91dF0pXSksbi5zdGF0ZVNpemU9bi51bml0cyxuLmRyb3BvdXRNYXNrPW51bGwsbi5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpLHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW2VbZS5sZW5ndGgtMV0sdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyx0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09KGU9ZSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2ltcGxlUk5OQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycywgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgcj1lWzFdO2U9ZVswXTt2YXIgaSxhPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmc7MDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsYSkpLDA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmbnVsbD09bi5yZWN1cnJlbnREcm9wb3V0TWFzayYmKG4ucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShyKX0sbi5yZWN1cnJlbnREcm9wb3V0LGEpKTt2YXIgbz1uLmRyb3BvdXRNYXNrLHM9bi5yZWN1cnJlbnREcm9wb3V0TWFzaztpPWRvdChudWxsIT1vP211bChlLG8pOmUsbi5rZXJuZWwucmVhZCgpKSxudWxsIT1uLmJpYXMmJihpPWJpYXNBZGQoaSxuLmJpYXMucmVhZCgpKSksbnVsbCE9cyYmKHI9bXVsKHIscykpO3ZhciBsPWFkZChpLGRvdChyLG4ucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO3JldHVybiBudWxsIT1uLmFjdGl2YXRpb24mJihsPW4uYWN0aXZhdGlvbi5hcHBseShsKSksW2wsbF19KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJTaW1wbGVSTk5DZWxsXCIsdH0oUk5OQ2VsbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpbXBsZVJOTkNlbGwpO3ZhciBTaW1wbGVSTk49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gdC5jZWxsPW5ldyBTaW1wbGVSTk5DZWxsKHQpLGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPXIuY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLmRyb3BvdXRNYXNrKSxyLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9ci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgaT1udWxsPT1uP251bGw6bi5tYXNrLGE9bnVsbD09bj9udWxsOm4udHJhaW5pbmcsbz1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGU7cmV0dXJuIGUucHJvdG90eXBlLmNhbGwuY2FsbChyLHQse21hc2s6aSx0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpvfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBuLmNlbGwsT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiU2ltcGxlUk5OXCIsdH0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2ltcGxlUk5OKTt2YXIgR1JVQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixuLnVuaXRzPXQudW5pdHMsYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4udW5pdHMsXCJ1bml0c1wiKSxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih2b2lkIDA9PT10LmFjdGl2YXRpb24/bi5ERUZBVUxUX0FDVElWQVRJT046dC5hY3RpdmF0aW9uKSxuLnJlY3VycmVudEFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih2b2lkIDA9PT10LnJlY3VycmVudEFjdGl2YXRpb24/bi5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OOnQucmVjdXJyZW50QWN0aXZhdGlvbiksbi51c2VCaWFzPW51bGw9PXQudXNlQmlhc3x8dC51c2VCaWFzLG4ua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5rZXJuZWxJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5yZWN1cnJlbnRJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LnJlY3VycmVudEluaXRpYWxpemVyfHxuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSxuLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJpYXNJbml0aWFsaXplcnx8bi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLG4ua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5rZXJuZWxSZWd1bGFyaXplciksbi5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LnJlY3VycmVudFJlZ3VsYXJpemVyKSxuLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJpYXNSZWd1bGFyaXplciksbi5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5rZXJuZWxDb25zdHJhaW50KSxuLnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LnJlY3VycmVudENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5kcm9wb3V0PzA6dC5kcm9wb3V0XSldKSxuLnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0PzA6dC5yZWN1cnJlbnREcm9wb3V0XSldKSxuLmltcGxlbWVudGF0aW9uPXQuaW1wbGVtZW50YXRpb24sbi5zdGF0ZVNpemU9bi51bml0cyxuLmRyb3BvdXRNYXNrPW51bGwsbi5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbZS5sZW5ndGgtMV07dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbdCwzKnRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsMyp0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsWzMqdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT0oZT1lKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJHUlVDZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgXCIrZS5sZW5ndGgrXCIuXCIpO3ZhciByPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmcsaT1lWzFdO2U9ZVswXSwwPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJm51bGw9PW4uZHJvcG91dE1hc2smJihuLmRyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2UoZSl9LG4uZHJvcG91dCxyLDMpKSwwPG4ucmVjdXJyZW50RHJvcG91dCYmbi5yZWN1cnJlbnREcm9wb3V0PDEmJm51bGw9PW4ucmVjdXJyZW50RHJvcG91dE1hc2smJihuLnJlY3VycmVudERyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2UoaSl9LG4ucmVjdXJyZW50RHJvcG91dCxyLDMpKTt2YXIgYSxvLHMsbD1uLmRyb3BvdXRNYXNrLHU9bi5yZWN1cnJlbnREcm9wb3V0TWFzazswPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJihlPW11bChlLGxbMF0pKTt2YXIgYz1kb3QoZSxuLmtlcm5lbC5yZWFkKCkpO24udXNlQmlhcyYmKGM9Ymlhc0FkZChjLG4uYmlhcy5yZWFkKCkpKSwwPG4ucmVjdXJyZW50RHJvcG91dCYmbi5yZWN1cnJlbnREcm9wb3V0PDEmJihpPW11bChpLHVbMF0pKTt2YXIgcD1uLnJlY3VycmVudEtlcm5lbC5yZWFkKCksaD1zcGxpdChwLFsyKm4udW5pdHMsbi51bml0c10scC5yYW5rLTEpLGQ9aFswXSxmPWhbMV0sZz1kb3QoaSxkKSxtPXNwbGl0KGMsMyxjLnJhbmstMSkseT1tWzBdLHY9bVsxXSxiPW1bMl0sdz1zcGxpdChnLDIsZy5yYW5rLTEpLHo9d1swXSxTPXdbMV07YT1uLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoYWRkKHkseikpLG89bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGFkZCh2LFMpKTt2YXIgST1kb3QobXVsKG8saSksZik7cz1uLmFjdGl2YXRpb24uYXBwbHkoYWRkKGIsSSkpO3ZhciBBPWFkZChtdWwoYSxpKSxtdWwoYWRkKDEsbmVnKGEpKSxzKSk7cmV0dXJuW0EsQV19KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkdSVUNlbGxcIix0fShSTk5DZWxsKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1JVQ2VsbCk7dmFyIEdSVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiAwPT09dC5pbXBsZW1lbnRhdGlvbiYmY29uc29sZS53YXJuKFwiYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC5cIiksdC5jZWxsPW5ldyBHUlVDZWxsKHQpLGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPXIuY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLmRyb3BvdXRNYXNrKSxyLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9ci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgaT1udWxsPT1uP251bGw6bi5tYXNrLGE9bnVsbD09bj9udWxsOm4udHJhaW5pbmcsbz1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGU7cmV0dXJuIGUucHJvdG90eXBlLmNhbGwuY2FsbChyLHQse21hc2s6aSx0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpvfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRBY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50QWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbXBsZW1lbnRhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmltcGxlbWVudGF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgbi5jZWxsLE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQuaW1wbG1lbnRhdGlvbiYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9LHQuY2xhc3NOYW1lPVwiR1JVXCIsdH0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1JVKTt2YXIgTFNUTUNlbGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIixuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbi51bml0cz10LnVuaXRzLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnVuaXRzLFwidW5pdHNcIiksbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5hY3RpdmF0aW9uP24uREVGQVVMVF9BQ1RJVkFUSU9OOnQuYWN0aXZhdGlvbiksbi5yZWN1cnJlbnRBY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5yZWN1cnJlbnRBY3RpdmF0aW9uP24uREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjp0LnJlY3VycmVudEFjdGl2YXRpb24pLG4udXNlQmlhcz1udWxsPT10LnVzZUJpYXN8fHQudXNlQmlhcyxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4ucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5yZWN1cnJlbnRJbml0aWFsaXplcnx8bi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLnVuaXRGb3JnZXRCaWFzPXQudW5pdEZvcmdldEJpYXMsbi5rZXJuZWxSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0Lmtlcm5lbFJlZ3VsYXJpemVyKSxuLnJlY3VycmVudFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQucmVjdXJyZW50UmVndWxhcml6ZXIpLG4uYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmlhc1JlZ3VsYXJpemVyKSxuLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0Lmtlcm5lbENvbnN0cmFpbnQpLG4ucmVjdXJyZW50Q29uc3RyYWludD1nZXRDb25zdHJhaW50KHQucmVjdXJyZW50Q29uc3RyYWludCksbi5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYmlhc0NvbnN0cmFpbnQpLG4uZHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LmRyb3BvdXQ/MDp0LmRyb3BvdXRdKV0pLG4ucmVjdXJyZW50RHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LnJlY3VycmVudERyb3BvdXQ/MDp0LnJlY3VycmVudERyb3BvdXRdKV0pLG4uaW1wbGVtZW50YXRpb249dC5pbXBsZW1lbnRhdGlvbixuLnN0YXRlU2l6ZT1bbi51bml0cyxuLnVuaXRzXSxuLmRyb3BvdXRNYXNrPW51bGwsbi5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0LG4scj0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpW2UubGVuZ3RoLTFdO2lmKHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3IsNCp0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLDQqdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMpe2lmKHRoaXMudW5pdEZvcmdldEJpYXMpe3ZhciBpPXRoaXMuYmlhc0luaXRpYWxpemVyLGE9dGhpcy51bml0cztuPW5ldygodD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj1pLmFwcGx5KFthXSkscj0obmV3IE9uZXMpLmFwcGx5KFthXSksbz1pLmFwcGx5KFsyKmFdKTtyZXR1cm4gY29uY2F0QWxvbmdGaXJzdEF4aXMoY29uY2F0QWxvbmdGaXJzdEF4aXMobixyKSxvKX0sdH0oSW5pdGlhbGl6ZXIpKS5jbGFzc05hbWU9XCJDdXN0b21Jbml0XCIsdCl9ZWxzZSBuPXRoaXMuYmlhc0luaXRpYWxpemVyO3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbNCp0aGlzLnVuaXRzXSxudWxsLG4sdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCl9ZWxzZSB0aGlzLmJpYXM9bnVsbDt0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmc7aWYoMyE9PShlPWUpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxTVE1DZWxsIGV4cGVjdHMgMyBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgXCIrZS5sZW5ndGgrXCIuXCIpO3ZhciBpPWVbMV0sYT1lWzJdO2U9ZVswXSwwPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJm51bGw9PW4uZHJvcG91dE1hc2smJihuLmRyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2UoZSl9LG4uZHJvcG91dCxyLDQpKSwwPG4ucmVjdXJyZW50RHJvcG91dCYmbi5yZWN1cnJlbnREcm9wb3V0PDEmJm51bGw9PW4ucmVjdXJyZW50RHJvcG91dE1hc2smJihuLnJlY3VycmVudERyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2UoaSl9LG4ucmVjdXJyZW50RHJvcG91dCxyLDQpKTt2YXIgbyxzLGwsdSxjPW4uZHJvcG91dE1hc2sscD1uLnJlY3VycmVudERyb3BvdXRNYXNrOzA8bi5kcm9wb3V0JiZuLmRyb3BvdXQ8MSYmKGU9bXVsKGUsY1swXSkpO3ZhciBoPWRvdChlLG4ua2VybmVsLnJlYWQoKSk7MDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiYoaT1tdWwoaSxwWzBdKSksaD1hZGQoaCxkb3QoaSxuLnJlY3VycmVudEtlcm5lbC5yZWFkKCkpKSxuLnVzZUJpYXMmJihoPWJpYXNBZGQoaCxuLmJpYXMucmVhZCgpKSk7dmFyIGQ9c3BsaXQoaCw0LGgucmFuay0xKSxmPWRbMF0sZz1kWzFdLG09ZFsyXSx5PWRbM107bz1uLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoZikscz1uLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoZyksbD1hZGQobXVsKHMsYSksbXVsKG8sbi5hY3RpdmF0aW9uLmFwcGx5KG0pKSksdT1uLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoeSk7dmFyIHY9bXVsKHUsbi5hY3RpdmF0aW9uLmFwcGx5KGwpKTtyZXR1cm5bdix2LGxdfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksdW5pdEZvcmdldEJpYXM6dGhpcy51bml0Rm9yZ2V0QmlhcyxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkxTVE1DZWxsXCIsdH0oUk5OQ2VsbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE1DZWxsKTt2YXIgTFNUTT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiAwPT09dC5pbXBsZW1lbnRhdGlvbiYmY29uc29sZS53YXJuKFwiYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC5cIiksdC5jZWxsPW5ldyBMU1RNQ2VsbCh0KSxlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtudWxsIT1yLmNlbGwuZHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5kcm9wb3V0TWFzayksci5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLG51bGwhPXIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrKSxyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCk7dmFyIGk9bnVsbD09bj9udWxsOm4ubWFzayxhPW51bGw9PW4/bnVsbDpuLnRyYWluaW5nLG89bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlO3JldHVybiBlLnByb3RvdHlwZS5jYWxsLmNhbGwocix0LHttYXNrOmksdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6b30pfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVuaXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudW5pdHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYWN0aXZhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmFjdGl2YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50QWN0aXZhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEFjdGl2YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXNlQmlhc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVzZUJpYXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1bml0Rm9yZ2V0Qmlhc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRGb3JnZXRCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50UmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50Q29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0NvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuZHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnREcm9wb3V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbXBsZW1lbnRhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmltcGxlbWVudGF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksdW5pdEZvcmdldEJpYXM6dGhpcy51bml0Rm9yZ2V0QmlhcyxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBuLmNlbGwsT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3JldHVybiAwPT09dC5pbXBsbWVudGF0aW9uJiYodC5pbXBsZW1lbnRhdGlvbj0xKSxuZXcgZSh0KX0sdC5jbGFzc05hbWU9XCJMU1RNXCIsdH0oUk5OKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTFNUTSk7dmFyIFN0YWNrZWRSTk5DZWxscz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmNlbGxzPXQuY2VsbHMsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RhdGVTaXplXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmNlbGxzLnNsaWNlKCkucmV2ZXJzZSgpO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO0FycmF5LmlzQXJyYXkoci5zdGF0ZVNpemUpP2UucHVzaC5hcHBseShlLHIuc3RhdGVTaXplKTplLnB1c2goci5zdGF0ZVNpemUpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciByPShlPWUpLnNsaWNlKDEpLGk9W10sYT0wLG89bi5jZWxscy5zbGljZSgpLnJldmVyc2UoKTthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9b1thXTtBcnJheS5pc0FycmF5KHMuc3RhdGVTaXplKT9pLnB1c2goci5zcGxpY2UoMCxzLnN0YXRlU2l6ZS5sZW5ndGgpKTppLnB1c2goci5zcGxpY2UoMCwxKSl9aS5yZXZlcnNlKCk7Zm9yKHZhciBsLHU9W10sYz0wO2M8bi5jZWxscy5sZW5ndGg7KytjKXtzPW4uY2VsbHNbY107cj1pW2NdLGw9MD09PWM/W2VbMF1dLmNvbmNhdChyKTpbbFswXV0uY29uY2F0KHIpLGw9cy5jYWxsKGwsdCksdS5wdXNoKGwuc2xpY2UoMSkpfXI9W107Zm9yKHZhciBwPTAsaD11LnNsaWNlKCkucmV2ZXJzZSgpO3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO3IucHVzaC5hcHBseShyLGQpfXJldHVybltsWzBdXS5jb25jYXQocil9KX0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ7aXNBcnJheU9mU2hhcGVzKGUpJiYoZT1lWzBdKSxlPWU7Zm9yKHZhciBuPTAscj10aGlzLmNlbGxzO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2kuYnVpbGQoZSksdD1BcnJheS5pc0FycmF5KGkuc3RhdGVTaXplKT9pLnN0YXRlU2l6ZVswXTppLnN0YXRlU2l6ZSxlPVtlWzBdLHRdfXRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxuPTAscj10aGlzLmNlbGxzO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO3QucHVzaCh7Y2xhc3NOYW1lOnRoaXMuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOmkuZ2V0Q29uZmlnKCl9KX12YXIgYT17Y2VsbHM6dH0sbz1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihhLG8pLGF9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQsbil7dm9pZCAwPT09biYmKG49e30pO2Zvcih2YXIgcj1bXSxpPTAsYT10LmNlbGxzO2k8YS5sZW5ndGg7aSsrKXt2YXIgbz1hW2ldO3IucHVzaChkZXNlcmlhbGl6ZShvLG4pKX1yZXR1cm4gbmV3IGUoe2NlbGxzOnJ9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy50cmFpbmFibGUpcmV0dXJuW107Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuY2VsbHM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoLmFwcGx5KGUsci50cmFpbmFibGVXZWlnaHRzKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmNlbGxzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIubm9uVHJhaW5hYmxlV2VpZ2h0cyl9aWYoIXRoaXMudHJhaW5hYmxlKXtmb3IodmFyIGk9W10sYT0wLG89dGhpcy5jZWxsczthPG8ubGVuZ3RoO2ErKyl7cj1vW2FdO2kucHVzaC5hcHBseShpLHIudHJhaW5hYmxlV2VpZ2h0cyl9cmV0dXJuIGkuY29uY2F0KGUpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxsczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLnB1c2guYXBwbHkoZSxyLndlaWdodHMpfXJldHVybiBiYXRjaEdldFZhbHVlKGUpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTAscj10aGlzLmNlbGxzO248ci5sZW5ndGg7bisrKWZvcih2YXIgaT1yW25dLGE9aS53ZWlnaHRzLmxlbmd0aCxvPWUuc3BsaWNlKGEpLHM9MDtzPGkud2VpZ2h0cy5sZW5ndGg7KytzKXQucHVzaChbaS53ZWlnaHRzW3NdLG9bc11dKTtiYXRjaFNldFZhbHVlKHQpfSx0LmNsYXNzTmFtZT1cIlN0YWNrZWRSTk5DZWxsc1wiLHR9KFJOTkNlbGwpO2Z1bmN0aW9uIGdlbmVyYXRlRHJvcG91dE1hc2soZSx0LG4scil7ZnVuY3Rpb24gaSgpe3JldHVybiBkcm9wb3V0KGUoKSx0KX1pZih2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0xKSxyPjEpe2Zvcih2YXIgYT1bXSxvPTA7bzxyO28rKylhLnB1c2goaW5UcmFpblBoYXNlKGksZSxuKSk7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBrZWVwKGUuY2xvbmUoKSl9KX1yZXR1cm4ga2VlcChpblRyYWluUGhhc2UoaSxlLG4pLmNsb25lKCkpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTdGFja2VkUk5OQ2VsbHMpO3ZhciBXcmFwcGVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4ubGF5ZXI9dC5sYXllcixufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt0aGlzLmJ1aWx0PSEwfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMubGF5ZXImJnRoaXMubGF5ZXIudHJhaW5hYmxlfSxzZXQ6ZnVuY3Rpb24oZSl7bnVsbCE9dGhpcy5sYXllciYmKHRoaXMubGF5ZXIudHJhaW5hYmxlPWUpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIudHJhaW5hYmxlV2VpZ2h0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLm5vblRyYWluYWJsZVdlaWdodHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXBkYXRlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5fdXBkYXRlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJsb3NzZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIubG9zc2VzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5nZXRXZWlnaHRzKCl9LHQucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24oZSl7dGhpcy5sYXllci5zZXRXZWlnaHRzKGUpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17bGF5ZXI6e2NsYXNzTmFtZTp0aGlzLmxheWVyLmdldENsYXNzTmFtZSgpLGNvbmZpZzp0aGlzLmxheWVyLmdldENvbmZpZygpfX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZnVuY3Rpb24odCl7ZS5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZC5jYWxsKHRoaXMsdCksbnVsbCE9dGhpcy5sYXllciYmdGhpcy5sYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcj1kZXNlcmlhbGl6ZSh0LmxheWVyLG4pO2RlbGV0ZSB0LmxheWVyO3ZhciBpPXtsYXllcjpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihpLHQpLG5ldyBlKGkpfSx0fShMYXllciksVGltZURpc3RyaWJ1dGVkPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKHQpe2lmKCh0PWdldEV4YWN0bHlPbmVTaGFwZSh0KSkubGVuZ3RoPDMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaW1lRGlzdHJpYnV0ZWQgbGF5ZXIgZXhwZWN0cyBhbiBpbnB1dCBzaGFwZSA+PSAzRCwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHQpKTt0aGlzLmlucHV0U3BlYz1be3NoYXBlOnR9XTt2YXIgbj1bdFswXV0uY29uY2F0KHQuc2xpY2UoMikpO3RoaXMubGF5ZXIuYnVpbHR8fCh0aGlzLmxheWVyLmJ1aWxkKG4pLHRoaXMubGF5ZXIuYnVpbHQ9ITApLGUucHJvdG90eXBlLmJ1aWxkLmNhbGwodGhpcyx0KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PVsoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpWzBdXS5jb25jYXQoZS5zbGljZSgyKSksbj10aGlzLmxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZSh0KSxyPWVbMV07cmV0dXJuW25bMF0scl0uY29uY2F0KG4uc2xpY2UoMSkpfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBybm4oZnVuY3Rpb24oZSxyKXtyZXR1cm5bZ2V0RXhhY3RseU9uZVRlbnNvcihuLmxheWVyLmNhbGwoZSx0KSksW11dfSxlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksW10sITEsbnVsbCxudWxsLCExLCEwKVsxXX0pfSx0LmNsYXNzTmFtZT1cIlRpbWVEaXN0cmlidXRlZFwiLHR9KFdyYXBwZXIpO2Z1bmN0aW9uIGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERVMsXCJCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlXCIsZSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRpbWVEaXN0cmlidXRlZCk7dmFyIERFRkFVTFRfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFPVwiY29uY2F0XCIsQmlkaXJlY3Rpb25hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzLHI9dC5sYXllci5nZXRDb25maWcoKSxpPXt9O2kuY2xhc3NOYW1lPXQubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksaS5jb25maWc9cixuLmZvcndhcmRMYXllcj1kZXNlcmlhbGl6ZShpKSxyLmdvQmFja3dhcmRzPSEwIT09ci5nb0JhY2t3YXJkczt2YXIgYT17fTtpZihhLmNsYXNzTmFtZT10LmxheWVyLmdldENsYXNzTmFtZSgpLGEuY29uZmlnPXIsbi5iYWNrd2FyZExheWVyPWRlc2VyaWFsaXplKGEpLG4uZm9yd2FyZExheWVyLm5hbWU9XCJmb3J3YXJkX1wiK24uZm9yd2FyZExheWVyLm5hbWUsbi5iYWNrd2FyZExheWVyLm5hbWU9XCJiYWNrd2FyZF9cIituLmJhY2t3YXJkTGF5ZXIubmFtZSxuLm1lcmdlTW9kZT12b2lkIDA9PT10Lm1lcmdlTW9kZT9ERUZBVUxUX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERTp0Lm1lcmdlTW9kZSxjaGVja0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUobi5tZXJnZU1vZGUpLHQud2VpZ2h0cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIndlaWdodHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEJpZGlyZWN0aW9uYWwgbGF5ZXIgeWV0LlwiKTtyZXR1cm4gbi5fc3RhdGVmdWw9dC5sYXllci5zdGF0ZWZ1bCxuLnJldHVyblNlcXVlbmNlcz10LmxheWVyLnJldHVyblNlcXVlbmNlcyxuLnJldHVyblN0YXRlPXQubGF5ZXIucmV0dXJuU3RhdGUsbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5fdHJhaW5hYmxlPSEwLG4uaW5wdXRTcGVjPXQubGF5ZXIuaW5wdXRTcGVjLG4ubnVtQ29uc3RhbnRzPW51bGwsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90cmFpbmFibGV9LHNldDpmdW5jdGlvbihlKXt0aGlzLl90cmFpbmFibGU9ZSxudWxsIT10aGlzLmZvcndhcmRMYXllciYmKHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZT1lKSxudWxsIT10aGlzLmJhY2t3YXJkTGF5ZXImJih0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlPWUpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aCxuPU1hdGguZmxvb3IodC8yKTt0aGlzLmZvcndhcmRMYXllci5zZXRXZWlnaHRzKGUuc2xpY2UoMCxuKSksdGhpcy5iYWNrd2FyZExheWVyLnNldFdlaWdodHMoZS5zbGljZShuKSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdCxuLHIsaT10aGlzLmZvcndhcmRMYXllci5jb21wdXRlT3V0cHV0U2hhcGUoZSk7cmV0dXJuIEFycmF5LmlzQXJyYXkoaSkmJkFycmF5LmlzQXJyYXkoaVswXSl8fChpPVtpXSksaT1pLHRoaXMucmV0dXJuU3RhdGU/KHI9aS5zbGljZSgxKSx0PWlbMF0pOnQ9aVswXSx0PXQsXCJjb25jYXRcIj09PXRoaXMubWVyZ2VNb2RlPyh0W3QubGVuZ3RoLTFdKj0yLG49W3RdKTpuPW51bGw9PXRoaXMubWVyZ2VNb2RlP1t0LHQuc2xpY2UoKV06W3RdLHRoaXMucmV0dXJuU3RhdGU/bnVsbD09dGhpcy5tZXJnZU1vZGU/bi5jb25jYXQocikuY29uY2F0KHIuc2xpY2UoKSk6W3RdLmNvbmNhdChyKS5jb25jYXQoci5zbGljZSgpKTpzaW5nbGV0b25PckFycmF5KG4pfSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbih0LG4pe3ZhciByPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZSxpPW51bGw9PW4/bnVsbDpuLmNvbnN0YW50cztudWxsPT1uJiYobj17fSk7dmFyIGE9c3RhbmRhcmRpemVBcmdzKHQscixpLHRoaXMubnVtQ29uc3RhbnRzKTtpZih0PWEuaW5wdXRzLHI9YS5pbml0aWFsU3RhdGUsaT1hLmNvbnN0YW50cyxBcnJheS5pc0FycmF5KHQpJiYocj10LnNsaWNlKDEpLHQ9dFswXSksKG51bGw9PXJ8fDA9PT1yLmxlbmd0aCkmJm51bGw9PWkpcmV0dXJuIGUucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyx0LG4pO3ZhciBvPVtdLHM9W107aWYobnVsbCE9cil7dmFyIGw9ci5sZW5ndGg7aWYobCUyPjApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgYGluaXRpYWxTdGF0ZWAgdG8gYSBCaWRyZWN0aW9uYWwgUk5OLCB0aGUgc3RhdGUgc2hvdWxkIGJlIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIHN0YXRlcyBvZiB0aGUgdW5kZXJseWluZyBSTk5zLlwiKTtuLmluaXRpYWxTdGF0ZT1yLG8ucHVzaC5hcHBseShvLHIpO3ZhciB1PXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgSW5wdXRTcGVjKHtzaGFwZTplLnNoYXBlfSl9KTt0aGlzLmZvcndhcmRMYXllci5zdGF0ZVNwZWM9dS5zbGljZSgwLGwvMiksdGhpcy5iYWNrd2FyZExheWVyLnN0YXRlU3BlYz11LnNsaWNlKGwvMikscy5wdXNoLmFwcGx5KHMsdSl9aWYobnVsbCE9aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlN1cHBvcnQgZm9yIGNvbnN0YW50cyBpbiBCaWRpcmVjdGlvbmFsIGxheWVycyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtmb3IodmFyIGM9b1swXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IscD0wLGg9bztwPGgubGVuZ3RoO3ArKyl7aWYoaFtwXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IhPT1jKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGluaXRpYWwgc3RhdGUgb2YgYSBCaWRpcmVjdGlvbmFsIGxheWVyIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXMgYSBtaXggb2Ygc3ltYm9saWMgYW5kIG5vbi1zeW1ib2xpYyB0ZW5zb3JzXCIpfWlmKGMpe3ZhciBkPVt0XS5jb25jYXQobyksZj10aGlzLmlucHV0U3BlYy5jb25jYXQocyksZz10aGlzLmlucHV0U3BlYzt0aGlzLmlucHV0U3BlYz1mO3ZhciBtPWUucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyxkLG4pO3JldHVybiB0aGlzLmlucHV0U3BlYz1nLG19cmV0dXJuIGUucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyx0LG4pfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKG51bGwhPXQubWFzayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBzdXBwb3J0IGZvciBtYXNraW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQmlkaXJlY3Rpb25hbCBsYXllcnMgeWV0LlwiKTt2YXIgcixpLGEsbyxzPXQuaW5pdGlhbFN0YXRlO2lmKG51bGw9PXMpcj1uLmZvcndhcmRMYXllci5jYWxsKGUsdCksaT1uLmJhY2t3YXJkTGF5ZXIuY2FsbChlLHQpO2Vsc2V7dmFyIGw9cy5zbGljZSgwLHMubGVuZ3RoLzIpLHU9cy5zbGljZShzLmxlbmd0aC8yKTtyPW4uZm9yd2FyZExheWVyLmNhbGwoZSxPYmplY3QuYXNzaWduKHQse2luaXRpYWxTdGF0ZTpsfSkpLGk9bi5iYWNrd2FyZExheWVyLmNhbGwoZSxPYmplY3QuYXNzaWduKHQse2luaXRpYWxTdGF0ZTp1fSkpfXJldHVybiBuLnJldHVyblN0YXRlJiYoQXJyYXkuaXNBcnJheShyKSYmKGE9ci5zbGljZSgxKS5jb25jYXQoaS5zbGljZSgxKSkpLHI9clswXSxpPWlbMF0pLG4ucmV0dXJuU2VxdWVuY2VzJiYoaT1yZXZlcnNlKGksMSkpLFwiY29uY2F0XCI9PT1uLm1lcmdlTW9kZT9vPWNvbmNhdGVuYXRlKFtyLGldKTpcInN1bVwiPT09bi5tZXJnZU1vZGU/bz1hZGQocixpKTpcImF2ZVwiPT09bi5tZXJnZU1vZGU/bz1tdWwoLjUsYWRkKHIsaSkpOlwibXVsXCI9PT1uLm1lcmdlTW9kZT9vPW11bChyLGkpOm51bGw9PW4ubWVyZ2VNb2RlJiYobz1bcixpXSksbi5yZXR1cm5TdGF0ZT9udWxsPT1uLm1lcmdlTW9kZT9vLmNvbmNhdChhKTpbb10uY29uY2F0KGEpOm99KX0sdC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oZSl7dGhpcy5mb3J3YXJkTGF5ZXIucmVzZXRTdGF0ZXMoKSx0aGlzLmJhY2t3YXJkTGF5ZXIucmVzZXRTdGF0ZXMoKX0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztuYW1lU2NvcGUodGhpcy5mb3J3YXJkTGF5ZXIubmFtZSxmdW5jdGlvbigpe3QuZm9yd2FyZExheWVyLmJ1aWxkKGUpfSksbmFtZVNjb3BlKHRoaXMuYmFja3dhcmRMYXllci5uYW1lLGZ1bmN0aW9uKCl7dC5iYWNrd2FyZExheWVyLmJ1aWxkKGUpfSksdGhpcy5idWlsdD0hMH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPWZ1bmN0aW9uKHQpe2UucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQuY2FsbCh0aGlzLHQpLG51bGwhPXRoaXMuZm9yd2FyZExheWVyJiZ0aGlzLmZvcndhcmRMYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpLG51bGwhPXRoaXMuYmFja3dhcmRMYXllciYmdGhpcy5iYWNrd2FyZExheWVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXttZXJnZU1vZGU6dGhpcy5tZXJnZU1vZGV9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXt2YXIgbj1kZXNlcmlhbGl6ZSh0LmxheWVyKTtpZihkZWxldGUgdC5sYXllcixudWxsIT10Lm51bUNvbnN0YW50cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgd2l0aCBudW1Db25zdGFudHMgcHJlc2VudCBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7dmFyIHI9dDtyZXR1cm4gci5sYXllcj1uLG5ldyBlKHIpfSx0LmNsYXNzTmFtZT1cIkJpZGlyZWN0aW9uYWxcIix0fShXcmFwcGVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQmlkaXJlY3Rpb25hbCk7dmFyIEdhdXNzaWFuTm9pc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5zdGRkZXY9dC5zdGRkZXYsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKSxuPXtzdGRkZXY6dGhpcy5zdGRkZXZ9O3JldHVybiBPYmplY3QuYXNzaWduKG4sdCksbn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gaW5UcmFpblBoYXNlKGZ1bmN0aW9uKCl7cmV0dXJuIHJhbmRvbU5vcm1hbCQxKHIuc2hhcGUsMCxuLnN0ZGRldikuYWRkKHIpfSxmdW5jdGlvbigpe3JldHVybiByfSx0LnRyYWluaW5nfHwhMSl9KX0sdC5jbGFzc05hbWU9XCJHYXVzc2lhbk5vaXNlXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHYXVzc2lhbk5vaXNlKTt2YXIgR2F1c3NpYW5Ecm9wb3V0PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ucmF0ZT10LnJhdGUsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKSxuPXtyYXRlOnRoaXMucmF0ZX07cmV0dXJuIE9iamVjdC5hc3NpZ24obix0KSxufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO2lmKG4ucmF0ZT4wJiZuLnJhdGU8MSl7cmV0dXJuIGluVHJhaW5QaGFzZShmdW5jdGlvbigpe3ZhciBlPU1hdGguc3FydChuLnJhdGUvKDEtbi5yYXRlKSk7cmV0dXJuIGRvdChyLHJhbmRvbU5vcm1hbCQxKHIuc2hhcGUsMSxlKSl9LGZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHQudHJhaW5pbmd8fCExKX1yZXR1cm4gcn0pfSx0LmNsYXNzTmFtZT1cIkdhdXNzaWFuRHJvcG91dFwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2F1c3NpYW5Ecm9wb3V0KTt2YXIgQWxwaGFEcm9wb3V0PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ucmF0ZT10LnJhdGUsbi5ub2lzZVNoYXBlPXQubm9pc2VTaGFwZSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5fZ2V0Tm9pc2VTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ub2lzZVNoYXBlfHxnZXRFeGFjdGx5T25lVGVuc29yKGUpLnNoYXBlfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpLG49e3JhdGU6dGhpcy5yYXRlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHQpLG59LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobi5yYXRlPDEmJm4ucmF0ZT4wKXt2YXIgcj1uLl9nZXROb2lzZVNoYXBlKGUpO3JldHVybiBpblRyYWluUGhhc2UoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpLGk9LTEuNzU4MDk5MzQwODQ3Mzc2NixhPWdyZWF0ZXJFcXVhbChyYW5kb21Vbmlmb3JtKHIpLG4ucmF0ZSk7YT1jYXN0JDEoYSxcImZsb2F0MzJcIik7dmFyIG89TWF0aC5wb3coKDEtbi5yYXRlKSooMStuLnJhdGUqTWF0aC5wb3coaSwyKSksLS41KSxzPS1vKmkqbi5yYXRlO3JldHVybiBkb3QodCxhKS5hZGQoYS5hZGQoLTEpLm11bChpKSkubXVsKG8pLmFkZChzKX0sZnVuY3Rpb24oKXtyZXR1cm4gZ2V0RXhhY3RseU9uZVRlbnNvcihlKX0sdC50cmFpbmluZ3x8ITEpfXJldHVybiBlfSl9LHQuY2xhc3NOYW1lPVwiQWxwaGFEcm9wb3V0XCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIGlucHV0TGF5ZXIoZSl7cmV0dXJuIG5ldyBJbnB1dExheWVyKGUpfWZ1bmN0aW9uIGVsdSQyKGUpe3JldHVybiBuZXcgRUxVKGUpfWZ1bmN0aW9uIHJlTFUoZSl7cmV0dXJuIG5ldyBSZUxVKGUpfWZ1bmN0aW9uIGxlYWt5UmVMVShlKXtyZXR1cm4gbmV3IExlYWt5UmVMVShlKX1mdW5jdGlvbiBwcmVsdSQxKGUpe3JldHVybiBuZXcgUFJlTFUoZSl9ZnVuY3Rpb24gc29mdG1heCQxKGUpe3JldHVybiBuZXcgU29mdG1heCQxKGUpfWZ1bmN0aW9uIHRocmVzaG9sZGVkUmVMVShlKXtyZXR1cm4gbmV3IFRocmVzaG9sZGVkUmVMVShlKX1mdW5jdGlvbiBjb252MWQkMihlKXtyZXR1cm4gbmV3IENvbnYxRChlKX1mdW5jdGlvbiBjb252MmQkMihlKXtyZXR1cm4gbmV3IENvbnYyRChlKX1mdW5jdGlvbiBjb252MmRUcmFuc3Bvc2UkMShlKXtyZXR1cm4gbmV3IENvbnYyRFRyYW5zcG9zZShlKX1mdW5jdGlvbiBjb252M2QkMihlKXtyZXR1cm4gbmV3IENvbnYzRChlKX1mdW5jdGlvbiBzZXBhcmFibGVDb252MmQkMShlKXtyZXR1cm4gbmV3IFNlcGFyYWJsZUNvbnYyRChlKX1mdW5jdGlvbiBjcm9wcGluZzJEKGUpe3JldHVybiBuZXcgQ3JvcHBpbmcyRChlKX1mdW5jdGlvbiB1cFNhbXBsaW5nMmQoZSl7cmV0dXJuIG5ldyBVcFNhbXBsaW5nMkQoZSl9ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkJDIoZSl7cmV0dXJuIG5ldyBEZXB0aHdpc2VDb252MkQoZSl9ZnVuY3Rpb24gYWN0aXZhdGlvbihlKXtyZXR1cm4gbmV3IEFjdGl2YXRpb24kMShlKX1mdW5jdGlvbiBkZW5zZShlKXtyZXR1cm4gbmV3IERlbnNlKGUpfWZ1bmN0aW9uIGRyb3BvdXQkMShlKXtyZXR1cm4gbmV3IERyb3BvdXQoZSl9ZnVuY3Rpb24gZmxhdHRlbiQxKGUpe3JldHVybiBuZXcgRmxhdHRlbihlKX1mdW5jdGlvbiByZXBlYXRWZWN0b3IoZSl7cmV0dXJuIG5ldyBSZXBlYXRWZWN0b3IoZSl9ZnVuY3Rpb24gcmVzaGFwZShlKXtyZXR1cm4gbmV3IFJlc2hhcGUoZSl9ZnVuY3Rpb24gcGVybXV0ZShlKXtyZXR1cm4gbmV3IFBlcm11dGUoZSl9ZnVuY3Rpb24gZW1iZWRkaW5nKGUpe3JldHVybiBuZXcgRW1iZWRkaW5nKGUpfWZ1bmN0aW9uIGFkZCQyKGUpe3JldHVybiBuZXcgQWRkKGUpfWZ1bmN0aW9uIGF2ZXJhZ2UkMShlKXtyZXR1cm4gbmV3IEF2ZXJhZ2UoZSl9ZnVuY3Rpb24gY29uY2F0ZW5hdGUkMihlKXtyZXR1cm4gbmV3IENvbmNhdGVuYXRlKGUpfWZ1bmN0aW9uIG1heGltdW0kMihlKXtyZXR1cm4gbmV3IE1heGltdW0oZSl9ZnVuY3Rpb24gbWluaW11bSQyKGUpe3JldHVybiBuZXcgTWluaW11bShlKX1mdW5jdGlvbiBtdWx0aXBseSQxKGUpe3JldHVybiBuZXcgTXVsdGlwbHkoZSl9ZnVuY3Rpb24gZG90JDEoZSl7cmV0dXJuIG5ldyBEb3QoZSl9ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uJDEoZSl7cmV0dXJuIG5ldyBCYXRjaE5vcm1hbGl6YXRpb24oZSl9ZnVuY3Rpb24gemVyb1BhZGRpbmcyZChlKXtyZXR1cm4gbmV3IFplcm9QYWRkaW5nMkQoZSl9ZnVuY3Rpb24gYXZlcmFnZVBvb2xpbmcxZChlKXtyZXR1cm4gbmV3IEF2ZXJhZ2VQb29saW5nMUQoZSl9ZnVuY3Rpb24gYXZnUG9vbDFkKGUpe3JldHVybiBhdmVyYWdlUG9vbGluZzFkKGUpfWZ1bmN0aW9uIGF2Z1Bvb2xpbmcxZChlKXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcxZChlKX1mdW5jdGlvbiBhdmVyYWdlUG9vbGluZzJkKGUpe3JldHVybiBuZXcgQXZlcmFnZVBvb2xpbmcyRChlKX1mdW5jdGlvbiBhdmdQb29sMmQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMmQoZSl9ZnVuY3Rpb24gYXZnUG9vbGluZzJkKGUpe3JldHVybiBhdmVyYWdlUG9vbGluZzJkKGUpfWZ1bmN0aW9uIGdsb2JhbEF2ZXJhZ2VQb29saW5nMWQoZSl7cmV0dXJuIG5ldyBHbG9iYWxBdmVyYWdlUG9vbGluZzFEKGUpfWZ1bmN0aW9uIGdsb2JhbEF2ZXJhZ2VQb29saW5nMmQoZSl7cmV0dXJuIG5ldyBHbG9iYWxBdmVyYWdlUG9vbGluZzJEKGUpfWZ1bmN0aW9uIGdsb2JhbE1heFBvb2xpbmcxZChlKXtyZXR1cm4gbmV3IEdsb2JhbE1heFBvb2xpbmcxRChlKX1mdW5jdGlvbiBnbG9iYWxNYXhQb29saW5nMmQoZSl7cmV0dXJuIG5ldyBHbG9iYWxNYXhQb29saW5nMkQoZSl9ZnVuY3Rpb24gbWF4UG9vbGluZzFkKGUpe3JldHVybiBuZXcgTWF4UG9vbGluZzFEKGUpfWZ1bmN0aW9uIG1heFBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IE1heFBvb2xpbmcyRChlKX1mdW5jdGlvbiBncnUoZSl7cmV0dXJuIG5ldyBHUlUoZSl9ZnVuY3Rpb24gZ3J1Q2VsbChlKXtyZXR1cm4gbmV3IEdSVUNlbGwoZSl9ZnVuY3Rpb24gbHN0bShlKXtyZXR1cm4gbmV3IExTVE0oZSl9ZnVuY3Rpb24gbHN0bUNlbGwoZSl7cmV0dXJuIG5ldyBMU1RNQ2VsbChlKX1mdW5jdGlvbiBzaW1wbGVSTk4oZSl7cmV0dXJuIG5ldyBTaW1wbGVSTk4oZSl9ZnVuY3Rpb24gc2ltcGxlUk5OQ2VsbChlKXtyZXR1cm4gbmV3IFNpbXBsZVJOTkNlbGwoZSl9ZnVuY3Rpb24gcm5uJDEoZSl7cmV0dXJuIG5ldyBSTk4oZSl9ZnVuY3Rpb24gc3RhY2tlZFJOTkNlbGxzKGUpe3JldHVybiBuZXcgU3RhY2tlZFJOTkNlbGxzKGUpfWZ1bmN0aW9uIGJpZGlyZWN0aW9uYWwoZSl7cmV0dXJuIG5ldyBCaWRpcmVjdGlvbmFsKGUpfWZ1bmN0aW9uIHRpbWVEaXN0cmlidXRlZChlKXtyZXR1cm4gbmV3IFRpbWVEaXN0cmlidXRlZChlKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQWxwaGFEcm9wb3V0KTt2YXIgZ2xvYmFsTWF4UG9vbDFkPWdsb2JhbE1heFBvb2xpbmcxZCxnbG9iYWxNYXhQb29sMmQ9Z2xvYmFsTWF4UG9vbGluZzJkLG1heFBvb2wxZD1tYXhQb29saW5nMWQsbWF4UG9vbDJkPW1heFBvb2xpbmcyZDtmdW5jdGlvbiBnYXVzc2lhbk5vaXNlKGUpe3JldHVybiBuZXcgR2F1c3NpYW5Ob2lzZShlKX1mdW5jdGlvbiBnYXVzc2lhbkRyb3BvdXQoZSl7cmV0dXJuIG5ldyBHYXVzc2lhbkRyb3BvdXQoZSl9ZnVuY3Rpb24gYWxwaGFEcm9wb3V0KGUpe3JldHVybiBuZXcgQWxwaGFEcm9wb3V0KGUpfWZ1bmN0aW9uIG1hc2tpbmcoZSl7cmV0dXJuIG5ldyBNYXNraW5nKGUpfXZhciBleHBvcnRzX2xheWVycz1PYmplY3QuZnJlZXplKHtpbnB1dExheWVyOmlucHV0TGF5ZXIsZWx1OmVsdSQyLHJlTFU6cmVMVSxsZWFreVJlTFU6bGVha3lSZUxVLHByZWx1OnByZWx1JDEsc29mdG1heDpzb2Z0bWF4JDEsdGhyZXNob2xkZWRSZUxVOnRocmVzaG9sZGVkUmVMVSxjb252MWQ6Y29udjFkJDIsY29udjJkOmNvbnYyZCQyLGNvbnYyZFRyYW5zcG9zZTpjb252MmRUcmFuc3Bvc2UkMSxjb252M2Q6Y29udjNkJDIsc2VwYXJhYmxlQ29udjJkOnNlcGFyYWJsZUNvbnYyZCQxLGNyb3BwaW5nMkQ6Y3JvcHBpbmcyRCx1cFNhbXBsaW5nMmQ6dXBTYW1wbGluZzJkLGRlcHRod2lzZUNvbnYyZDpkZXB0aHdpc2VDb252MmQkMixhY3RpdmF0aW9uOmFjdGl2YXRpb24sZGVuc2U6ZGVuc2UsZHJvcG91dDpkcm9wb3V0JDEsZmxhdHRlbjpmbGF0dGVuJDEscmVwZWF0VmVjdG9yOnJlcGVhdFZlY3RvcixyZXNoYXBlOnJlc2hhcGUscGVybXV0ZTpwZXJtdXRlLGVtYmVkZGluZzplbWJlZGRpbmcsYWRkOmFkZCQyLGF2ZXJhZ2U6YXZlcmFnZSQxLGNvbmNhdGVuYXRlOmNvbmNhdGVuYXRlJDIsbWF4aW11bTptYXhpbXVtJDIsbWluaW11bTptaW5pbXVtJDIsbXVsdGlwbHk6bXVsdGlwbHkkMSxkb3Q6ZG90JDEsYmF0Y2hOb3JtYWxpemF0aW9uOmJhdGNoTm9ybWFsaXphdGlvbiQxLHplcm9QYWRkaW5nMmQ6emVyb1BhZGRpbmcyZCxhdmVyYWdlUG9vbGluZzFkOmF2ZXJhZ2VQb29saW5nMWQsYXZnUG9vbDFkOmF2Z1Bvb2wxZCxhdmdQb29saW5nMWQ6YXZnUG9vbGluZzFkLGF2ZXJhZ2VQb29saW5nMmQ6YXZlcmFnZVBvb2xpbmcyZCxhdmdQb29sMmQ6YXZnUG9vbDJkLGF2Z1Bvb2xpbmcyZDphdmdQb29saW5nMmQsZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZDpnbG9iYWxBdmVyYWdlUG9vbGluZzFkLGdsb2JhbEF2ZXJhZ2VQb29saW5nMmQ6Z2xvYmFsQXZlcmFnZVBvb2xpbmcyZCxnbG9iYWxNYXhQb29saW5nMWQ6Z2xvYmFsTWF4UG9vbGluZzFkLGdsb2JhbE1heFBvb2xpbmcyZDpnbG9iYWxNYXhQb29saW5nMmQsbWF4UG9vbGluZzFkOm1heFBvb2xpbmcxZCxtYXhQb29saW5nMmQ6bWF4UG9vbGluZzJkLGdydTpncnUsZ3J1Q2VsbDpncnVDZWxsLGxzdG06bHN0bSxsc3RtQ2VsbDpsc3RtQ2VsbCxzaW1wbGVSTk46c2ltcGxlUk5OLHNpbXBsZVJOTkNlbGw6c2ltcGxlUk5OQ2VsbCxybm46cm5uJDEsc3RhY2tlZFJOTkNlbGxzOnN0YWNrZWRSTk5DZWxscyxiaWRpcmVjdGlvbmFsOmJpZGlyZWN0aW9uYWwsdGltZURpc3RyaWJ1dGVkOnRpbWVEaXN0cmlidXRlZCxnbG9iYWxNYXhQb29sMWQ6Z2xvYmFsTWF4UG9vbDFkLGdsb2JhbE1heFBvb2wyZDpnbG9iYWxNYXhQb29sMmQsbWF4UG9vbDFkOm1heFBvb2wxZCxtYXhQb29sMmQ6bWF4UG9vbDJkLExheWVyOkxheWVyLFJOTjpSTk4sUk5OQ2VsbDpSTk5DZWxsLGlucHV0OmlucHV0LGdhdXNzaWFuTm9pc2U6Z2F1c3NpYW5Ob2lzZSxnYXVzc2lhbkRyb3BvdXQ6Z2F1c3NpYW5Ecm9wb3V0LGFscGhhRHJvcG91dDphbHBoYURyb3BvdXQsbWFza2luZzptYXNraW5nfSk7ZnVuY3Rpb24gYmluYXJ5QWNjdXJhY3kkMShlLHQpe3JldHVybiBiaW5hcnlBY2N1cmFjeShlLHQpfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSQyKGUsdCl7cmV0dXJuIGJpbmFyeUNyb3NzZW50cm9weSQxKGUsdCl9ZnVuY3Rpb24gc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeSQxKGUsdCl7cmV0dXJuIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KX1mdW5jdGlvbiBjYXRlZ29yaWNhbEFjY3VyYWN5JDEoZSx0KXtyZXR1cm4gY2F0ZWdvcmljYWxBY2N1cmFjeShlLHQpfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDIoZSx0KXtyZXR1cm4gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMShlLHQpfWZ1bmN0aW9uIHByZWNpc2lvbiQxKGUsdCl7cmV0dXJuIHByZWNpc2lvbihlLHQpfWZ1bmN0aW9uIHJlY2FsbCQxKGUsdCl7cmV0dXJuIHJlY2FsbChlLHQpfWZ1bmN0aW9uIGNvc2luZVByb3hpbWl0eSQxKGUsdCl7cmV0dXJuIGNvc2luZVByb3hpbWl0eShlLHQpfWZ1bmN0aW9uIG1lYW5BYnNvbHV0ZUVycm9yJDEoZSx0KXtyZXR1cm4gbWVhbkFic29sdXRlRXJyb3IoZSx0KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IkMShlLHQpe3JldHVybiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KX1mdW5jdGlvbiBNQVBFJDIoZSx0KXtyZXR1cm4gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGUsdCl9ZnVuY3Rpb24gbWFwZSQyKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihlLHQpfWZ1bmN0aW9uIG1lYW5TcXVhcmVkRXJyb3IkMShlLHQpe3JldHVybiBtZWFuU3F1YXJlZEVycm9yKGUsdCl9ZnVuY3Rpb24gTVNFJDIoZSx0KXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvcihlLHQpfWZ1bmN0aW9uIG1zZSQyKGUsdCl7cmV0dXJuIG1lYW5TcXVhcmVkRXJyb3IoZSx0KX12YXIgZXhwb3J0c19tZXRyaWNzPU9iamVjdC5mcmVlemUoe2JpbmFyeUFjY3VyYWN5OmJpbmFyeUFjY3VyYWN5JDEsYmluYXJ5Q3Jvc3NlbnRyb3B5OmJpbmFyeUNyb3NzZW50cm9weSQyLHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3k6c3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeSQxLGNhdGVnb3JpY2FsQWNjdXJhY3k6Y2F0ZWdvcmljYWxBY2N1cmFjeSQxLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDIscHJlY2lzaW9uOnByZWNpc2lvbiQxLHJlY2FsbDpyZWNhbGwkMSxjb3NpbmVQcm94aW1pdHk6Y29zaW5lUHJveGltaXR5JDEsbWVhbkFic29sdXRlRXJyb3I6bWVhbkFic29sdXRlRXJyb3IkMSxtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yJDEsTUFQRTpNQVBFJDIsbWFwZTptYXBlJDIsbWVhblNxdWFyZWRFcnJvcjptZWFuU3F1YXJlZEVycm9yJDEsTVNFOk1TRSQyLG1zZTptc2UkMn0pLGV4cG9ydHNfbW9kZWxzPU9iamVjdC5mcmVlemUoe21vZGVsRnJvbUpTT046bW9kZWxGcm9tSlNPTn0pO2Z1bmN0aW9uIGwxbDIoZSl7cmV0dXJuIG5ldyBMMUwyKGUpfWZ1bmN0aW9uIGwxJDEoZSl7cmV0dXJuIGwxKGUpfWZ1bmN0aW9uIGwyJDEoZSl7cmV0dXJuIGwyKGUpfXZhciBleHBvcnRzX3JlZ3VsYXJpemVycz1PYmplY3QuZnJlZXplKHtsMWwyOmwxbDIsbDE6bDEkMSxsMjpsMiQxfSksQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciB0PW51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gdC5tb2RlbD1udWxsLHR9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnNldE1vZGVsPWZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIExheWVyc01vZGVsKSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBtdXN0IGJlIGEgTGF5ZXJzTW9kZWwsIG5vdCBzb21lIG90aGVyIENvbnRhaW5lclwiKTt0aGlzLm1vZGVsPWV9LHR9KEJhc2VDYWxsYmFjayk7ZnVuY3Rpb24gbGVzcyhlLHQpe3JldHVybiBlPHR9ZnVuY3Rpb24gZ3JlYXRlciQxKGUsdCl7cmV0dXJuIGU+dH12YXIgRWFybHlTdG9wcGluZz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztpZihudWxsPT10JiYodD17fSksdC5yZXN0b3JlQmVzdFdlaWdodHMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJyZXN0b3JlQmVzdFdlaWdodHMgPSBUcnVlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBFYXJseVN0b3BwaW5nIHlldC5cIik7cmV0dXJuIG4ubW9uaXRvcj10Lm1vbml0b3J8fFwidmFsX2xvc3NcIixuLm1pbkRlbHRhPU1hdGguYWJzKHQubWluRGVsdGF8fDApLG4ucGF0aWVuY2U9dC5wYXRpZW5jZXx8MCxuLnZlcmJvc2U9dC52ZXJib3NlfHwwLG4ubW9kZT10Lm1vZGV8fFwiYXV0b1wiLG4uYmFzZWxpbmU9dC5iYXNlbGluZSwtMT09PVtcImF1dG9cIixcIm1pblwiLFwibWF4XCJdLmluZGV4T2Yobi5tb2RlKSYmKGNvbnNvbGUud2FybihcIkVhcmx5U3RvcHBpbmcgbW9kZSAnXCIrbi5tb2RlK1wiJyBpcyBpbnZhbGlkLiBGYWxsaW5nIGJhY2sgdG8gbW9kZSAnYXV0bycuXCIpLG4ubW9kZT1cImF1dG9cIiksXCJtaW5cIj09PW4ubW9kZT9uLm1vbml0b3JGdW5jPWxlc3M6XCJtYXhcIj09PW4ubW9kZT9uLm1vbml0b3JGdW5jPWdyZWF0ZXIkMTotMSE9PW4ubW9uaXRvci5pbmRleE9mKFwiYWNjXCIpP24ubW9uaXRvckZ1bmM9Z3JlYXRlciQxOm4ubW9uaXRvckZ1bmM9bGVzcyxuLm1vbml0b3JGdW5jPT09bGVzcyYmKG4ubWluRGVsdGEqPS0xKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53YWl0PTAsdGhpcy5zdG9wcGVkRXBvY2g9MCxudWxsIT10aGlzLmJhc2VsaW5lP3RoaXMuYmVzdD10aGlzLmJhc2VsaW5lOnRoaXMuYmVzdD10aGlzLm1vbml0b3JGdW5jPT09bGVzcz8xLzA6LTEvMCxbMl19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6cmV0dXJuIHIuc2VudCgpLG51bGw9PShuPXRoaXMuZ2V0TW9uaXRvclZhbHVlKHQpKT9bMl06KHRoaXMubW9uaXRvckZ1bmMobi10aGlzLm1pbkRlbHRhLHRoaXMuYmVzdCk/KHRoaXMuYmVzdD1uLHRoaXMud2FpdD0wKToodGhpcy53YWl0KyssdGhpcy53YWl0Pj10aGlzLnBhdGllbmNlJiYodGhpcy5zdG9wcGVkRXBvY2g9ZSx0aGlzLm1vZGVsLnN0b3BUcmFpbmluZz0hMCkpLFsyXSl9fSl9KX0sdC5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0b3BwZWRFcG9jaD4wJiZ0aGlzLnZlcmJvc2UmJmNvbnNvbGUubG9nKFwiRXBvY2ggXCIrdGhpcy5zdG9wcGVkRXBvY2grXCI6IGVhcmx5IHN0b3BwaW5nLlwiKSxbMl19KX0pfSx0LnByb3RvdHlwZS5nZXRNb25pdG9yVmFsdWU9ZnVuY3Rpb24oZSl7bnVsbD09ZSYmKGU9e30pO3ZhciB0PWVbdGhpcy5tb25pdG9yXTtyZXR1cm4gbnVsbD09dCYmY29uc29sZS53YXJuKFwiTWV0cmljIGZvciBFYXJseVN0b3BwaW5nIFwiK3RoaXMubW9uaXRvcitcIiBpcyBub3QgYXZhaWxhYmxlLiBBdmFpbGFibGUgbWV0cmljcyBhcmU6IFwiK09iamVjdC5rZXlzKGUpKSx0fSx0fShDYWxsYmFjayk7ZnVuY3Rpb24gZWFybHlTdG9wcGluZyhlKXtyZXR1cm4gbmV3IEVhcmx5U3RvcHBpbmcoZSl9dmFyIGNhbGxiYWNrcz17ZWFybHlTdG9wcGluZzplYXJseVN0b3BwaW5nfTtleHBvcnR7ZXhwb3J0c19jb25zdHJhaW50cyBhcyBjb25zdHJhaW50cyxleHBvcnRzX2luaXRpYWxpemVycyBhcyBpbml0aWFsaXplcnMsZXhwb3J0c19sYXllcnMgYXMgbGF5ZXJzLGV4cG9ydHNfbWV0cmljcyBhcyBtZXRyaWNzLGV4cG9ydHNfbW9kZWxzIGFzIG1vZGVscyxleHBvcnRzX3JlZ3VsYXJpemVycyBhcyByZWd1bGFyaXplcnMsQ2FsbGJhY2tMaXN0LEN1c3RvbUNhbGxiYWNrLEhpc3RvcnksQ2FsbGJhY2ssY2FsbGJhY2tzLEVhcmx5U3RvcHBpbmcsSW5wdXRTcGVjLFN5bWJvbGljVGVuc29yLExheWVyc01vZGVsLGlucHV0LGxvYWRMYXllcnNNb2RlbCxtb2RlbCxyZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3Isc2VxdWVudGlhbCxSTk4sU2VxdWVudGlhbCxMYXllclZhcmlhYmxlLHZlcnNpb24gYXMgdmVyc2lvbl9sYXllcnN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtbGF5ZXJzLmVzbS5qcy5tYXBcbiIsIi8vIEB0ZW5zb3JmbG93L3RmanMgQ29weXJpZ2h0IDIwMTkgR29vZ2xlXG5pbXBvcnR7dmVyc2lvbl9jb3JlfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO2V4cG9ydCpmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIjtpbXBvcnR7dmVyc2lvbl9sYXllcnN9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1sYXllcnNcIjtleHBvcnQqZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1sYXllcnNcIjtpbXBvcnR7dmVyc2lvbl9jb252ZXJ0ZXJ9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXJcIjtleHBvcnQqZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXJcIjtpbXBvcnQqYXMgdGZqc0RhdGEgZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1kYXRhXCI7aW1wb3J0e3ZlcnNpb25fZGF0YX1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWRhdGFcIjtleHBvcnR7dGZqc0RhdGEgYXMgZGF0YX07dmFyIHZlcnNpb249XCIxLjEuMlwiLHZlcnNpb24kMT17XCJ0ZmpzLWNvcmVcIjp2ZXJzaW9uX2NvcmUsXCJ0ZmpzLWRhdGFcIjp2ZXJzaW9uX2RhdGEsXCJ0ZmpzLWxheWVyc1wiOnZlcnNpb25fbGF5ZXJzLFwidGZqcy1jb252ZXJ0ZXJcIjp2ZXJzaW9uX2NvbnZlcnRlcix0ZmpzOnZlcnNpb259O2V4cG9ydHt2ZXJzaW9uJDEgYXMgdmVyc2lvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi5lc20uanMubWFwXG4iLCJ2YXIgYXNuMSA9IGV4cG9ydHM7XG5cbmFzbjEuYmlnbnVtID0gcmVxdWlyZSgnYm4uanMnKTtcblxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FzbjEvYXBpJykuZGVmaW5lO1xuYXNuMS5iYXNlID0gcmVxdWlyZSgnLi9hc24xL2Jhc2UnKTtcbmFzbjEuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9hc24xL2NvbnN0YW50cycpO1xuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9kZWNvZGVycycpO1xuYXNuMS5lbmNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9lbmNvZGVycycpO1xuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgYXBpID0gZXhwb3J0cztcblxuYXBpLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShuYW1lLCBib2R5KSB7XG4gIHJldHVybiBuZXcgRW50aXR5KG5hbWUsIGJvZHkpO1xufTtcblxuZnVuY3Rpb24gRW50aXR5KG5hbWUsIGJvZHkpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICB0aGlzLmRlY29kZXJzID0ge307XG4gIHRoaXMuZW5jb2RlcnMgPSB7fTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2NyZWF0ZU5hbWVkID0gZnVuY3Rpb24gY3JlYXRlTmFtZWQoYmFzZSkge1xuICB2YXIgbmFtZWQ7XG4gIHRyeSB7XG4gICAgbmFtZWQgPSByZXF1aXJlKCd2bScpLnJ1bkluVGhpc0NvbnRleHQoXG4gICAgICAnKGZ1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnKGVudGl0eSkge1xcbicgK1xuICAgICAgJyAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSk7XFxuJyArXG4gICAgICAnfSknXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG5hbWVkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgdGhpcy5faW5pdE5hbWVkKGVudGl0eSk7XG4gICAgfTtcbiAgfVxuICBpbmhlcml0cyhuYW1lZCwgYmFzZSk7XG4gIG5hbWVkLnByb3RvdHlwZS5faW5pdE5hbWVkID0gZnVuY3Rpb24gaW5pdG5hbWVkKGVudGl0eSkge1xuICAgIGJhc2UuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB9O1xuXG4gIHJldHVybiBuZXcgbmFtZWQodGhpcyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXREZWNvZGVyID0gZnVuY3Rpb24gX2dldERlY29kZXIoZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAnZGVyJztcbiAgLy8gTGF6aWx5IGNyZWF0ZSBkZWNvZGVyXG4gIGlmICghdGhpcy5kZWNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZGVjb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZGVjb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmRlY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldERlY29kZXIoZW5jKS5kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9nZXRFbmNvZGVyID0gZnVuY3Rpb24gX2dldEVuY29kZXIoZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAnZGVyJztcbiAgLy8gTGF6aWx5IGNyZWF0ZSBlbmNvZGVyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZW5jb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZW5jb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmVuY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBlbmMsIC8qIGludGVybmFsICovIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmNvZGVyKGVuYykuZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gRGVjb2RlckJ1ZmZlcihiYXNlLCBvcHRpb25zKSB7XG4gIFJlcG9ydGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJhc2UpKSB7XG4gICAgdGhpcy5lcnJvcignSW5wdXQgbm90IEJ1ZmZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuYmFzZSA9IGJhc2U7XG4gIHRoaXMub2Zmc2V0ID0gMDtcbiAgdGhpcy5sZW5ndGggPSBiYXNlLmxlbmd0aDtcbn1cbmluaGVyaXRzKERlY29kZXJCdWZmZXIsIFJlcG9ydGVyKTtcbmV4cG9ydHMuRGVjb2RlckJ1ZmZlciA9IERlY29kZXJCdWZmZXI7XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICByZXR1cm4geyBvZmZzZXQ6IHRoaXMub2Zmc2V0LCByZXBvcnRlcjogUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzKSB9O1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoc2F2ZSkge1xuICAvLyBSZXR1cm4gc2tpcHBlZCBkYXRhXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xuICByZXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldDtcblxuICB0aGlzLm9mZnNldCA9IHNhdmUub2Zmc2V0O1xuICBSZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZS5jYWxsKHRoaXMsIHNhdmUucmVwb3J0ZXIpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0ID09PSB0aGlzLmxlbmd0aDtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChmYWlsKSB7XG4gIGlmICh0aGlzLm9mZnNldCArIDEgPD0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5yZWFkVUludDgodGhpcy5vZmZzZXQrKywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoYnl0ZXMsIGZhaWwpIHtcbiAgaWYgKCEodGhpcy5vZmZzZXQgKyBieXRlcyA8PSB0aGlzLmxlbmd0aCkpXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG5cbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG5cbiAgLy8gU2hhcmUgcmVwb3J0ZXIgc3RhdGVcbiAgcmVzLl9yZXBvcnRlclN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIHJlcy5sZW5ndGggPSB0aGlzLm9mZnNldCArIGJ5dGVzO1xuICB0aGlzLm9mZnNldCArPSBieXRlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gcmF3KHNhdmUpIHtcbiAgcmV0dXJuIHRoaXMuYmFzZS5zbGljZShzYXZlID8gc2F2ZS5vZmZzZXQgOiB0aGlzLm9mZnNldCwgdGhpcy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBFbmNvZGVyQnVmZmVyKHZhbHVlLCByZXBvcnRlcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRW5jb2RlckJ1ZmZlcikpXG4gICAgICAgIGl0ZW0gPSBuZXcgRW5jb2RlckJ1ZmZlcihpdGVtLCByZXBvcnRlcik7XG4gICAgICB0aGlzLmxlbmd0aCArPSBpdGVtLmxlbmd0aDtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoISgwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDB4ZmYpKVxuICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdub24tYnl0ZSBFbmNvZGVyQnVmZmVyIHZhbHVlJyk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgdHlwZW9mIHZhbHVlKTtcbiAgfVxufVxuZXhwb3J0cy5FbmNvZGVyQnVmZmVyID0gRW5jb2RlckJ1ZmZlcjtcblxuRW5jb2RlckJ1ZmZlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ob3V0LCBvZmZzZXQpIHtcbiAgaWYgKCFvdXQpXG4gICAgb3V0ID0gbmV3IEJ1ZmZlcih0aGlzLmxlbmd0aCk7XG4gIGlmICghb2Zmc2V0KVxuICAgIG9mZnNldCA9IDA7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBvdXQ7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICB0aGlzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaXRlbS5qb2luKG91dCwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBpdGVtLmxlbmd0aDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgb3V0W29mZnNldF0gPSB0aGlzLnZhbHVlO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgIG91dC53cml0ZSh0aGlzLnZhbHVlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLnZhbHVlKSlcbiAgICAgIHRoaXMudmFsdWUuY29weShvdXQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4iLCJ2YXIgYmFzZSA9IGV4cG9ydHM7XG5cbmJhc2UuUmVwb3J0ZXIgPSByZXF1aXJlKCcuL3JlcG9ydGVyJykuUmVwb3J0ZXI7XG5iYXNlLkRlY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkRlY29kZXJCdWZmZXI7XG5iYXNlLkVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpLkVuY29kZXJCdWZmZXI7XG5iYXNlLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbiIsInZhciBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5SZXBvcnRlcjtcbnZhciBFbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkVuY29kZXJCdWZmZXI7XG52YXIgRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5EZWNvZGVyQnVmZmVyO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuLy8gU3VwcG9ydGVkIHRhZ3NcbnZhciB0YWdzID0gW1xuICAnc2VxJywgJ3NlcW9mJywgJ3NldCcsICdzZXRvZicsICdvYmppZCcsICdib29sJyxcbiAgJ2dlbnRpbWUnLCAndXRjdGltZScsICdudWxsXycsICdlbnVtJywgJ2ludCcsICdvYmpEZXNjJyxcbiAgJ2JpdHN0cicsICdibXBzdHInLCAnY2hhcnN0cicsICdnZW5zdHInLCAnZ3JhcGhzdHInLCAnaWE1c3RyJywgJ2lzbzY0NnN0cicsXG4gICdudW1zdHInLCAnb2N0c3RyJywgJ3ByaW50c3RyJywgJ3Q2MXN0cicsICd1bmlzdHInLCAndXRmOHN0cicsICd2aWRlb3N0cidcbl07XG5cbi8vIFB1YmxpYyBtZXRob2RzIGxpc3RcbnZhciBtZXRob2RzID0gW1xuICAna2V5JywgJ29iaicsICd1c2UnLCAnb3B0aW9uYWwnLCAnZXhwbGljaXQnLCAnaW1wbGljaXQnLCAnZGVmJywgJ2Nob2ljZScsXG4gICdhbnknLCAnY29udGFpbnMnXG5dLmNvbmNhdCh0YWdzKTtcblxuLy8gT3ZlcnJpZGVkIG1ldGhvZHMgbGlzdFxudmFyIG92ZXJyaWRlZCA9IFtcbiAgJ19wZWVrVGFnJywgJ19kZWNvZGVUYWcnLCAnX3VzZScsXG4gICdfZGVjb2RlU3RyJywgJ19kZWNvZGVPYmppZCcsICdfZGVjb2RlVGltZScsXG4gICdfZGVjb2RlTnVsbCcsICdfZGVjb2RlSW50JywgJ19kZWNvZGVCb29sJywgJ19kZWNvZGVMaXN0JyxcblxuICAnX2VuY29kZUNvbXBvc2l0ZScsICdfZW5jb2RlU3RyJywgJ19lbmNvZGVPYmppZCcsICdfZW5jb2RlVGltZScsXG4gICdfZW5jb2RlTnVsbCcsICdfZW5jb2RlSW50JywgJ19lbmNvZGVCb29sJ1xuXTtcblxuZnVuY3Rpb24gTm9kZShlbmMsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdGhpcy5fYmFzZVN0YXRlID0gc3RhdGU7XG5cbiAgc3RhdGUuZW5jID0gZW5jO1xuXG4gIHN0YXRlLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICBzdGF0ZS5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLy8gU3RhdGVcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuYXJncyA9IG51bGw7XG4gIHN0YXRlLnJldmVyc2VBcmdzID0gbnVsbDtcbiAgc3RhdGUuY2hvaWNlID0gbnVsbDtcbiAgc3RhdGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgc3RhdGUuYW55ID0gZmFsc2U7XG4gIHN0YXRlLm9iaiA9IGZhbHNlO1xuICBzdGF0ZS51c2UgPSBudWxsO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gbnVsbDtcbiAgc3RhdGUua2V5ID0gbnVsbDtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IG51bGw7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVsbDtcbiAgc3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICBzdGF0ZS5jb250YWlucyA9IG51bGw7XG5cbiAgLy8gU2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb24gZWFjaCBtZXRob2RcbiAgaWYgKCFzdGF0ZS5wYXJlbnQpIHtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuX3dyYXAoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgc3RhdGVQcm9wcyA9IFtcbiAgJ2VuYycsICdwYXJlbnQnLCAnY2hpbGRyZW4nLCAndGFnJywgJ2FyZ3MnLCAncmV2ZXJzZUFyZ3MnLCAnY2hvaWNlJyxcbiAgJ29wdGlvbmFsJywgJ2FueScsICdvYmonLCAndXNlJywgJ2FsdGVyZWRVc2UnLCAna2V5JywgJ2RlZmF1bHQnLCAnZXhwbGljaXQnLFxuICAnaW1wbGljaXQnLCAnY29udGFpbnMnXG5dO1xuXG5Ob2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBjc3RhdGUgPSB7fTtcbiAgc3RhdGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBjc3RhdGVbcHJvcF0gPSBzdGF0ZVtwcm9wXTtcbiAgfSk7XG4gIHZhciByZXMgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihjc3RhdGUucGFyZW50KTtcbiAgcmVzLl9iYXNlU3RhdGUgPSBjc3RhdGU7XG4gIHJldHVybiByZXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fd3JhcCA9IGZ1bmN0aW9uIHdyYXAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uIF93cmFwcGVkTWV0aG9kKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNsb25lKTtcbiAgICAgIHJldHVybiBjbG9uZVttZXRob2RdLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIHRoaXMpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGJvZHkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBib2R5LmNhbGwodGhpcyk7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuXG4gIHN0YXRlLmNoaWxkcmVuID0gc3RhdGUuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID09PSB0aGlzO1xuICB9LCB0aGlzKTtcbiAgYXNzZXJ0LmVxdWFsKHN0YXRlLmNoaWxkcmVuLmxlbmd0aCwgMSwgJ1Jvb3Qgbm9kZSBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZCcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3VzZUFyZ3MgPSBmdW5jdGlvbiB1c2VBcmdzKGFyZ3MpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlbiBhbmQgYXJnc1xuICB2YXIgY2hpbGRyZW4gPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfSwgdGhpcyk7XG4gIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gIShhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5jaGlsZHJlbiA9PT0gbnVsbCk7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgIC8vIFJlcGxhY2UgcGFyZW50IHRvIG1haW50YWluIGJhY2t3YXJkIGxpbmtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9IHRoaXM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmFyZ3MgPT09IG51bGwpO1xuICAgIHN0YXRlLmFyZ3MgPSBhcmdzO1xuICAgIHN0YXRlLnJldmVyc2VBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpXG4gICAgICAgIHJldHVybiBhcmc7XG5cbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSAoa2V5IHwgMCkpXG4gICAgICAgICAga2V5IHw9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ1trZXldO1xuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuLy8gT3ZlcnJpZGVkIG1ldGhvZHNcbi8vXG5cbm92ZXJyaWRlZC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkIGZvciBlbmNvZGluZzogJyArIHN0YXRlLmVuYyk7XG4gIH07XG59KTtcblxuLy9cbi8vIFB1YmxpYyBtZXRob2RzXG4vL1xuXG50YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gIE5vZGUucHJvdG90eXBlW3RhZ10gPSBmdW5jdGlvbiBfdGFnTWV0aG9kKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhc3NlcnQoc3RhdGUudGFnID09PSBudWxsKTtcbiAgICBzdGF0ZS50YWcgPSB0YWc7XG5cbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuTm9kZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGl0ZW0pIHtcbiAgYXNzZXJ0KGl0ZW0pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZSA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vcHRpb25hbCA9IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZGVmID0gZnVuY3Rpb24gZGVmKHZhbCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gdmFsO1xuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5leHBsaWNpdCA9IGZ1bmN0aW9uIGV4cGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuZXhwbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pbXBsaWNpdCA9IGZ1bmN0aW9uIGltcGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuaW1wbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vYmogPSBmdW5jdGlvbiBvYmooKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIHN0YXRlLm9iaiA9IHRydWU7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKVxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiBrZXkobmV3S2V5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUua2V5ID09PSBudWxsKTtcbiAgc3RhdGUua2V5ID0gbmV3S2V5O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gYW55KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUuYW55ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNob2ljZSA9IGZ1bmN0aW9uIGNob2ljZShvYmopIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5jaG9pY2UgPT09IG51bGwpO1xuICBzdGF0ZS5jaG9pY2UgPSBvYmo7XG4gIHRoaXMuX3VzZUFyZ3MoT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9KSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGl0ZW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS51c2UgPT09IG51bGwpO1xuICBzdGF0ZS5jb250YWlucyA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRGVjb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gaW5wdXQud3JhcFJlc3VsdChzdGF0ZS5jaGlsZHJlblswXS5fZGVjb2RlKGlucHV0LCBvcHRpb25zKSk7XG5cbiAgdmFyIHJlc3VsdCA9IHN0YXRlWydkZWZhdWx0J107XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICB2YXIgcHJldktleSA9IG51bGw7XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwpXG4gICAgcHJldktleSA9IGlucHV0LmVudGVyS2V5KHN0YXRlLmtleSk7XG5cbiAgLy8gQ2hlY2sgaWYgdGFnIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCkge1xuICAgIHZhciB0YWcgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmV4cGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuaW1wbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCAmJiAhc3RhdGUuYW55KSB7XG4gICAgICAvLyBUcmlhbCBhbmQgRXJyb3JcbiAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgcHJlc2VudCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXNlbnQgPSB0aGlzLl9wZWVrVGFnKGlucHV0LCB0YWcsIHN0YXRlLmFueSk7XG5cbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKHByZXNlbnQpKVxuICAgICAgICByZXR1cm4gcHJlc2VudDtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIG9iamVjdCBvbiBzdGFja1xuICB2YXIgcHJldk9iajtcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHByZXZPYmogPSBpbnB1dC5lbnRlck9iamVjdCgpO1xuXG4gIGlmIChwcmVzZW50KSB7XG4gICAgLy8gVW53cmFwIGV4cGxpY2l0IHZhbHVlc1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGV4cGxpY2l0ID0gdGhpcy5fZGVjb2RlVGFnKGlucHV0LCBzdGF0ZS5leHBsaWNpdCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihleHBsaWNpdCkpXG4gICAgICAgIHJldHVybiBleHBsaWNpdDtcbiAgICAgIGlucHV0ID0gZXhwbGljaXQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gaW5wdXQub2Zmc2V0O1xuXG4gICAgLy8gVW53cmFwIGltcGxpY2l0IGFuZCBub3JtYWwgdmFsdWVzXG4gICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kZWNvZGVUYWcoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnLFxuICAgICAgICBzdGF0ZS5hbnlcbiAgICAgICk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihib2R5KSlcbiAgICAgICAgcmV0dXJuIGJvZHk7XG5cbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHJlc3VsdCA9IGlucHV0LnJhdyhzYXZlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgaW5wdXQgPSBib2R5O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIHN0YXJ0LCBpbnB1dC5sZW5ndGgsICd0YWdnZWQnKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIGlucHV0Lm9mZnNldCwgaW5wdXQubGVuZ3RoLCAnY29udGVudCcpO1xuXG4gICAgLy8gU2VsZWN0IHByb3BlciBtZXRob2QgZm9yIHRhZ1xuICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICByZXN1bHQgPSByZXN1bHQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0LCBvcHRpb25zKTtcbiAgICBlbHNlXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlucHV0LmlzRXJyb3IocmVzdWx0KSlcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAvLyBEZWNvZGUgY2hpbGRyZW5cbiAgICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwgJiYgc3RhdGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gZGVjb2RlQ2hpbGRyZW4oY2hpbGQpIHtcbiAgICAgICAgLy8gTk9URTogV2UgYXJlIGlnbm9yaW5nIGVycm9ycyBoZXJlLCB0byBsZXQgcGFyc2VyIGNvbnRpbnVlIHdpdGggb3RoZXJcbiAgICAgICAgLy8gcGFydHMgb2YgZW5jb2RlZCBkYXRhXG4gICAgICAgIGNoaWxkLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIGNvbnRhaW5lZC9lbmNvZGVkIGJ5IHNjaGVtYSwgb25seSBpbiBiaXQgb3Igb2N0ZXQgc3RyaW5nc1xuICAgIGlmIChzdGF0ZS5jb250YWlucyAmJiAoc3RhdGUudGFnID09PSAnb2N0c3RyJyB8fCBzdGF0ZS50YWcgPT09ICdiaXRzdHInKSkge1xuICAgICAgdmFyIGRhdGEgPSBuZXcgRGVjb2RlckJ1ZmZlcihyZXN1bHQpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLmNvbnRhaW5zLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAgICAgLl9kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wIG9iamVjdFxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcmVzdWx0ID0gaW5wdXQubGVhdmVPYmplY3QocHJldk9iaik7XG5cbiAgLy8gU2V0IGtleVxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsICYmIChyZXN1bHQgIT09IG51bGwgfHwgcHJlc2VudCA9PT0gdHJ1ZSkpXG4gICAgaW5wdXQubGVhdmVLZXkocHJldktleSwgc3RhdGUua2V5LCByZXN1bHQpO1xuICBlbHNlIGlmIChwcmV2S2V5ICE9PSBudWxsKVxuICAgIGlucHV0LmV4aXRLZXkocHJldktleSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVHZW5lcmljID0gZnVuY3Rpb24gZGVjb2RlR2VuZXJpYyh0YWcsIGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAodGFnID09PSAnc2VxJyB8fCB0YWcgPT09ICdzZXQnKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodGFnID09PSAnc2Vxb2YnIHx8IHRhZyA9PT0gJ3NldG9mJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTGlzdChpbnB1dCwgdGFnLCBzdGF0ZS5hcmdzWzBdLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAoL3N0ciQvLnRlc3QodGFnKSlcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcgJiYgc3RhdGUuYXJncylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIHN0YXRlLmFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBudWxsLCBudWxsLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVRpbWUoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTnVsbChpbnB1dCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVCb29sKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaW50JyB8fCB0YWcgPT09ICdlbnVtJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlSW50KGlucHV0LCBzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuXG4gIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKVxuICAgICAgICAuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCd1bmtub3duIHRhZzogJyArIHRhZyk7XG4gIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLl9nZXRVc2UgPSBmdW5jdGlvbiBfZ2V0VXNlKGVudGl0eSwgb2JqKSB7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAvLyBDcmVhdGUgYWx0ZXJlZCB1c2UgZGVjb2RlciBpZiBpbXBsaWNpdCBpcyBzZXRcbiAgc3RhdGUudXNlRGVjb2RlciA9IHRoaXMuX3VzZShlbnRpdHksIG9iaik7XG4gIGFzc2VydChzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5jaGlsZHJlblswXTtcbiAgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQpIHtcbiAgICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5jbG9uZSgpO1xuICAgIHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IHN0YXRlLmltcGxpY2l0O1xuICB9XG4gIHJldHVybiBzdGF0ZS51c2VEZWNvZGVyO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUNob2ljZSA9IGZ1bmN0aW9uIGRlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICBPYmplY3Qua2V5cyhzdGF0ZS5jaG9pY2UpLnNvbWUoZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgdmFyIG5vZGUgPSBzdGF0ZS5jaG9pY2Vba2V5XTtcbiAgICB0cnkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXN1bHQgPSB7IHR5cGU6IGtleSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICBtYXRjaCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIHRoaXMpO1xuXG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCdDaG9pY2Ugbm90IG1hdGNoZWQnKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy9cbi8vIEVuY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fY3JlYXRlRW5jb2RlckJ1ZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSkge1xuICByZXR1cm4gbmV3IEVuY29kZXJCdWZmZXIoZGF0YSwgdGhpcy5yZXBvcnRlcik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbCAmJiBzdGF0ZVsnZGVmYXVsdCddID09PSBkYXRhKVxuICAgIHJldHVybjtcblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZW5jb2RlVmFsdWUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCk7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm47XG5cbiAgaWYgKHRoaXMuX3NraXBEZWZhdWx0KHJlc3VsdCwgcmVwb3J0ZXIsIHBhcmVudCkpXG4gICAgcmV0dXJuO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBzdGF0ZS5jaGlsZHJlblswXS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyIHx8IG5ldyBSZXBvcnRlcigpKTtcblxuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAvLyBTZXQgcmVwb3J0ZXIgdG8gc2hhcmUgaXQgd2l0aCBhIGNoaWxkIGNsYXNzXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcblxuICAvLyBDaGVjayBpZiBkYXRhIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbClcbiAgICAgIGRhdGEgPSBzdGF0ZVsnZGVmYXVsdCddXG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5jb2RlIGNoaWxkcmVuIGZpcnN0XG4gIHZhciBjb250ZW50ID0gbnVsbDtcbiAgdmFyIHByaW1pdGl2ZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuYW55KSB7XG4gICAgLy8gQW55dGhpbmcgdGhhdCB3YXMgZ2l2ZW4gaXMgdHJhbnNsYXRlZCB0byBidWZmZXJcbiAgICByZXN1bHQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNob2ljZSkge1xuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcik7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY29udGFpbnMpIHtcbiAgICBjb250ZW50ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLmNvbnRhaW5zLCBwYXJlbnQpLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xuICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hpbGRyZW4pIHtcbiAgICBjb250ZW50ID0gc3RhdGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS50YWcgPT09ICdudWxsXycpXG4gICAgICAgIHJldHVybiBjaGlsZC5fZW5jb2RlKG51bGwsIHJlcG9ydGVyLCBkYXRhKTtcblxuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUua2V5ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIHNob3VsZCBoYXZlIGEga2V5Jyk7XG4gICAgICB2YXIgcHJldktleSA9IHJlcG9ydGVyLmVudGVyS2V5KGNoaWxkLl9iYXNlU3RhdGUua2V5KTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdDaGlsZCBleHBlY3RlZCwgYnV0IGlucHV0IGlzIG5vdCBvYmplY3QnKTtcblxuICAgICAgdmFyIHJlcyA9IGNoaWxkLl9lbmNvZGUoZGF0YVtjaGlsZC5fYmFzZVN0YXRlLmtleV0sIHJlcG9ydGVyLCBkYXRhKTtcbiAgICAgIHJlcG9ydGVyLmxlYXZlS2V5KHByZXZLZXkpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICAgIGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICdzZXFvZicgfHwgc3RhdGUudGFnID09PSAnc2V0b2YnKSB7XG4gICAgICAvLyBUT0RPKGluZHV0bnkpOiB0aGlzIHNob3VsZCBiZSB0aHJvd24gb24gRFNMIGxldmVsXG4gICAgICBpZiAoIShzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3MubGVuZ3RoID09PSAxKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdUb28gbWFueSBhcmdzIGZvciA6ICcgKyBzdGF0ZS50YWcpO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignc2Vxb2Yvc2V0b2YsIGJ1dCBkYXRhIGlzIG5vdCBBcnJheScpO1xuXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLmltcGxpY2l0ID0gbnVsbDtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUuYXJnc1swXSwgZGF0YSkuX2VuY29kZShpdGVtLCByZXBvcnRlcik7XG4gICAgICB9LCBjaGlsZCkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUudXNlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBwYXJlbnQpLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5fZW5jb2RlUHJpbWl0aXZlKHN0YXRlLnRhZywgZGF0YSk7XG4gICAgICBwcmltaXRpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVuY29kZSBkYXRhIGl0c2VsZlxuICB2YXIgcmVzdWx0O1xuICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICB2YXIgdGFnID0gc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZztcbiAgICB2YXIgY2xzID0gc3RhdGUuaW1wbGljaXQgPT09IG51bGwgPyAndW5pdmVyc2FsJyA6ICdjb250ZXh0JztcblxuICAgIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlcG9ydGVyLmVycm9yKCdUYWcgY291bGQgYmUgb21pdHRlZCBvbmx5IGZvciAudXNlKCknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHRhZywgcHJpbWl0aXZlLCBjbHMsIGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXAgaW4gZXhwbGljaXRcbiAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZShzdGF0ZS5leHBsaWNpdCwgZmFsc2UsICdjb250ZXh0JywgcmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZUNob2ljZSA9IGZ1bmN0aW9uIGVuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgdmFyIG5vZGUgPSBzdGF0ZS5jaG9pY2VbZGF0YS50eXBlXTtcbiAgaWYgKCFub2RlKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZGF0YS50eXBlICsgJyBub3QgZm91bmQgaW4gJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzdGF0ZS5jaG9pY2UpKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuX2VuY29kZShkYXRhLnZhbHVlLCByZXBvcnRlcik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlUHJpbWl0aXZlID0gZnVuY3Rpb24gZW5jb2RlUHJpbWl0aXZlKHRhZywgZGF0YSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKC9zdHIkLy50ZXN0KHRhZykpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcgJiYgc3RhdGUuYXJncylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgc3RhdGUucmV2ZXJzZUFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIG51bGwsIG51bGwpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlVGltZShkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU51bGwoKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaW50JyB8fCB0YWcgPT09ICdlbnVtJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlSW50KGRhdGEsIHN0YXRlLmFyZ3MgJiYgc3RhdGUucmV2ZXJzZUFyZ3NbMF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlQm9vbChkYXRhKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0YWc6ICcgKyB0YWcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzTnVtc3RyID0gZnVuY3Rpb24gaXNOdW1zdHIoc3RyKSB7XG4gIHJldHVybiAvXlswLTkgXSokLy50ZXN0KHN0cik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNQcmludHN0ciA9IGZ1bmN0aW9uIGlzUHJpbnRzdHIoc3RyKSB7XG4gIHJldHVybiAvXltBLVphLXowLTkgJ1xcKFxcKVxcKyxcXC1cXC5cXC86PVxcP10qJC8udGVzdChzdHIpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIFJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5fcmVwb3J0ZXJTdGF0ZSA9IHtcbiAgICBvYmo6IG51bGwsXG4gICAgcGF0aDogW10sXG4gICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcbiAgICBlcnJvcnM6IFtdXG4gIH07XG59XG5leHBvcnRzLlJlcG9ydGVyID0gUmVwb3J0ZXI7XG5cblJlcG9ydGVyLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmV0dXJuIHsgb2JqOiBzdGF0ZS5vYmosIHBhdGhMZW46IHN0YXRlLnBhdGgubGVuZ3RoIH07XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZGF0YSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLm9iaiA9IGRhdGEub2JqO1xuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBkYXRhLnBhdGhMZW4pO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyS2V5ID0gZnVuY3Rpb24gZW50ZXJLZXkoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGgucHVzaChrZXkpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmV4aXRLZXkgPSBmdW5jdGlvbiBleGl0S2V5KGluZGV4KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgaW5kZXggLSAxKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZUtleSA9IGZ1bmN0aW9uIGxlYXZlS2V5KGluZGV4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdGhpcy5leGl0S2V5KGluZGV4KTtcbiAgaWYgKHN0YXRlLm9iaiAhPT0gbnVsbClcbiAgICBzdGF0ZS5vYmpba2V5XSA9IHZhbHVlO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLmpvaW4oJy8nKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlck9iamVjdCA9IGZ1bmN0aW9uIGVudGVyT2JqZWN0KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBwcmV2ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSB7fTtcbiAgcmV0dXJuIHByZXY7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVPYmplY3QgPSBmdW5jdGlvbiBsZWF2ZU9iamVjdChwcmV2KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIG5vdyA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0gcHJldjtcbiAgcmV0dXJuIG5vdztcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB2YXIgZXJyO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBpbmhlcml0ZWQgPSBtc2cgaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xuICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgZXJyID0gbXNnO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IG5ldyBSZXBvcnRlckVycm9yKHN0YXRlLnBhdGgubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiAnWycgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArICddJztcbiAgICB9KS5qb2luKCcnKSwgbXNnLm1lc3NhZ2UgfHwgbXNnLCBtc2cuc3RhY2spO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgdGhyb3cgZXJyO1xuXG4gIGlmICghaW5oZXJpdGVkKVxuICAgIHN0YXRlLmVycm9ycy5wdXNoKGVycik7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS53cmFwUmVzdWx0ID0gZnVuY3Rpb24gd3JhcFJlc3VsdChyZXN1bHQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICByZXR1cm4ge1xuICAgIHJlc3VsdDogdGhpcy5pc0Vycm9yKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0LFxuICAgIGVycm9yczogc3RhdGUuZXJyb3JzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBSZXBvcnRlckVycm9yKHBhdGgsIG1zZykge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLnJldGhyb3cobXNnKTtcbn07XG5pbmhlcml0cyhSZXBvcnRlckVycm9yLCBFcnJvcik7XG5cblJlcG9ydGVyRXJyb3IucHJvdG90eXBlLnJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KG1zZykge1xuICB0aGlzLm1lc3NhZ2UgPSBtc2cgKyAnIGF0OiAnICsgKHRoaXMucGF0aCB8fCAnKHNoYWxsb3cpJyk7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXBvcnRlckVycm9yKTtcblxuICBpZiAoIXRoaXMuc3RhY2spIHtcbiAgICB0cnkge1xuICAgICAgLy8gSUUgb25seSBhZGRzIHN0YWNrIHdoZW4gdGhyb3duXG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5tZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5leHBvcnRzLnRhZ0NsYXNzID0ge1xuICAwOiAndW5pdmVyc2FsJyxcbiAgMTogJ2FwcGxpY2F0aW9uJyxcbiAgMjogJ2NvbnRleHQnLFxuICAzOiAncHJpdmF0ZSdcbn07XG5leHBvcnRzLnRhZ0NsYXNzQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnQ2xhc3MpO1xuXG5leHBvcnRzLnRhZyA9IHtcbiAgMHgwMDogJ2VuZCcsXG4gIDB4MDE6ICdib29sJyxcbiAgMHgwMjogJ2ludCcsXG4gIDB4MDM6ICdiaXRzdHInLFxuICAweDA0OiAnb2N0c3RyJyxcbiAgMHgwNTogJ251bGxfJyxcbiAgMHgwNjogJ29iamlkJyxcbiAgMHgwNzogJ29iakRlc2MnLFxuICAweDA4OiAnZXh0ZXJuYWwnLFxuICAweDA5OiAncmVhbCcsXG4gIDB4MGE6ICdlbnVtJyxcbiAgMHgwYjogJ2VtYmVkJyxcbiAgMHgwYzogJ3V0ZjhzdHInLFxuICAweDBkOiAncmVsYXRpdmVPaWQnLFxuICAweDEwOiAnc2VxJyxcbiAgMHgxMTogJ3NldCcsXG4gIDB4MTI6ICdudW1zdHInLFxuICAweDEzOiAncHJpbnRzdHInLFxuICAweDE0OiAndDYxc3RyJyxcbiAgMHgxNTogJ3ZpZGVvc3RyJyxcbiAgMHgxNjogJ2lhNXN0cicsXG4gIDB4MTc6ICd1dGN0aW1lJyxcbiAgMHgxODogJ2dlbnRpbWUnLFxuICAweDE5OiAnZ3JhcGhzdHInLFxuICAweDFhOiAnaXNvNjQ2c3RyJyxcbiAgMHgxYjogJ2dlbnN0cicsXG4gIDB4MWM6ICd1bmlzdHInLFxuICAweDFkOiAnY2hhcnN0cicsXG4gIDB4MWU6ICdibXBzdHInXG59O1xuZXhwb3J0cy50YWdCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWcpO1xuIiwidmFyIGNvbnN0YW50cyA9IGV4cG9ydHM7XG5cbi8vIEhlbHBlclxuY29uc3RhbnRzLl9yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShtYXApIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBDb252ZXJ0IGtleSB0byBpbnRlZ2VyIGlmIGl0IGlzIHN0cmluZ2lmaWVkXG4gICAgaWYgKChrZXkgfCAwKSA9PSBrZXkpXG4gICAgICBrZXkgPSBrZXkgfCAwO1xuXG4gICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0YW50cy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi8uLi9hc24xJyk7XG52YXIgYmFzZSA9IGFzbjEuYmFzZTtcbnZhciBiaWdudW0gPSBhc24xLmJpZ251bTtcblxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcbnZhciBkZXIgPSBhc24xLmNvbnN0YW50cy5kZXI7XG5cbmZ1bmN0aW9uIERFUkRlY29kZXIoZW50aXR5KSB7XG4gIHRoaXMuZW5jID0gJ2Rlcic7XG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcblxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XG4gIHRoaXMudHJlZS5faW5pdChlbnRpdHkuYm9keSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBERVJEZWNvZGVyO1xuXG5ERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBpZiAoIShkYXRhIGluc3RhbmNlb2YgYmFzZS5EZWNvZGVyQnVmZmVyKSlcbiAgICBkYXRhID0gbmV3IGJhc2UuRGVjb2RlckJ1ZmZlcihkYXRhLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy50cmVlLl9kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vLyBUcmVlIG1ldGhvZHNcblxuZnVuY3Rpb24gREVSTm9kZShwYXJlbnQpIHtcbiAgYmFzZS5Ob2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBiYXNlLk5vZGUpO1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fcGVla1RhZyA9IGZ1bmN0aW9uIHBlZWtUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICBpZiAoYnVmZmVyLmlzRW1wdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCAnRmFpbGVkIHRvIHBlZWsgdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcblxuICByZXR1cm4gZGVjb2RlZFRhZy50YWcgPT09IHRhZyB8fCBkZWNvZGVkVGFnLnRhZ1N0ciA9PT0gdGFnIHx8XG4gICAgKGRlY29kZWRUYWcudGFnU3RyICsgJ29mJykgPT09IHRhZyB8fCBhbnk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGFnID0gZnVuY3Rpb24gZGVjb2RlVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgdmFyIGRlY29kZWRUYWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY29kZSB0YWcgb2YgXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkVGFnLnByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBsZW5ndGggb2YgXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gRmFpbHVyZVxuICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIGlmICghYW55ICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZyAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciAhPT0gdGFnICYmXG4gICAgICBkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicgIT09IHRhZykge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICB9XG5cbiAgaWYgKGRlY29kZWRUYWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoLi4uIGZpbmQgRU5EIHRhZ1xuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKFxuICAgICAgYnVmZmVyLFxuICAgICAgJ0ZhaWxlZCB0byBza2lwIGluZGVmaW5pdGUgbGVuZ3RoIGJvZHk6IFwiJyArIHRoaXMudGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG5cbiAgbGVuID0gYnVmZmVyLm9mZnNldCAtIHN0YXRlLm9mZnNldDtcbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuICByZXR1cm4gYnVmZmVyLnNraXAobGVuLCAnRmFpbGVkIHRvIG1hdGNoIGJvZHkgb2Y6IFwiJyArIHRhZyArICdcIicpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBVbnRpbEVuZCA9IGZ1bmN0aW9uIHNraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgdGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHRhZykpXG4gICAgICByZXR1cm4gdGFnO1xuICAgIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLCB0YWcucHJpbWl0aXZlLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IobGVuKSlcbiAgICAgIHJldHVybiBsZW47XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0YWcucHJpbWl0aXZlIHx8IGxlbiAhPT0gbnVsbClcbiAgICAgIHJlcyA9IGJ1ZmZlci5za2lwKGxlbilcbiAgICBlbHNlXG4gICAgICByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKTtcblxuICAgIC8vIEZhaWx1cmVcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICAgIHJldHVybiByZXM7XG5cbiAgICBpZiAodGFnLnRhZ1N0ciA9PT0gJ2VuZCcpXG4gICAgICBicmVhaztcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUxpc3QgPSBmdW5jdGlvbiBkZWNvZGVMaXN0KGJ1ZmZlciwgdGFnLCBkZWNvZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgcG9zc2libGVFbmQgPSB0aGlzLl9wZWVrVGFnKGJ1ZmZlciwgJ2VuZCcpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihwb3NzaWJsZUVuZCkpXG4gICAgICByZXR1cm4gcG9zc2libGVFbmQ7XG5cbiAgICB2YXIgcmVzID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLCAnZGVyJywgb3B0aW9ucyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykgJiYgcG9zc2libGVFbmQpXG4gICAgICBicmVhaztcbiAgICByZXN1bHQucHVzaChyZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlU3RyID0gZnVuY3Rpb24gZGVjb2RlU3RyKGJ1ZmZlciwgdGFnKSB7XG4gIGlmICh0YWcgPT09ICdiaXRzdHInKSB7XG4gICAgdmFyIHVudXNlZCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodW51c2VkKSlcbiAgICAgIHJldHVybiB1bnVzZWQ7XG4gICAgcmV0dXJuIHsgdW51c2VkOiB1bnVzZWQsIGRhdGE6IGJ1ZmZlci5yYXcoKSB9O1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JtcHN0cicpIHtcbiAgICB2YXIgcmF3ID0gYnVmZmVyLnJhdygpO1xuICAgIGlmIChyYXcubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiBibXBzdHIgbGVuZ3RoIG1pc21hdGNoJyk7XG5cbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyYXcucmVhZFVJbnQxNkJFKGkgKiAyKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnbnVtc3RyJykge1xuICAgIHZhciBudW1zdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgaWYgKCF0aGlzLl9pc051bXN0cihudW1zdHIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdudW1zdHIgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtc3RyO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29jdHN0cicpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdwcmludHN0cicpIHtcbiAgICB2YXIgcHJpbnRzdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoJ2FzY2lpJyk7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW50c3RyKHByaW50c3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAncHJpbnRzdHIgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbnRzdHI7XG4gIH0gZWxzZSBpZiAoL3N0ciQvLnRlc3QodGFnKSkge1xuICAgIHJldHVybiBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArICcgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU9iamlkID0gZnVuY3Rpb24gZGVjb2RlT2JqaWQoYnVmZmVyLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIHZhciByZXN1bHQ7XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICB2YXIgaWRlbnQgPSAwO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgc3ViaWRlbnQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWRlbnQgPDw9IDc7XG4gICAgaWRlbnQgfD0gc3ViaWRlbnQgJiAweDdmO1xuICAgIGlmICgoc3ViaWRlbnQgJiAweDgwKSA9PT0gMCkge1xuICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG4gICAgICBpZGVudCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChzdWJpZGVudCAmIDB4ODApXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG5cbiAgdmFyIGZpcnN0ID0gKGlkZW50aWZpZXJzWzBdIC8gNDApIHwgMDtcbiAgdmFyIHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XG5cbiAgaWYgKHJlbGF0aXZlKVxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xuICBlbHNlXG4gICAgcmVzdWx0ID0gW2ZpcnN0LCBzZWNvbmRdLmNvbmNhdChpZGVudGlmaWVycy5zbGljZSgxKSk7XG5cbiAgaWYgKHZhbHVlcykge1xuICAgIHZhciB0bXAgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJyAnKV07XG4gICAgaWYgKHRtcCA9PT0gdW5kZWZpbmVkKVxuICAgICAgdG1wID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcuJyldO1xuICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZClcbiAgICAgIHJlc3VsdCA9IHRtcDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlVGltZSA9IGZ1bmN0aW9uIGRlY29kZVRpbWUoYnVmZmVyLCB0YWcpIHtcbiAgdmFyIHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICB2YXIgeWVhciA9IHN0ci5zbGljZSgwLCA0KSB8IDA7XG4gICAgdmFyIG1vbiA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XG4gICAgdmFyIGRheSA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIGhvdXIgPSBzdHIuc2xpY2UoOCwgMTApIHwgMDtcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTIsIDE0KSB8IDA7XG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcbiAgICB2YXIgeWVhciA9IHN0ci5zbGljZSgwLCAyKSB8IDA7XG4gICAgdmFyIG1vbiA9IHN0ci5zbGljZSgyLCA0KSB8IDA7XG4gICAgdmFyIGRheSA9IHN0ci5zbGljZSg0LCA2KSB8IDA7XG4gICAgdmFyIGhvdXIgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoOCwgMTApIHwgMDtcbiAgICB2YXIgc2VjID0gc3RyLnNsaWNlKDEwLCAxMikgfCAwO1xuICAgIGlmICh5ZWFyIDwgNzApXG4gICAgICB5ZWFyID0gMjAwMCArIHllYXI7XG4gICAgZWxzZVxuICAgICAgeWVhciA9IDE5MDAgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVOdWxsID0gZnVuY3Rpb24gZGVjb2RlTnVsbChidWZmZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlQm9vbCA9IGZ1bmN0aW9uIGRlY29kZUJvb2woYnVmZmVyKSB7XG4gIHZhciByZXMgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzICE9PSAwO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChidWZmZXIsIHZhbHVlcykge1xuICAvLyBCaWdpbnQsIHJldHVybiBhcyBpdCBpcyAoYXNzdW1lIGJpZyBlbmRpYW4pXG4gIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gIHZhciByZXMgPSBuZXcgYmlnbnVtKHJhdyk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXMgPSB2YWx1ZXNbcmVzLnRvU3RyaW5nKDEwKV0gfHwgcmVzO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXREZWNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGRlckRlY29kZVRhZyhidWYsIGZhaWwpIHtcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcih0YWcpKVxuICAgIHJldHVybiB0YWc7XG5cbiAgdmFyIGNscyA9IGRlci50YWdDbGFzc1t0YWcgPj4gNl07XG4gIHZhciBwcmltaXRpdmUgPSAodGFnICYgMHgyMCkgPT09IDA7XG5cbiAgLy8gTXVsdGktb2N0ZXQgdGFnIC0gbG9hZFxuICBpZiAoKHRhZyAmIDB4MWYpID09PSAweDFmKSB7XG4gICAgdmFyIG9jdCA9IHRhZztcbiAgICB0YWcgPSAwO1xuICAgIHdoaWxlICgob2N0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIG9jdCA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgICBpZiAoYnVmLmlzRXJyb3Iob2N0KSlcbiAgICAgICAgcmV0dXJuIG9jdDtcblxuICAgICAgdGFnIDw8PSA3O1xuICAgICAgdGFnIHw9IG9jdCAmIDB4N2Y7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhZyAmPSAweDFmO1xuICB9XG4gIHZhciB0YWdTdHIgPSBkZXIudGFnW3RhZ107XG5cbiAgcmV0dXJuIHtcbiAgICBjbHM6IGNscyxcbiAgICBwcmltaXRpdmU6IHByaW1pdGl2ZSxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWdTdHI6IHRhZ1N0clxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXJEZWNvZGVMZW4oYnVmLCBwcmltaXRpdmUsIGZhaWwpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgLy8gSW5kZWZpbml0ZSBmb3JtXG4gIGlmICghcHJpbWl0aXZlICYmIGxlbiA9PT0gMHg4MClcbiAgICByZXR1cm4gbnVsbDtcblxuICAvLyBEZWZpbml0ZSBmb3JtXG4gIGlmICgobGVuICYgMHg4MCkgPT09IDApIHtcbiAgICAvLyBTaG9ydCBmb3JtXG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICB2YXIgbnVtID0gbGVuICYgMHg3ZjtcbiAgaWYgKG51bSA+IDQpXG4gICAgcmV0dXJuIGJ1Zi5lcnJvcignbGVuZ3RoIG9jdGVjdCBpcyB0b28gbG9uZycpO1xuXG4gIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBsZW4gPDw9IDg7XG4gICAgdmFyIGogPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICAgIGlmIChidWYuaXNFcnJvcihqKSlcbiAgICAgIHJldHVybiBqO1xuICAgIGxlbiB8PSBqO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn1cbiIsInZhciBkZWNvZGVycyA9IGV4cG9ydHM7XG5cbmRlY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5kZWNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBERVJEZWNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRGVjb2RlcihlbnRpdHkpIHtcbiAgREVSRGVjb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRGVjb2RlciwgREVSRGVjb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTURlY29kZXI7XG5cblBFTURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBsaW5lcyA9IGRhdGEudG9TdHJpbmcoKS5zcGxpdCgvW1xcclxcbl0rL2cpO1xuXG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwudG9VcHBlckNhc2UoKTtcblxuICB2YXIgcmUgPSAvXi0tLS0tKEJFR0lOfEVORCkgKFteLV0rKS0tLS0tJC87XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lc1tpXS5tYXRjaChyZSk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAobWF0Y2hbMl0gIT09IGxhYmVsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdCRUdJTicpXG4gICAgICAgIGJyZWFrO1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdFTkQnKVxuICAgICAgICBicmVhaztcbiAgICAgIGVuZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcignUEVNIHNlY3Rpb24gbm90IGZvdW5kIGZvcjogJyArIGxhYmVsKTtcblxuICB2YXIgYmFzZTY0ID0gbGluZXMuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLmpvaW4oJycpO1xuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHN5bWJvbHNcbiAgYmFzZTY0LnJlcGxhY2UoL1teYS16MC05XFwrXFwvPV0rL2dpLCAnJyk7XG5cbiAgdmFyIGlucHV0ID0gbmV3IEJ1ZmZlcihiYXNlNjQsICdiYXNlNjQnKTtcbiAgcmV0dXJuIERFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIGlucHV0LCBvcHRpb25zKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi8uLi9hc24xJyk7XG52YXIgYmFzZSA9IGFzbjEuYmFzZTtcblxuLy8gSW1wb3J0IERFUiBjb25zdGFudHNcbnZhciBkZXIgPSBhc24xLmNvbnN0YW50cy5kZXI7XG5cbmZ1bmN0aW9uIERFUkVuY29kZXIoZW50aXR5KSB7XG4gIHRoaXMuZW5jID0gJ2Rlcic7XG4gIHRoaXMubmFtZSA9IGVudGl0eS5uYW1lO1xuICB0aGlzLmVudGl0eSA9IGVudGl0eTtcblxuICAvLyBDb25zdHJ1Y3QgYmFzZSB0cmVlXG4gIHRoaXMudHJlZSA9IG5ldyBERVJOb2RlKCk7XG4gIHRoaXMudHJlZS5faW5pdChlbnRpdHkuYm9keSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBERVJFbmNvZGVyO1xuXG5ERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMudHJlZS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKS5qb2luKCk7XG59O1xuXG4vLyBUcmVlIG1ldGhvZHNcblxuZnVuY3Rpb24gREVSTm9kZShwYXJlbnQpIHtcbiAgYmFzZS5Ob2RlLmNhbGwodGhpcywgJ2RlcicsIHBhcmVudCk7XG59XG5pbmhlcml0cyhERVJOb2RlLCBiYXNlLk5vZGUpO1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQ29tcG9zaXRlID0gZnVuY3Rpb24gZW5jb2RlQ29tcG9zaXRlKHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQpIHtcbiAgdmFyIGVuY29kZWRUYWcgPSBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgdGhpcy5yZXBvcnRlcik7XG5cbiAgLy8gU2hvcnQgZm9ybVxuICBpZiAoY29udGVudC5sZW5ndGggPCAweDgwKSB7XG4gICAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMik7XG4gICAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgICBoZWFkZXJbMV0gPSBjb250ZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICAvLyBDb3VudCBvY3RldHMgcmVxdWlyZWQgdG8gc3RvcmUgbGVuZ3RoXG4gIHZhciBsZW5PY3RldHMgPSAxO1xuICBmb3IgKHZhciBpID0gY29udGVudC5sZW5ndGg7IGkgPj0gMHgxMDA7IGkgPj49IDgpXG4gICAgbGVuT2N0ZXRzKys7XG5cbiAgdmFyIGhlYWRlciA9IG5ldyBCdWZmZXIoMSArIDEgKyBsZW5PY3RldHMpO1xuICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICBoZWFkZXJbMV0gPSAweDgwIHwgbGVuT2N0ZXRzO1xuXG4gIGZvciAodmFyIGkgPSAxICsgbGVuT2N0ZXRzLCBqID0gY29udGVudC5sZW5ndGg7IGogPiAwOyBpLS0sIGogPj49IDgpXG4gICAgaGVhZGVyW2ldID0gaiAmIDB4ZmY7XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBoZWFkZXIsIGNvbnRlbnQgXSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlU3RyID0gZnVuY3Rpb24gZW5jb2RlU3RyKHN0ciwgdGFnKSB7XG4gIGlmICh0YWcgPT09ICdiaXRzdHInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBzdHIudW51c2VkIHwgMCwgc3RyLmRhdGEgXSk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHN0ci5sZW5ndGggKiAyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoc3RyLmNoYXJDb2RlQXQoaSksIGkgKiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgaWYgKCF0aGlzLl9pc051bXN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IG51bXN0ciBzdXBwb3J0cyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IGRpZ2l0cyBhbmQgc3BhY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdwcmludHN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIoc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiBwcmludHN0ciBzdXBwb3J0cyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IGxhdGluIHVwcGVyIGFuZCBsb3dlciBjYXNlIGxldHRlcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpZ2l0cywgc3BhY2UsIGFwb3N0cm9waGUsIGxlZnQgYW5kIHJpZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcmVudGhlc2lzLCBwbHVzIHNpZ24sIGNvbW1hLCBoeXBoZW4sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RvdCwgc2xhc2gsIGNvbG9uLCBlcXVhbCBzaWduLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdxdWVzdGlvbiBtYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAoL3N0ciQvLnRlc3QodGFnKSkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlT2JqaWQgPSBmdW5jdGlvbiBlbmNvZGVPYmppZChpZCwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdmFsdWVzKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ3N0cmluZyBvYmppZCBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAgZm91bmQnKTtcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShpZCkpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQgbm90IGZvdW5kIGluIHZhbHVlcyBtYXAnKTtcbiAgICBpZCA9IHZhbHVlc1tpZF0uc3BsaXQoL1tcXHNcXC5dKy9nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKVxuICAgICAgaWRbaV0gfD0gMDtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIGlkID0gaWQuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKVxuICAgICAgaWRbaV0gfD0gMDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignb2JqaWQoKSBzaG91bGQgYmUgZWl0aGVyIGFycmF5IG9yIHN0cmluZywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dvdDogJyArIEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gIH1cblxuICBpZiAoIXJlbGF0aXZlKSB7XG4gICAgaWYgKGlkWzFdID49IDQwKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1NlY29uZCBvYmppZCBpZGVudGlmaWVyIE9PQicpO1xuICAgIGlkLnNwbGljZSgwLCAyLCBpZFswXSAqIDQwICsgaWRbMV0pO1xuICB9XG5cbiAgLy8gQ291bnQgbnVtYmVyIG9mIG9jdGV0c1xuICB2YXIgc2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBmb3IgKHNpemUrKzsgaWRlbnQgPj0gMHg4MDsgaWRlbnQgPj49IDcpXG4gICAgICBzaXplKys7XG4gIH1cblxuICB2YXIgb2JqaWQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgb2Zmc2V0ID0gb2JqaWQubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IGlkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGlkZW50ID0gaWRbaV07XG4gICAgb2JqaWRbb2Zmc2V0LS1dID0gaWRlbnQgJiAweDdmO1xuICAgIHdoaWxlICgoaWRlbnQgPj49IDcpID4gMClcbiAgICAgIG9iamlkW29mZnNldC0tXSA9IDB4ODAgfCAoaWRlbnQgJiAweDdmKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG9iamlkKTtcbn07XG5cbmZ1bmN0aW9uIHR3byhudW0pIHtcbiAgaWYgKG51bSA8IDEwKVxuICAgIHJldHVybiAnMCcgKyBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtO1xufVxuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlVGltZSA9IGZ1bmN0aW9uIGVuY29kZVRpbWUodGltZSwgdGFnKSB7XG4gIHZhciBzdHI7XG4gIHZhciBkYXRlID0gbmV3IERhdGUodGltZSk7XG5cbiAgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnKSB7XG4gICAgc3RyID0gW1xuICAgICAgdHdvKGRhdGUuZ2V0RnVsbFllYXIoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNb250aCgpICsgMSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENEYXRlKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDSG91cnMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNaW51dGVzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSxcbiAgICAgICdaJ1xuICAgIF0uam9pbignJyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAndXRjdGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyAnICsgdGFnICsgJyB0aW1lIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKHN0ciwgJ29jdHN0cicpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZU51bGwgPSBmdW5jdGlvbiBlbmNvZGVOdWxsKCkge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcignJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2YgbnVtID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdmFsdWVzKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1N0cmluZyBpbnQgb3IgZW51bSBnaXZlbiwgYnV0IG5vIHZhbHVlcyBtYXAnKTtcbiAgICBpZiAoIXZhbHVlcy5oYXNPd25Qcm9wZXJ0eShudW0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignVmFsdWVzIG1hcCBkb2VzblxcJ3QgY29udGFpbjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShudW0pKTtcbiAgICB9XG4gICAgbnVtID0gdmFsdWVzW251bV07XG4gIH1cblxuICAvLyBCaWdudW0sIGFzc3VtZSBiaWcgZW5kaWFuXG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyAmJiAhQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcbiAgICB2YXIgbnVtQXJyYXkgPSBudW0udG9BcnJheSgpO1xuICAgIGlmICghbnVtLnNpZ24gJiYgbnVtQXJyYXlbMF0gJiAweDgwKSB7XG4gICAgICBudW1BcnJheS51bnNoaWZ0KDApO1xuICAgIH1cbiAgICBudW0gPSBuZXcgQnVmZmVyKG51bUFycmF5KTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBzaXplID0gbnVtLmxlbmd0aDtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIHNpemUrKztcblxuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgIG51bS5jb3B5KG91dCk7XG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXG4gICAgICBvdXRbMF0gPSAwXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob3V0KTtcbiAgfVxuXG4gIGlmIChudW0gPCAweDgwKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG51bSk7XG5cbiAgaWYgKG51bSA8IDB4MTAwKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFswLCBudW1dKTtcblxuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSBudW07IGkgPj0gMHgxMDA7IGkgPj49IDgpXG4gICAgc2l6ZSsrO1xuXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAodmFyIGkgPSBvdXQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBvdXRbaV0gPSBudW0gJiAweGZmO1xuICAgIG51bSA+Pj0gODtcbiAgfVxuICBpZihvdXRbMF0gJiAweDgwKSB7XG4gICAgb3V0LnVuc2hpZnQoMCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihuZXcgQnVmZmVyKG91dCkpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUJvb2wgPSBmdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHZhbHVlID8gMHhmZiA6IDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RW5jb2RlcignZGVyJykudHJlZTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwRGVmYXVsdCA9IGZ1bmN0aW9uIHNraXBEZWZhdWx0KGRhdGFCdWZmZXIsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgaTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkYXRhID0gZGF0YUJ1ZmZlci5qb2luKCk7XG4gIGlmIChzdGF0ZS5kZWZhdWx0QnVmZmVyID09PSB1bmRlZmluZWQpXG4gICAgc3RhdGUuZGVmYXVsdEJ1ZmZlciA9IHRoaXMuX2VuY29kZVZhbHVlKHN0YXRlWydkZWZhdWx0J10sIHJlcG9ydGVyLCBwYXJlbnQpLmpvaW4oKTtcblxuICBpZiAoZGF0YS5sZW5ndGggIT09IHN0YXRlLmRlZmF1bHRCdWZmZXIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGk9MDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRhdGFbaV0gIT09IHN0YXRlLmRlZmF1bHRCdWZmZXJbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHJlcG9ydGVyKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJylcbiAgICB0YWcgPSAnc2VxJztcbiAgZWxzZSBpZiAodGFnID09PSAnc2V0b2YnKVxuICAgIHRhZyA9ICdzZXQnO1xuXG4gIGlmIChkZXIudGFnQnlOYW1lLmhhc093blByb3BlcnR5KHRhZykpXG4gICAgcmVzID0gZGVyLnRhZ0J5TmFtZVt0YWddO1xuICBlbHNlIGlmICh0eXBlb2YgdGFnID09PSAnbnVtYmVyJyAmJiAodGFnIHwgMCkgPT09IHRhZylcbiAgICByZXMgPSB0YWc7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vua25vd24gdGFnOiAnICsgdGFnKTtcblxuICBpZiAocmVzID49IDB4MWYpXG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdNdWx0aS1vY3RldCB0YWcgZW5jb2RpbmcgdW5zdXBwb3J0ZWQnKTtcblxuICBpZiAoIXByaW1pdGl2ZSlcbiAgICByZXMgfD0gMHgyMDtcblxuICByZXMgfD0gKGRlci50YWdDbGFzc0J5TmFtZVtjbHMgfHwgJ3VuaXZlcnNhbCddIDw8IDYpO1xuXG4gIHJldHVybiByZXM7XG59XG4iLCJ2YXIgZW5jb2RlcnMgPSBleHBvcnRzO1xuXG5lbmNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZW5jb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBERVJFbmNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRW5jb2RlcihlbnRpdHkpIHtcbiAgREVSRW5jb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRW5jb2RlciwgREVSRW5jb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTUVuY29kZXI7XG5cblBFTUVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBidWYgPSBERVJFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUuY2FsbCh0aGlzLCBkYXRhKTtcblxuICB2YXIgcCA9IGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG4gIHZhciBvdXQgPSBbICctLS0tLUJFR0lOICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDY0KVxuICAgIG91dC5wdXNoKHAuc2xpY2UoaSwgaSArIDY0KSk7XG4gIG91dC5wdXNoKCctLS0tLUVORCAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScpO1xuICByZXR1cm4gb3V0LmpvaW4oJ1xcbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByIDw8PSA0O1xuXG4gICAgICAvLyAnYScgLSAnZidcbiAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcbiAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJyAtICdGJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcbiAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciB8PSBjICYgMHhmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgfVxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuc3RyaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwidmFyIHI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmFuZChsZW4pIHtcbiAgaWYgKCFyKVxuICAgIHIgPSBuZXcgUmFuZChudWxsKTtcblxuICByZXR1cm4gci5nZW5lcmF0ZShsZW4pO1xufTtcblxuZnVuY3Rpb24gUmFuZChyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQ7XG59XG5tb2R1bGUuZXhwb3J0cy5SYW5kID0gUmFuZDtcblxuUmFuZC5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3JhbmQobGVuKTtcbn07XG5cbi8vIEVtdWxhdGUgY3J5cHRvIEFQSSB1c2luZyByYW5keVxuUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gIGlmICh0aGlzLnJhbmQuZ2V0Qnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMucmFuZC5nZXRCeXRlcyhuKTtcblxuICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgIHJlc1tpXSA9IHRoaXMucmFuZC5nZXRCeXRlKCk7XG4gIHJldHVybiByZXM7XG59O1xuXG5pZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnKSB7XG4gIGlmIChzZWxmLmNyeXB0byAmJiBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGYubXNDcnlwdG8gJiYgc2VsZi5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBJRVxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgc2VsZi5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAvLyBTYWZhcmkncyBXZWJXb3JrZXJzIGRvIG5vdCBoYXZlIGBjcnlwdG9gXG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBPbGQganVua1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICAvLyBOb2RlLmpzIG9yIFdlYiB3b3JrZXIgd2l0aCBubyBjcnlwdG8gc3VwcG9ydFxuICB0cnkge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCcpO1xuXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuIiwiLy8gYmFzZWQgb24gdGhlIGFlcyBpbXBsaW1lbnRhdGlvbiBpbiB0cmlwbGUgc2VjXG4vLyBodHRwczovL2dpdGh1Yi5jb20va2V5YmFzZS90cmlwbGVzZWNcbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBhc1VJbnQzMkFycmF5IChidWYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuXG4gIHZhciBsZW4gPSAoYnVmLmxlbmd0aCAvIDQpIHwgMFxuICB2YXIgb3V0ID0gbmV3IEFycmF5KGxlbilcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gc2NydWJWZWMgKHYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgdisrKSB7XG4gICAgdltpXSA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBjcnlwdEJsb2NrIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCwgblJvdW5kcykge1xuICB2YXIgU1VCX01JWDAgPSBTVUJfTUlYWzBdXG4gIHZhciBTVUJfTUlYMSA9IFNVQl9NSVhbMV1cbiAgdmFyIFNVQl9NSVgyID0gU1VCX01JWFsyXVxuICB2YXIgU1VCX01JWDMgPSBTVUJfTUlYWzNdXG5cbiAgdmFyIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHZhciBzMSA9IE1bMV0gXiBrZXlTY2hlZHVsZVsxXVxuICB2YXIgczIgPSBNWzJdIF4ga2V5U2NoZWR1bGVbMl1cbiAgdmFyIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIHZhciB0MCwgdDEsIHQyLCB0M1xuICB2YXIga3NSb3cgPSA0XG5cbiAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICB0MCA9IFNVQl9NSVgwW3MwID4+PiAyNF0gXiBTVUJfTUlYMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDEgPSBTVUJfTUlYMFtzMSA+Pj4gMjRdIF4gU1VCX01JWDFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWDBbczIgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MyA9IFNVQl9NSVgwW3MzID4+PiAyNF0gXiBTVUJfTUlYMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgczAgPSB0MFxuICAgIHMxID0gdDFcbiAgICBzMiA9IHQyXG4gICAgczMgPSB0M1xuICB9XG5cbiAgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MCA9IHQwID4+PiAwXG4gIHQxID0gdDEgPj4+IDBcbiAgdDIgPSB0MiA+Pj4gMFxuICB0MyA9IHQzID4+PiAwXG5cbiAgcmV0dXJuIFt0MCwgdDEsIHQyLCB0M11cbn1cblxuLy8gQUVTIGNvbnN0YW50c1xudmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl1cbnZhciBHID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcbiAgdmFyIGQgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgaWYgKGogPCAxMjgpIHtcbiAgICAgIGRbal0gPSBqIDw8IDFcbiAgICB9IGVsc2Uge1xuICAgICAgZFtqXSA9IChqIDw8IDEpIF4gMHgxMWJcbiAgICB9XG4gIH1cblxuICB2YXIgU0JPWCA9IFtdXG4gIHZhciBJTlZfU0JPWCA9IFtdXG4gIHZhciBTVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuICB2YXIgSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG5cbiAgLy8gV2FsayBHRigyXjgpXG4gIHZhciB4ID0gMFxuICB2YXIgeGkgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvLyBDb21wdXRlIHNib3hcbiAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KVxuICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2M1xuICAgIFNCT1hbeF0gPSBzeFxuICAgIElOVl9TQk9YW3N4XSA9IHhcblxuICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICB2YXIgeDIgPSBkW3hdXG4gICAgdmFyIHg0ID0gZFt4Ml1cbiAgICB2YXIgeDggPSBkW3g0XVxuXG4gICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKVxuICAgIFNVQl9NSVhbMF1beF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICBTVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIFNVQl9NSVhbMl1beF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICBTVUJfTUlYWzNdW3hdID0gdFxuXG4gICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKVxuICAgIElOVl9TVUJfTUlYWzBdW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIElOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICBJTlZfU1VCX01JWFsyXVtzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICBJTlZfU1VCX01JWFszXVtzeF0gPSB0XG5cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgeCA9IHhpID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dXG4gICAgICB4aSBePSBkW2RbeGldXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU0JPWDogU0JPWCxcbiAgICBJTlZfU0JPWDogSU5WX1NCT1gsXG4gICAgU1VCX01JWDogU1VCX01JWCxcbiAgICBJTlZfU1VCX01JWDogSU5WX1NVQl9NSVhcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBBRVMgKGtleSkge1xuICB0aGlzLl9rZXkgPSBhc1VJbnQzMkFycmF5KGtleSlcbiAgdGhpcy5fcmVzZXQoKVxufVxuXG5BRVMuYmxvY2tTaXplID0gNCAqIDRcbkFFUy5rZXlTaXplID0gMjU2IC8gOFxuQUVTLnByb3RvdHlwZS5ibG9ja1NpemUgPSBBRVMuYmxvY2tTaXplXG5BRVMucHJvdG90eXBlLmtleVNpemUgPSBBRVMua2V5U2l6ZVxuQUVTLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlXb3JkcyA9IHRoaXMuX2tleVxuICB2YXIga2V5U2l6ZSA9IGtleVdvcmRzLmxlbmd0aFxuICB2YXIgblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNFxuXG4gIHZhciBrZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAodmFyIGsgPSAwOyBrIDwga2V5U2l6ZTsgaysrKSB7XG4gICAga2V5U2NoZWR1bGVba10gPSBrZXlXb3Jkc1trXVxuICB9XG5cbiAgZm9yIChrID0ga2V5U2l6ZTsgayA8IGtzUm93czsgaysrKSB7XG4gICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrIC0gMV1cblxuICAgIGlmIChrICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgICAgdCA9XG4gICAgICAgIChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoRy5TQk9YW3QgJiAweGZmXSlcblxuICAgICAgdCBePSBSQ09OWyhrIC8ga2V5U2l6ZSkgfCAwXSA8PCAyNFxuICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYgayAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgIHQgPVxuICAgICAgICAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHxcbiAgICAgICAgKEcuU0JPWFt0ICYgMHhmZl0pXG4gICAgfVxuXG4gICAga2V5U2NoZWR1bGVba10gPSBrZXlTY2hlZHVsZVtrIC0ga2V5U2l6ZV0gXiB0XG4gIH1cblxuICB2YXIgaW52S2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKHZhciBpayA9IDA7IGlrIDwga3NSb3dzOyBpaysrKSB7XG4gICAgdmFyIGtzUiA9IGtzUm93cyAtIGlrXG4gICAgdmFyIHR0ID0ga2V5U2NoZWR1bGVba3NSIC0gKGlrICUgNCA/IDAgOiA0KV1cblxuICAgIGlmIChpayA8IDQgfHwga3NSIDw9IDQpIHtcbiAgICAgIGludktleVNjaGVkdWxlW2lrXSA9IHR0XG4gICAgfSBlbHNlIHtcbiAgICAgIGludktleVNjaGVkdWxlW2lrXSA9XG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3R0ID4+PiAyNF1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFsxXVtHLlNCT1hbKHR0ID4+PiAxNikgJiAweGZmXV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzJdW0cuU0JPWFsodHQgPj4+IDgpICYgMHhmZl1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdHQgJiAweGZmXV1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9uUm91bmRzID0gblJvdW5kc1xuICB0aGlzLl9rZXlTY2hlZHVsZSA9IGtleVNjaGVkdWxlXG4gIHRoaXMuX2ludktleVNjaGVkdWxlID0gaW52S2V5U2NoZWR1bGVcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2tSYXcgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYXNVSW50MzJBcnJheShNKVxuICByZXR1cm4gY3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gsIHRoaXMuX25Sb3VuZHMpXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIG91dCA9IHRoaXMuZW5jcnlwdEJsb2NrUmF3KE0pXG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5kZWNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICBNID0gYXNVSW50MzJBcnJheShNKVxuXG4gIC8vIHN3YXBcbiAgdmFyIG0xID0gTVsxXVxuICBNWzFdID0gTVszXVxuICBNWzNdID0gbTFcblxuICB2YXIgb3V0ID0gY3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWCwgdGhpcy5fblJvdW5kcylcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKCkge1xuICBzY3J1YlZlYyh0aGlzLl9rZXlTY2hlZHVsZSlcbiAgc2NydWJWZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViVmVjKHRoaXMuX2tleSlcbn1cblxubW9kdWxlLmV4cG9ydHMuQUVTID0gQUVTXG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEdIQVNIID0gcmVxdWlyZSgnLi9naGFzaCcpXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG52YXIgaW5jcjMyID0gcmVxdWlyZSgnLi9pbmNyMzInKVxuXG5mdW5jdGlvbiB4b3JUZXN0IChhLCBiKSB7XG4gIHZhciBvdXQgPSAwXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIG91dCsrXG5cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIG91dCArPSAoYVtpXSBeIGJbaV0pXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNhbGNJdiAoc2VsZiwgaXYsIGNrKSB7XG4gIGlmIChpdi5sZW5ndGggPT09IDEyKSB7XG4gICAgc2VsZi5fZmluSUQgPSBCdWZmZXIuY29uY2F0KFtpdiwgQnVmZmVyLmZyb20oWzAsIDAsIDAsIDFdKV0pXG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2l2LCBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMl0pXSlcbiAgfVxuICB2YXIgZ2hhc2ggPSBuZXcgR0hBU0goY2spXG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIHRvUGFkID0gbGVuICUgMTZcbiAgZ2hhc2gudXBkYXRlKGl2KVxuICBpZiAodG9QYWQpIHtcbiAgICB0b1BhZCA9IDE2IC0gdG9QYWRcbiAgICBnaGFzaC51cGRhdGUoQnVmZmVyLmFsbG9jKHRvUGFkLCAwKSlcbiAgfVxuICBnaGFzaC51cGRhdGUoQnVmZmVyLmFsbG9jKDgsIDApKVxuICB2YXIgaXZCaXRzID0gbGVuICogOFxuICB2YXIgdGFpbCA9IEJ1ZmZlci5hbGxvYyg4KVxuICB0YWlsLndyaXRlVUludEJFKGl2Qml0cywgMCwgOClcbiAgZ2hhc2gudXBkYXRlKHRhaWwpXG4gIHNlbGYuX2ZpbklEID0gZ2hhc2guc3RhdGVcbiAgdmFyIG91dCA9IEJ1ZmZlci5mcm9tKHNlbGYuX2ZpbklEKVxuICBpbmNyMzIob3V0KVxuICByZXR1cm4gb3V0XG59XG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB2YXIgaCA9IEJ1ZmZlci5hbGxvYyg0LCAwKVxuXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdmFyIGNrID0gdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKVxuICB0aGlzLl9naGFzaCA9IG5ldyBHSEFTSChjaylcbiAgaXYgPSBjYWxjSXYodGhpcywgaXYsIGNrKVxuXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fc2VjQ2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICB0aGlzLl9tb2RlID0gbW9kZVxuXG4gIHRoaXMuX2F1dGhUYWcgPSBudWxsXG4gIHRoaXMuX2NhbGxlZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKCF0aGlzLl9jYWxsZWQgJiYgdGhpcy5fYWxlbikge1xuICAgIHZhciBydW1wID0gMTYgLSAodGhpcy5fYWxlbiAlIDE2KVxuICAgIGlmIChydW1wIDwgMTYpIHtcbiAgICAgIHJ1bXAgPSBCdWZmZXIuYWxsb2MocnVtcCwgMClcbiAgICAgIHRoaXMuX2doYXNoLnVwZGF0ZShydW1wKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmICF0aGlzLl9hdXRoVGFnKSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG5cbiAgdmFyIHRhZyA9IHhvcih0aGlzLl9naGFzaC5maW5hbCh0aGlzLl9hbGVuICogOCwgdGhpcy5fbGVuICogOCksIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodGhpcy5fZmluSUQpKVxuICBpZiAodGhpcy5fZGVjcnlwdCAmJiB4b3JUZXN0KHRhZywgdGhpcy5fYXV0aFRhZykpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcblxuICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCB8fCAhQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICByZXR1cm4gdGhpcy5fYXV0aFRhZ1xufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiBzZXRBdXRoVGFnICh0YWcpIHtcbiAgaWYgKCF0aGlzLl9kZWNyeXB0KSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICB0aGlzLl9hdXRoVGFnID0gdGFnXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gc2V0QUFEIChidWYpIHtcbiAgaWYgKHRoaXMuX2NhbGxlZCkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBBQUQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHRoaXMuX2doYXNoLnVwZGF0ZShidWYpXG4gIHRoaXMuX2FsZW4gKz0gYnVmLmxlbmd0aFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuIiwidmFyIGNpcGhlcnMgPSByZXF1aXJlKCcuL2VuY3J5cHRlcicpXG52YXIgZGVjaXBoZXJzID0gcmVxdWlyZSgnLi9kZWNyeXB0ZXInKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2Rlcy9saXN0Lmpzb24nKVxuXG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVzKVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY2lwaGVycy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY2lwaGVycy5jcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGV4cG9ydHMuRGVjaXBoZXJpdiA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgTU9ERVMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxuRGVjaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICByZXR1cm4gdW5wYWQodGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKSlcbiAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuXG5EZWNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGF1dG9QYWRkaW5nKSB7XG4gIHZhciBvdXRcbiAgaWYgKGF1dG9QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHJldHVybiB0aGlzLmNhY2hlXG59XG5cbmZ1bmN0aW9uIHVucGFkIChsYXN0KSB7XG4gIHZhciBwYWRkZWQgPSBsYXN0WzE1XVxuICBpZiAocGFkZGVkIDwgMSB8fCBwYWRkZWQgPiAxNikge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gIH1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHJldHVyblxuXG4gIHJldHVybiBsYXN0LnNsaWNlKDAsIDE2IC0gcGFkZGVkKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykgaXYgPSBCdWZmZXIuZnJvbShpdilcbiAgaWYgKGNvbmZpZy5tb2RlICE9PSAnR0NNJyAmJiBpdi5sZW5ndGggIT09IGNvbmZpZy5pdikgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcblxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZClcbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuXG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH1cblxuICByZXR1cm4gbmV3IERlY2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuIiwidmFyIE1PREVTID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBTdHJlYW1DaXBoZXIgPSByZXF1aXJlKCcuL3N0cmVhbUNpcGhlcicpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cblxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQoKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxudmFyIFBBRERJTkcgPSBCdWZmZXIuYWxsb2MoMTYsIDB4MTApXG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBpZiAoIWNodW5rLmVxdWFscyhQQURESU5HKSkge1xuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGRhdGFdKVxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNSkge1xuICAgIHZhciBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHJldHVybiBvdXRcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW4gPSAxNiAtIHRoaXMuY2FjaGUubGVuZ3RoXG4gIHZhciBwYWRCdWZmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHBhZEJ1ZmZdKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQpXG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcblxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykgaXYgPSBCdWZmZXIuZnJvbShpdilcbiAgaWYgKGNvbmZpZy5tb2RlICE9PSAnR0NNJyAmJiBpdi5sZW5ndGggIT09IGNvbmZpZy5pdikgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcblxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBaRVJPRVMgPSBCdWZmZXIuYWxsb2MoMTYsIDApXG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5IChvdXQpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdID4+PiAwLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0gPj4+IDAsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSA+Pj4gMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdID4+PiAwLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gQnVmZmVyLmFsbG9jKDE2LCAwKVxuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cbi8vIGZyb20gaHR0cDovL2JpdHdpc2VzaGlmdGxlZnQuZ2l0aHViLmlvL3NqY2wvZG9jL3N5bWJvbHMvc3JjL2NvcmVfZ2NtLmpzLmh0bWxcbi8vIGJ5IEp1aG8gVsOkaMOkLUhlcnR0dWFcbkdIQVNILnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBibG9jay5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YXRlW2ldIF49IGJsb2NrW2ldXG4gIH1cbiAgdGhpcy5fbXVsdGlwbHkoKVxufVxuXG5HSEFTSC5wcm90b3R5cGUuX211bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgVmkgPSB0b0FycmF5KHRoaXMuaClcbiAgdmFyIFppID0gWzAsIDAsIDAsIDBdXG4gIHZhciBqLCB4aSwgbHNiVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSAoaSAlIDgpKSkpICE9PSAwXG4gICAgaWYgKHhpKSB7XG4gICAgICAvLyBaX2krMSA9IFpfaSBeIFZfaVxuICAgICAgWmlbMF0gXj0gVmlbMF1cbiAgICAgIFppWzFdIF49IFZpWzFdXG4gICAgICBaaVsyXSBePSBWaVsyXVxuICAgICAgWmlbM10gXj0gVmlbM11cbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JWaSA9IChWaVszXSAmIDEpICE9PSAwXG5cbiAgICAvLyBWX2krMSA9IFZfaSA+PiAxXG4gICAgZm9yIChqID0gMzsgaiA+IDA7IGotLSkge1xuICAgICAgVmlbal0gPSAoVmlbal0gPj4+IDEpIHwgKChWaVtqIC0gMV0gJiAxKSA8PCAzMSlcbiAgICB9XG4gICAgVmlbMF0gPSBWaVswXSA+Pj4gMVxuXG4gICAgLy8gSWYgTFNCKFZfaSkgaXMgMSwgVl9pKzEgPSAoVl9pID4+IDEpIF4gUlxuICAgIGlmIChsc2JWaSkge1xuICAgICAgVmlbMF0gPSBWaVswXSBeICgweGUxIDw8IDI0KVxuICAgIH1cbiAgfVxuICB0aGlzLnN0YXRlID0gZnJvbUFycmF5KFppKVxufVxuXG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5cbkdIQVNILnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIChhYmwsIGJsKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuZ2hhc2goQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgWkVST0VTXSwgMTYpKVxuICB9XG5cbiAgdGhpcy5naGFzaChmcm9tQXJyYXkoWzAsIGFibCwgMCwgYmxdKSlcbiAgcmV0dXJuIHRoaXMuc3RhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHSEFTSFxuIiwiZnVuY3Rpb24gaW5jcjMyIChpdikge1xuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciBpdGVtXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGl0ZW0gPSBpdi5yZWFkVUludDgobGVuKVxuICAgIGlmIChpdGVtID09PSAyNTUpIHtcbiAgICAgIGl2LndyaXRlVUludDgoMCwgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtKytcbiAgICAgIGl2LndyaXRlVUludDgoaXRlbSwgbGVuKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jcjMyXG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgZGF0YSA9IHhvcihibG9jaywgc2VsZi5fcHJldilcblxuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhkYXRhKVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIHBhZCA9IHNlbGYuX3ByZXZcblxuICBzZWxmLl9wcmV2ID0gYmxvY2tcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG5cbiAgcmV0dXJuIHhvcihvdXQsIHBhZClcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBlbmNyeXB0U3RhcnQgKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoXG4gIHZhciBvdXQgPSB4b3IoZGF0YSwgc2VsZi5fY2FjaGUpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UobGVuKVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldiwgZGVjcnlwdCA/IGRhdGEgOiBvdXRdKVxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdmFyIGxlblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX2NhY2hlID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgICAgc2VsZi5fcHJldiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIGxlbiA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YS5zbGljZSgwLCBsZW4pLCBkZWNyeXB0KV0pXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEsIGRlY3J5cHQpXSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZFxuICB2YXIgaSA9IC0xXG4gIHZhciBsZW4gPSA4XG4gIHZhciBvdXQgPSAwXG4gIHZhciBiaXQsIHZhbHVlXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgYml0ID0gKGJ5dGVQYXJhbSAmICgxIDw8ICg3IC0gaSkpKSA/IDB4ODAgOiAwXG4gICAgdmFsdWUgPSBwYWRbMF0gXiBiaXRcbiAgICBvdXQgKz0gKCh2YWx1ZSAmIDB4ODApID4+IChpICUgOCkpXG4gICAgc2VsZi5fcHJldiA9IHNoaWZ0SW4oc2VsZi5fcHJldiwgZGVjcnlwdCA/IGJpdCA6IHZhbHVlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gc2hpZnRJbiAoYnVmZmVyLCB2YWx1ZSkge1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmZmVyLmxlbmd0aClcbiAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShbdmFsdWVdKV0pXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1ZmZlcltpXSA8PCAxIHwgYnVmZmVyW2kgKyAxXSA+PiAoNylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIHZhciBpID0gLTFcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICB2YXIgb3V0ID0gcGFkWzBdIF4gYnl0ZVBhcmFtXG5cbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIHNlbGYuX3ByZXYuc2xpY2UoMSksXG4gICAgQnVmZmVyLmZyb20oW2RlY3J5cHQgPyBieXRlUGFyYW0gOiBvdXRdKVxuICBdKVxuXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIHZhciBpID0gLTFcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBpbmNyMzIgPSByZXF1aXJlKCcuLi9pbmNyMzInKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9ja1JhdyhzZWxmLl9wcmV2KVxuICBpbmNyMzIoc2VsZi5fcHJldilcbiAgcmV0dXJuIG91dFxufVxuXG52YXIgYmxvY2tTaXplID0gMTZcbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB2YXIgY2h1bmtOdW0gPSBNYXRoLmNlaWwoY2h1bmsubGVuZ3RoIC8gYmxvY2tTaXplKVxuICB2YXIgc3RhcnQgPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBzZWxmLl9jYWNoZSxcbiAgICBCdWZmZXIuYWxsb2NVbnNhZmUoY2h1bmtOdW0gKiBibG9ja1NpemUpXG4gIF0pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtOdW07IGkrKykge1xuICAgIHZhciBvdXQgPSBnZXRCbG9jayhzZWxmKVxuICAgIHZhciBvZmZzZXQgPSBzdGFydCArIGkgKiBibG9ja1NpemVcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFswXSwgb2Zmc2V0ICsgMClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFsxXSwgb2Zmc2V0ICsgNClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFsyXSwgb2Zmc2V0ICsgOClcbiAgICBzZWxmLl9jYWNoZS53cml0ZVVJbnQzMkJFKG91dFszXSwgb2Zmc2V0ICsgMTIpXG4gIH1cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsImV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICByZXR1cm4gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhibG9jaylcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuIiwidmFyIG1vZGVNb2R1bGVzID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vY3RyJylcbn1cblxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9saXN0Lmpzb24nKVxuXG5mb3IgKHZhciBrZXkgaW4gbW9kZXMpIHtcbiAgbW9kZXNba2V5XS5tb2R1bGUgPSBtb2RlTW9kdWxlc1ttb2Rlc1trZXldLm1vZGVdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kZXNcbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cblxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX2NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX3NlY0NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX21vZGUgPSBtb2RlXG59XG5cbmluaGVyaXRzKFN0cmVhbUNpcGhlciwgVHJhbnNmb3JtKVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaywgdGhpcy5fZGVjcnlwdClcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG4iLCJ2YXIgREVTID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMnKVxudmFyIGFlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXInKVxudmFyIGFlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvbW9kZXMnKVxudmFyIGRlc01vZGVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1kZXMvbW9kZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIGtleUxlbiwgaXZMZW5cbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGFlc01vZGVzW3N1aXRlXS5rZXlcbiAgICBpdkxlbiA9IGFlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGRlc01vZGVzW3N1aXRlXS5rZXkgKiA4XG4gICAgaXZMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwga2V5TGVuLCBpdkxlbilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBhZXMuY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleSwgaXYpXG4gIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBuZXcgREVTKHsga2V5OiBrZXksIGl2OiBpdiwgbW9kZTogc3VpdGUgfSlcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlcml2IChzdWl0ZSwga2V5LCBpdikge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkgcmV0dXJuIGFlcy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICBpZiAoZGVzTW9kZXNbc3VpdGVdKSByZXR1cm4gbmV3IERFUyh7IGtleToga2V5LCBpdjogaXYsIG1vZGU6IHN1aXRlLCBkZWNyeXB0OiB0cnVlIH0pXG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbn1cblxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkZXNNb2RlcykuY29uY2F0KGFlcy5nZXRDaXBoZXJzKCkpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gZXhwb3J0cy5DaXBoZXIgPSBjcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGV4cG9ydHMuRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG4iLCJ2YXIgQ2lwaGVyQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBkZXMgPSByZXF1aXJlKCdkZXMuanMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBtb2RlcyA9IHtcbiAgJ2Rlcy1lZGUzLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlMyc6IGRlcy5FREUsXG4gICdkZXMtZWRlLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlJzogZGVzLkVERSxcbiAgJ2Rlcy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5ERVMpLFxuICAnZGVzLWVjYic6IGRlcy5ERVNcbn1cbm1vZGVzLmRlcyA9IG1vZGVzWydkZXMtY2JjJ11cbm1vZGVzLmRlczMgPSBtb2Rlc1snZGVzLWVkZTMtY2JjJ11cbm1vZHVsZS5leHBvcnRzID0gREVTXG5pbmhlcml0cyhERVMsIENpcGhlckJhc2UpXG5mdW5jdGlvbiBERVMgKG9wdHMpIHtcbiAgQ2lwaGVyQmFzZS5jYWxsKHRoaXMpXG4gIHZhciBtb2RlTmFtZSA9IG9wdHMubW9kZS50b0xvd2VyQ2FzZSgpXG4gIHZhciBtb2RlID0gbW9kZXNbbW9kZU5hbWVdXG4gIHZhciB0eXBlXG4gIGlmIChvcHRzLmRlY3J5cHQpIHtcbiAgICB0eXBlID0gJ2RlY3J5cHQnXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9ICdlbmNyeXB0J1xuICB9XG4gIHZhciBrZXkgPSBvcHRzLmtleVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAga2V5ID0gQnVmZmVyLmZyb20oa2V5KVxuICB9XG4gIGlmIChtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUnIHx8IG1vZGVOYW1lID09PSAnZGVzLWVkZS1jYmMnKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBrZXkuc2xpY2UoMCwgOCldKVxuICB9XG4gIHZhciBpdiA9IG9wdHMuaXZcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaXYpKSB7XG4gICAgaXYgPSBCdWZmZXIuZnJvbShpdilcbiAgfVxuICB0aGlzLl9kZXMgPSBtb2RlLmNyZWF0ZSh7XG4gICAga2V5OiBrZXksXG4gICAgaXY6IGl2LFxuICAgIHR5cGU6IHR5cGVcbiAgfSlcbn1cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLl9kZXMudXBkYXRlKGRhdGEpKVxufVxuREVTLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLl9kZXMuZmluYWwoKSlcbn1cbiIsImV4cG9ydHNbJ2Rlcy1lY2InXSA9IHtcbiAga2V5OiA4LFxuICBpdjogMFxufVxuZXhwb3J0c1snZGVzLWNiYyddID0gZXhwb3J0cy5kZXMgPSB7XG4gIGtleTogOCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzLWNiYyddID0gZXhwb3J0cy5kZXMzID0ge1xuICBrZXk6IDI0LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZTMnXSA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUtY2JjJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiAwXG59XG4iLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gY3J0O1xuZnVuY3Rpb24gYmxpbmQocHJpdikge1xuICB2YXIgciA9IGdldHIocHJpdik7XG4gIHZhciBibGluZGVyID0gci50b1JlZChibi5tb250KHByaXYubW9kdWx1cykpXG4gIC5yZWRQb3cobmV3IGJuKHByaXYucHVibGljRXhwb25lbnQpKS5mcm9tUmVkKCk7XG4gIHJldHVybiB7XG4gICAgYmxpbmRlcjogYmxpbmRlcixcbiAgICB1bmJsaW5kZXI6ci5pbnZtKHByaXYubW9kdWx1cylcbiAgfTtcbn1cbmZ1bmN0aW9uIGNydChtc2csIHByaXYpIHtcbiAgdmFyIGJsaW5kcyA9IGJsaW5kKHByaXYpO1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG1vZCA9IGJuLm1vbnQocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGJsaW5kZWQgPSBuZXcgYm4obXNnKS5tdWwoYmxpbmRzLmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLnVtb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cykudG9BcnJheShmYWxzZSwgbGVuKSk7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci51bW9kKHByaXYucHJpbWUxKSB8fCAhci51bW9kKHByaXYucHJpbWUyKSkge1xuICAgIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci9hbGdvcml0aG1zLmpzb24nKVxuIiwidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaWduID0gcmVxdWlyZSgnLi9zaWduJylcbnZhciB2ZXJpZnkgPSByZXF1aXJlKCcuL3ZlcmlmeScpXG5cbnZhciBhbGdvcml0aG1zID0gcmVxdWlyZSgnLi9hbGdvcml0aG1zLmpzb24nKVxuT2JqZWN0LmtleXMoYWxnb3JpdGhtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGFsZ29yaXRobXNba2V5XS5pZCA9IG5ldyBCdWZmZXIoYWxnb3JpdGhtc1trZXldLmlkLCAnaGV4JylcbiAgYWxnb3JpdGhtc1trZXkudG9Mb3dlckNhc2UoKV0gPSBhbGdvcml0aG1zW2tleV1cbn0pXG5cbmZ1bmN0aW9uIFNpZ24gKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3JpdGhtc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoVHlwZSA9IGRhdGEuaGFzaFxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFNpZ24sIHN0cmVhbS5Xcml0YWJsZSlcblxuU2lnbi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChkYXRhLCBfLCBkb25lKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIGRvbmUoKVxufVxuXG5TaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuU2lnbi5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ25NZXRob2QgKGtleSwgZW5jKSB7XG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBzaWcgPSBzaWduKGhhc2gsIGtleSwgdGhpcy5faGFzaFR5cGUsIHRoaXMuX3NpZ25UeXBlLCB0aGlzLl90YWcpXG5cbiAgcmV0dXJuIGVuYyA/IHNpZy50b1N0cmluZyhlbmMpIDogc2lnXG59XG5cbmZ1bmN0aW9uIFZlcmlmeSAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdmFyIGRhdGEgPSBhbGdvcml0aG1zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGRhdGEuaGFzaClcbiAgdGhpcy5fdGFnID0gZGF0YS5pZFxuICB0aGlzLl9zaWduVHlwZSA9IGRhdGEuc2lnblxufVxuaW5oZXJpdHMoVmVyaWZ5LCBzdHJlYW0uV3JpdGFibGUpXG5cblZlcmlmeS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChkYXRhLCBfLCBkb25lKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIGRvbmUoKVxufVxuXG5WZXJpZnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5WZXJpZnkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeU1ldGhvZCAoa2V5LCBzaWcsIGVuYykge1xuICBpZiAodHlwZW9mIHNpZyA9PT0gJ3N0cmluZycpIHNpZyA9IG5ldyBCdWZmZXIoc2lnLCBlbmMpXG5cbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgcmV0dXJuIHZlcmlmeShzaWcsIGhhc2gsIGtleSwgdGhpcy5fc2lnblR5cGUsIHRoaXMuX3RhZylcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2lnbiAoYWxnb3JpdGhtKSB7XG4gIHJldHVybiBuZXcgU2lnbihhbGdvcml0aG0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmlmeSAoYWxnb3JpdGhtKSB7XG4gIHJldHVybiBuZXcgVmVyaWZ5KGFsZ29yaXRobSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNpZ246IGNyZWF0ZVNpZ24sXG4gIFZlcmlmeTogY3JlYXRlVmVyaWZ5LFxuICBjcmVhdGVTaWduOiBjcmVhdGVTaWduLFxuICBjcmVhdGVWZXJpZnk6IGNyZWF0ZVZlcmlmeVxufVxuIiwiLy8gbXVjaCBvZiB0aGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL3JzYS5qc1xudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzLmpzb24nKVxuXG5mdW5jdGlvbiBzaWduIChoYXNoLCBrZXksIGhhc2hUeXBlLCBzaWduVHlwZSwgdGFnKSB7XG4gIHZhciBwcml2ID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHByaXYuY3VydmUpIHtcbiAgICAvLyByc2Ega2V5cyBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgZWNkc2Egb25lcyBpbiBvcGVuc3NsXG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZWNkc2EnICYmIHNpZ25UeXBlICE9PSAnZWNkc2EvcnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICByZXR1cm4gZWNTaWduKGhhc2gsIHByaXYpXG4gIH0gZWxzZSBpZiAocHJpdi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGRzYVNpZ24oaGFzaCwgcHJpdiwgaGFzaFR5cGUpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gIH1cbiAgaGFzaCA9IEJ1ZmZlci5jb25jYXQoW3RhZywgaGFzaF0pXG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBwYWQgPSBbIDAsIDEgXVxuICB3aGlsZSAoaGFzaC5sZW5ndGggKyBwYWQubGVuZ3RoICsgMSA8IGxlbikgcGFkLnB1c2goMHhmZilcbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHBhZC5wdXNoKGhhc2hbaV0pXG5cbiAgdmFyIG91dCA9IGNydChwYWQsIHByaXYpXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gZWNTaWduIChoYXNoLCBwcml2KSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3ByaXYuY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjdXJ2ZSAnICsgcHJpdi5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBrZXkgPSBjdXJ2ZS5rZXlGcm9tUHJpdmF0ZShwcml2LnByaXZhdGVLZXkpXG4gIHZhciBvdXQgPSBrZXkuc2lnbihoYXNoKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKG91dC50b0RFUigpKVxufVxuXG5mdW5jdGlvbiBkc2FTaWduIChoYXNoLCBwcml2LCBhbGdvKSB7XG4gIHZhciB4ID0gcHJpdi5wYXJhbXMucHJpdl9rZXlcbiAgdmFyIHAgPSBwcml2LnBhcmFtcy5wXG4gIHZhciBxID0gcHJpdi5wYXJhbXMucVxuICB2YXIgZyA9IHByaXYucGFyYW1zLmdcbiAgdmFyIHIgPSBuZXcgQk4oMClcbiAgdmFyIGtcbiAgdmFyIEggPSBiaXRzMmludChoYXNoLCBxKS5tb2QocSlcbiAgdmFyIHMgPSBmYWxzZVxuICB2YXIga3YgPSBnZXRLZXkoeCwgcSwgaGFzaCwgYWxnbylcbiAgd2hpbGUgKHMgPT09IGZhbHNlKSB7XG4gICAgayA9IG1ha2VLZXkocSwga3YsIGFsZ28pXG4gICAgciA9IG1ha2VSKGcsIGssIHAsIHEpXG4gICAgcyA9IGsuaW52bShxKS5pbXVsKEguYWRkKHgubXVsKHIpKSkubW9kKHEpXG4gICAgaWYgKHMuY21wbigwKSA9PT0gMCkge1xuICAgICAgcyA9IGZhbHNlXG4gICAgICByID0gbmV3IEJOKDApXG4gICAgfVxuICB9XG4gIHJldHVybiB0b0RFUihyLCBzKVxufVxuXG5mdW5jdGlvbiB0b0RFUiAociwgcykge1xuICByID0gci50b0FycmF5KClcbiAgcyA9IHMudG9BcnJheSgpXG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApIHIgPSBbIDAgXS5jb25jYXQocilcbiAgaWYgKHNbMF0gJiAweDgwKSBzID0gWyAwIF0uY29uY2F0KHMpXG5cbiAgdmFyIHRvdGFsID0gci5sZW5ndGggKyBzLmxlbmd0aCArIDRcbiAgdmFyIHJlcyA9IFsgMHgzMCwgdG90YWwsIDB4MDIsIHIubGVuZ3RoIF1cbiAgcmVzID0gcmVzLmNvbmNhdChyLCBbIDB4MDIsIHMubGVuZ3RoIF0sIHMpXG4gIHJldHVybiBuZXcgQnVmZmVyKHJlcylcbn1cblxuZnVuY3Rpb24gZ2V0S2V5ICh4LCBxLCBoYXNoLCBhbGdvKSB7XG4gIHggPSBuZXcgQnVmZmVyKHgudG9BcnJheSgpKVxuICBpZiAoeC5sZW5ndGggPCBxLmJ5dGVMZW5ndGgoKSkge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIocS5ieXRlTGVuZ3RoKCkgLSB4Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgeCA9IEJ1ZmZlci5jb25jYXQoWyB6ZXJvcywgeCBdKVxuICB9XG4gIHZhciBobGVuID0gaGFzaC5sZW5ndGhcbiAgdmFyIGhiaXRzID0gYml0czJvY3RldHMoaGFzaCwgcSlcbiAgdmFyIHYgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIHYuZmlsbCgxKVxuICB2YXIgayA9IG5ldyBCdWZmZXIoaGxlbilcbiAgay5maWxsKDApXG4gIGsgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS51cGRhdGUobmV3IEJ1ZmZlcihbIDAgXSkpLnVwZGF0ZSh4KS51cGRhdGUoaGJpdHMpLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikudXBkYXRlKG5ldyBCdWZmZXIoWyAxIF0pKS51cGRhdGUoeCkudXBkYXRlKGhiaXRzKS5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgcmV0dXJuIHsgazogaywgdjogdiB9XG59XG5cbmZ1bmN0aW9uIGJpdHMyaW50IChvYml0cywgcSkge1xuICB2YXIgYml0cyA9IG5ldyBCTihvYml0cylcbiAgdmFyIHNoaWZ0ID0gKG9iaXRzLmxlbmd0aCA8PCAzKSAtIHEuYml0TGVuZ3RoKClcbiAgaWYgKHNoaWZ0ID4gMCkgYml0cy5pc2hybihzaGlmdClcbiAgcmV0dXJuIGJpdHNcbn1cblxuZnVuY3Rpb24gYml0czJvY3RldHMgKGJpdHMsIHEpIHtcbiAgYml0cyA9IGJpdHMyaW50KGJpdHMsIHEpXG4gIGJpdHMgPSBiaXRzLm1vZChxKVxuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihiaXRzLnRvQXJyYXkoKSlcbiAgaWYgKG91dC5sZW5ndGggPCBxLmJ5dGVMZW5ndGgoKSkge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIocS5ieXRlTGVuZ3RoKCkgLSBvdXQubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFsgemVyb3MsIG91dCBdKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gbWFrZUtleSAocSwga3YsIGFsZ28pIHtcbiAgdmFyIHRcbiAgdmFyIGtcblxuICBkbyB7XG4gICAgdCA9IG5ldyBCdWZmZXIoMClcblxuICAgIHdoaWxlICh0Lmxlbmd0aCAqIDggPCBxLmJpdExlbmd0aCgpKSB7XG4gICAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikuZGlnZXN0KClcbiAgICAgIHQgPSBCdWZmZXIuY29uY2F0KFsgdCwga3YudiBdKVxuICAgIH1cblxuICAgIGsgPSBiaXRzMmludCh0LCBxKVxuICAgIGt2LmsgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS51cGRhdGUobmV3IEJ1ZmZlcihbIDAgXSkpLmRpZ2VzdCgpXG4gICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLmRpZ2VzdCgpXG4gIH0gd2hpbGUgKGsuY21wKHEpICE9PSAtMSlcblxuICByZXR1cm4ga1xufVxuXG5mdW5jdGlvbiBtYWtlUiAoZywgaywgcCwgcSkge1xuICByZXR1cm4gZy50b1JlZChCTi5tb250KHApKS5yZWRQb3coaykuZnJvbVJlZCgpLm1vZChxKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpZ25cbm1vZHVsZS5leHBvcnRzLmdldEtleSA9IGdldEtleVxubW9kdWxlLmV4cG9ydHMubWFrZUtleSA9IG1ha2VLZXlcbiIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gdmVyaWZ5IChzaWcsIGhhc2gsIGtleSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHViID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHB1Yi50eXBlID09PSAnZWMnKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZWNWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSBpZiAocHViLnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgfVxuICBoYXNoID0gQnVmZmVyLmNvbmNhdChbdGFnLCBoYXNoXSlcbiAgdmFyIGxlbiA9IHB1Yi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAxIF1cbiAgdmFyIHBhZE51bSA9IDBcbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDIgPCBsZW4pIHtcbiAgICBwYWQucHVzaCgweGZmKVxuICAgIHBhZE51bSsrXG4gIH1cbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHtcbiAgICBwYWQucHVzaChoYXNoW2ldKVxuICB9XG4gIHBhZCA9IG5ldyBCdWZmZXIocGFkKVxuICB2YXIgcmVkID0gQk4ubW9udChwdWIubW9kdWx1cylcbiAgc2lnID0gbmV3IEJOKHNpZykudG9SZWQocmVkKVxuXG4gIHNpZyA9IHNpZy5yZWRQb3cobmV3IEJOKHB1Yi5wdWJsaWNFeHBvbmVudCkpXG4gIHNpZyA9IG5ldyBCdWZmZXIoc2lnLmZyb21SZWQoKS50b0FycmF5KCkpXG4gIHZhciBvdXQgPSBwYWROdW0gPCA4ID8gMSA6IDBcbiAgbGVuID0gTWF0aC5taW4oc2lnLmxlbmd0aCwgcGFkLmxlbmd0aClcbiAgaWYgKHNpZy5sZW5ndGggIT09IHBhZC5sZW5ndGgpIG91dCA9IDFcblxuICBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikgb3V0IHw9IHNpZ1tpXSBeIHBhZFtpXVxuICByZXR1cm4gb3V0ID09PSAwXG59XG5cbmZ1bmN0aW9uIGVjVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjdXJ2ZSAnICsgcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgRUMoY3VydmVJZClcbiAgdmFyIHB1YmtleSA9IHB1Yi5kYXRhLnN1YmplY3RQcml2YXRlS2V5LmRhdGFcblxuICByZXR1cm4gY3VydmUudmVyaWZ5KGhhc2gsIHNpZywgcHVia2V5KVxufVxuXG5mdW5jdGlvbiBkc2FWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBwID0gcHViLmRhdGEucFxuICB2YXIgcSA9IHB1Yi5kYXRhLnFcbiAgdmFyIGcgPSBwdWIuZGF0YS5nXG4gIHZhciB5ID0gcHViLmRhdGEucHViX2tleVxuICB2YXIgdW5wYWNrZWQgPSBwYXJzZUtleXMuc2lnbmF0dXJlLmRlY29kZShzaWcsICdkZXInKVxuICB2YXIgcyA9IHVucGFja2VkLnNcbiAgdmFyIHIgPSB1bnBhY2tlZC5yXG4gIGNoZWNrVmFsdWUocywgcSlcbiAgY2hlY2tWYWx1ZShyLCBxKVxuICB2YXIgbW9udHAgPSBCTi5tb250KHApXG4gIHZhciB3ID0gcy5pbnZtKHEpXG4gIHZhciB2ID0gZy50b1JlZChtb250cClcbiAgICAucmVkUG93KG5ldyBCTihoYXNoKS5tdWwodykubW9kKHEpKVxuICAgIC5mcm9tUmVkKClcbiAgICAubXVsKHkudG9SZWQobW9udHApLnJlZFBvdyhyLm11bCh3KS5tb2QocSkpLmZyb21SZWQoKSlcbiAgICAubW9kKHApXG4gICAgLm1vZChxKVxuICByZXR1cm4gdi5jbXAocikgPT09IDBcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZSAoYiwgcSkge1xuICBpZiAoYi5jbXBuKDApIDw9IDApIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxuICBpZiAoYi5jbXAocSkgPj0gcSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyaWZ5XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlcltpXSA9IGFbaV0gXiBiW2ldXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICBpZiAodGhpcy5fZmluYWwpIHtcbiAgICB0aGlzLl9fZmluYWwgPSB0aGlzLl9maW5hbFxuICAgIHRoaXMuX2ZpbmFsID0gbnVsbFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGlucHV0RW5jKVxuICB9XG5cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHJldHVybiB0aGlzXG5cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cblxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH1cblxuICBkb25lKGVycilcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX19maW5hbCgpIHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3Qgc3dpdGNoIGVuY29kaW5ncycpXG5cbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXG4gIGlmIChmaW4pIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsInZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJylcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFQ0RIIChjdXJ2ZSkge1xuICByZXR1cm4gbmV3IEVDREgoY3VydmUpXG59XG5cbnZhciBhbGlhc2VzID0ge1xuICBzZWNwMjU2azE6IHtcbiAgICBuYW1lOiAnc2VjcDI1NmsxJyxcbiAgICBieXRlTGVuZ3RoOiAzMlxuICB9LFxuICBzZWNwMjI0cjE6IHtcbiAgICBuYW1lOiAncDIyNCcsXG4gICAgYnl0ZUxlbmd0aDogMjhcbiAgfSxcbiAgcHJpbWUyNTZ2MToge1xuICAgIG5hbWU6ICdwMjU2JyxcbiAgICBieXRlTGVuZ3RoOiAzMlxuICB9LFxuICBwcmltZTE5MnYxOiB7XG4gICAgbmFtZTogJ3AxOTInLFxuICAgIGJ5dGVMZW5ndGg6IDI0XG4gIH0sXG4gIGVkMjU1MTk6IHtcbiAgICBuYW1lOiAnZWQyNTUxOScsXG4gICAgYnl0ZUxlbmd0aDogMzJcbiAgfSxcbiAgc2VjcDM4NHIxOiB7XG4gICAgbmFtZTogJ3AzODQnLFxuICAgIGJ5dGVMZW5ndGg6IDQ4XG4gIH0sXG4gIHNlY3A1MjFyMToge1xuICAgIG5hbWU6ICdwNTIxJyxcbiAgICBieXRlTGVuZ3RoOiA2NlxuICB9XG59XG5cbmFsaWFzZXMucDIyNCA9IGFsaWFzZXMuc2VjcDIyNHIxXG5hbGlhc2VzLnAyNTYgPSBhbGlhc2VzLnNlY3AyNTZyMSA9IGFsaWFzZXMucHJpbWUyNTZ2MVxuYWxpYXNlcy5wMTkyID0gYWxpYXNlcy5zZWNwMTkycjEgPSBhbGlhc2VzLnByaW1lMTkydjFcbmFsaWFzZXMucDM4NCA9IGFsaWFzZXMuc2VjcDM4NHIxXG5hbGlhc2VzLnA1MjEgPSBhbGlhc2VzLnNlY3A1MjFyMVxuXG5mdW5jdGlvbiBFQ0RIIChjdXJ2ZSkge1xuICB0aGlzLmN1cnZlVHlwZSA9IGFsaWFzZXNbY3VydmVdXG4gIGlmICghdGhpcy5jdXJ2ZVR5cGUpIHtcbiAgICB0aGlzLmN1cnZlVHlwZSA9IHtcbiAgICAgIG5hbWU6IGN1cnZlXG4gICAgfVxuICB9XG4gIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuZWModGhpcy5jdXJ2ZVR5cGUubmFtZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIHRoaXMua2V5cyA9IHZvaWQgMFxufVxuXG5FQ0RILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcbiAgdGhpcy5rZXlzID0gdGhpcy5jdXJ2ZS5nZW5LZXlQYWlyKClcbiAgcmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KGVuYywgZm9ybWF0KVxufVxuXG5FQ0RILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyLCBpbmVuYywgZW5jKSB7XG4gIGluZW5jID0gaW5lbmMgfHwgJ3V0ZjgnXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuICAgIG90aGVyID0gbmV3IEJ1ZmZlcihvdGhlciwgaW5lbmMpXG4gIH1cbiAgdmFyIG90aGVyUHViID0gdGhpcy5jdXJ2ZS5rZXlGcm9tUHVibGljKG90aGVyKS5nZXRQdWJsaWMoKVxuICB2YXIgb3V0ID0gb3RoZXJQdWIubXVsKHRoaXMua2V5cy5nZXRQcml2YXRlKCkpLmdldFgoKVxuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUob3V0LCBlbmMsIHRoaXMuY3VydmVUeXBlLmJ5dGVMZW5ndGgpXG59XG5cbkVDREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuICB2YXIga2V5ID0gdGhpcy5rZXlzLmdldFB1YmxpYyhmb3JtYXQgPT09ICdjb21wcmVzc2VkJywgdHJ1ZSlcbiAgaWYgKGZvcm1hdCA9PT0gJ2h5YnJpZCcpIHtcbiAgICBpZiAoa2V5W2tleS5sZW5ndGggLSAxXSAlIDIpIHtcbiAgICAgIGtleVswXSA9IDdcbiAgICB9IGVsc2Uge1xuICAgICAga2V5WzBdID0gNlxuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoa2V5LCBlbmMpXG59XG5cbkVDREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpLCBlbmMpXG59XG5cbkVDREgucHJvdG90eXBlLnNldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWIsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKVxuICB9XG4gIHRoaXMua2V5cy5faW1wb3J0UHVibGljKHB1YilcbiAgcmV0dXJuIHRoaXNcbn1cblxuRUNESC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2LCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2KSkge1xuICAgIHByaXYgPSBuZXcgQnVmZmVyKHByaXYsIGVuYylcbiAgfVxuXG4gIHZhciBfcHJpdiA9IG5ldyBCTihwcml2KVxuICBfcHJpdiA9IF9wcml2LnRvU3RyaW5nKDE2KVxuICB0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKVxuICB0aGlzLmtleXMuX2ltcG9ydFByaXZhdGUoX3ByaXYpXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlIChibiwgZW5jLCBsZW4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGJuKSkge1xuICAgIGJuID0gYm4udG9BcnJheSgpXG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4pXG4gIGlmIChsZW4gJiYgYnVmLmxlbmd0aCA8IGxlbikge1xuICAgIHZhciB6ZXJvcyA9IG5ldyBCdWZmZXIobGVuIC0gYnVmLmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbemVyb3MsIGJ1Zl0pXG4gIH1cbiAgaWYgKCFlbmMpIHtcbiAgICByZXR1cm4gYnVmXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhlbmMpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG52YXIgUklQRU1EMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbmZ1bmN0aW9uIEhhc2ggKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG59XG5cbmluaGVyaXRzKEhhc2gsIEJhc2UpXG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxufVxuXG5IYXNoLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNoLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAoYWxnKSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmIChhbGcgPT09ICdtZDUnKSByZXR1cm4gbmV3IE1ENSgpXG4gIGlmIChhbGcgPT09ICdybWQxNjAnIHx8IGFsZyA9PT0gJ3JpcGVtZDE2MCcpIHJldHVybiBuZXcgUklQRU1EMTYwKClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG4iLCJ2YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiBuZXcgTUQ1KCkudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KClcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIExlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5JylcbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1JylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxuXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXkpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBCdWZmZXIuZnJvbShrZXkpXG4gIH1cblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICB2YXIgaGFzaCA9IGFsZyA9PT0gJ3JtZDE2MCcgPyBuZXcgUklQRU1EMTYwKCkgOiBzaGEoYWxnKVxuICAgIGtleSA9IGhhc2gudXBkYXRlKGtleSkuZGlnZXN0KClcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuICB0aGlzLl9oYXNoID0gYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYShhbGcpXG4gIHRoaXMuX2hhc2gudXBkYXRlKGlwYWQpXG59XG5cbmluaGVyaXRzKEhtYWMsIEJhc2UpXG5cbkhtYWMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2FsZyA9PT0gJ3JtZDE2MCcgPyBuZXcgUklQRU1EMTYwKCkgOiBzaGEodGhpcy5fYWxnKVxuICByZXR1cm4gaGFzaC51cGRhdGUodGhpcy5fb3BhZCkudXBkYXRlKGgpLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSG1hYyAoYWxnLCBrZXkpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykge1xuICAgIHJldHVybiBuZXcgSG1hYygncm1kMTYwJywga2V5KVxuICB9XG4gIGlmIChhbGcgPT09ICdtZDUnKSB7XG4gICAgcmV0dXJuIG5ldyBMZWdhY3kobWQ1LCBrZXkpXG4gIH1cbiAgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbnZhciBaRVJPUyA9IEJ1ZmZlci5hbGxvYygxMjgpXG52YXIgYmxvY2tzaXplID0gNjRcblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXkpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBCdWZmZXIuZnJvbShrZXkpXG4gIH1cblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBhbGcoa2V5KVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdGhpcy5faGFzaCA9IFtpcGFkXVxufVxuXG5pbmhlcml0cyhIbWFjLCBCYXNlKVxuXG5IbWFjLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC5wdXNoKGRhdGEpXG59XG5cbkhtYWMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGggPSB0aGlzLl9hbGcoQnVmZmVyLmNvbmNhdCh0aGlzLl9oYXNoKSlcbiAgcmV0dXJuIHRoaXMuX2FsZyhCdWZmZXIuY29uY2F0KFt0aGlzLl9vcGFkLCBoXSkpXG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5ybmcgPSBleHBvcnRzLnBzZXVkb1JhbmRvbUJ5dGVzID0gZXhwb3J0cy5wcm5nID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZXhwb3J0cy5IYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxuZXhwb3J0cy5jcmVhdGVIbWFjID0gZXhwb3J0cy5IbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxuXG52YXIgYWxnb3MgPSByZXF1aXJlKCdicm93c2VyaWZ5LXNpZ24vYWxnb3MnKVxudmFyIGFsZ29LZXlzID0gT2JqZWN0LmtleXMoYWxnb3MpXG52YXIgaGFzaGVzID0gWydzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicsICdtZDUnLCAncm1kMTYwJ10uY29uY2F0KGFsZ29LZXlzKVxuZXhwb3J0cy5nZXRIYXNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoYXNoZXNcbn1cblxudmFyIHAgPSByZXF1aXJlKCdwYmtkZjInKVxuZXhwb3J0cy5wYmtkZjIgPSBwLnBia2RmMlxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcC5wYmtkZjJTeW5jXG5cbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWNpcGhlcicpXG5cbmV4cG9ydHMuQ2lwaGVyID0gYWVzLkNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBhZXMuY3JlYXRlQ2lwaGVyXG5leHBvcnRzLkNpcGhlcml2ID0gYWVzLkNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gYWVzLmNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLkRlY2lwaGVyID0gYWVzLkRlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gYWVzLmNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLkRlY2lwaGVyaXYgPSBhZXMuRGVjaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gYWVzLmNyZWF0ZURlY2lwaGVyaXZcbmV4cG9ydHMuZ2V0Q2lwaGVycyA9IGFlcy5nZXRDaXBoZXJzXG5leHBvcnRzLmxpc3RDaXBoZXJzID0gYWVzLmxpc3RDaXBoZXJzXG5cbnZhciBkaCA9IHJlcXVpcmUoJ2RpZmZpZS1oZWxsbWFuJylcblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuR3JvdXAgPSBkaC5EaWZmaWVIZWxsbWFuR3JvdXBcbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwID0gZGguY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwXG5leHBvcnRzLmdldERpZmZpZUhlbGxtYW4gPSBkaC5nZXREaWZmaWVIZWxsbWFuXG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBkaC5jcmVhdGVEaWZmaWVIZWxsbWFuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW4gPSBkaC5EaWZmaWVIZWxsbWFuXG5cbnZhciBzaWduID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduJylcblxuZXhwb3J0cy5jcmVhdGVTaWduID0gc2lnbi5jcmVhdGVTaWduXG5leHBvcnRzLlNpZ24gPSBzaWduLlNpZ25cbmV4cG9ydHMuY3JlYXRlVmVyaWZ5ID0gc2lnbi5jcmVhdGVWZXJpZnlcbmV4cG9ydHMuVmVyaWZ5ID0gc2lnbi5WZXJpZnlcblxuZXhwb3J0cy5jcmVhdGVFQ0RIID0gcmVxdWlyZSgnY3JlYXRlLWVjZGgnKVxuXG52YXIgcHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJ3B1YmxpYy1lbmNyeXB0JylcblxuZXhwb3J0cy5wdWJsaWNFbmNyeXB0ID0gcHVibGljRW5jcnlwdC5wdWJsaWNFbmNyeXB0XG5leHBvcnRzLnByaXZhdGVFbmNyeXB0ID0gcHVibGljRW5jcnlwdC5wcml2YXRlRW5jcnlwdFxuZXhwb3J0cy5wdWJsaWNEZWNyeXB0ID0gcHVibGljRW5jcnlwdC5wdWJsaWNEZWNyeXB0XG5leHBvcnRzLnByaXZhdGVEZWNyeXB0ID0gcHVibGljRW5jcnlwdC5wcml2YXRlRGVjcnlwdFxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbi8vIDtbXG4vLyAgICdjcmVhdGVDcmVkZW50aWFscydcbi8vIF0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuLy8gICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHRocm93IG5ldyBFcnJvcihbXG4vLyAgICAgICAnc29ycnksICcgKyBuYW1lICsgJyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyxcbi8vICAgICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4vLyAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0by1icm93c2VyaWZ5L2NyeXB0by1icm93c2VyaWZ5J1xuLy8gICAgIF0uam9pbignXFxuJykpXG4vLyAgIH1cbi8vIH0pXG5cbnZhciByZiA9IHJlcXVpcmUoJ3JhbmRvbWZpbGwnKVxuXG5leHBvcnRzLnJhbmRvbUZpbGwgPSByZi5yYW5kb21GaWxsXG5leHBvcnRzLnJhbmRvbUZpbGxTeW5jID0gcmYucmFuZG9tRmlsbFN5bmNcblxuZXhwb3J0cy5jcmVhdGVDcmVkZW50aWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAnc29ycnksIGNyZWF0ZUNyZWRlbnRpYWxzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG8tYnJvd3NlcmlmeS9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gICdESF9DSEVDS19QX05PVF9TQUZFX1BSSU1FJzogMixcbiAgJ0RIX0NIRUNLX1BfTk9UX1BSSU1FJzogMSxcbiAgJ0RIX1VOQUJMRV9UT19DSEVDS19HRU5FUkFUT1InOiA0LFxuICAnREhfTk9UX1NVSVRBQkxFX0dFTkVSQVRPUic6IDgsXG4gICdOUE5fRU5BQkxFRCc6IDEsXG4gICdBTFBOX0VOQUJMRUQnOiAxLFxuICAnUlNBX1BLQ1MxX1BBRERJTkcnOiAxLFxuICAnUlNBX1NTTFYyM19QQURESU5HJzogMixcbiAgJ1JTQV9OT19QQURESU5HJzogMyxcbiAgJ1JTQV9QS0NTMV9PQUVQX1BBRERJTkcnOiA0LFxuICAnUlNBX1g5MzFfUEFERElORyc6IDUsXG4gICdSU0FfUEtDUzFfUFNTX1BBRERJTkcnOiA2LFxuICAnUE9JTlRfQ09OVkVSU0lPTl9DT01QUkVTU0VEJzogMixcbiAgJ1BPSU5UX0NPTlZFUlNJT05fVU5DT01QUkVTU0VEJzogNCxcbiAgJ1BPSU5UX0NPTlZFUlNJT05fSFlCUklEJzogNlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi9kZXMvdXRpbHMnKTtcbmV4cG9ydHMuQ2lwaGVyID0gcmVxdWlyZSgnLi9kZXMvY2lwaGVyJyk7XG5leHBvcnRzLkRFUyA9IHJlcXVpcmUoJy4vZGVzL2RlcycpO1xuZXhwb3J0cy5DQkMgPSByZXF1aXJlKCcuL2Rlcy9jYmMnKTtcbmV4cG9ydHMuRURFID0gcmVxdWlyZSgnLi9kZXMvZWRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgcHJvdG8gPSB7fTtcblxuZnVuY3Rpb24gQ0JDU3RhdGUoaXYpIHtcbiAgYXNzZXJ0LmVxdWFsKGl2Lmxlbmd0aCwgOCwgJ0ludmFsaWQgSVYgbGVuZ3RoJyk7XG5cbiAgdGhpcy5pdiA9IG5ldyBBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml2Lmxlbmd0aDsgaSsrKVxuICAgIHRoaXMuaXZbaV0gPSBpdltpXTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGUoQmFzZSkge1xuICBmdW5jdGlvbiBDQkMob3B0aW9ucykge1xuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9jYmNJbml0KCk7XG4gIH1cbiAgaW5oZXJpdHMoQ0JDLCBCYXNlKTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgQ0JDLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgfVxuXG4gIENCQy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ0JDKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBDQkM7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxucHJvdG8uX2NiY0luaXQgPSBmdW5jdGlvbiBfY2JjSW5pdCgpIHtcbiAgdmFyIHN0YXRlID0gbmV3IENCQ1N0YXRlKHRoaXMub3B0aW9ucy5pdik7XG4gIHRoaXMuX2NiY1N0YXRlID0gc3RhdGU7XG59O1xuXG5wcm90by5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9jYmNTdGF0ZTtcbiAgdmFyIHN1cGVyUHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgdmFyIGl2ID0gc3RhdGUuaXY7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0Jykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldIF49IGlucFtpbk9mZiArIGldO1xuXG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaXYsIDAsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gb3V0W291dE9mZiArIGldO1xuICB9IGVsc2Uge1xuICAgIHN1cGVyUHJvdG8uX3VwZGF0ZS5jYWxsKHRoaXMsIGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIG91dFtvdXRPZmYgKyBpXSBePSBpdltpXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGl2W2ldID0gaW5wW2luT2ZmICsgaV07XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIENpcGhlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgdGhpcy50eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gIHRoaXMuYmxvY2tTaXplID0gODtcbiAgdGhpcy5faW5pdCgpO1xuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXI7XG5cbkNpcGhlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gTWlnaHQgYmUgb3ZlcnJpZGVkXG59O1xuXG5DaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2RlY3J5cHQnKVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVEZWNyeXB0KGRhdGEpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUVuY3J5cHQoZGF0YSk7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiBfYnVmZmVyKGRhdGEsIG9mZikge1xuICAvLyBBcHBlbmQgZGF0YSB0byBidWZmZXJcbiAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMuYnVmZmVyT2ZmLCBkYXRhLmxlbmd0aCAtIG9mZik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmYgKyBpXSA9IGRhdGFbb2ZmICsgaV07XG4gIHRoaXMuYnVmZmVyT2ZmICs9IG1pbjtcblxuICAvLyBTaGlmdCBuZXh0XG4gIHJldHVybiBtaW47XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIF9mbHVzaEJ1ZmZlcihvdXQsIG9mZikge1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgb2ZmKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xuICByZXR1cm4gdGhpcy5ibG9ja1NpemU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVFbmNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZUVuY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSAoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIHwgMDtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICBpZiAodGhpcy5idWZmZXJPZmYgIT09IDApIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyT2ZmID09PSB0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gV3JpdGUgYmxvY2tzXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCAtICgoZGF0YS5sZW5ndGggLSBpbnB1dE9mZikgJSB0aGlzLmJsb2NrU2l6ZSk7XG4gIGZvciAoOyBpbnB1dE9mZiA8IG1heDsgaW5wdXRPZmYgKz0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICB0aGlzLl91cGRhdGUoZGF0YSwgaW5wdXRPZmYsIG91dCwgb3V0cHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5ibG9ja1NpemU7XG4gIH1cblxuICAvLyBRdWV1ZSByZXN0XG4gIGZvciAoOyBpbnB1dE9mZiA8IGRhdGEubGVuZ3RoOyBpbnB1dE9mZisrLCB0aGlzLmJ1ZmZlck9mZisrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmXSA9IGRhdGFbaW5wdXRPZmZdO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVEZWNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZURlY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSBNYXRoLmNlaWwoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIC0gMTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBUT0RPKGluZHV0bnkpOiBvcHRpbWl6ZSBpdCwgdGhpcyBpcyBmYXIgZnJvbSBvcHRpbWFsXG4gIGZvciAoOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBCdWZmZXIgcmVzdCBvZiB0aGUgaW5wdXRcbiAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIGZpbmFsKGJ1ZmZlcikge1xuICB2YXIgZmlyc3Q7XG4gIGlmIChidWZmZXIpXG4gICAgZmlyc3QgPSB0aGlzLnVwZGF0ZShidWZmZXIpO1xuXG4gIHZhciBsYXN0O1xuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRW5jcnlwdCgpO1xuICBlbHNlXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRGVjcnlwdCgpO1xuXG4gIGlmIChmaXJzdClcbiAgICByZXR1cm4gZmlyc3QuY29uY2F0KGxhc3QpO1xuICBlbHNlXG4gICAgcmV0dXJuIGxhc3Q7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBfcGFkKGJ1ZmZlciwgb2ZmKSB7XG4gIGlmIChvZmYgPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHdoaWxlIChvZmYgPCBidWZmZXIubGVuZ3RoKVxuICAgIGJ1ZmZlcltvZmYrK10gPSAwO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxFbmNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRW5jcnlwdCgpIHtcbiAgaWYgKCF0aGlzLl9wYWQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyT2ZmKSlcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCAwKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxEZWNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRGVjcnlwdCgpIHtcbiAgYXNzZXJ0LmVxdWFsKHRoaXMuYnVmZmVyT2ZmLCB0aGlzLmJsb2NrU2l6ZSwgJ05vdCBlbm91Z2ggZGF0YSB0byBkZWNyeXB0Jyk7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIDApO1xuXG4gIHJldHVybiB0aGlzLl91bnBhZChvdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciB1dGlscyA9IGRlcy51dGlscztcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xuXG5mdW5jdGlvbiBERVNTdGF0ZSgpIHtcbiAgdGhpcy50bXAgPSBuZXcgQXJyYXkoMik7XG4gIHRoaXMua2V5cyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIERFUyhvcHRpb25zKSB7XG4gIENpcGhlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBERVNTdGF0ZSgpO1xuICB0aGlzLl9kZXNTdGF0ZSA9IHN0YXRlO1xuXG4gIHRoaXMuZGVyaXZlS2V5cyhzdGF0ZSwgb3B0aW9ucy5rZXkpO1xufVxuaW5oZXJpdHMoREVTLCBDaXBoZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBERVM7XG5cbkRFUy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IERFUyhvcHRpb25zKTtcbn07XG5cbnZhciBzaGlmdFRhYmxlID0gW1xuICAxLCAxLCAyLCAyLCAyLCAyLCAyLCAyLFxuICAxLCAyLCAyLCAyLCAyLCAyLCAyLCAxXG5dO1xuXG5ERVMucHJvdG90eXBlLmRlcml2ZUtleXMgPSBmdW5jdGlvbiBkZXJpdmVLZXlzKHN0YXRlLCBrZXkpIHtcbiAgc3RhdGUua2V5cyA9IG5ldyBBcnJheSgxNiAqIDIpO1xuXG4gIGFzc2VydC5lcXVhbChrZXkubGVuZ3RoLCB0aGlzLmJsb2NrU2l6ZSwgJ0ludmFsaWQga2V5IGxlbmd0aCcpO1xuXG4gIHZhciBrTCA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDApO1xuICB2YXIga1IgPSB1dGlscy5yZWFkVUludDMyQkUoa2V5LCA0KTtcblxuICB1dGlscy5wYzEoa0wsIGtSLCBzdGF0ZS50bXAsIDApO1xuICBrTCA9IHN0YXRlLnRtcFswXTtcbiAga1IgPSBzdGF0ZS50bXBbMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUua2V5cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBzaGlmdCA9IHNoaWZ0VGFibGVbaSA+Pj4gMV07XG4gICAga0wgPSB1dGlscy5yMjhzaGwoa0wsIHNoaWZ0KTtcbiAgICBrUiA9IHV0aWxzLnIyOHNobChrUiwgc2hpZnQpO1xuICAgIHV0aWxzLnBjMihrTCwga1IsIHN0YXRlLmtleXMsIGkpO1xuICB9XG59O1xuXG5ERVMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Rlc1N0YXRlO1xuXG4gIHZhciBsID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYpO1xuICB2YXIgciA9IHV0aWxzLnJlYWRVSW50MzJCRShpbnAsIGluT2ZmICsgNCk7XG5cbiAgLy8gSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5pcChsLCByLCBzdGF0ZS50bXAsIDApO1xuICBsID0gc3RhdGUudG1wWzBdO1xuICByID0gc3RhdGUudG1wWzFdO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0JylcbiAgICB0aGlzLl9lbmNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuICBlbHNlXG4gICAgdGhpcy5fZGVjcnlwdChzdGF0ZSwgbCwgciwgc3RhdGUudG1wLCAwKTtcblxuICBsID0gc3RhdGUudG1wWzBdO1xuICByID0gc3RhdGUudG1wWzFdO1xuXG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCBsLCBvdXRPZmYpO1xuICB1dGlscy53cml0ZVVJbnQzMkJFKG91dCwgciwgb3V0T2ZmICsgNCk7XG59O1xuXG5ERVMucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBfcGFkKGJ1ZmZlciwgb2ZmKSB7XG4gIHZhciB2YWx1ZSA9IGJ1ZmZlci5sZW5ndGggLSBvZmY7XG4gIGZvciAodmFyIGkgPSBvZmY7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYnVmZmVyW2ldID0gdmFsdWU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5ERVMucHJvdG90eXBlLl91bnBhZCA9IGZ1bmN0aW9uIF91bnBhZChidWZmZXIpIHtcbiAgdmFyIHBhZCA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG4gIGZvciAodmFyIGkgPSBidWZmZXIubGVuZ3RoIC0gcGFkOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgIGFzc2VydC5lcXVhbChidWZmZXJbaV0sIHBhZCk7XG5cbiAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBidWZmZXIubGVuZ3RoIC0gcGFkKTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX2VuY3J5cHQgPSBmdW5jdGlvbiBfZW5jcnlwdChzdGF0ZSwgbFN0YXJ0LCByU3RhcnQsIG91dCwgb2ZmKSB7XG4gIHZhciBsID0gbFN0YXJ0O1xuICB2YXIgciA9IHJTdGFydDtcblxuICAvLyBBcHBseSBmKCkgeDE2IHRpbWVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUua2V5cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChyLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gcjtcbiAgICByID0gKGwgXiBmKSA+Pj4gMDtcbiAgICBsID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAociwgbCwgb3V0LCBvZmYpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZGVjcnlwdCA9IGZ1bmN0aW9uIF9kZWNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSByU3RhcnQ7XG4gIHZhciByID0gbFN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IHN0YXRlLmtleXMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICB2YXIga2V5TCA9IHN0YXRlLmtleXNbaV07XG4gICAgdmFyIGtleVIgPSBzdGF0ZS5rZXlzW2kgKyAxXTtcblxuICAgIC8vIGYociwgaylcbiAgICB1dGlscy5leHBhbmQobCwgc3RhdGUudG1wLCAwKTtcblxuICAgIGtleUwgXj0gc3RhdGUudG1wWzBdO1xuICAgIGtleVIgXj0gc3RhdGUudG1wWzFdO1xuICAgIHZhciBzID0gdXRpbHMuc3Vic3RpdHV0ZShrZXlMLCBrZXlSKTtcbiAgICB2YXIgZiA9IHV0aWxzLnBlcm11dGUocyk7XG5cbiAgICB2YXIgdCA9IGw7XG4gICAgbCA9IChyIF4gZikgPj4+IDA7XG4gICAgciA9IHQ7XG4gIH1cblxuICAvLyBSZXZlcnNlIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMucmlwKGwsIHIsIG91dCwgb2ZmKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcbnZhciBERVMgPSBkZXMuREVTO1xuXG5mdW5jdGlvbiBFREVTdGF0ZSh0eXBlLCBrZXkpIHtcbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIDI0LCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGsxID0ga2V5LnNsaWNlKDAsIDgpO1xuICB2YXIgazIgPSBrZXkuc2xpY2UoOCwgMTYpO1xuICB2YXIgazMgPSBrZXkuc2xpY2UoMTYsIDI0KTtcblxuICBpZiAodHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgdGhpcy5jaXBoZXJzID0gW1xuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMSB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazIgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGszIH0pXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGszIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazEgfSlcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIEVERShvcHRpb25zKSB7XG4gIENpcGhlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBFREVTdGF0ZSh0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5rZXkpO1xuICB0aGlzLl9lZGVTdGF0ZSA9IHN0YXRlO1xufVxuaW5oZXJpdHMoRURFLCBDaXBoZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVERTtcblxuRURFLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRURFKG9wdGlvbnMpO1xufTtcblxuRURFLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9lZGVTdGF0ZTtcblxuICBzdGF0ZS5jaXBoZXJzWzBdLl91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzFdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbiAgc3RhdGUuY2lwaGVyc1syXS5fdXBkYXRlKG91dCwgb3V0T2ZmLCBvdXQsIG91dE9mZik7XG59O1xuXG5FREUucHJvdG90eXBlLl9wYWQgPSBERVMucHJvdG90eXBlLl9wYWQ7XG5FREUucHJvdG90eXBlLl91bnBhZCA9IERFUy5wcm90b3R5cGUuX3VucGFkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShieXRlcywgb2ZmKSB7XG4gIHZhciByZXMgPSAgKGJ5dGVzWzAgKyBvZmZdIDw8IDI0KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzEgKyBvZmZdIDw8IDE2KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzIgKyBvZmZdIDw8IDgpIHxcbiAgICAgICAgICAgICBieXRlc1szICsgb2ZmXTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn07XG5cbmV4cG9ydHMud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUoYnl0ZXMsIHZhbHVlLCBvZmYpIHtcbiAgYnl0ZXNbMCArIG9mZl0gPSB2YWx1ZSA+Pj4gMjQ7XG4gIGJ5dGVzWzEgKyBvZmZdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICBieXRlc1syICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICBieXRlc1szICsgb2ZmXSA9IHZhbHVlICYgMHhmZjtcbn07XG5cbmV4cG9ydHMuaXAgPSBmdW5jdGlvbiBpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucmlwID0gZnVuY3Rpb24gcmlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDQ7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGMxID0gZnVuY3Rpb24gcGMxKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICAvLyA3LCAxNSwgMjMsIDMxLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA2LCAxNCwgMjIsIDMwLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA1LCAxMywgMjEsIDI5LCAzOSwgNDcsIDU1LCA2M1xuICAvLyA0LCAxMiwgMjAsIDI4XG4gIGZvciAodmFyIGkgPSA3OyBpID49IDU7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIC8vIDEsIDksIDE3LCAyNSwgMzMsIDQxLCA0OSwgNTdcbiAgLy8gMiwgMTAsIDE4LCAyNiwgMzQsIDQyLCA1MCwgNThcbiAgLy8gMywgMTEsIDE5LCAyNywgMzUsIDQzLCA1MSwgNTlcbiAgLy8gMzYsIDQ0LCA1MiwgNjBcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucjI4c2hsID0gZnVuY3Rpb24gcjI4c2hsKG51bSwgc2hpZnQpIHtcbiAgcmV0dXJuICgobnVtIDw8IHNoaWZ0KSAmIDB4ZmZmZmZmZikgfCAobnVtID4+PiAoMjggLSBzaGlmdCkpO1xufTtcblxudmFyIHBjMnRhYmxlID0gW1xuICAvLyBpbkwgPT4gb3V0TFxuICAxNCwgMTEsIDE3LCA0LCAyNywgMjMsIDI1LCAwLFxuICAxMywgMjIsIDcsIDE4LCA1LCA5LCAxNiwgMjQsXG4gIDIsIDIwLCAxMiwgMjEsIDEsIDgsIDE1LCAyNixcblxuICAvLyBpblIgPT4gb3V0UlxuICAxNSwgNCwgMjUsIDE5LCA5LCAxLCAyNiwgMTYsXG4gIDUsIDExLCAyMywgOCwgMTIsIDcsIDE3LCAwLFxuICAyMiwgMywgMTAsIDE0LCA2LCAyMCwgMjcsIDI0XG5dO1xuXG5leHBvcnRzLnBjMiA9IGZ1bmN0aW9uIHBjMihpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgdmFyIGxlbiA9IHBjMnRhYmxlLmxlbmd0aCA+Pj4gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5MID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IHBjMnRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpblIgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLmV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChyLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBvdXRMID0gKChyICYgMSkgPDwgNSkgfCAociA+Pj4gMjcpO1xuICBmb3IgKHZhciBpID0gMjM7IGkgPj0gMTU7IGkgLT0gNCkge1xuICAgIG91dEwgPDw9IDY7XG4gICAgb3V0TCB8PSAociA+Pj4gaSkgJiAweDNmO1xuICB9XG4gIGZvciAodmFyIGkgPSAxMTsgaSA+PSAzOyBpIC09IDQpIHtcbiAgICBvdXRSIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gICAgb3V0UiA8PD0gNjtcbiAgfVxuICBvdXRSIHw9ICgociAmIDB4MWYpIDw8IDEpIHwgKHIgPj4+IDMxKTtcblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxudmFyIHNUYWJsZSA9IFtcbiAgMTQsIDAsIDQsIDE1LCAxMywgNywgMSwgNCwgMiwgMTQsIDE1LCAyLCAxMSwgMTMsIDgsIDEsXG4gIDMsIDEwLCAxMCwgNiwgNiwgMTIsIDEyLCAxMSwgNSwgOSwgOSwgNSwgMCwgMywgNywgOCxcbiAgNCwgMTUsIDEsIDEyLCAxNCwgOCwgOCwgMiwgMTMsIDQsIDYsIDksIDIsIDEsIDExLCA3LFxuICAxNSwgNSwgMTIsIDExLCA5LCAzLCA3LCAxNCwgMywgMTAsIDEwLCAwLCA1LCA2LCAwLCAxMyxcblxuICAxNSwgMywgMSwgMTMsIDgsIDQsIDE0LCA3LCA2LCAxNSwgMTEsIDIsIDMsIDgsIDQsIDE0LFxuICA5LCAxMiwgNywgMCwgMiwgMSwgMTMsIDEwLCAxMiwgNiwgMCwgOSwgNSwgMTEsIDEwLCA1LFxuICAwLCAxMywgMTQsIDgsIDcsIDEwLCAxMSwgMSwgMTAsIDMsIDQsIDE1LCAxMywgNCwgMSwgMixcbiAgNSwgMTEsIDgsIDYsIDEyLCA3LCA2LCAxMiwgOSwgMCwgMywgNSwgMiwgMTQsIDE1LCA5LFxuXG4gIDEwLCAxMywgMCwgNywgOSwgMCwgMTQsIDksIDYsIDMsIDMsIDQsIDE1LCA2LCA1LCAxMCxcbiAgMSwgMiwgMTMsIDgsIDEyLCA1LCA3LCAxNCwgMTEsIDEyLCA0LCAxMSwgMiwgMTUsIDgsIDEsXG4gIDEzLCAxLCA2LCAxMCwgNCwgMTMsIDksIDAsIDgsIDYsIDE1LCA5LCAzLCA4LCAwLCA3LFxuICAxMSwgNCwgMSwgMTUsIDIsIDE0LCAxMiwgMywgNSwgMTEsIDEwLCA1LCAxNCwgMiwgNywgMTIsXG5cbiAgNywgMTMsIDEzLCA4LCAxNCwgMTEsIDMsIDUsIDAsIDYsIDYsIDE1LCA5LCAwLCAxMCwgMyxcbiAgMSwgNCwgMiwgNywgOCwgMiwgNSwgMTIsIDExLCAxLCAxMiwgMTAsIDQsIDE0LCAxNSwgOSxcbiAgMTAsIDMsIDYsIDE1LCA5LCAwLCAwLCA2LCAxMiwgMTAsIDExLCAxLCA3LCAxMywgMTMsIDgsXG4gIDE1LCA5LCAxLCA0LCAzLCA1LCAxNCwgMTEsIDUsIDEyLCAyLCA3LCA4LCAyLCA0LCAxNCxcblxuICAyLCAxNCwgMTIsIDExLCA0LCAyLCAxLCAxMiwgNywgNCwgMTAsIDcsIDExLCAxMywgNiwgMSxcbiAgOCwgNSwgNSwgMCwgMywgMTUsIDE1LCAxMCwgMTMsIDMsIDAsIDksIDE0LCA4LCA5LCA2LFxuICA0LCAxMSwgMiwgOCwgMSwgMTIsIDExLCA3LCAxMCwgMSwgMTMsIDE0LCA3LCAyLCA4LCAxMyxcbiAgMTUsIDYsIDksIDE1LCAxMiwgMCwgNSwgOSwgNiwgMTAsIDMsIDQsIDAsIDUsIDE0LCAzLFxuXG4gIDEyLCAxMCwgMSwgMTUsIDEwLCA0LCAxNSwgMiwgOSwgNywgMiwgMTIsIDYsIDksIDgsIDUsXG4gIDAsIDYsIDEzLCAxLCAzLCAxMywgNCwgMTQsIDE0LCAwLCA3LCAxMSwgNSwgMywgMTEsIDgsXG4gIDksIDQsIDE0LCAzLCAxNSwgMiwgNSwgMTIsIDIsIDksIDgsIDUsIDEyLCAxNSwgMywgMTAsXG4gIDcsIDExLCAwLCAxNCwgNCwgMSwgMTAsIDcsIDEsIDYsIDEzLCAwLCAxMSwgOCwgNiwgMTMsXG5cbiAgNCwgMTMsIDExLCAwLCAyLCAxMSwgMTQsIDcsIDE1LCA0LCAwLCA5LCA4LCAxLCAxMywgMTAsXG4gIDMsIDE0LCAxMiwgMywgOSwgNSwgNywgMTIsIDUsIDIsIDEwLCAxNSwgNiwgOCwgMSwgNixcbiAgMSwgNiwgNCwgMTEsIDExLCAxMywgMTMsIDgsIDEyLCAxLCAzLCA0LCA3LCAxMCwgMTQsIDcsXG4gIDEwLCA5LCAxNSwgNSwgNiwgMCwgOCwgMTUsIDAsIDE0LCA1LCAyLCA5LCAzLCAyLCAxMixcblxuICAxMywgMSwgMiwgMTUsIDgsIDEzLCA0LCA4LCA2LCAxMCwgMTUsIDMsIDExLCA3LCAxLCA0LFxuICAxMCwgMTIsIDksIDUsIDMsIDYsIDE0LCAxMSwgNSwgMCwgMCwgMTQsIDEyLCA5LCA3LCAyLFxuICA3LCAyLCAxMSwgMSwgNCwgMTQsIDEsIDcsIDksIDQsIDEyLCAxMCwgMTQsIDgsIDIsIDEzLFxuICAwLCAxNSwgNiwgMTIsIDEwLCA5LCAxMywgMCwgMTUsIDMsIDMsIDUsIDUsIDYsIDgsIDExXG5dO1xuXG5leHBvcnRzLnN1YnN0aXR1dGUgPSBmdW5jdGlvbiBzdWJzdGl0dXRlKGluTCwgaW5SKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluTCA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlW2kgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5SID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbNCAqIDB4NDAgKyBpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxudmFyIHBlcm11dGVUYWJsZSA9IFtcbiAgMTYsIDI1LCAxMiwgMTEsIDMsIDIwLCA0LCAxNSwgMzEsIDE3LCA5LCA2LCAyNywgMTQsIDEsIDIyLFxuICAzMCwgMjQsIDgsIDE4LCAwLCA1LCAyOSwgMjMsIDEzLCAxOSwgMiwgMjYsIDEwLCAyMSwgMjgsIDdcbl07XG5cbmV4cG9ydHMucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUobnVtKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlcm11dGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dCA8PD0gMTtcbiAgICBvdXQgfD0gKG51bSA+Pj4gcGVybXV0ZVRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYWRTcGxpdCA9IGZ1bmN0aW9uIHBhZFNwbGl0KG51bSwgc2l6ZSwgZ3JvdXApIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygyKTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBzaXplKVxuICAgIHN0ciA9ICcwJyArIHN0cjtcblxuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBncm91cClcbiAgICBvdXQucHVzaChzdHIuc2xpY2UoaSwgaSArIGdyb3VwKSk7XG4gIHJldHVybiBvdXQuam9pbignICcpO1xufTtcbiIsInZhciBnZW5lcmF0ZVByaW1lID0gcmVxdWlyZSgnLi9saWIvZ2VuZXJhdGVQcmltZScpXG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9saWIvcHJpbWVzLmpzb24nKVxuXG52YXIgREggPSByZXF1aXJlKCcuL2xpYi9kaCcpXG5cbmZ1bmN0aW9uIGdldERpZmZpZUhlbGxtYW4gKG1vZCkge1xuICB2YXIgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLnByaW1lLCAnaGV4JylcbiAgdmFyIGdlbiA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0uZ2VuLCAnaGV4JylcblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW4pXG59XG5cbnZhciBFTkNPRElOR1MgPSB7XG4gICdiaW5hcnknOiB0cnVlLCAnaGV4JzogdHJ1ZSwgJ2Jhc2U2NCc6IHRydWVcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlmZmllSGVsbG1hbiAocHJpbWUsIGVuYywgZ2VuZXJhdG9yLCBnZW5jKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZW5jKSB8fCBFTkNPRElOR1NbZW5jXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURpZmZpZUhlbGxtYW4ocHJpbWUsICdiaW5hcnknLCBlbmMsIGdlbmVyYXRvcilcbiAgfVxuXG4gIGVuYyA9IGVuYyB8fCAnYmluYXJ5J1xuICBnZW5jID0gZ2VuYyB8fCAnYmluYXJ5J1xuICBnZW5lcmF0b3IgPSBnZW5lcmF0b3IgfHwgbmV3IEJ1ZmZlcihbMl0pXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuZXJhdG9yKSkge1xuICAgIGdlbmVyYXRvciA9IG5ldyBCdWZmZXIoZ2VuZXJhdG9yLCBnZW5jKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IERIKGdlbmVyYXRlUHJpbWUocHJpbWUsIGdlbmVyYXRvciksIGdlbmVyYXRvciwgdHJ1ZSlcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaW1lKSkge1xuICAgIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZSwgZW5jKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuZXJhdG9yLCB0cnVlKVxufVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZ2V0RGlmZmllSGVsbG1hblxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZXhwb3J0cy5EaWZmaWVIZWxsbWFuID0gY3JlYXRlRGlmZmllSGVsbG1hblxuIiwidmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgVFdFTlRZRk9VUiA9IG5ldyBCTigyNCk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBURU4gPSBuZXcgQk4oMTApO1xudmFyIFRIUkVFID0gbmV3IEJOKDMpO1xudmFyIFNFVkVOID0gbmV3IEJOKDcpO1xudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vZ2VuZXJhdGVQcmltZScpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gREg7XG5cbmZ1bmN0aW9uIHNldFB1YmxpY0tleShwdWIsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG4gICAgcHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHViID0gbmV3IEJOKHB1Yik7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRQcml2YXRlS2V5KHByaXYsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2KSkge1xuICAgIHByaXYgPSBuZXcgQnVmZmVyKHByaXYsIGVuYyk7XG4gIH1cbiAgdGhpcy5fcHJpdiA9IG5ldyBCTihwcml2KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcmltZUNhY2hlID0ge307XG5mdW5jdGlvbiBjaGVja1ByaW1lKHByaW1lLCBnZW5lcmF0b3IpIHtcbiAgdmFyIGdlbiA9IGdlbmVyYXRvci50b1N0cmluZygnaGV4Jyk7XG4gIHZhciBoZXggPSBbZ2VuLCBwcmltZS50b1N0cmluZygxNildLmpvaW4oJ18nKTtcbiAgaWYgKGhleCBpbiBwcmltZUNhY2hlKSB7XG4gICAgcmV0dXJuIHByaW1lQ2FjaGVbaGV4XTtcbiAgfVxuICB2YXIgZXJyb3IgPSAwO1xuXG4gIGlmIChwcmltZS5pc0V2ZW4oKSB8fFxuICAgICFwcmltZXMuc2ltcGxlU2lldmUgfHxcbiAgICAhcHJpbWVzLmZlcm1hdFRlc3QocHJpbWUpIHx8XG4gICAgIW1pbGxlclJhYmluLnRlc3QocHJpbWUpKSB7XG4gICAgLy9ub3QgYSBwcmltZSBzbyArMVxuICAgIGVycm9yICs9IDE7XG5cbiAgICBpZiAoZ2VuID09PSAnMDInIHx8IGdlbiA9PT0gJzA1Jykge1xuICAgICAgLy8gd2UnZCBiZSBhYmxlIHRvIGNoZWNrIHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIGl0IHdvdWxkIGZhaWwgc28gKzhcbiAgICAgIGVycm9yICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZXN0IHRoZSBnZW5lcmF0b3JcbiAgICAgIC8vIHNvICs0XG4gICAgICBlcnJvciArPSA0O1xuICAgIH1cbiAgICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKCFtaWxsZXJSYWJpbi50ZXN0KHByaW1lLnNocm4oMSkpKSB7XG4gICAgLy9ub3QgYSBzYWZlIHByaW1lXG4gICAgZXJyb3IgKz0gMjtcbiAgfVxuICB2YXIgcmVtO1xuICBzd2l0Y2ggKGdlbikge1xuICAgIGNhc2UgJzAyJzpcbiAgICAgIGlmIChwcmltZS5tb2QoVFdFTlRZRk9VUikuY21wKEVMRVZFTikpIHtcbiAgICAgICAgLy8gdW5zdWlkYWJsZSBnZW5lcmF0b3JcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzA1JzpcbiAgICAgIHJlbSA9IHByaW1lLm1vZChURU4pO1xuICAgICAgaWYgKHJlbS5jbXAoVEhSRUUpICYmIHJlbS5jbXAoU0VWRU4pKSB7XG4gICAgICAgIC8vIHByaW1lIG1vZCAxMCBuZWVkcyB0byBlcXVhbCAzIG9yIDdcbiAgICAgICAgZXJyb3IgKz0gODtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciArPSA0O1xuICB9XG4gIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIERIKHByaW1lLCBnZW5lcmF0b3IsIG1hbGxlYWJsZSkge1xuICB0aGlzLnNldEdlbmVyYXRvcihnZW5lcmF0b3IpO1xuICB0aGlzLl9fcHJpbWUgPSBuZXcgQk4ocHJpbWUpO1xuICB0aGlzLl9wcmltZSA9IEJOLm1vbnQodGhpcy5fX3ByaW1lKTtcbiAgdGhpcy5fcHJpbWVMZW4gPSBwcmltZS5sZW5ndGg7XG4gIHRoaXMuX3B1YiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpdiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJpbWVDb2RlID0gdW5kZWZpbmVkO1xuICBpZiAobWFsbGVhYmxlKSB7XG4gICAgdGhpcy5zZXRQdWJsaWNLZXkgPSBzZXRQdWJsaWNLZXk7XG4gICAgdGhpcy5zZXRQcml2YXRlS2V5ID0gc2V0UHJpdmF0ZUtleTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wcmltZUNvZGUgPSA4O1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREgucHJvdG90eXBlLCAndmVyaWZ5RXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcHJpbWVDb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fcHJpbWVDb2RlID0gY2hlY2tQcmltZSh0aGlzLl9fcHJpbWUsIHRoaXMuX19nZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpbWVDb2RlO1xuICB9XG59KTtcbkRILnByb3RvdHlwZS5nZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fcHJpdikge1xuICAgIHRoaXMuX3ByaXYgPSBuZXcgQk4ocmFuZG9tQnl0ZXModGhpcy5fcHJpbWVMZW4pKTtcbiAgfVxuICB0aGlzLl9wdWIgPSB0aGlzLl9nZW4udG9SZWQodGhpcy5fcHJpbWUpLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHJldHVybiB0aGlzLmdldFB1YmxpY0tleSgpO1xufTtcblxuREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgb3RoZXIgPSBuZXcgQk4ob3RoZXIpO1xuICBvdGhlciA9IG90aGVyLnRvUmVkKHRoaXMuX3ByaW1lKTtcbiAgdmFyIHNlY3JldCA9IG90aGVyLnJlZFBvdyh0aGlzLl9wcml2KS5mcm9tUmVkKCk7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKHNlY3JldC50b0FycmF5KCkpO1xuICB2YXIgcHJpbWUgPSB0aGlzLmdldFByaW1lKCk7XG4gIGlmIChvdXQubGVuZ3RoIDwgcHJpbWUubGVuZ3RoKSB7XG4gICAgdmFyIGZyb250ID0gbmV3IEJ1ZmZlcihwcmltZS5sZW5ndGggLSBvdXQubGVuZ3RoKTtcbiAgICBmcm9udC5maWxsKDApO1xuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW2Zyb250LCBvdXRdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuREgucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIGdldFB1YmxpY0tleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3B1YiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZUtleShlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX3ByaXYsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpbWUgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9fcHJpbWUsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fZ2VuLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLnNldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChnZW4sIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW4pKSB7XG4gICAgZ2VuID0gbmV3IEJ1ZmZlcihnZW4sIGVuYyk7XG4gIH1cbiAgdGhpcy5fX2dlbiA9IGdlbjtcbiAgdGhpcy5fZ2VuID0gbmV3IEJOKGdlbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUoYm4sIGVuYykge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihibi50b0FycmF5KCkpO1xuICBpZiAoIWVuYykge1xuICAgIHJldHVybiBidWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhlbmMpO1xuICB9XG59XG4iLCJ2YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmaW5kUHJpbWU7XG5maW5kUHJpbWUuc2ltcGxlU2lldmUgPSBzaW1wbGVTaWV2ZTtcbmZpbmRQcmltZS5mZXJtYXRUZXN0ID0gZmVybWF0VGVzdDtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgVFdFTlRZRk9VUiA9IG5ldyBCTigyNCk7XG52YXIgTWlsbGVyUmFiaW4gPSByZXF1aXJlKCdtaWxsZXItcmFiaW4nKTtcbnZhciBtaWxsZXJSYWJpbiA9IG5ldyBNaWxsZXJSYWJpbigpO1xudmFyIE9ORSA9IG5ldyBCTigxKTtcbnZhciBUV08gPSBuZXcgQk4oMik7XG52YXIgRklWRSA9IG5ldyBCTig1KTtcbnZhciBTSVhURUVOID0gbmV3IEJOKDE2KTtcbnZhciBFSUdIVCA9IG5ldyBCTig4KTtcbnZhciBURU4gPSBuZXcgQk4oMTApO1xudmFyIFRIUkVFID0gbmV3IEJOKDMpO1xudmFyIFNFVkVOID0gbmV3IEJOKDcpO1xudmFyIEVMRVZFTiA9IG5ldyBCTigxMSk7XG52YXIgRk9VUiA9IG5ldyBCTig0KTtcbnZhciBUV0VMVkUgPSBuZXcgQk4oMTIpO1xudmFyIHByaW1lcyA9IG51bGw7XG5cbmZ1bmN0aW9uIF9nZXRQcmltZXMoKSB7XG4gIGlmIChwcmltZXMgIT09IG51bGwpXG4gICAgcmV0dXJuIHByaW1lcztcblxuICB2YXIgbGltaXQgPSAweDEwMDAwMDtcbiAgdmFyIHJlcyA9IFtdO1xuICByZXNbMF0gPSAyO1xuICBmb3IgKHZhciBpID0gMSwgayA9IDM7IGsgPCBsaW1pdDsgayArPSAyKSB7XG4gICAgdmFyIHNxcnQgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGspKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgJiYgcmVzW2pdIDw9IHNxcnQ7IGorKylcbiAgICAgIGlmIChrICUgcmVzW2pdID09PSAwKVxuICAgICAgICBicmVhaztcblxuICAgIGlmIChpICE9PSBqICYmIHJlc1tqXSA8PSBzcXJ0KVxuICAgICAgY29udGludWU7XG5cbiAgICByZXNbaSsrXSA9IGs7XG4gIH1cbiAgcHJpbWVzID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVTaWV2ZShwKSB7XG4gIHZhciBwcmltZXMgPSBfZ2V0UHJpbWVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmltZXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHAubW9kbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICBpZiAocC5jbXBuKHByaW1lc1tpXSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmZXJtYXRUZXN0KHApIHtcbiAgdmFyIHJlZCA9IEJOLm1vbnQocCk7XG4gIHJldHVybiBUV08udG9SZWQocmVkKS5yZWRQb3cocC5zdWJuKDEpKS5mcm9tUmVkKCkuY21wbigxKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZmluZFByaW1lKGJpdHMsIGdlbikge1xuICBpZiAoYml0cyA8IDE2KSB7XG4gICAgLy8gdGhpcyBpcyB3aGF0IG9wZW5zc2wgZG9lc1xuICAgIGlmIChnZW4gPT09IDIgfHwgZ2VuID09PSA1KSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDdiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQk4oWzB4OGMsIDB4MjddKTtcbiAgICB9XG4gIH1cbiAgZ2VuID0gbmV3IEJOKGdlbik7XG5cbiAgdmFyIG51bSwgbjI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBudW0gPSBuZXcgQk4ocmFuZG9tQnl0ZXMoTWF0aC5jZWlsKGJpdHMgLyA4KSkpO1xuICAgIHdoaWxlIChudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICBudW0uaXNocm4oMSk7XG4gICAgfVxuICAgIGlmIChudW0uaXNFdmVuKCkpIHtcbiAgICAgIG51bS5pYWRkKE9ORSk7XG4gICAgfVxuICAgIGlmICghbnVtLnRlc3RuKDEpKSB7XG4gICAgICBudW0uaWFkZChUV08pO1xuICAgIH1cbiAgICBpZiAoIWdlbi5jbXAoVFdPKSkge1xuICAgICAgd2hpbGUgKG51bS5tb2QoVFdFTlRZRk9VUikuY21wKEVMRVZFTikpIHtcbiAgICAgICAgbnVtLmlhZGQoRk9VUik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ2VuLmNtcChGSVZFKSkge1xuICAgICAgd2hpbGUgKG51bS5tb2QoVEVOKS5jbXAoVEhSRUUpKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH1cbiAgICBuMiA9IG51bS5zaHJuKDEpO1xuICAgIGlmIChzaW1wbGVTaWV2ZShuMikgJiYgc2ltcGxlU2lldmUobnVtKSAmJlxuICAgICAgZmVybWF0VGVzdChuMikgJiYgZmVybWF0VGVzdChudW0pICYmXG4gICAgICBtaWxsZXJSYWJpbi50ZXN0KG4yKSAmJiBtaWxsZXJSYWJpbi50ZXN0KG51bSkpIHtcbiAgICAgIHJldHVybiBudW07XG4gICAgfVxuICB9XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5lbGxpcHRpYy51dGlscyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvdXRpbHMnKTtcbmVsbGlwdGljLnJhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG5lbGxpcHRpYy5jdXJ2ZSA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmUnKTtcbmVsbGlwdGljLmN1cnZlcyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvY3VydmVzJyk7XG5cbi8vIFByb3RvY29sc1xuZWxsaXB0aWMuZWMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VjJyk7XG5lbGxpcHRpYy5lZGRzYSA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWRkc2EnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBnZXROQUYgPSB1dGlscy5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHMuZ2V0SlNGO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgLy8gR2VuZXJhbGl6ZWQgR3JlZyBNYXh3ZWxsJ3MgdHJpY2tcbiAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcbiAgaWYgKCFhZGp1c3RDb3VudCB8fCBhZGp1c3RDb3VudC5jbXBuKDEwMCkgPiAwKSB7XG4gICAgdGhpcy5yZWROID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYXh3ZWxsVHJpY2sgPSB0cnVlO1xuICAgIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydChwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIHZhciBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBrID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGsgPj0gajsgay0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3KTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgaysrO1xuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0pO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMyAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG4gIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cbiAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcbiAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuXG4gICAgdmFyIHJlcyA9ICB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSkgO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91Ymxlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlc1xuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEVkd2FyZHNDdXJ2ZShjb25mKSB7XG4gIC8vIE5PVEU6IEltcG9ydGFudCBhcyB3ZSBhcmUgY3JlYXRpbmcgcG9pbnQgaW4gQmFzZS5jYWxsKClcbiAgdGhpcy50d2lzdGVkID0gKGNvbmYuYSB8IDApICE9PSAxO1xuICB0aGlzLm1PbmVBID0gdGhpcy50d2lzdGVkICYmIChjb25mLmEgfCAwKSA9PT0gLTE7XG4gIHRoaXMuZXh0ZW5kZWQgPSB0aGlzLm1PbmVBO1xuXG4gIEJhc2UuY2FsbCh0aGlzLCAnZWR3YXJkcycsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS51bW9kKHRoaXMucmVkLm0pO1xuICB0aGlzLmEgPSB0aGlzLmEudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMgPSBuZXcgQk4oY29uZi5jLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmMyID0gdGhpcy5jLnJlZFNxcigpO1xuICB0aGlzLmQgPSBuZXcgQk4oY29uZi5kLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmRkID0gdGhpcy5kLnJlZEFkZCh0aGlzLmQpO1xuXG4gIGFzc2VydCghdGhpcy50d2lzdGVkIHx8IHRoaXMuYy5mcm9tUmVkKCkuY21wbigxKSA9PT0gMCk7XG4gIHRoaXMub25lQyA9IChjb25mLmMgfCAwKSA9PT0gMTtcbn1cbmluaGVyaXRzKEVkd2FyZHNDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVkd2FyZHNDdXJ2ZTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQSA9IGZ1bmN0aW9uIF9tdWxBKG51bSkge1xuICBpZiAodGhpcy5tT25lQSlcbiAgICByZXR1cm4gbnVtLnJlZE5lZygpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYS5yZWRNdWwobnVtKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEMgPSBmdW5jdGlvbiBfbXVsQyhudW0pIHtcbiAgaWYgKHRoaXMub25lQylcbiAgICByZXR1cm4gbnVtO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuYy5yZWRNdWwobnVtKTtcbn07XG5cbi8vIEp1c3QgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTaG9ydCBjdXJ2ZVxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5LCB6LCB0KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRTdWIodGhpcy5hLnJlZE11bCh4MikpO1xuICB2YXIgbGhzID0gdGhpcy5vbmUucmVkU3ViKHRoaXMuYzIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHgyKSk7XG5cbiAgdmFyIHkyID0gcmhzLnJlZE11bChsaHMucmVkSW52bSgpKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWSA9IGZ1bmN0aW9uIHBvaW50RnJvbVkoeSwgb2RkKSB7XG4gIHkgPSBuZXcgQk4oeSwgMTYpO1xuICBpZiAoIXkucmVkKVxuICAgIHkgPSB5LnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyB4XjIgPSAoeV4yIC0gY14yKSAvIChjXjIgZCB5XjIgLSBhKVxuICB2YXIgeTIgPSB5LnJlZFNxcigpO1xuICB2YXIgbGhzID0geTIucmVkU3ViKHRoaXMuYzIpO1xuICB2YXIgcmhzID0geTIucmVkTXVsKHRoaXMuZCkucmVkTXVsKHRoaXMuYzIpLnJlZFN1Yih0aGlzLmEpO1xuICB2YXIgeDIgPSBsaHMucmVkTXVsKHJocy5yZWRJbnZtKCkpO1xuXG4gIGlmICh4Mi5jbXAodGhpcy56ZXJvKSA9PT0gMCkge1xuICAgIGlmIChvZGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5wb2ludCh0aGlzLnplcm8sIHkpO1xuICB9XG5cbiAgdmFyIHggPSB4Mi5yZWRTcXJ0KCk7XG4gIGlmICh4LnJlZFNxcigpLnJlZFN1Yih4MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgaWYgKHguZnJvbVJlZCgpLmlzT2RkKCkgIT09IG9kZClcbiAgICB4ID0geC5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIEN1cnZlOiBBICogWF4yICsgWV4yID0gQ14yICogKDEgKyBEICogWF4yICogWV4yKVxuICBwb2ludC5ub3JtYWxpemUoKTtcblxuICB2YXIgeDIgPSBwb2ludC54LnJlZFNxcigpO1xuICB2YXIgeTIgPSBwb2ludC55LnJlZFNxcigpO1xuICB2YXIgbGhzID0geDIucmVkTXVsKHRoaXMuYSkucmVkQWRkKHkyKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkTXVsKHRoaXMub25lLnJlZEFkZCh0aGlzLmQucmVkTXVsKHgyKS5yZWRNdWwoeTIpKSk7XG5cbiAgcmV0dXJuIGxocy5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCB6LCB0KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy56T25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0geiA/IG5ldyBCTih6LCAxNikgOiB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0ICYmIG5ldyBCTih0LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKHRoaXMudCAmJiAhdGhpcy50LnJlZClcbiAgICAgIHRoaXMudCA9IHRoaXMudC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblxuICAgIC8vIFVzZSBleHRlbmRlZCBjb29yZGluYXRlc1xuICAgIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkICYmICF0aGlzLnQpIHtcbiAgICAgIHRoaXMudCA9IHRoaXMueC5yZWRNdWwodGhpcy55KTtcbiAgICAgIGlmICghdGhpcy56T25lKVxuICAgICAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICAgIH1cbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIHosIHQpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdLCBvYmpbMl0pO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy54LmNtcG4oMCkgPT09IDAgJiZcbiAgICAodGhpcy55LmNtcCh0aGlzLnopID09PSAwIHx8XG4gICAgKHRoaXMuek9uZSAmJiB0aGlzLnkuY21wKHRoaXMuY3VydmUuYykgPT09IDApKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24gX2V4dERibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAvLyA0TSArIDRTXG5cbiAgLy8gQSA9IFgxXjJcbiAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEIgPSBZMV4yXG4gIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBDID0gMiAqIFoxXjJcbiAgdmFyIGMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIGMgPSBjLnJlZElBZGQoYyk7XG4gIC8vIEQgPSBhICogQVxuICB2YXIgZCA9IHRoaXMuY3VydmUuX211bEEoYSk7XG4gIC8vIEUgPSAoWDEgKyBZMSleMiAtIEEgLSBCXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihiKTtcbiAgLy8gRyA9IEQgKyBCXG4gIHZhciBnID0gZC5yZWRBZGQoYik7XG4gIC8vIEYgPSBHIC0gQ1xuICB2YXIgZiA9IGcucmVkU3ViKGMpO1xuICAvLyBIID0gRCAtIEJcbiAgdmFyIGggPSBkLnJlZFN1YihiKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qRGJsID0gZnVuY3Rpb24gX3Byb2pEYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWJiamxwXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDctYmxcbiAgLy8gYW5kIG90aGVyc1xuICAvLyBHZW5lcmFsbHkgM00gKyA0UyBvciAyTSArIDRTXG5cbiAgLy8gQiA9IChYMSArIFkxKV4yXG4gIHZhciBiID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpO1xuICAvLyBDID0gWDFeMlxuICB2YXIgYyA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gRCA9IFkxXjJcbiAgdmFyIGQgPSB0aGlzLnkucmVkU3FyKCk7XG5cbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIEUgPSBhICogQ1xuICAgIHZhciBlID0gdGhpcy5jdXJ2ZS5fbXVsQShjKTtcbiAgICAvLyBGID0gRSArIERcbiAgICB2YXIgZiA9IGUucmVkQWRkKGQpO1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgIC8vIFgzID0gKEIgLSBDIC0gRCkgKiAoRiAtIDIpXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZFN1YihkKS5yZWRNdWwoZi5yZWRTdWIodGhpcy5jdXJ2ZS50d28pKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGXjIgLSAyICogRlxuICAgICAgbnogPSBmLnJlZFNxcigpLnJlZFN1YihmKS5yZWRTdWIoZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEggPSBaMV4yXG4gICAgICB2YXIgaCA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAgIC8vIEogPSBGIC0gMiAqIEhcbiAgICAgIHZhciBqID0gZi5yZWRTdWIoaCkucmVkSVN1YihoKTtcbiAgICAgIC8vIFgzID0gKEItQy1EKSpKXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZElTdWIoZCkucmVkTXVsKGopO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEYgKiBKXG4gICAgICBueiA9IGYucmVkTXVsKGopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBFID0gQyArIERcbiAgICB2YXIgZSA9IGMucmVkQWRkKGQpO1xuICAgIC8vIEggPSAoYyAqIFoxKV4yXG4gICAgdmFyIGggPSB0aGlzLmN1cnZlLl9tdWxDKHRoaXMueikucmVkU3FyKCk7XG4gICAgLy8gSiA9IEUgLSAyICogSFxuICAgIHZhciBqID0gZS5yZWRTdWIoaCkucmVkU3ViKGgpO1xuICAgIC8vIFgzID0gYyAqIChCIC0gRSkgKiBKXG4gICAgbnggPSB0aGlzLmN1cnZlLl9tdWxDKGIucmVkSVN1YihlKSkucmVkTXVsKGopO1xuICAgIC8vIFkzID0gYyAqIEUgKiAoQyAtIEQpXG4gICAgbnkgPSB0aGlzLmN1cnZlLl9tdWxDKGUpLnJlZE11bChjLnJlZElTdWIoZCkpO1xuICAgIC8vIFozID0gRSAqIEpcbiAgICBueiA9IGUucmVkTXVsKGopO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIERvdWJsZSBpbiBleHRlbmRlZCBjb29yZGluYXRlc1xuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0RGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakRibCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHRBZGQgPSBmdW5jdGlvbiBfZXh0QWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gIC8vIDhNXG5cbiAgLy8gQSA9IChZMSAtIFgxKSAqIChZMiAtIFgyKVxuICB2YXIgYSA9IHRoaXMueS5yZWRTdWIodGhpcy54KS5yZWRNdWwocC55LnJlZFN1YihwLngpKTtcbiAgLy8gQiA9IChZMSArIFgxKSAqIChZMiArIFgyKVxuICB2YXIgYiA9IHRoaXMueS5yZWRBZGQodGhpcy54KS5yZWRNdWwocC55LnJlZEFkZChwLngpKTtcbiAgLy8gQyA9IFQxICogayAqIFQyXG4gIHZhciBjID0gdGhpcy50LnJlZE11bCh0aGlzLmN1cnZlLmRkKS5yZWRNdWwocC50KTtcbiAgLy8gRCA9IFoxICogMiAqIFoyXG4gIHZhciBkID0gdGhpcy56LnJlZE11bChwLnoucmVkQWRkKHAueikpO1xuICAvLyBFID0gQiAtIEFcbiAgdmFyIGUgPSBiLnJlZFN1YihhKTtcbiAgLy8gRiA9IEQgLSBDXG4gIHZhciBmID0gZC5yZWRTdWIoYyk7XG4gIC8vIEcgPSBEICsgQ1xuICB2YXIgZyA9IGQucmVkQWRkKGMpO1xuICAvLyBIID0gQiArIEFcbiAgdmFyIGggPSBiLnJlZEFkZChhKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qQWRkID0gZnVuY3Rpb24gX3Byb2pBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1iYmpscFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA3LWJsXG4gIC8vIDEwTSArIDFTXG5cbiAgLy8gQSA9IFoxICogWjJcbiAgdmFyIGEgPSB0aGlzLnoucmVkTXVsKHAueik7XG4gIC8vIEIgPSBBXjJcbiAgdmFyIGIgPSBhLnJlZFNxcigpO1xuICAvLyBDID0gWDEgKiBYMlxuICB2YXIgYyA9IHRoaXMueC5yZWRNdWwocC54KTtcbiAgLy8gRCA9IFkxICogWTJcbiAgdmFyIGQgPSB0aGlzLnkucmVkTXVsKHAueSk7XG4gIC8vIEUgPSBkICogQyAqIERcbiAgdmFyIGUgPSB0aGlzLmN1cnZlLmQucmVkTXVsKGMpLnJlZE11bChkKTtcbiAgLy8gRiA9IEIgLSBFXG4gIHZhciBmID0gYi5yZWRTdWIoZSk7XG4gIC8vIEcgPSBCICsgRVxuICB2YXIgZyA9IGIucmVkQWRkKGUpO1xuICAvLyBYMyA9IEEgKiBGICogKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEMgLSBEKVxuICB2YXIgdG1wID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZE11bChwLngucmVkQWRkKHAueSkpLnJlZElTdWIoYykucmVkSVN1YihkKTtcbiAgdmFyIG54ID0gYS5yZWRNdWwoZikucmVkTXVsKHRtcCk7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gYSAqIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIodGhpcy5jdXJ2ZS5fbXVsQShjKSkpO1xuICAgIC8vIFozID0gRiAqIEdcbiAgICBueiA9IGYucmVkTXVsKGcpO1xuICB9IGVsc2Uge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIoYykpO1xuICAgIC8vIFozID0gYyAqIEYgKiBHXG4gICAgbnogPSB0aGlzLmN1cnZlLl9tdWxDKGYpLnJlZE11bChnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0QWRkKHApO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pBZGQocCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgZmFsc2UpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICBpZiAodGhpcy56T25lKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB2YXIgemkgPSB0aGlzLnoucmVkSW52bSgpO1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHppKTtcbiAgdGhpcy55ID0gdGhpcy55LnJlZE11bCh6aSk7XG4gIGlmICh0aGlzLnQpXG4gICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh6aSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICB0aGlzLnpPbmUgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWROZWcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCAmJiB0aGlzLnQucmVkTmVnKCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgICAgIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwICYmXG4gICAgICAgICB0aGlzLmdldFkoKS5jbXAob3RoZXIuZ2V0WSgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwodGhpcy56KTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHRoaXMueik7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBDb21wYXRpYmlsaXR5IHdpdGggQmFzZUN1cnZlXG5Qb2ludC5wcm90b3R5cGUudG9QID0gUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZTtcblBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IFBvaW50LnByb3RvdHlwZS5hZGQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcblxuZnVuY3Rpb24gTW9udEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdtb250JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5pNCA9IG5ldyBCTig0KS50b1JlZCh0aGlzLnJlZCkucmVkSW52bSgpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYTI0ID0gdGhpcy5pNC5yZWRNdWwodGhpcy5hLnJlZEFkZCh0aGlzLnR3bykpO1xufVxuaW5oZXJpdHMoTW9udEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gTW9udEN1cnZlO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludC5ub3JtYWxpemUoKS54O1xuICB2YXIgeDIgPSB4LnJlZFNxcigpO1xuICB2YXIgcmhzID0geDIucmVkTXVsKHgpLnJlZEFkZCh4Mi5yZWRNdWwodGhpcy5hKSkucmVkQWRkKHgpO1xuICB2YXIgeSA9IHJocy5yZWRTcXJ0KCk7XG5cbiAgcmV0dXJuIHkucmVkU3FyKCkuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyksIDEpO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHopIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB6KTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAvLyBOby1vcFxufTtcblxuUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpKTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSB8fCBjdXJ2ZS5vbmUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkb3VibGluZy1kYmwtMTk4Ny1tLTNcbiAgLy8gMk0gKyAyUyArIDRBXG5cbiAgLy8gQSA9IFgxICsgWjFcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEFBID0gQV4yXG4gIHZhciBhYSA9IGEucmVkU3FyKCk7XG4gIC8vIEIgPSBYMSAtIFoxXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBCQiA9IEJeMlxuICB2YXIgYmIgPSBiLnJlZFNxcigpO1xuICAvLyBDID0gQUEgLSBCQlxuICB2YXIgYyA9IGFhLnJlZFN1YihiYik7XG4gIC8vIFgzID0gQUEgKiBCQlxuICB2YXIgbnggPSBhYS5yZWRNdWwoYmIpO1xuICAvLyBaMyA9IEMgKiAoQkIgKyBBMjQgKiBDKVxuICB2YXIgbnogPSBjLnJlZE11bChiYi5yZWRBZGQodGhpcy5jdXJ2ZS5hMjQucmVkTXVsKGMpKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRpZmZBZGQgPSBmdW5jdGlvbiBkaWZmQWRkKHAsIGRpZmYpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZGlmZmFkZC1kYWRkLTE5ODctbS0zXG4gIC8vIDRNICsgMlMgKyA2QVxuXG4gIC8vIEEgPSBYMiArIFoyXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBCID0gWDIgLSBaMlxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQyA9IFgzICsgWjNcbiAgdmFyIGMgPSBwLngucmVkQWRkKHAueik7XG4gIC8vIEQgPSBYMyAtIFozXG4gIHZhciBkID0gcC54LnJlZFN1YihwLnopO1xuICAvLyBEQSA9IEQgKiBBXG4gIHZhciBkYSA9IGQucmVkTXVsKGEpO1xuICAvLyBDQiA9IEMgKiBCXG4gIHZhciBjYiA9IGMucmVkTXVsKGIpO1xuICAvLyBYNSA9IFoxICogKERBICsgQ0IpXjJcbiAgdmFyIG54ID0gZGlmZi56LnJlZE11bChkYS5yZWRBZGQoY2IpLnJlZFNxcigpKTtcbiAgLy8gWjUgPSBYMSAqIChEQSAtIENCKV4yXG4gIHZhciBueiA9IGRpZmYueC5yZWRNdWwoZGEucmVkSVN1YihjYikucmVkU3FyKCkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIHZhciB0ID0gay5jbG9uZSgpO1xuICB2YXIgYSA9IHRoaXM7IC8vIChOIC8gMikgKiBRICsgUVxuICB2YXIgYiA9IHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7IC8vIChOIC8gMikgKiBRXG4gIHZhciBjID0gdGhpczsgLy8gUVxuXG4gIGZvciAodmFyIGJpdHMgPSBbXTsgdC5jbXBuKDApICE9PSAwOyB0Lml1c2hybigxKSlcbiAgICBiaXRzLnB1c2godC5hbmRsbigxKSk7XG5cbiAgZm9yICh2YXIgaSA9IGJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYml0c1tpXSA9PT0gMCkge1xuICAgICAgLy8gTiAqIFEgKyBRID0gKChOIC8gMikgKiBRICsgUSkpICsgKE4gLyAyKSAqIFFcbiAgICAgIGEgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKSlcbiAgICAgIGIgPSBiLmRibCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOICogUSA9ICgoTiAvIDIpICogUSArIFEpICsgKChOIC8gMikgKiBRKVxuICAgICAgYiA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRICsgUSA9IDIgKiAoKE4gLyAyKSAqIFEgKyBRKVxuICAgICAgYSA9IGEuZGJsKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qdW1sQWRkID0gZnVuY3Rpb24ganVtbEFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzKFNob3J0Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCh0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cbiAgdmFyIGJhc2lzO1xuICBpZiAoY29uZi5iYXNpcykge1xuICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgQk4odmVjLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IEJOKHZlYy5iLCAxNilcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXNcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IEJOLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgQk4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgQk4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cbiAgLy8gMy43NFxuICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuICB2YXIgdSA9IGxhbWJkYTtcbiAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeTEgPSBuZXcgQk4oMCk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcbiAgdmFyIHkyID0gbmV3IEJOKDEpO1xuXG4gIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2QgbilcbiAgdmFyIGEwO1xuICB2YXIgYjA7XG4gIC8vIEZpcnN0IHZlY3RvclxuICB2YXIgYTE7XG4gIHZhciBiMTtcbiAgLy8gU2Vjb25kIHZlY3RvclxuICB2YXIgYTI7XG4gIHZhciBiMjtcblxuICB2YXIgcHJldlI7XG4gIHZhciBpID0gMDtcbiAgdmFyIHI7XG4gIHZhciB4O1xuICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG4gICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICByID0gdi5zdWIocS5tdWwodSkpO1xuICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcbiAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuXG4gICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG4gICAgICBhMCA9IHByZXZSLm5lZygpO1xuICAgICAgYjAgPSB4MTtcbiAgICAgIGExID0gci5uZWcoKTtcbiAgICAgIGIxID0geDtcbiAgICB9IGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZSID0gcjtcblxuICAgIHYgPSB1O1xuICAgIHUgPSByO1xuICAgIHgyID0geDE7XG4gICAgeDEgPSB4O1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB5O1xuICB9XG4gIGEyID0gci5uZWcoKTtcbiAgYjIgPSB4O1xuXG4gIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuICBpZiAobGVuMi5jbXAobGVuMSkgPj0gMCkge1xuICAgIGEyID0gYTA7XG4gICAgYjIgPSBiMDtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzaWduc1xuICBpZiAoYTEubmVnYXRpdmUpIHtcbiAgICBhMSA9IGExLm5lZygpO1xuICAgIGIxID0gYjEubmVnKCk7XG4gIH1cbiAgaWYgKGEyLm5lZ2F0aXZlKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH1cbiAgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcbiAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgdmFyIHYyID0gYmFzaXNbMV07XG5cbiAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcbiAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG4gIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cbiAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcbiAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIC8vIFhYWCBJcyB0aGVyZSBhbnkgd2F5IHRvIHRlbGwgaWYgdGhlIG51bWJlciBpcyBvZGQgd2l0aG91dCBjb252ZXJ0aW5nIGl0XG4gIC8vIHRvIG5vbi1yZWQgZm9ybT9cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmluZilcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IHBvaW50Lng7XG4gIHZhciB5ID0gcG9pbnQueTtcblxuICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG4gICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgcCA9IHAubmVnKHRydWUpO1xuICAgIH1cbiAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsyLmluZWcoKTtcbiAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICB9XG5cbiAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICB9XG4gIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG5cbiAgLy8gQ2xlYW4tdXAgcmVmZXJlbmNlcyB0byBwb2ludHMgYW5kIGNvZWZmaWNpZW50c1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICBucG9pbnRzW2pdID0gbnVsbDtcbiAgICBuY29lZmZzW2pdID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIGlzUmVkKSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdhZmZpbmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IG51bGw7XG4gICAgdGhpcy55ID0gbnVsbDtcbiAgICB0aGlzLmluZiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIC8vIEZvcmNlIHJlZGdvbWVyeSByZXByZXNlbnRhdGlvbiB3aGVuIGxvYWRpbmcgZnJvbSBKU09OXG4gICAgaWYgKGlzUmVkKSB7XG4gICAgICB0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgdGhpcy55LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuaW5mID0gZmFsc2U7XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCBpc1JlZCk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqLCByZWQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybjtcblxuICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgaWYgKHByZSAmJiBwcmUuYmV0YSlcbiAgICByZXR1cm4gcHJlLmJldGE7XG5cbiAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICBpZiAocHJlKSB7XG4gICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcbiAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSksIHAueSk7XG4gICAgfTtcbiAgICBwcmUuYmV0YSA9IGJldGE7XG4gICAgYmV0YS5wcmVjb21wdXRlZCA9IHtcbiAgICAgIGJldGE6IG51bGwsXG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYmV0YTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xuXG4gIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcbiAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSlcbiAgICB9LFxuICAgIG5hZjogdGhpcy5wcmVjb21wdXRlZC5uYWYgJiYge1xuICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKVxuICAgIH1cbiAgfSBdO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqLCByZWQpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcbiAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICBpZiAoIW9ialsyXSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcbiAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIH1cblxuICB2YXIgcHJlID0gb2JqWzJdO1xuICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgYmV0YTogbnVsbCxcbiAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUuZG91Ymxlcy5wb2ludHMubWFwKG9iajJwb2ludCkpXG4gICAgfSxcbiAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICByZXR1cm4gdGhpcy5pbmY7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIFAgKyBQID0gMlBcbiAgaWYgKHRoaXMuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgLy8gUCArICgtUCkgPSBPXG4gIGlmICh0aGlzLm5lZygpLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIC8vIFAgKyBRID0gT1xuICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBjID0gdGhpcy55LnJlZFN1YihwLnkpO1xuICBpZiAoYy5jbXBuKDApICE9PSAwKVxuICAgIGMgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDJQID0gT1xuICB2YXIgeXMxID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICBpZiAoeXMxLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpO1xuICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuXG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgayA9IG5ldyBCTihrLCAxNik7XG5cbiAgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBCTigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0cyhKUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHopIHtcbiAgcmV0dXJuIG5ldyBKUG9pbnQodGhpcywgeCwgeSwgeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRvUCA9IGZ1bmN0aW9uIHRvUCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciB6aW52ID0gdGhpcy56LnJlZEludm0oKTtcbiAgdmFyIHppbnYyID0gemludi5yZWRTcXIoKTtcbiAgdmFyIGF4ID0gdGhpcy54LnJlZE11bCh6aW52Mik7XG4gIHZhciBheSA9IHRoaXMueS5yZWRNdWwoemludjIpLnJlZE11bCh6aW52KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChheCwgYXkpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDEyTSArIDRTICsgN0FcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6Mik7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnkucmVkTXVsKHB6Mi5yZWRNdWwocC56KSk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIucmVkTXVsKHRoaXMueikpO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKHAueikucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdW5jdGlvbiBtaXhlZEFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHAudG9KKCk7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyA4TSArIDNTICsgN0FcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLng7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAocG93KSB7XG4gIGlmIChwb3cgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFwb3cpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKylcbiAgICAgIHIgPSByLmRibCgpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gMU0gKyAyUyArIDFBICsgTiAqICg0UyArIDVNICsgOEEpXG4gIC8vIE4gPSAxID0+IDZNICsgNlMgKyA5QVxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcbiAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG5cbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIC8vIFJldXNlIHJlc3VsdHNcbiAgdmFyIGp5ZCA9IGp5LnJlZEFkZChqeSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspIHtcbiAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcbiAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcbiAgICBpZiAoaSArIDEgPCBwb3cpXG4gICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG4gICAganggPSBueDtcbiAgICBqeiA9IG56O1xuICAgIGp5ZCA9IGRueTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9kYmwoKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTRBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuICAgIC8vIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyKlkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcbiAgICAvLyAyTSArIDVTICsgMTNBXG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIEIgPSBZMV4yXG4gICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gQyA9IEJeMlxuICAgIHZhciBjID0gYi5yZWRTcXIoKTtcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcbiAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgIC8vIEUgPSAzICogQVxuICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG4gICAgLy8gOCAqIENcbiAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG4gICAgLy8gWDMgPSBGIC0gMiAqIERcbiAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgIC8vIFozID0gMiAqIFkxICogWjFcbiAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICBueiA9IG56LnJlZElBZGQobnopO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE1QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGFcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuICAgIC8vIFQgPSBNXjIgLSAyICogU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMiAqIFkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuICAgIC8vIDNNICsgNVNcblxuICAgIC8vIGRlbHRhID0gWjFeMlxuICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAvLyBnYW1tYSA9IFkxXjJcbiAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcbiAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG4gICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG4gICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcbiAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG4gICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG4gICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIC8vIDRNICsgNlMgKyAxMEFcbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG4gIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcbiAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcbiAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG4gIC8vIDVNICsgMTBTICsgLi4uXG5cbiAgLy8gWFggPSBYMV4yXG4gIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gWVkgPSBZMV4yXG4gIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gWlogPSBaMV4yXG4gIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgLy8gWVlZWSA9IFlZXjJcbiAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG4gIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgLy8gTU0gPSBNXjJcbiAgdmFyIG1tID0gbS5yZWRTcXIoKTtcbiAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICBlID0gZS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkSVN1YihtbSk7XG4gIC8vIEVFID0gRV4yXG4gIHZhciBlZSA9IGUucmVkU3FyKCk7XG4gIC8vIFQgPSAxNipZWVlZXG4gIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcbiAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcbiAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG4gIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG4gIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcbiAgayA9IG5ldyBCTihrLCBrYmFzZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuICBpZiAodGhpcyA9PT0gcClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG4gIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBKUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uL2VsbGlwdGljJyk7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0JylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmN1cnZlLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmN1cnZlLmVkd2FyZHMob3B0aW9ucyk7XG4gIGVsc2VcbiAgICB0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmN1cnZlLm1vbnQob3B0aW9ucyk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cbiAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuICBhc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSwgJ0ludmFsaWQgY3VydmUsIEcqTiAhPSBPJyk7XG59XG5jdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY3VydmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH1cbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AyMjQnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjU2Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcbiAgbjogJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyxcbiAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZidcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwNTIxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG4gICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcbiAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcbiAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG4gICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG4gIGhhc2g6IGhhc2guc2hhNTEyLFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcbiAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG4gICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG4gICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMScsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCdcbiAgXVxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSByZXF1aXJlKCcuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMScpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnXG4gICAgfVxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmVcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgSG1hY0RSQkcgPSByZXF1aXJlKCdobWFjLWRyYmcnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoZWxsaXB0aWMuY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gZWxsaXB0aWMuY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBlbGxpcHRpYy5jdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBlbGxpcHRpYy5yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4J1xuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgdHJ1ZTsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXG4gIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG4gICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICB2YXIgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5lYyA9IGVjO1xuICB0aGlzLnByaXYgPSBudWxsO1xuICB0aGlzLnB1YiA9IG51bGw7XG5cbiAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG4gIGlmIChvcHRpb25zLnByaXYpXG4gICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG4gIGlmIChvcHRpb25zLnB1YilcbiAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHJpdjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwcml2OiBwcml2LFxuICAgIHByaXZFbmM6IGVuY1xuICB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHZhciBwdWIgPSB0aGlzLmdldFB1YmxpYygpO1xuXG4gIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgaWYgKCFwdWIudmFsaWRhdGUoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcblxuICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsIGVuYykge1xuICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG4gIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBjb21wYWN0O1xuICAgIGNvbXBhY3QgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLnB1YilcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuICBpZiAoIWVuYylcbiAgICByZXR1cm4gdGhpcy5wdWI7XG5cbiAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIGdldFByaXZhdGUoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMucHJpdjtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LCBlbmMpIHtcbiAgdGhpcy5wcml2ID0gbmV3IEJOKGtleSwgZW5jIHx8IDE2KTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJpdiB3b24ndCBiZSBiaWdnZXIgdGhhbiBuLCBvdGhlcndpc2Ugd2UgbWF5IGZhaWxcbiAgLy8gaW4gZml4ZWQgbXVsdGlwbGljYXRpb24gbWV0aG9kXG4gIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksIGVuYykge1xuICBpZiAoa2V5LnggfHwga2V5LnkpIHtcbiAgICAvLyBNb250Z29tZXJ5IHBvaW50cyBvbmx5IGhhdmUgYW4gYHhgIGNvb3JkaW5hdGUuXG4gICAgLy8gV2VpZXJzdHJhc3MvRWR3YXJkcyBwb2ludHMgb24gdGhlIG90aGVyIGhhbmQgaGF2ZSBib3RoIGB4YCBhbmRcbiAgICAvLyBgeWAgY29vcmRpbmF0ZXMuXG4gICAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ21vbnQnKSB7XG4gICAgICBhc3NlcnQoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnc2hvcnQnIHx8XG4gICAgICAgICAgICAgICB0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdlZHdhcmRzJykge1xuICAgICAgYXNzZXJ0KGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgcmV0dXJuIHB1Yi5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xuXG4vLyBFQ0RTQVxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IEJOKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgQk4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gIH1cbiAgcC5wbGFjZSA9IG9mZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgZGF0YSA9IHV0aWxzLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDAgJiYgKHJbMV0gJiAweDgwKSkge1xuICAgIHIgPSByLnNsaWNlKDEpO1xuICB9XG4gIGlmIChzWzBdID09PSAwICYmIChzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgdGhpcy5zID0gbmV3IEJOKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgdmFyIGN1cnZlID0gZWxsaXB0aWMuY3VydmVzW2N1cnZlXS5jdXJ2ZTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBjdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShjdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgdGhpcy5wb2ludENsYXNzID0gY3VydmUucG9pbnQoKS5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5lbmNvZGluZ0xlbmd0aCA9IE1hdGguY2VpbChjdXJ2ZS5uLmJpdExlbmd0aCgpIC8gOCk7XG4gIHRoaXMuaGFzaCA9IGhhc2guc2hhNTEyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVERFNBO1xuXG4vKipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfEtleVBhaXJ9IHNlY3JldCAtIHNlY3JldCBieXRlcyBvciBhIGtleXBhaXJcbiogQHJldHVybnMge1NpZ25hdHVyZX0gLSBzaWduYXR1cmVcbiovXG5FRERTQS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0KSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tU2VjcmV0KHNlY3JldCk7XG4gIHZhciByID0gdGhpcy5oYXNoSW50KGtleS5tZXNzYWdlUHJlZml4KCksIG1lc3NhZ2UpO1xuICB2YXIgUiA9IHRoaXMuZy5tdWwocik7XG4gIHZhciBSZW5jb2RlZCA9IHRoaXMuZW5jb2RlUG9pbnQoUik7XG4gIHZhciBzXyA9IHRoaXMuaGFzaEludChSZW5jb2RlZCwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIGNhY2hlZFByb3BlcnR5ID0gdXRpbHMuY2FjaGVkUHJvcGVydHk7XG5cbi8qKlxuKiBAcGFyYW0ge0VERFNBfSBlZGRzYSAtIGluc3RhbmNlXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFyYW1ldGVyc1xuKlxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnNlY3JldF0gLSBzZWNyZXQgc2VlZCBieXRlc1xuKiBAcGFyYW0ge1BvaW50fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IChha2EgYEFgIGluIGVkZHNhIHRlcm1zKVxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IGVuY29kZWQgYXMgYnl0ZXNcbipcbiovXG5mdW5jdGlvbiBLZXlQYWlyKGVkZHNhLCBwYXJhbXMpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuICB0aGlzLl9zZWNyZXQgPSBwYXJzZUJ5dGVzKHBhcmFtcy5zZWNyZXQpO1xuICBpZiAoZWRkc2EuaXNQb2ludChwYXJhbXMucHViKSlcbiAgICB0aGlzLl9wdWIgPSBwYXJhbXMucHViO1xuICBlbHNlXG4gICAgdGhpcy5fcHViQnl0ZXMgPSBwYXJzZUJ5dGVzKHBhcmFtcy5wdWIpO1xufVxuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVkZHNhLCBwdWIpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHB1YjogcHViIH0pO1xufTtcblxuS2V5UGFpci5mcm9tU2VjcmV0ID0gZnVuY3Rpb24gZnJvbVNlY3JldChlZGRzYSwgc2VjcmV0KSB7XG4gIGlmIChzZWNyZXQgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBzZWNyZXQ7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBzZWNyZXQ6IHNlY3JldCB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnNlY3JldCA9IGZ1bmN0aW9uIHNlY3JldCgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlY3JldDtcbn07XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwdWJCeXRlcycsIGZ1bmN0aW9uIHB1YkJ5dGVzKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLnB1YigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViJywgZnVuY3Rpb24gcHViKCkge1xuICBpZiAodGhpcy5fcHViQnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5fcHViQnl0ZXMpO1xuICByZXR1cm4gdGhpcy5lZGRzYS5nLm11bCh0aGlzLnByaXYoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXZCeXRlcycsIGZ1bmN0aW9uIHByaXZCeXRlcygpIHtcbiAgdmFyIGVkZHNhID0gdGhpcy5lZGRzYTtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgdmFyIGxhc3RJeCA9IGVkZHNhLmVuY29kaW5nTGVuZ3RoIC0gMTtcblxuICB2YXIgYSA9IGhhc2guc2xpY2UoMCwgZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xuICBhWzBdICY9IDI0ODtcbiAgYVtsYXN0SXhdICY9IDEyNztcbiAgYVtsYXN0SXhdIHw9IDY0O1xuXG4gIHJldHVybiBhO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2JywgZnVuY3Rpb24gcHJpdigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlSW50KHRoaXMucHJpdkJ5dGVzKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdoYXNoJywgZnVuY3Rpb24gaGFzaCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuaGFzaCgpLnVwZGF0ZSh0aGlzLnNlY3JldCgpKS5kaWdlc3QoKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnbWVzc2FnZVByZWZpeCcsIGZ1bmN0aW9uIG1lc3NhZ2VQcmVmaXgoKSB7XG4gIHJldHVybiB0aGlzLmhhc2goKS5zbGljZSh0aGlzLmVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbn0pO1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGNhbiBvbmx5IHZlcmlmeScpO1xuICByZXR1cm4gdGhpcy5lZGRzYS5zaWduKG1lc3NhZ2UsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZykge1xuICByZXR1cm4gdGhpcy5lZGRzYS52ZXJpZnkobWVzc2FnZSwgc2lnLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFNlY3JldCA9IGZ1bmN0aW9uIGdldFNlY3JldChlbmMpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgaXMgcHVibGljIG9ubHknKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnNlY3JldCgpLCBlbmMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGVuYykge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMucHViQnl0ZXMoKSwgZW5jKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gZWRkc2EgaW5zdGFuY2VcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58T2JqZWN0fSBzaWcgLVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxQb2ludH0gW3NpZy5SXSAtIFIgcG9pbnQgYXMgUG9pbnQgb3IgYnl0ZXNcbiogQHBhcmFtIHtBcnJheTxCeXRlcz58Ym59IFtzaWcuU10gLSBTIHNjYWxhciBhcyBibiBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5SZW5jb2RlZF0gLSBSIHBvaW50IGVuY29kZWRcbiogQHBhcmFtIHtBcnJheTxCeXRlcz59IFtzaWcuU2VuY29kZWRdIC0gUyBzY2FsYXIgZW5jb2RlZFxuKi9cbmZ1bmN0aW9uIFNpZ25hdHVyZShlZGRzYSwgc2lnKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcblxuICBpZiAodHlwZW9mIHNpZyAhPT0gJ29iamVjdCcpXG4gICAgc2lnID0gcGFyc2VCeXRlcyhzaWcpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICBzaWcgPSB7XG4gICAgICBSOiBzaWcuc2xpY2UoMCwgZWRkc2EuZW5jb2RpbmdMZW5ndGgpLFxuICAgICAgUzogc2lnLnNsaWNlKGVkZHNhLmVuY29kaW5nTGVuZ3RoKVxuICAgIH07XG4gIH1cblxuICBhc3NlcnQoc2lnLlIgJiYgc2lnLlMsICdTaWduYXR1cmUgd2l0aG91dCBSIG9yIFMnKTtcblxuICBpZiAoZWRkc2EuaXNQb2ludChzaWcuUikpXG4gICAgdGhpcy5fUiA9IHNpZy5SO1xuICBpZiAoc2lnLlMgaW5zdGFuY2VvZiBCTilcbiAgICB0aGlzLl9TID0gc2lnLlM7XG5cbiAgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5SKSA/IHNpZy5SIDogc2lnLlJlbmNvZGVkO1xuICB0aGlzLl9TZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlMpID8gc2lnLlMgOiBzaWcuU2VuY29kZWQ7XG59XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1MnLCBmdW5jdGlvbiBTKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSJywgZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSZW5jb2RlZCcsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLlIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnU2VuY29kZWQnLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlSW50KHRoaXMuUygpKTtcbn0pO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICByZXR1cm4gdGhpcy5SZW5jb2RlZCgpLmNvbmNhdCh0aGlzLlNlbmNvZGVkKCkpO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMudG9CeXRlcygpLCAnaGV4JykudG9VcHBlckNhc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvdWJsZXM6IHtcbiAgICBzdGVwOiA0LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZTYwZmNlOTNiNTllOWVjNTMwMTFhYWJjMjFjMjNlOTdiMmEzMTM2OWI4N2E1YWU5YzQ0ZWU4OWUyYTZkZWMwYScsXG4gICAgICAgICdmN2UzNTA3Mzk5ZTU5NTkyOWRiOTlmMzRmNTc5MzcxMDEyOTY4OTFlNDRkMjNmMGJlMWYzMmNjZTY5NjE2ODIxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyODIyNjMyMTJjNjA5ZDllYTJhNmUzZTE3MmRlMjM4ZDhjMzljYWJkNWFjMWNhMTA2NDZlMjNmZDVmNTE1MDgnLFxuICAgICAgICAnMTFmOGE4MDk4NTU3ZGZlNDVlODI1NmU4MzBiNjBhY2U2MmQ2MTNhYzJmN2IxN2JlZDMxYjZlYWZmNmUyNmNhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzVlMTU5ZjcyOGI4NjVhNzJmOTljYzZjNmZjODQ2ZGUwYjkzODMzZmQyMjIyZWQ3M2ZjZTViNTUxZTViNzM5JyxcbiAgICAgICAgJ2QzNTA2ZTBkOWUzYzc5ZWJhNGVmOTdhNTFmZjcxZjVlYWNiNTk1NWFkZDI0MzQ1YzZlZmE2ZmZlZTlmZWQ2OTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzYzZDkwZDQ0N2IwMGM5Yzk5Y2VhYzA1YjYyNjJlZTA1MzQ0MWM3ZTU1NTUyZmZlNTI2YmFkOGY4M2ZmNDY0MCcsXG4gICAgICAgICc0ZTI3M2FkZmM3MzIyMjE5NTNiNDQ1Mzk3ZjMzNjMxNDViOWE4OTAwODE5OWVjYjYyMDAzYzdmM2JlZTlkZTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGI0YjVmMTY1ZGYzYzJiZThjNjI0NGI1Yjc0NTYzODg0M2U0YTc4MWExNWJjZDFiNjlmNzlhNTVkZmZkZjgwYycsXG4gICAgICAgICc0YWFkMGE2ZjY4ZDMwOGI0YjNmYmQ3ODEzYWIwZGEwNGY5ZTMzNjU0NjE2MmVlNTZiM2VmZjBjNjVmZDRmZDM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzcyM2NiYWE2ZTVkYjk5NmQ2YmY3NzFjMDBiZDU0OGM3YjcwMGRiZmZhNmMwZTc3YmNiNjExNTkyNTIzMmZjZGEnLFxuICAgICAgICAnOTZlODY3YjU1OTVjYzQ5OGE5MjExMzc0ODg4MjRkNmUyNjYwYTA2NTM3Nzk0OTQ4MDFkYzA2OWQ5ZWIzOWY1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZWJmYTRkNDkzYmViZjk4YmE1ZmVlYzgxMmMyZDNiNTA5NDc5NjEyMzdhOTE5ODM5YTUzM2VjYTBlN2RkN2ZhJyxcbiAgICAgICAgJzVkOWE4Y2EzOTcwZWYwZjI2OWVlN2VkYWYxNzgwODlkOWFlNGNkYzNhNzExZjcxMmRkZmQ0ZmRhZTFkZTg5OTknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTAwZjQ0ZGE2OTZlNzE2NzI3OTFkMGEwOWI3YmRlNDU5ZjEyMTVhMjliM2MwM2JmZWZkNzgzNWIzOWE0OGRiMCcsXG4gICAgICAgICdjZGQ5ZTEzMTkyYTAwYjc3MmVjOGYzMzAwYzA5MDY2NmI3ZmY0YTE4ZmY1MTk1YWMwZmJkNWNkNjJiYzY1YTA5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UxMDMxYmUyNjJjN2VkMWIxZGM5MjI3YTRhMDRjMDE3YTc3ZjhkNDQ2NGYzYjM4NTJjOGFjZGU2ZTUzNGZkMmQnLFxuICAgICAgICAnOWQ3MDYxOTI4OTQwNDA1ZTZiYjZhNDE3NjU5NzUzNWFmMjkyZGQ0MTllMWNlZDc5YTQ0ZjE4ZjI5NDU2YTAwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWVhNmNhZTQ2ZDU1YjUzMGFjMjgzOWYxNDNiZDdlYzVjZjhiMjY2YTQxZDZhZjUyZDVlNjg4ZDkwOTQ2OTZkJyxcbiAgICAgICAgJ2U1N2M2YjZjOTdkY2UxYmFiMDZlNGUxMmJmM2VjZDVjOTgxYzg5NTdjYzQxNDQyZDMxNTVkZWJmMTgwOTAwODgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2N2E5MWQ5MTA0OWNkY2IzNjdiZTRiZTZmZmNhM2NmZWVkNjU3ZDgwODU4M2RlMzNmYTk3OGJjMWVjNmNiMScsXG4gICAgICAgICc5YmFjYWEzNTQ4MTY0MmJjNDFmNDYzZjdlYzk3ODBlNWRlYzdhZGM1MDhmNzQwYTE3ZTllYThlMjdhNjhiZTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUzOTA0ZmFhMGIzMzRjZGRhNmUwMDA5MzVlZjIyMTUxZWMwOGQwZjdiYjExMDY5ZjU3NTQ1Y2NjMWEzN2I3YzAnLFxuICAgICAgICAnNWJjMDg3ZDBiYzgwMTA2ZDg4YzllY2NhYzIwZDNjMWMxMzk5OTk4MWUxNDQzNDY5OWRjYjA5NmIwMjI3NzFjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZTdiY2QwYmQzNTk4M2E3NzE5Y2NhNzc2NGNhOTA2Nzc5YjUzYTA0M2E5YjhiY2FlZmY5NTlmNDNhZDg2MDQ3JyxcbiAgICAgICAgJzEwYjc3NzBiMmEzZGE0YjM5NDAzMTA0MjBjYTk1MTQ1NzllODhlMmU0N2ZkNjhiM2VhMTAwNDdlODQ2MDM3MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzg1ZWVkMzRjMWNkZmYyMWU2ZDA4MTg2ODliODFiZGU3MWE3ZjRmMTgzOTdlNjY5MGE4NDFlMTU5OWM0Mzg2MicsXG4gICAgICAgICcyODNiZWJjM2U4ZWEyM2Y1NjcwMWRlMTllOWViZjQ1NzZiMzA0ZWVjMjA4NmRjOGNjMDQ1OGZlNTU0MmU1NDUzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZmOWQ5YjgwM2VjZjE5MTYzN2M3M2E0NDEzZGZhMTgwZmRkZjg0YTU5NDdmYmM5YzYwNmVkODZjM2ZhYzNhNycsXG4gICAgICAgICc3YzgwYzY4ZTYwMzA1OWJhNjliOGUyYTMwZTQ1YzRkNDdlYTRkZDJmNWMyODEwMDJkODY4OTA2MDNhODQyMTYwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzMjJkNDAxMjQzYzRlMjU4MmEyMTQ3YzEwNGQ2ZWNiZjc3NGQxNjNkYjBmNWU1MzEzYjdlMGU3NDJkMGU2YmQnLFxuICAgICAgICAnNTZlNzA3OTdlOTY2NGVmNWJmYjAxOWJjNGRkYWY5YjcyODA1ZjYzZWEyODczYWY2MjRmM2EyZTk2YzI4YjJhMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NTY3MmM3ZDJkZTBiN2RhMmJkMTc3MGQ4OTY2NTg2ODc0MWIzZjlhZjc2NDMzOTc3MjFkNzRkMjgxMzRhYjgzJyxcbiAgICAgICAgJzdjNDgxYjliNWI0M2IyZWI2Mzc0MDQ5YmZhNjJjMmU1ZTc3ZjE3ZmNjNTI5OGY0NGM4ZTMwOTRmNzkwMzEzYTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4YmY4MDliMTk4OGE0NmIwNmM5ZjE5MTk0MTNiMTBmOTIyNmM2MGY2Njg4MzJmZmQ5NTlhZjYwYzgyYTBhJyxcbiAgICAgICAgJzUzYTU2Mjg1NmRjYjY2NDZkYzZiNzRjNWQxYzM0MThjNmQ0ZGZmMDhjOTdjZDJiZWQ0Y2I3Zjg4ZDhjOGU1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjI2MGNlN2Y0NjE4MDFjMzRmMDY3Y2UwZjAyODczYThmMWIwZTQ0ZGZjNjk3NTJhY2NlY2Q4MTlmMzhmZDhlOCcsXG4gICAgICAgICdiYzJkYTgyYjZmYTViNTcxYTdmMDkwNDk3NzZhMWVmN2VjZDI5MjIzODA1MWMxOThjMWE4NGU5NWIyYjRhZTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U1MDM3ZGUwYWZjMWQ4ZDQzZDgzNDg0MTRiYmY0MTAzMDQzZWM4ZjU3NWJmZGM0MzI5NTNjYzhkMjAzN2ZhMmQnLFxuICAgICAgICAnNDU3MTUzNGJhYTk0ZDNiNWY5Zjk4ZDA5ZmI5OTBiZGRiZDVmNWIwM2VjNDgxZjEwZTBlNWRjODQxZDc1NWJkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMDYzNzJiMGY0YTIwN2FkZjVlYTkwNWU4ZjE3NzFiNGU3ZThkYmQxYzZhNmM1YjcyNTg2NmEwYWU0ZmNlNzI1JyxcbiAgICAgICAgJzdhOTA4OTc0YmNlMThjZmUxMmEyN2JiMmFkNWE0ODhjZDc0ODRhNzc4NzEwNDg3MGIyNzAzNGY5NGVlZTMxZGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjEzYzdhNzE1Y2Q1ZDQ1MzU4ZDBiYmY5ZGMwY2UwMjIwNGIxMGJkZGUyYTNmNTg1NDBhZDY5MDhkMDU1OTc1NCcsXG4gICAgICAgICc0YjZkYWQwYjVhZTQ2MjUwNzAxM2FkMDYyNDViYTE5MGJiNDg1MGY1ZjM2YTdlZWRkZmYyYzI3NTM0YjQ1OGYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlN2MyNzJhN2FmNGIzNGU4ZGJiOTM1MmE1NDE5YTg3ZTI4MzhjNzBhZGM2MmNkZGYwY2MzYTNiMDhmYmQ1M2MnLFxuICAgICAgICAnMTc3NDljNzY2YzlkMGIxOGUxNmZkMDlmNmRlZjY4MWI1MzBiOTYxNGJmZjdkZDMzZTBiMzk0MTgxN2RjYWFlNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWE3NGUzZGJlNzc4YjFiMTBmMjM4YWQ2MTY4NmFhNWM3NmUzZGIyYmU0MzA1NzYzMjQyN2UyODQwZmIyN2I2JyxcbiAgICAgICAgJzZlMDU2OGRiOWIwYjEzMjk3Y2Y2NzRkZWNjYjZhZjkzMTI2YjU5NmI5NzNmN2I3NzcwMWQzZGI3ZjIzY2I5NmYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzZlNjQxMTNmNjc3Y2YwZTEwYTI1NzBkNTk5OTY4ZDMxNTQ0ZTE3OWI3NjA0MzI5NTJjMDJhNDQxN2JkZGUzOScsXG4gICAgICAgICdjOTBkZGY4ZGVlNGU5NWNmNTc3MDY2ZDcwNjgxZjBkMzVlMmEzM2QyYjU2ZDIwMzJiNGIxNzUyZDE5MDFhYzAxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M3MzhjNTZiMDNiMmFiZTFlODI4MWJhYTc0M2Y4ZjlhOGY3Y2M2NDNkZjI2Y2JlZTNhYjE1MDI0MmJjYmI4OTEnLFxuICAgICAgICAnODkzZmI1Nzg5NTFhZDI1MzdmNzE4ZjJlYWNiZmJiYmI4MjMxNGVlZjc4ODBjZmU5MTdlNzM1ZDk2OTlhODRjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkODk1NjI2NTQ4YjY1YjgxZTI2NGM3NjM3Yzk3Mjg3N2QxZDcyZTVmM2E5MjUwMTQzNzJlOWY2NTg4ZjZjMTRiJyxcbiAgICAgICAgJ2ZlYmZhYTM4ZjJiYzdlYWU3MjhlYzYwODE4YzM0MGViMDM0MjhkNjMyYmIwNjdlMTc5MzYzZWQ3NWQ3ZDk5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjhkYTk0MDMyYTk1NzUxOGViMGY2NDMzNTcxZTg3NjFjZWZmYzczNjkzZTg0ZWRkNDkxNTBhNTY0ZjY3NmUwMycsXG4gICAgICAgICcyODA0ZGZhNDQ4MDVhMWU0ZDdjOTljYzk3NjI4MDhiMDkyY2M1ODRkOTVmZjNiNTExNDg4ZTRlNzRlZmRmNmU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U4MGZlYTE0NDQxZmIzM2E3ZDhhZGFiOTQ3NWQ3ZmFiMjAxOWVmZmI1MTU2YTc5MmYxYTExNzc4ZTNjMGRmNWQnLFxuICAgICAgICAnZWVkMWRlN2Y2MzhlMDA3NzFlODk3NjhjYTNjYTk0NDcyZDE1NWU4MGFmMzIyZWE5ZmNiNDI5MWI2YWM5ZWM3OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMzAxNjk3YmRmY2Q3MDQzMTNiYTQ4ZTUxZDU2NzU0M2YyYTE4MjAzMWVmZDY5MTVkZGMwN2JiY2M0ZTE2MDcwJyxcbiAgICAgICAgJzczNzBmOTFjZmI2N2U0ZjUwODE4MDlmYTI1ZDQwZjliMTczNWRiZjdjMGExMWExMzBjMGQxYTA0MWUxNzdlYTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTBhZDg1YjM4OWQ2YjkzNjQ2M2Y5ZDA1MTI2NzhkZTIwOGNjMzMwYjExMzA3ZmZmYWI3YWM2M2UzZmIwNGVkNCcsXG4gICAgICAgICdlNTA3YTM2MjBhMzgyNjFhZmZkY2JkOTQyNzIyMmI4MzlhZWZhYmUxNTgyODk0ZDk5MWQ0ZDQ4Y2I2ZWYxNTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGY2OGI5ZDJmNjNiNWYzMzkyMzljMWFkOTgxZjE2MmVlODhjNTY3ODcyM2VhMzM1MWI3YjQ0NGM5ZWM0YzBkYScsXG4gICAgICAgICc2NjJhOWYyZGJhMDYzOTg2ZGUxZDkwYzJiNmJlMjE1ZGJiZWEyY2ZlOTU1MTBiZmRmMjNjYmY3OTUwMWZmZjgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0ZjNmYjAxNzZhZjg1ZDY1ZmY5OWZmOTE5OGMzNjA5MWY0OGU4NjUwMzY4MWUzZTY2ODZmZDUwNTMyMzFlMTEnLFxuICAgICAgICAnMWU2MzYzM2FkMGVmNGYxYzE2NjFhNmQwZWEwMmI3Mjg2Y2M3ZTc0ZWM5NTFkMWM5ODIyYzM4NTc2ZmViNzNiYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzAwZmE5YjE4ZWJmMzMxZWI5NjE1MzdhNDVhNDI2NmM3MDM0ZjJmMGQ0ZTFkMDcxNmZiNmVhZTIwZWFlMjllJyxcbiAgICAgICAgJ2VmYTQ3MjY3ZmVhNTIxYTFhOWRjMzQzYTM3MzZjOTc0YzJmYWRhZmE4MWUzNmM1NGU3ZDJhNGM2NjcwMjQxNGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTdhMjZjZTY5ZGQ0ODI5ZjNlMTBjZWMwYTllOThlZDMxNDNkMDg0ZjMwOGI5MmMwOTk3ZmRkZmM2MGNiM2U0MScsXG4gICAgICAgICcyYTc1OGUzMDBmYTc5ODRiNDcxYjAwNmExYWFmYmIxOGQwYTZiMmMwNDIwZTgzZTIwZThhOTQyMWNmMmNmZDUxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I2NDU5ZTBlZTM2NjJlYzhkMjM1NDBjMjIzYmNiZGM1NzFjYmNiOTY3ZDc5NDI0ZjNjZjI5ZWIzZGU2YjgwZWYnLFxuICAgICAgICAnNjdjODc2ZDA2ZjNlMDZkZTFkYWRmMTZlNTY2MWRiM2M0YjNhZTZkNDhlMzViMmZmMzBiZjBiNjFhNzFiYTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q2OGE4MGM4MjgwYmI4NDA3OTMyMzRhYTExOGYwNjIzMWQ2ZjFmYzY3ZTczYzVhNWRlZGEwZjViNDk2OTQzZTgnLFxuICAgICAgICAnZGI4YmE5ZmZmNGI1ODZkMDBjNGIxZjkxNzdiMGUyOGI1YjBlN2I4Zjc4NDUyOTVhMjk0Yzg0MjY2YjEzMzEyMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMjRhZWQ3ZGY2NWM4MDQyNTJkYzAyNzA5MDdhMzBiMDk2MTJhZWI5NzM0NDljZWE0MDk1OTgwZmMyOGQzZDVkJyxcbiAgICAgICAgJzY0OGEzNjU3NzRiNjFmMmZmMTMwYzBjMzVhZWMxZjRmMTkyMTNiMGM3ZTMzMjg0Mzk2NzIyNGFmOTZhYjdjODQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGRmOWMxNDkxOWNkZTYxZjZkNTFkZmRiZTVmZWU1ZGNlZWM0MTQzYmE4ZDFjYTg4OGU4YmQzNzNmZDA1NGM5NicsXG4gICAgICAgICczNWVjNTEwOTJkODcyODA1MDk3NGMyM2ExZDg1ZDRiNWQ1MDZjZGMyODg0OTAxOTJlYmFjMDZjYWQxMGQ1ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5YzM5MTlhODRhNDc0ODcwZmFlZDhhOWMxY2M2NjAyMTUyMzQ4OTA1NGQ3ZjAzMDhjYmZjOTljOGFjMWY5OGNkJyxcbiAgICAgICAgJ2RkYjg0ZjBmNGE0ZGRkNTc1ODRmMDQ0YmYyNjBlNjQxOTA1MzI2Zjc2YzY0YzhlNmJlN2U1ZTAzZDRmYzU5OWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1NzE3MGIxZGQxMmZkZjhkZTA1ZjI4MWQ4ZTA2YmI5MWUxNDkzYThiOTFkNGNjNWEyMTM4MjEyMGE5NTllNScsXG4gICAgICAgICc5YTFhZjBiMjZhNmE0ODA3YWRkOWEyZGFmNzFkZjI2MjQ2NTE1MmJjM2VlMjRjNjVlODk5YmU5MzIzODVhMmE4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1NzZkZjhlMjNhMDg0MTE0MjE0MzlhNDUxOGRhMzE4ODBjZWYwZmJhN2Q0ZGYxMmIxYTY5NzNlZWNiOTQyNjYnLFxuICAgICAgICAnNDBhNmJmMjBlNzY2NDBiMmM5MmI5N2FmZTU4Y2Q4MmM0MzJlMTBhN2Y1MTRkOWYzZWU4YmUxMWFlMWIyOGVjOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3Nzc4YTc4YzI4ZGVjM2UzMGEwNWZlOTYyOWRlOGMzOGJiMzBkMWY1Y2Y5YTNhMjA4Zjc2Mzg4OWJlNThhZDcxJyxcbiAgICAgICAgJzM0NjI2ZDlhYjVhNWIyMmZmNzA5OGUxMmYyZmY1ODAwODdiMzg0MTFmZjI0YWM1NjNiNTEzZmMxZmQ5ZjQzYWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI4OTU1ZWU2MzdhODQ0NjM3MjlmZDMwZTdhZmQyZWQ1Zjk2Mjc0ZTVhZDdlNWNiMDllZGE5YzA2ZDkwM2FjJyxcbiAgICAgICAgJ2MyNTYyMTAwM2QzZjQyYTgyN2I3OGExMzA5M2E5NWVlYWMzZDI2ZWZhOGE4ZDgzZmM1MTgwZTkzNWJjZDA5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODVkMGZlZjNlYzZkYjEwOTM5OTA2NGYzYTBlM2IyODU1NjQ1YjRhOTA3YWQzNTQ1MjdhYWU3NTE2M2Q4Mjc1MScsXG4gICAgICAgICcxZjAzNjQ4NDEzYTM4YzBiZTI5ZDQ5NmU1ODJjZjU2NjNlODc1MWU5Njg3NzMzMTU4MmMyMzdhMjRlYjFmOTYyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMmIwZGNlOTdlZWNlOTdjMWM5YjYwNDE3OThiODVkZmRmYjZkODg4MmRhMjAzMDhmNTQwNDgyNDUyNjA4N2UnLFxuICAgICAgICAnNDkzZDEzZmVmNTI0YmExODhhZjRjNGRjNTRkMDc5MzZjN2I3ZWQ2ZmI5MGUyY2ViMmM5NTFlMDFmMGMyOTkwNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjdmYmJlNGIxZTg4MGVhOWVkMmIyZTYzMDFiMjEyYjU3ZjFlZTE0OGNkNmRkMjg3ODBlNWUyY2Y4NTZlMjQxJyxcbiAgICAgICAgJ2M2MGY5YzkyM2M3MjdiMGI3MWJlZjJjNjdkMWQxMjY4N2ZmN2E2MzE4NjkwMzE2NmQ2MDViNjhiYWVjMjkzZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNjQ5ZjIxZjUxYmRiYWU3YmU0YWUzNGNlNmU1MjE3YTU4ZmRjZTdmNDdmOWFhN2YzYjU4ZmEyMTIwZTJiMycsXG4gICAgICAgICdiZTMyNzllZDViYmJiMDNhYzY5YTgwZjg5ODc5YWE1YTAxYTZiOTY1ZjEzZjdlNTlkNDdhNTMwNWJhNWFkOTNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0YTQyZDQzYzVjZjE2OWQ5MzkxZGY2ZGVjZjQyZWU1NDFiNmQ4ZjBjOWExMzc0MDFlMjM2MzJkZGEzNGQyNGYnLFxuICAgICAgICAnNGQ5ZjkyZTcxNmQxYzczNTI2ZmM5OWNjZmI4YWQzNGNlODg2ZWVkZmE4ZDhlNGYxM2E3ZjcxMzFkZWJhOTQxNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZWM4MGZlZjM2MGNiZGQ5NTQxNjBmYWRhYjM1MmI2YjkyYjUzNTc2YTg4ZmVhNDk0NzE3M2I5ZDQzMDBiZjE5JyxcbiAgICAgICAgJ2FlZWZlOTM3NTZiNTM0MGQyZjNhNDk1OGE3YWJiZjVlMDE0NmU3N2Y2Mjk1YTA3YjY3MWNkYzFjYzEwN2NlZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTQ2YTc3OGMwNDY3MGMyZjkxYjAwYWY0NjgwZGZhOGJjZTM0OTA3MTdkNThiYTg4OWRkYjU5MjgzNjY2NDJiZScsXG4gICAgICAgICdiMzE4ZTBlYzMzNTQwMjhhZGQ2Njk4MjdmOWQ0YjI4NzBhYWE5NzFkMmY3ZTVlZDFkMGIyOTc0ODNkODNlZmQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZhNTBjMGY2MWQyMmU1ZjA3ZTNhY2ViYjFhYTA3YjEyOGQwMDEyMjA5YTI4Yjk3NzZkNzZhODc5MzE4MGVlZjknLFxuICAgICAgICAnNmI4NGM2OTIyMzk3ZWJhOWI3MmNkMjg3MjI4MWE2OGE1ZTY4MzI5M2E1N2EyMTNiMzhjZDhkN2QzZjRmMjgxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTFkNjFkMGNhNzIxYTExYjFhNWJmNmI3ZDg4ZTg0MjFhMjg4YWI1ZDViYmE1MjIwZTUzZDMyYjVmMDY3ZWMyJyxcbiAgICAgICAgJzgxNTdmNTVhN2M5OTMwNmM3OWMwNzY2MTYxYzkxZTI5NjZhNzM4OTlkMjc5YjQ4YTY1NWZiYTBmMWFkODM2ZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYThlMjgyZmYwYzk3MDY5MDcyMTVmZjk4ZThmZDQxNjYxNTMxMWRlMDQ0NmYxZTA2MmE3M2IwNjEwZDA2NGUxMycsXG4gICAgICAgICc3Zjk3MzU1YjhkYjgxYzA5YWJmYjdmM2M1YjI1MTU4ODhiNjc5YTNlNTBkZDZiZDZjZWY3YzczMTExZjRjYzBjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NGE1M2I5YzlhMjg1ODcyZDM5ZTU2ZTY5MTNjYWIxNWQ1OWIxZmE1MTI1MDhjMDIyZjM4MmRlODMxOTQ5N2MnLFxuICAgICAgICAnY2NjOWRjMzdhYmZjOWMxNjU3YjQxNTVmMmM0N2Y5ZTY2NDZiM2ExZDhjYjk4NTQzODNkYTEzYWMwNzlhZmE3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NTkzOTY5ODE5NDM3ODVjM2QzZTU3ZWRmNTAxOGNkYmUwMzllNzMwZTQ5MThiM2Q4ODRmZGZmMDk0NzViN2JhJyxcbiAgICAgICAgJzJlN2U1NTI4ODhjMzMxZGQ4YmEwMzg2YTRiOWNkNjg0OWM2NTNmNjRjODcwOTM4NWU5YjhhYmY4NzUyNGYyZmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDJhNjNhNTBhZTQwMWU1NmQ2NDVhMTE1M2IxMDlhOGZjY2EwYTQzZDU2MWZiYTJkYmI1MTM0MGM5ZDgyYjE1MScsXG4gICAgICAgICdlODJkODZmYjY0NDNmY2I3NTY1YWVlNThiMjk0ODIyMGE3MGY3NTBhZjQ4NGNhNTJkNDE0MjE3NGRjZjg5NDA1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY0NTg3ZTIzMzU0NzFlYjg5MGVlNzg5NmQ3Y2ZkYzg2NmJhY2JkYmQzODM5MzE3YjM0MzZmOWI0NTYxN2UwNzMnLFxuICAgICAgICAnZDk5ZmNkZDViZjY5MDJlMmFlOTZkZDY0NDdjMjk5YTE4NWI5MGEzOTEzM2FlYWIzNTgyOTllNWU5ZmFmNjU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDgxYmRlMGU0ZTRkODg1YjNhNTQ2ZDNlNTQ5ZGUwNDJmMGFhNmNlYTI1MGU3ZmQzNThkNmM4NmRkNDVlNDU4JyxcbiAgICAgICAgJzM4ZWU3YjhjYmE1NDA0ZGQ4NGEyNWJmMzljZWNiMmNhOTAwYTc5YzQyYjI2MmU1NTZkNjRiMWI1OTc3OTA1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTM0NjRhNTdhNzgxMDJhYTYyYjY5NzlhZTgxN2Y0NjM3ZmZjZmVkM2M0YjFjZTMwYmNkNjMwM2Y2Y2FmNjY2YicsXG4gICAgICAgICc2OWJlMTU5MDA0NjE0NTgwZWY3ZTQzMzQ1M2NjYjBjYTQ4ZjMwMGE4MWQwOTQyZTEzZjQ5NWE5MDdmNmVjYzI3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JjNGE5ZGY1YjcxM2ZlMmU5YWVmNDMwYmNjMWRjOTdhMGNkOWNjZWRlMmYyODU4OGNhZGEzYTBkMmQ4M2YzNjYnLFxuICAgICAgICAnZDNhODFjYTZlNzg1YzA2MzgzOTM3YWRmNGI3OThjYWE2ZThhOWZiZmE1NDdiMTZkNzU4ZDY2NjU4MWYzM2MxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMjhhOTdiZjgyOThiYzBkMjNkOGM3NDk0NTJhMzJlNjk0YjY1ZTMwYTk0NzJhMzk1NGFiMzBmZTUzMjRjYWEnLFxuICAgICAgICAnNDBhMzA0NjNhMzMwNTE5MzM3OGZlZGYzMWY3Y2MwZWI3YWU3ODRmMDQ1MWNiOTQ1OWU3MWRjNzNjYmVmOTQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZWE5NjY2MTM5NTI3YThjMWRkOTRjZTRmMDcxZmQyM2M4YjM1MGM1YTRiYjMzNzQ4YzRiYTExMWZhY2NhZTAnLFxuICAgICAgICAnNjIwZWZhYmJjOGVlMjc4MmUyNGU3YzBjZmI5NWM1ZDczNWI3ODNiZTljZjBmOGU5NTVhZjM0YTMwZTYyYjk0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZDM2MjVmYWVmNWJhMDYwNzQ2Njk3MTZiYmQzNzg4ZDg5YmRkZTgxNTk1OTk2ODA5MmY3NmNjNGViOWE5Nzg3JyxcbiAgICAgICAgJzdhMTg4ZmEzNTIwZTMwZDQ2MWRhMjUwMTA0NTczMWNhOTQxNDYxOTgyODgzMzk1OTM3ZjY4ZDAwYzY0NGE1NzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjcxMGQ3OWQ5ZWI5NjIyOTdlNGY2MjMyYjQwZThmN2ZlYjJiYzYzODE0NjE0ZDY5MmMxMmRlNzUyNDA4MjIxZScsXG4gICAgICAgICdlYTk4ZTY3MjMyZDNiMzI5NWQzYjUzNTUzMjExNWNjYWM4NjEyYzcyMTg1MTYxNzUyNmFlNDdhOWM3N2JmYzgyJ1xuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgbmFmOiB7XG4gICAgd25kOiA3LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZjkzMDhhMDE5MjU4YzMxMDQ5MzQ0Zjg1Zjg5ZDUyMjliNTMxYzg0NTgzNmY5OWIwODYwMWYxMTNiY2UwMzZmOScsXG4gICAgICAgICczODhmN2IwZjYzMmRlODE0MGZlMzM3ZTYyYTM3ZjM1NjY1MDBhOTk5MzRjMjIzMWI2Y2I5ZmQ3NTg0YjhlNjcyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmOGJkZTRkMWEwNzIwOTM1NWI0YTcyNTBhNWM1MTI4ZTg4Yjg0YmRkYzYxOWFiN2NiYThkNTY5YjI0MGVmZTQnLFxuICAgICAgICAnZDhhYzIyMjYzNmU1ZTNkNmQ0ZGJhOWRkYTZjOWM0MjZmNzg4MjcxYmFiMGQ2ODQwZGNhODdkM2FhNmFjNjJkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1Y2JkZjA2NDZlNWRiNGVhYTM5OGYzNjVmMmVhN2EwZTNkNDE5YjdlMDMzMGUzOWNlOTJiZGRlZGNhYzRmOWJjJyxcbiAgICAgICAgJzZhZWJjYTQwYmEyNTU5NjBhMzE3OGQ2ZDg2MWE1NGRiYTgxM2QwYjgxM2ZkZTdiNWE1MDgyNjI4MDg3MjY0ZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWNkNDg0ZTJmMGM3ZjY1MzA5YWQxNzhhOWY1NTlhYmRlMDk3OTY5NzRjNTdlNzE0YzM1ZjExMGRmYzI3Y2NiZScsXG4gICAgICAgICdjYzMzODkyMWIwYTdkOWZkNjQzODA5NzE3NjNiNjFlOWFkZDg4OGE0Mzc1ZjhlMGYwNWNjMjYyYWM2NGY5YzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NGFlN2Y4NThhOTQxMWU1ZWY0MjQ2YjcwYzY1YWFjNTY0OTk4MGJlNWMxNzg5MWJiZWMxNzg5NWRhMDA4Y2InLFxuICAgICAgICAnZDk4NGEwMzJlYjZiNWUxOTAyNDNkZDU2ZDdiN2IzNjUzNzJkYjFlMmRmZjlkNmE4MzAxZDc0YzljOTUzYzYxYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjg3NzNjMmQ5NzUyODhiYzdkMWQyMDVjMzc0ODY1MWIwNzVmYmM2NjEwZTU4Y2RkZWVkZGY4ZjE5NDA1YWE4JyxcbiAgICAgICAgJ2FiMDkwMmU4ZDg4MGE4OTc1ODIxMmViNjVjZGFmNDczYTFhMDZkYTUyMWZhOTFmMjliNWNiNTJkYjAzZWQ4MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNzkyNGQ0ZjdkNDNlYTk2NWE0NjVhZTMwOTVmZjQxMTMxZTU5NDZmM2M4NWY3OWU0NGFkYmNmOGUyN2UwODBlJyxcbiAgICAgICAgJzU4MWUyODcyYTg2YzcyYTY4Mzg0MmVjMjI4Y2M2ZGVmZWE0MGFmMmJkODk2ZDNhNWM1MDRkYzlmZjZhMjZiNTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGVmZGVhNGNkYjY3Nzc1MGE0MjBmZWU4MDdlYWNmMjFlYjk4OThhZTc5Yjk3Njg3NjZlNGZhYTA0YTJkNGEzNCcsXG4gICAgICAgICc0MjExYWIwNjk0NjM1MTY4ZTk5N2IwZWFkMmE5M2RhZWNlZDFmNGEwNGE5NWMwZjZjZmIxOTlmNjllNTZlYjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJiNGVhMGE3OTdhNDQzZDI5M2VmNWNmZjQ0NGY0OTc5ZjA2YWNmZWJkN2U4NmQyNzc0NzU2NTYxMzgzODViNmMnLFxuICAgICAgICAnODVlODliYzAzNzk0NWQ5M2IzNDMwODNiNWExYzg2MTMxYTAxZjYwYzUwMjY5NzYzYjU3MGM4NTRlNWMwOWI3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTJiYmY0YTRjZGQxMjU2NGY5M2ZhMzMyY2UzMzMzMDFkOWFkNDAyNzFmODEwNzE4MTM0MGFlZjI1YmU1OWQ1JyxcbiAgICAgICAgJzMyMWViNDA3NTM0OGY1MzRkNTljMTgyNTlkZGEzZTFmNGExYjNiMmU3MWIxMDM5YzY3YmQzZDhiY2Y4MTk5OGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmZhMjEwNGQ2YjM4ZDExYjAyMzAwMTA1NTk4NzkxMjRlNDJhYjhkZmVmZjVmZjI5ZGM5Y2RhZGQ0ZWNhY2MzZicsXG4gICAgICAgICcyZGUxMDY4Mjk1ZGQ4NjViNjQ1NjkzMzViZDVkZDgwMTgxZDcwZWNmYzg4MjY0ODQyM2JhNzZiNTMyYjdkNjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI0ODI3OWIwOWI0ZDY4ZGFiMjFhOWIwNjZlZGRhODMyNjNjM2Q4NGUwOTU3MmUyNjljYTBjZDdmNTQ1MzcxNCcsXG4gICAgICAgICc3MzAxNmY3YmYyMzRhYWRlNWQxYWE3MWJkZWEyYjFmZjNmYzBkZTJhODg3OTEyZmZlNTRhMzJjZTk3Y2IzNDAyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhZWQ0ZjJiZTNhOGJmMjc4ZTcwMTMyZmIwYmViNzUyMmY1NzBlMTQ0YmY2MTVjMDdlOTk2ZDQ0M2RlZTg3MjknLFxuICAgICAgICAnYTY5ZGNlNGE3ZDZjOThlOGQ0YTFhY2E4N2VmOGQ3MDAzZjgzYzIzMGYzYWZhNzI2YWI0MGU1MjI5MGJlMWM1NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDRkMTJjNzA2NWQ4MTJlOGFjZjI4ZDdjYmIxOWY5MDExZWNkOWU5ZmRmMjgxYjBlNmEzYjVlODdkMjJlN2RiJyxcbiAgICAgICAgJzIxMTlhNDYwY2UzMjZjZGM3NmM0NTkyNmM5ODJmZGFjMGUxMDZlODYxZWRmNjFjNWEwMzkwNjNmMGUwZTY0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmEyNDViZjZkYzY5ODUwNGM4OWEyMGNmZGVkNjA4NTMxNTJiNjk1MzM2YzI4MDYzYjYxYzY1Y2JkMjY5ZTZiNCcsXG4gICAgICAgICdlMDIyY2Y0MmMyYmQ0YTcwOGIzZjUxMjZmMTZhMjRhZDhiMzNiYTQ4ZDA0MjNiNmVmZDVlNjM0ODEwMGQ4YTgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2OTdmZmE2ZmQ5ZGU2MjdjMDc3ZTNkMmZlNTQxMDg0Y2UxMzMwMGIwYmVjMTE0NmY5NWFlNTdmMGQwYmQ2YTUnLFxuICAgICAgICAnYjljMzk4ZjE4NjgwNmY1ZDI3NTYxNTA2ZTQ1NTc0MzNhMmNmMTUwMDllNDk4YWU3YWRlZTlkNjNkMDFiMjM5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDViZGIwMTk5ODE3MThiOTg2ZDBmMDdlODM0Y2IwZDlkZWI4MzYwZmZiN2Y2MWRmOTgyMzQ1ZWYyN2E3NDc5JyxcbiAgICAgICAgJzI5NzJkMmRlNGY4ZDIwNjgxYTc4ZDkzZWM5NmZlMjNjMjZiZmFlODRmYjE0ZGI0M2IwMWUxZTkwNTZiOGM0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MmQxNGRhYjQxNTBiZjQ5NzQwMmZkYzQ1YTIxNWUxMGRjYjAxYzM1NDk1OWIxMGNmZTMxYzdlOWQ4N2ZmMzNkJyxcbiAgICAgICAgJzgwZmMwNmJkOGNjNWIwMTA5ODA4OGExOTUwZWVkMGRiMDFhYTEzMjk2N2FiNDcyMjM1ZjU2NDI0ODNiMjVlYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODBjNjBhZDAwNDBmMjdkYWRlNWI0YjA2YzQwOGU1NmIyYzUwZTlmNTZiOWI4YjQyNWU1NTVjMmY4NjMwOGI2ZicsXG4gICAgICAgICcxYzM4MzAzZjFjYzVjMzBmMjZlNjZiYWQ3ZmU3MmY3MGE2NWVlZDRjYmU3MDI0ZWIxYWEwMWY1NjQzMGJkNTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdhOTM3NWFkNjE2N2FkNTRhYTc0YzYzNDhjYzU0ZDM0NGNjNWRjOTQ4N2Q4NDcwNDlkNWVhYmIwZmEwM2M4ZmInLFxuICAgICAgICAnZDBlM2ZhOWVjYTg3MjY5MDk1NTllMGQ3OTI2OTA0NmJkYzU5ZWExMGM3MGNlMmIwMmQ0OTllYzIyNGRjN2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1MjhlY2Q5YjY5NmI1NGM5MDdhOWVkMDQ1NDQ3YTc5YmI0MDhlYzM5YjY4ZGY1MDRiYjUxZjQ1OWJjM2ZmYzknLFxuICAgICAgICAnZWVjZjQxMjUzMTM2ZTVmOTk5NjZmMjE4ODFmZDY1NmViYzQzNDU0MDVjNTIwZGJjMDYzNDY1YjUyMTQwOTkzMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTM3MGE0YjVmNDM0MTJlYTI1ZjUxNGU4ZWNkYWQwNTI2NjExNWU0YTdlY2IxMzg3MjMxODA4ZjhiNDU5NjMnLFxuICAgICAgICAnNzU4ZjNmNDFhZmQ2ZWQ0MjhiMzA4MWIwNTEyZmQ2MmE1NGMzZjNhZmJiNWI2NzY0YjY1MzA1MmExMjk0OWM5YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3N2YyMzA5MzZlZTg4Y2JiZDczZGY5MzBkNjQ3MDJlZjg4MWQ4MTFlMGUxNDk4ZTJmMWMxM2ViMWZjMzQ1ZDc0JyxcbiAgICAgICAgJzk1OGVmNDJhNzg4NmI2NDAwYTA4MjY2ZTliYTFiMzc4OTZjOTUzMzBkOTcwNzdjYmJlOGViM2M3NjcxYzYwZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjJkYWM5OTFjYzRjZTRiOWVhNDQ4ODdlNWM3YzBiY2U1OGM4MDA3NGFiOWQ0ZGJhZWIyODUzMWI3NzM5ZjUzMCcsXG4gICAgICAgICdlMGRlZGM5YjNiMmY4ZGFkNGRhMWYzMmRlYzI1MzFkZjllYjVmYmViMDU5OGU0ZmQxYTExN2RiYTcwM2EzYzM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2IzZDlmNjYyNjIxZmIxYjRiZThmYmJlMjUyMDEyNWEyMTZjZGZjOWRhZTNkZWJjYmE0ODUwYzY5MGQ0NWInLFxuICAgICAgICAnNWVkNDMwZDc4YzI5NmMzNTQzMTE0MzA2ZGQ4NjIyZDdjNjIyZTI3Yzk3MGExZGUzMWNiMzc3YjAxYWY3MzA3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTZmODA0MjQ0ZTQ2ZTJhMDkyMzJkNGFmZjNiNTk5NzZiOThmYWMxNDMyOGEyZDFhMzI0OTZiNDk5OThmMjQ3JyxcbiAgICAgICAgJ2NlZGFiZDliODIyMDNmN2UxM2QyMDZmY2RmNGUzM2Q5MmE2YzUzYzI2ZTVjY2UyNmQ2NTc5OTYyYzRlMzFkZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2FmNzU0MjcyZGM4NDU2M2IwMzUyYjdhMTQzMTFhZjU1ZDI0NTMxNWFjZTI3YzY1MzY5ZTE1ZjcxNTFkNDFkMScsXG4gICAgICAgICdjYjQ3NDY2MGVmMzVmNWYyYTQxYjY0M2ZhNWU0NjA1NzVmNGZhOWI3OTYyMjMyYTVjMzJmOTA4MzE4YTA0NDc2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI2MDBjYTRiMjgyY2I5ODZmODVkMGYxNzA5OTc5ZDhiNDRhMDljMDdjYjg2ZDdjMTI0NDk3YmM4NmYwODIxMjAnLFxuICAgICAgICAnNDExOWI4ODc1M2MxNWJkNmE2OTNiMDNmY2RkYmI0NWQ1YWM2YmU3NGFiNWYwZWY0NGIwYmU5NDc1YTdlNGI0MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjM1Y2E3MmQ3ZTg0MzJjMzM4ZWM1M2NkMTIyMjBiYzAxYzQ4Njg1ZTI0ZjdkYzhjNjAyYTc3NDY5OThlNDM1JyxcbiAgICAgICAgJzkxYjY0OTYwOTQ4OWQ2MTNkMWQ1ZTU5MGY3OGU2ZDc0ZWNmYzA2MWQ1NzA0OGJhZDllNzZmMzAyYzViOWM2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NTRlMzIzOWYzMjU1NzBjZGJiZjRhODdkZWVlOGE2NmI3ZjJiMzM0NzlkNDY4ZmJjMWE1MDc0M2JmNTZjYzE4JyxcbiAgICAgICAgJzY3M2ZiODZlNWJkYTMwZmIzY2QwZWQzMDRlYTQ5YTAyM2VlMzNkMDE5N2E2OTVkMGM1ZDk4MDkzYzUzNjY4MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2U2YmQxMDcxYTFlOTZhZmY1Nzg1OWM4MmQ1NzBmMDMzMDgwMDY2MWQxYzk1MmY5ZmUyNjk0NjkxZDliOWU4JyxcbiAgICAgICAgJzU5YzllMGJiYTM5NGU3NmY0MGMwYWE1ODM3OWEzY2I2YTVhMjI4Mzk5M2U5MGM0MTY3MDAyYWY0OTIwZTM3ZjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTg2YjQ4M2QwNTZhMDMzODI2YWU3M2Q4OGY3MzI5ODVjNGNjYjFmMzJiYTM1ZjRiNGNjNDdmZGNmMDRhYTZlYicsXG4gICAgICAgICczYjk1MmQzMmM2N2NmNzdlMmUxNzQ0NmUyMDQxODBhYjIxZmI4MDkwODk1MTM4YjRhNGE3OTdmODZlODA4ODhiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmOWQ3MGE2Yjk4NzZjZTU0NGM5ODU2MWY0YmU0ZjcyNTQ0MmU2ZDJiNzM3ZDljOTFhODMyMTcyNGNlMDk2M2YnLFxuICAgICAgICAnNTVlYjJkYWZkODRkNmNjZDVmODYyYjc4NWRjMzlkNGFiMTU3MjIyNzIwZWY5ZGEyMTdiOGM0NWNmMmJhMjQxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZWRkNWNjMjNjNTFlODdhNDk3Y2E4MTVkNWRjZTBmOGFiNTI1NTRmODQ5ZWQ4OTk1ZGU2NGM1ZjM0Y2U3MTQzJyxcbiAgICAgICAgJ2VmYWU5YzhkYmMxNDEzMDY2MWU4Y2VjMDMwYzg5YWQwYzEzYzY2YzBkMTdhMjkwNWNkYzcwNmFiNzM5OWE4NjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjkwNzk4YzJiNjQ3NjgzMGRhMTJmZTAyMjg3ZTllNzc3YWEzZmJhMWMzNTViMTdhNzIyZDM2MmY4NDYxNGZiYScsXG4gICAgICAgICdlMzhkYTc2ZGNkNDQwNjIxOTg4ZDAwYmNmNzlhZjI1ZDViMjljMDk0ZGIyYTIzMTQ2ZDAwM2FmZDQxOTQzZTdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmM2M0MjNhOTVkOWY1YjMwNTQ3NTRlZmExNTBhYzM5Y2QyOTU1MmZlMzYwMjU3MzYyZGZkZWNlZjQwNTNiNDUnLFxuICAgICAgICAnZjk4YTNmZDgzMWViMmI3NDlhOTNiMGU2ZjM1Y2ZiNDBjOGNkNWFhNjY3YTE1NTgxYmMyZmVkZWQ0OThmZDljNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NjZkYmIyNGQxMzRlNzQ1Y2NjYWEyOGM5OWJmMjc0OTA2YmI2NmIyNmRjZjk4ZGY4ZDJmZWQ1MGQ4ODQyNDlhJyxcbiAgICAgICAgJzc0NGIxMTUyZWFjYmU1ZTM4ZGNjODg3OTgwZGEzOGI4OTc1ODRhNjVmYTA2Y2VkZDJjOTI0Zjk3Y2JhYzU5OTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTlkYmY0NmY4Yzk0NzU5YmEyMTI3N2MzMzc4NGY0MTY0NWY3YjQ0ZjZjNTk2YTU4Y2U5MmU2NjYxOTFhYmUzZScsXG4gICAgICAgICdjNTM0YWQ0NDE3NWZiYzMwMGY0ZWE2Y2U2NDgzMDlhMDQyY2U3MzlhNzkxOTc5OGNkODVlMjE2YzRhMzA3ZjZlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxM2FkYTk1MTAzYzQ1MzczMDVlNjkxZTc0ZTlhNGE4ZGQ2NDdlNzExYTk1ZTczY2I2MmRjNjAxOGNmZDg3YjgnLFxuICAgICAgICAnZTEzODE3YjQ0ZWUxNGRlNjYzYmY0YmM4MDgzNDFmMzI2OTQ5ZTIxYTZhNzVjMjU3MDc3ODQxOWJkYWY1NzMzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzU0YjRmYTBlOGFjZWQwNmQ0MTY3YTJjNTljY2E0Y2RhMTg2OWMwNmViYWRmYjY0ODg1NTAwMTVhODg1MjJjJyxcbiAgICAgICAgJzMwZTkzZTg2NGU2NjlkODIyMjRiOTY3YzMwMjBiOGZhOGQxZTRlMzUwYjZjYmNjNTM3YTQ4YjU3ODQxMTYzYTInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTQ4ZGNhZGY1OTkwZTA0OGFhMzg3NGQ0NmFiZWY5ZDcwMTg1OGY5NWRlODA0MWQyYTY4MjhjOTllMjI2MjUxOScsXG4gICAgICAgICdlNDkxYTQyNTM3ZjZlNTk3ZDVkMjhhMzIyNGIxYmMyNWRmOTE1NGVmYmQyZWYxZDJjYmJhMmNhZTUzNDdkNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5NjI0MTQ0NTBjNzZjMTY4OWM3YjQ4ZjgyMDJlYzM3ZmIyMjRjZjVhYzBiZmExNTcwMzI4YThhM2Q3Yzc3YWInLFxuICAgICAgICAnMTAwYjYxMGVjNGZmYjQ3NjBkNWMxZmMxMzNlZjZmNmIxMjUwN2EwNTFmMDRhYzU3NjBhZmE1YjI5ZGI4MzQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNTE0MDg3ODM0OTY0YjU0YjE1YjE2MDY0NGQ5MTU0ODVhMTY5NzcyMjViODg0N2JiMGRkMDg1MTM3ZWM0N2NhJyxcbiAgICAgICAgJ2VmMGFmYmIyMDU2MjA1NDQ4ZTE2NTJjNDhlODEyN2ZjNjAzOWU3N2MxNWMyMzc4YjdlN2QxNWEwZGUyOTMzMTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNjYzMwYWQ2YjQ4M2U0YmM3OWNlMmM5ZGQ4YmM1NDk5M2U5NDdlYjhkZjc4N2I0NDI5NDNkM2Y3YjUyN2VhZicsXG4gICAgICAgICc4YjM3OGEyMmQ4MjcyNzhkODljNWU5YmU4Zjk1MDhhZTNjMmFkNDYyOTAzNTg2MzBhZmIzNGRiMDRlZWRlMGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2MjRkODQ3ODA3MzI4NjBjZTFjNzhmY2JmZWZlMDhiMmIyOTgyM2RiOTEzZjY0OTM5NzViYTBmZjQ4NDc2MTAnLFxuICAgICAgICAnNjg2NTFjZjliNmRhOTAzZTA5MTQ0NDhjNmNkOWQ0Y2E4OTY4NzhmNTI4MmJlNGM4Y2MwNmUyYTQwNDA3ODU3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MzNjZTgwZGE5NTVhOGEyNjkwMmM5NTYzM2U2MmE5ODUxOTI0NzRiNWFmMjA3ZGE2ZGY3YjRmZDVmYzYxY2Q0JyxcbiAgICAgICAgJ2Y1NDM1YTJiZDJiYWRmN2Q0ODVhNGQ4YjhkYjlmY2NlM2UxZWY4ZTAyMDFlNDU3OGM1NDY3M2JjMWRjNWVhMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTVkOTQ0MTI1NDk0NTA2NGNmMWExYzMzYmJkM2I0OWY4OTY2YzUwOTIxNzFlNjk5ZWYyNThkZmFiODFjMDQ1YycsXG4gICAgICAgICdkNTZlYjMwYjY5NDYzZTcyMzRmNTEzN2I3M2I4NDE3NzQzNDgwMGJhY2ViZmM2ODVmYzM3YmJlOWVmZTQwNzBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ExZDBmY2YyZWM5ZGU2NzViNjEyMTM2ZTVjZTcwZDI3MWMyMTQxN2M5ZDJiOGFhYWFjMTM4NTk5ZDA3MTc5NDAnLFxuICAgICAgICAnZWRkNzdmNTBiY2I1YTNjYWIyZTkwNzM3MzA5NjY3ZjI2NDE0NjJhNTQwNzBmM2Q1MTkyMTJkMzljMTk3YTYyOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMjJmYmUxNWMwYWY4Y2NjNTc4MGMwNzM1Zjg0ZGJlOWE3OTBiYWRlZTgyNDVjMDZjN2NhMzczMzFjYjM2OTgwJyxcbiAgICAgICAgJ2E4NTViYWJhZDVjZDYwYzg4YjQzMGE2OWY1M2ExYTdhMzgyODkxNTQ5NjQ3OTliZTQzZDA2ZDc3ZDMxZGEwNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMTEwOTFkZDk4NjBlOGUyMGVlMTM0NzNjMTE1NWY1ZjY5NjM1ZTM5NDcwNGVhYTc0MDA5NDUyMjQ2Y2ZhOWIzJyxcbiAgICAgICAgJzY2ZGI2NTZmODdkMWYwNGZmZmQxZjA0Nzg4YzA2ODMwODcxZWM1YTY0ZmVlZTY4NWJkODBmMGIxMjg2ZDgzNzQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzRjMWZkMDRkMzAxYmU4OWIzMWMwNDQyZDNlNmFjMjQ4ODM5MjhiNDVhOTM0MDc4MTg2N2Q0MjMyZWMyZGJkZicsXG4gICAgICAgICc5NDE0Njg1ZTk3YjFiNTk1NGJkNDZmNzMwMTc0MTM2ZDU3ZjFjZWViNDg3NDQzZGM1MzIxODU3YmE3M2FiZWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjIxOWVhNWQ2YjU0NzAxYzFjMTRkZTViNTU3ZWI0MmE4ZDEzZjNhYmJjZDA4YWZmY2MyYTVlNmIwNDliOGQ2MycsXG4gICAgICAgICc0Y2I5NTk1N2U4M2Q0MGIwZjczYWY0NTQ0Y2NjZjZiMWY0YjA4ZDNjMDdiMjdmYjhkOGMyOTYyYTQwMDc2NmQxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3Yjg3NDBmNzRhOGZiYWFiMWY2ODNkYjhmNDVkZTI2NTQzYTU0OTBiY2E2MjcwODcyMzY5MTI0NjlhMGI0NDgnLFxuICAgICAgICAnZmE3Nzk2ODEyOGQ5YzkyZWUxMDEwZjMzN2FkNDcxN2VmZjE1ZGI1ZWQzYzA0OWIzNDExZTAzMTVlYWE0NTkzYidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmQzMWMyMjJmOGY2ZjBlZjg2ZjdjOThkM2EzMzM1ZWFkNWJjZDMyYWJkZDk0Mjg5ZmU0ZDMwOTFhYTgyNGJmJyxcbiAgICAgICAgJzVmMzAzMmY1ODkyMTU2ZTM5Y2NkM2Q3OTE1YjllMWRhMmU2ZGFjOWU2ZjI2ZTk2MTExOGQxNGI4NDYyZTE2NjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzQ2MWYzNzE5MTRhYjMyNjcxMDQ1YTE1NWQ5ODMxZWE4NzkzZDc3Y2Q1OTU5MmM0MzQwZjg2Y2JjMTgzNDdiNScsXG4gICAgICAgICc4ZWMwYmEyMzhiOTZiZWMwY2JkZGRjYWUwYWE0NDI1NDJlZWUxZmY1MGM5ODZlYTZiMzk4NDdiM2NjMDkyZmY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMDc5YWRiMWRmMTg2MDA3NDM1NmEyNWFhMzgyMDZhNmQ3MTZiMmMzZTY3NDUzZDI4NzY5OGJhZDdiMmIyZDYnLFxuICAgICAgICAnOGRjMjQxMmFhZmUzYmU1YzRjNWYzN2UwZWNjNWY5ZjZhNDQ2OTg5YWYwNGM0ZTI1ZWJhYWM0NzllYzFjOGMxZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNmVjOTNlNDQ3ZWM4M2YwNDY3YjE4MzAyZWU2MjBmN2U2NWRlMzMxODc0YzlkYzcyYmZkODYxNmJhOWRhNmI1JyxcbiAgICAgICAgJzVlNDYzMTE1MGU2MmZiNDBkMGU4YzJhN2NhNTgwNGEzOWQ1ODE4NmE1MGU0OTcxMzk2MjY3NzhlMjViMDY3NGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWFhNWY5ODBjMjQ1ZjZmMDM4OTc4MjkwYWZhNzBiNmJkODg1NTg5N2Y5OGI2YWE0ODViOTYwNjVkNTM3YmQ5OScsXG4gICAgICAgICdmNjVmNWQzZTI5MmMyZTA4MTlhNTI4MzkxYzk5NDYyNGQ3ODQ4NjlkN2U2ZWE2N2ZiMTgwNDEwMjRlZGMwN2RjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc4Yzk0MDc1NDRhYzEzMjY5MmVlMTkxMGEwMjQzOTk1OGFlMDQ4NzcxNTEzNDJlYTk2YzRiNmIzNWE0OWY1MScsXG4gICAgICAgICdmM2UwMzE5MTY5ZWI5Yjg1ZDU0MDQ3OTU1MzlhNWU2OGZhMWZiZDU4M2MwNjRkMjQ2MmI2NzVmMTk0YTNkZGI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5NGY0YmUyMTlhMWE3NzAxNmRjZDgzODQzMWFlYTAwMDFjZGM4YWU3YTZmYzY4ODcyNjU3OGQ5NzAyODU3YTUnLFxuICAgICAgICAnNDIyNDJhOTY5MjgzYTVmMzM5YmE3ZjA3NWUzNmJhMmFmOTI1Y2UzMGQ3NjdlZDZlNTVmNGIwMzE4ODBkNTYyYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTk4YTgwMzBkYTZkODZjNmJjN2YyZjUxNDRlYTU0OWQyODIxMWVhNThmYWE3MGViZjRjMWU2NjVjMWZlOWI1JyxcbiAgICAgICAgJzIwNGI1ZDZmODQ4MjJjMzA3ZTRiNGE3MTQwNzM3YWVjMjNmYzYzYjY1YjM1Zjg2YTEwMDI2ZGJkMmQ4NjRlNmInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQxOTE2MzY1YWJiMmI1ZDA5MTkyZjVmMmRiZWFmZWMyMDhmMDIwZjEyNTcwYTE4NGRiYWRjM2U1ODU5NTk5NycsXG4gICAgICAgICc0ZjE0MzUxZDAwODdlZmE0OWQyNDViMzI4OTg0OTg5ZDVjYWY5NDUwZjM0YmZjMGVkMTZlOTZiNThmYTk5MTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQxZDYwNjNhNTg2ZmE0NzVhNzI0NjA0ZGEwM2JjNWI5MmEyZTBkMmUwYTM2YWNmZTRjNzNhNTUxNDc0Mjg4MScsXG4gICAgICAgICc3Mzg2N2Y1OWMwNjU5ZTgxOTA0ZjlhMWM3NTQzNjk4ZTYyNTYyZDY3NDRjMTY5Y2U3YTM2ZGUwMWE4ZDYxNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWU5NWJiMzk5YTY5NzFkMzc2MDI2OTQ3Zjg5YmRlMmYyODJiMzM4MTA5MjhiZTRkZWQxMTJhYzRkNzBlMjBkNScsXG4gICAgICAgICczOWYyM2YzNjY4MDkwODViZWViZmM3MTE4MTMxMzc3NWE5OWM5YWVkN2Q4YmEzOGIxNjEzODRjNzQ2MDEyODY1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2ZTQ2NDFhNTM5NDhmZDQ3NmMzOWY4YTk5ZmQ5NzRlNWVjMDc1NjRiNTMxNWQ4YmY5OTQ3MWJjYTBlZjJmNjYnLFxuICAgICAgICAnZDI0MjRiMWIxYWJlNGViODE2NDIyN2IwODVjOWFhOTQ1NmVhMTM0OTNmZDU2M2UwNmZkNTFjZjU2OTRjNzhmYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzY1ODFlYTdiZmJiYjI5MGMxOTFhMmY1MDdhNDFjZjU2NDM4NDIxNzBlOTE0ZmFlYWIyN2MyYzU3OWY3MjYnLFxuICAgICAgICAnZWFkMTIxNjg1OTVmZTFiZTk5MjUyMTI5YjZlNTZiMzM5MWY3YWIxNDEwY2QxZTBlZjNkY2RjYWJkMmZkYTIyNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YWI4OTgxNmRhZGZkNmI2YTFmMjYzNGZjZjAwZWM4NDAzNzgxMDI1ZWQ2ODkwYzQ4NDk3NDI3MDZiZDQzZWRlJyxcbiAgICAgICAgJzZmZGNlZjA5ZjJmNmQwYTA0NGU2NTRhZWY2MjQxMzZmNTAzZDQ1OWMzZTg5ODQ1ODU4YTQ3YTkxMjljZGQyNGUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWUzM2YxYTc0NmM5YzU3NzgxMzMzNDRkOTI5OWZjYWEyMGIwOTM4ZThhY2ZmMjU0NGJiNDAyODRiOGM1ZmI5NCcsXG4gICAgICAgICc2MDY2MDI1N2RkMTFiM2FhOWM4ZWQ2MThkMjRlZGZmMjMwNmQzMjBmMWQwMzAxMGUzM2E3ZDIwNTdmM2IzYjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODViN2MxZGNiM2NlYzFiN2VlN2YzMGRlZDc5ZGQyMGEwZWQxZjRjYzE4Y2JjZmNmYTQxMDM2MWZkOGYwOGYzMScsXG4gICAgICAgICczZDk4YTljZGQwMjZkZDQzZjM5MDQ4ZjI1YTg4NDdmNGZjYWZhZDE4OTVkN2E2MzNjNmZlZDNjMzVlOTk5NTExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5ZGY5ZmJkOGQ5ZTQ2NTA5Mjc1ZjRiMTI1ZDZkNDVkN2ZiZTlhM2I4NzhhN2FmODcyYTI4MDA2NjFhYzVmNTEnLFxuICAgICAgICAnYjRjNGZlOTljNzc1YTYwNmUyZDg4NjIxNzkxMzlmZmRhNjFkYzg2MWMwMTllNTVjZDI4NzZlYjJhMjdkODRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EwYjFjYWUwNmIwYTg0N2EzZmVhNmU2NzFhYWY4YWRmZGZlNThjYTJmNzY4MTA1YzgwODJiMmU0NDlmY2UyNTInLFxuICAgICAgICAnYWU0MzQxMDJlZGRlMDk1OGVjNGIxOWQ5MTdhNmEyOGU2YjcyZGExODM0YWZmMGU2NTBmMDQ5NTAzYTI5NmNmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZThjZWFmYjliM2U5YTEzNmRjN2ZmNjdlODQwMjk1YjQ5OWRmYjNiMjEzM2U0YmExMTNmMmU0YzBlMTIxZTUnLFxuICAgICAgICAnY2YyMTc0MTE4YzhiNmQ3YTRiNDhmNmQ1MzRjZTVjNzk0MjJjMDg2YTYzNDYwNTAyYjgyN2NlNjJhMzI2NjgzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMjRhNDRlMDQ3ZTE5YjZmNWFmYjgxYzdjYTJmNjkwODBhNTA3NjY4OWEwMTA5MTlmNDI3MjVjMmI3ODlhMzNiJyxcbiAgICAgICAgJzZmYjhkNTU5MWI0NjZmOGZjNjNkYjUwZjFjMGYxYzY5MDEzZjk5Njg4N2I4MjQ0ZDJjZGVjNDE3YWZlYThmYTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWEwMTYwNmE3YTZjOWNkZDI0OWZkZmNmYWNiOTk1ODQwMDFlZGQyOGFiYmFiNzdiNTEwNGU5OGU4ZTNiMzVkNCcsXG4gICAgICAgICczMjJhZjQ5MDhjNzMxMmIwY2ZiZmUzNjlmN2E3YjNjZGI3ZDQ0OTRiYzI4MjM3MDBjZmQ2NTIxODhhM2VhOThkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmOGFkZGJmMmI2NjFjOGE2YzYzMjg2NTVlYjk2NjUxMjUyMDA3ZDhjNWVhMzFiZTRhZDE5NmRlOGNlMjEzMWYnLFxuICAgICAgICAnNjc0OWU2N2MwMjliODVmNTJhMDM0ZWFmZDA5NjgzNmIyNTIwODE4NjgwZTI2YWM4ZjNkZmJjZGI3MTc0OTcwMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlM2FlMTk3NDU2NmNhMDZjYzUxNmQ0N2UwZmIxNjVhNjc0YTNkYWJjZmNhMTVlNzIyZjBlMzQ1MGY0NTg4OScsXG4gICAgICAgICcyYWVhYmU3ZTQ1MzE1MTAxMTYyMTdmMDdiZjRkMDczMDBkZTk3ZTQ4NzRmODFmNTMzNDIwYTcyZWViMGJkNmE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5MWVlMzU1MzEzZDk5NzIxY2Y2OTkzZmZlZDFlM2UzMDE5OTNmZjNlZDI1ODgwMjA3NWVhOGNlZDM5N2UyNDYnLFxuICAgICAgICAnYjBlYTU1OGExMTNjMzBiZWE2MGZjNDc3NTQ2MGM3OTAxZmYwYjA1M2QyNWNhMmJkZWVlOThmMWE0YmU1ZDE5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMTM5NmQ1NWZkYTU0YzQ5ZjE5YWE5NzMxOGQ4ZGE2MWZhODU4NGU0N2IwODQ5NDUwNzdjZjAzMjU1YjUyOTg0JyxcbiAgICAgICAgJzk5OGM3NGE4Y2Q0NWFjMDEyODlkNTgzM2E3YmViNDc0NGZmNTM2YjAxYjI1N2JlNGM1NzY3YmVhOTNlYTU3YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2M1ZDJhMWJhMzljNWExNzkwMDAwNzM4YzllMGM0MGI4ZGNkZmQ1NDY4NzU0YjY0MDU1NDAxNTdlMDE3YWE3YScsXG4gICAgICAgICdiMjI4NDI3OTk5NWEzNGUyZjlkNGRlNzM5NmZjMThiODBmOWI4YjlmZGQyNzBmNjY2MWY3OWNhNGM4MWJkMjU3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NjODcwNGI4YTYwYTBkZWZhM2E5OWE3Mjk5ZjJlOWMzZmJjMzk1YWZiMDRhYzA3ODQyNWVmOGExNzkzY2MwMzAnLFxuICAgICAgICAnYmRkNDYwMzlmZWVkMTc4ODFkMWUwODYyZGIzNDdmOGNmMzk1Yjc0ZmM0YmNkYzRlOTQwYjc0ZTNhYzFmMWIxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNTMzZTRmN2VhODU1NWFhY2Q5Nzc3YWM1Y2FkMjliOTdkZDRkZWZjY2M1M2VlN2VhMjA0MTE5YjI4ODliMTk3JyxcbiAgICAgICAgJzZmMGEyNTZiYzVlZmRmNDI5YTJmYjYyNDJmMWE0M2EyZDliOTI1YmI0YTRiM2EyNmJiOGUwZjQ1ZWI1OTYwOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzE0ZjhmMmNjYjI3ZDZmMTA5ZjZkMDhkMDNjYzk2YTY5YmE4YzM0ZWVjMDdiYmNmNTY2ZDQ4ZTMzZGE2NTkzJyxcbiAgICAgICAgJ2MzNTlkNjkyM2JiMzk4ZjdmZDQ0NzNlMTZmZTFjMjg0NzViNzQwZGQwOTgwNzVlNmMwZTg2NDkxMTNkYzNhMzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTZjYmMzMDQ2YmM2YTQ1MGJhYzI0Nzg5ZmExNzExNWE0Yzk3MzllZDc1ZjhmMjFjZTQ0MWY3MmUwYjkwZTZlZicsXG4gICAgICAgICcyMWFlN2Y0NjgwZTg4OWJiMTMwNjE5ZTJjMGY5NWEzNjBjZWI1NzNjNzA2MDMxMzk4NjJhZmQ2MTdmYTliOWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzQ3ZDZkOWEwMmM0ODkyN2ViZmI4NmMxMzU5YjFjYWYxMzBhM2MwMjY3ZDExY2U2MzQ0YjM5Zjk5ZDQzY2MzOCcsXG4gICAgICAgICc2MGVhN2Y2MWEzNTM1MjRkMWM5ODdmNmVjZWM5MmYwODZkNTY1YWI2ODc4NzBjYjEyNjg5ZmYxZTMxYzc0NDQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjU0NWQyMTgxZGI4ZDk4M2Y3ZGNiMzc1ZWY1ODY2ZDQ3YzY3YjFiZjMxYzhjZjg1NWVmNzQzN2I3MjY1NmEnLFxuICAgICAgICAnNDliOTY3MTVhYjY4NzhhNzllNzhmMDdjZTU2ODBjNWQ2NjczMDUxYjQ5MzViZDg5N2ZlYTgyNGI3N2RjMjA4YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDA3NDdjYzlkMDEyY2IxYTEzYjgxNDgzMDljNmRlN2VjMjVkNjk0NWQ2NTcxNDZiOWQ1OTk0YjhmZWIxMTExJyxcbiAgICAgICAgJzVjYTU2MDc1M2JlMmExMmZjNmRlNmNhZjJjYjQ4OTU2NWRiOTM2MTU2Yjk1MTRlMWJiNWU4MzAzN2UwZmEyZDQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU0MmM4ZWM4MmM5OTc5OGNjZjNhNjEwYmU4NzBlNzgzMzhjN2Y3MTMzNDhiZDM0YzgyMDNlZjQwMzdmMzUwMicsXG4gICAgICAgICc3NTcxZDc0ZWU1ZTBmYjkyYTdhOGIzM2EwNzc4MzM0MWE1NDkyMTQ0Y2M1NGJjYzQwYTk0NDczNjkzNjA2NDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM3NzVhYjcwODliYzZhZjgyM2FiYTJlMWFmNzBiMjM2ZDI1MWNhZGIwYzg2NzQzMjg3NTIyYTFiM2IwZGVkZWEnLFxuICAgICAgICAnYmU1MmQxMDdiY2ZhMDlkOGJjYjk3MzZhODI4Y2ZhN2ZhYzhkYjE3YmY3YTc2YTJjNDJhZDk2MTQwOTAxOGNmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjZWUzMWNiZjdlMzRlYzM3OWQ5NGZiODE0ZDNkNzc1YWQ5NTQ1OTVkMTMxNGJhODg0Njk1OWUzZTgyZjc0ZTI2JyxcbiAgICAgICAgJzhmZDY0YTE0YzA2YjU4OWMyNmI5NDdhZTJiY2Y2YmZhMDE0OWVmMGJlMTRlZDRkODBmNDQ4YTAxYzQzYjFjNmQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjRmOWVhZWEwOWI2OTE3NjE5ZjZlYTZhNGViNTQ2NGVmZGRiNThmZDQ1YjFlYmVmY2RjMWEwMWQwOGI0Nzk4NicsXG4gICAgICAgICczOWU1Yzk5MjViNWE1NGIwNzQzM2E0ZjE4YzYxNzI2ZjhiYjEzMWMwMTJjYTU0MmViMjRhOGFjMDcyMDA2ODJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q0MjYzZGZjM2QyZGY5MjNhMDE3OWE0ODk2NmQzMGNlODRlMjUxNWFmYzNkY2NjMWI3NzkwNzc5MmViY2M2MGUnLFxuICAgICAgICAnNjJkZmFmMDdhMGY3OGZlYjMwZTMwZDYyOTU4NTNjZTE4OWUxMjc3NjBhZDZjZjdmYWUxNjRlMTIyYTIwOGQ1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ODQ1NzUyNDgyMGZhNjVhNGY4ZDM1ZWI2OTMwODU3YzAwMzJhY2MwYTRhMmRlNDIyMjMzZWVkYTg5NzYxMmM0JyxcbiAgICAgICAgJzI1YTc0OGFiMzY3OTc5ZDk4NzMzYzM4YTFmYTFjMmU3ZGM2Y2MwN2RiMmQ2MGE5YWU3YTc2YWFhNDliZDBmNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGZlZWVmMTg4MTEwMWYyY2IxMTY0NGYzYTJhZmRmYzIwNDVlMTk5MTkxNTI5MjNmMzY3YTE3NjdjMTFjY2VkYScsXG4gICAgICAgICdlY2ZiNzA1NmNmMWRlMDQyZjk0MjBiYWIzOTY3OTNjMGMzOTBiZGU3NGI0YmJkZmYxNmE4M2FlMDlhOWE3NTE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZkN2VmNmIxNzU0M2Y4MzczYzU3M2Y0NGUxZjM4OTgzNWQ4OWJjYmM2MDYyY2VkMzZjODJkZjgzYjhmYWU4NTknLFxuICAgICAgICAnY2Q0NTBlYzMzNTQzODk4NmRmZWZhMTBjNTdmZWE5YmNjNTIxYTA5NTliMmQ4MGJiZjc0YjE5MGRjYTcxMmQxMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNzU2MDVkNTkxMDJhNWEyNjg0NTAwZDNiOTkxZjJlM2YzYzg4YjkzMjI1NTQ3MDM1YWYyNWFmNjZlMDQ1NDFmJyxcbiAgICAgICAgJ2Y1YzU0NzU0YThmNzFlZTU0MGI5YjQ4NzI4NDczZTMxNGY3MjlhYzUzMDhiMDY5MzgzNjA5OTBlMmJmYWQxMjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWI5ODY2MGY0YzRkZmFhMDZhMmJlNDUzZDUwMjBiYzk5YTBjMmU2MGFiZTM4ODQ1N2RkNDNmZWZiMWVkNjIwYycsXG4gICAgICAgICc2Y2I5YTg4NzZkOWNiODUyMDYwOWFmM2FkZDI2Y2QyMGEwYTdjZDhhOTQxMTEzMWNlODVmNDQxMDAwOTkyMjNlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzZTg3YjAyN2Q4NTE0ZDM1OTM5ZjJlNjg5MmIxOTkyMjE1NDU5Njk0MTg4ODMzNmRjMzU2M2UzYjhkYmE5NDInLFxuICAgICAgICAnZmVmNWEzYzY4MDU5YTZkZWM1ZDYyNDExNGJmMWU5MWFhYzJiOWRhNTY4ZDZhYmViMjU3MGQ1NTY0NmI4YWRmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTE2MzAyNmU5ZmQ2ZmUwMTdjMzhmMDZhNWJlNmZjMTI1NDI0YjM3MWNlMjcwOGU3YmY0NDkxNjkxZTU3NjRhJyxcbiAgICAgICAgJzFhY2IyNTBmMjU1ZGQ2MWM0M2Q5NGNjYzY3MGQwZjU4ZjQ5YWUzZmExNWI5NjYyM2U1NDMwZGEwYWQ2YzYyYjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjI2OGY1ZWY5YWQ1MWU0ZDc4ZGUzYTc1MGMyZGM4OWIxZTYyNmQ0MzUwNTg2Nzk5OTkzMmU1ZGIzM2FmM2Q4MCcsXG4gICAgICAgICc1ZjMxMGQ0YjNjOTliOWViYjE5Zjc3ZDQxYzFkZWUwMThjZjBkMzRmZDQxOTE2MTQwMDNlOTQ1YTEyMTZlNDIzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMDdmMzExOGE5ZGYwMzVlOWZhZDg1ZWI2YzdiZmU0MmIwMmYwMWNhOTljZWVhM2JmN2ZmZGJhOTNjNDc1MGQnLFxuICAgICAgICAnNDM4MTM2ZDYwM2U4NThhM2E1YzQ0MGMzOGVjY2JhZGRjMWQyOTQyMTE0ZTJlZGRkNDc0MGQwOThjZWQxZjBkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZDhiOTg1NWM3YzA1MmEzNDE0NmZkMjBmZmI2NThiZWE0YjlmNjllMGQ4MjVlYmVjMTZlOGMzY2UyYjUyNmExJyxcbiAgICAgICAgJ2NkYjU1OWVlZGMyZDc5ZjkyNmJhZjQ0ZmI4NGVhNGQ0NGJjZjUwZmVlNTFkN2NlYjMwZTJlN2Y0NjMwMzY3NTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTJkYjBiNTM4NGRmYmYwNWJmYTlkNDcyZDdhZTI2ZGZlNGI4NTFjZWNhOTFiMWViYTU0MjYzMTgwZGEzMmI2MycsXG4gICAgICAgICdjM2I5OTdkMDUwZWU1ZDQyM2ViYWY2NmE2ZGI5ZjU3YjMxODBjOTAyODc1Njc5ZGU5MjRiNjlkODRhN2IzNzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTYyZjk0OTBkM2Q1MWRhNjM5NWVmZDI0ZTgwOTE5Y2M3ZDBmMjljM2YzZmE0OGM2ZmZmNTQzYmVjYmQ0MzM1MicsXG4gICAgICAgICc2ZDg5YWQ3YmE0ODc2YjBiMjJjMmNhMjgwYzY4Mjg2MmYzNDJjODU5MWYxZGFmNTE3MGUwN2JmZDljY2FmYTdkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzdmMzBlYTI0NzZiMzk5YjQ5NTc1MDljODhmNzdkMDE5MWFmYTJmZjVjYjdiMTRmZDZkOGU3ZDY1YWFhYjExOTMnLFxuICAgICAgICAnY2E1ZWY3ZDRiMjMxYzk0YzNiMTUzODlhNWY2MzExZTlkYWZmN2JiNjdiMTAzZTk4ODBlZjRiZmY2MzdhY2FlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MDk4ZmYxZTFkOWYxNGZiNDZhMjEwZmFkYTZjOTAzZmVmMGZiN2I0YTFkZDFkOWFjNjBhMDM2MTgwMGI3YTAwJyxcbiAgICAgICAgJzk3MzExNDFkODFmYzhmODA4NGQzN2M2ZTc1NDIwMDZiM2VlMWI0MGQ2MGRmZTUzNjJhNWIxMzJmZDE3ZGRjMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmI3OGM3ZGU5ZWU1MTJhNzI4OTViZTZiOWNiZWZhNmUyZjNjNGNjY2U0NDVjOTZiOWYyYzgxZTI3NzhhZDU4JyxcbiAgICAgICAgJ2VlMTg0OWY1MTNkZjcxZTMyZWZjMzg5NmVlMjgyNjBjNzNiYjgwNTQ3YWUyMjc1YmE0OTcyMzc3OTRjODc1M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTJjYjc0ZmRkYzhlOWZiY2QwNzZlZWYyYTdjNzJiMGNlMzdkNTBmMDgyNjlkZmMwNzRiNTgxNTUwNTQ3YTRmNycsXG4gICAgICAgICdkM2FhMmVkNzFjOWRkMjI0N2E2MmRmMDYyNzM2ZWIwYmFkZGVhOWUzNjEyMmQyYmU4NjQxYWJjYjAwNWNjNGE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0Mzg0NDc1NjZkNGQ3YmVkYWRjMjk5NDk2YWIzNTc0MjYwMDlhMzVmMjM1Y2IxNDFiZTBkOTljZDEwYWUzYTgnLFxuICAgICAgICAnYzRlMTAyMDkxNjk4MGE0ZGE1ZDAxYWM1ZTZhZDMzMDczNGVmMGQ3OTA2NjMxYzRmMjM5MDQyNmIyZWRkNzkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0MTYyZDQ4OGI4OTQwMjAzOWI1ODRjNmZjNmMzMDg4NzA1ODdkOWM0NmY2NjBiODc4YWI2NWM4MmM3MTFkNjdlJyxcbiAgICAgICAgJzY3MTYzZTkwMzIzNjI4OWY3NzZmMjJjMjVmYjhhM2FmYzE3MzJmMmI4NGI0ZTk1ZGJkYTQ3YWU1YTA4NTI2NDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnM2ZhZDNmYTg0Y2FmMGYzNGYwZjg5YmZkMmRjZjU0ZmMxNzVkNzY3YWVjM2U1MDY4NGYzYmE0YTRiZjVmNjgzZCcsXG4gICAgICAgICdjZDFiYzdjYjZjYzQwN2JiMmYwY2E2NDdjNzE4YTczMGNmNzE4NzJlN2QwZDJhNTNmYTIwZWZjZGZlNjE4MjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjc0ZjI2MDBhMzAwN2EwMDU2OGMxYTdjZTA1ZDA4MTZjMWZiODRiZjEzNzA3OThmMWM2OTUzMmZhZWIxYTg2YicsXG4gICAgICAgICcyOTlkMjFmOTQxM2YzM2IzZWRmNDNiMjU3MDA0NTgwYjcwZGI1N2RhMGIxODIyNTllMDllZWNjNjllMGQzOGE1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzMmY0ZGE1NGFkZTc0YWJiODFiODE1YWQxZmIzYjI2M2Q4MmQ2YzY5MjcxNGJjZmY4N2QyOWJkNWVlOWYwOGYnLFxuICAgICAgICAnZjk0MjllNzM4YjhlNTNiOTY4ZTk5MDE2YzA1OTcwNzc4MmUxNGY0NTM1MzU5ZDU4MmZjNDE2OTEwYjNlZWE4NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMGU0ZTY3MDQzNTM4NTU1NmU1OTM2NTcxMzU4NDVkMzZmYmI2OTMxZjcyYjA4Y2IxZWQ5NTRmMWUzY2UzZmY2JyxcbiAgICAgICAgJzQ2MmY5YmNlNjE5ODk4NjM4NDk5MzUwMTEzYmJjOWIxMGE4NzhkMzVkYTcwNzQwZGM2OTVhNTU5ZWI4OGRiN2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmUyMDYyMDAzYzUxY2MzMDA0NjgyOTA0MzMwZTRkZWU3ZjNkY2QxMGIwMWU1ODBiZjE5NzFiMDRkNGNhZDI5NycsXG4gICAgICAgICc2MjE4OGJjNDlkNjFlNTQyODU3M2Q0OGE3NGUxYzY1NWIxYzYxMDkwOTA1NjgyYTBkNTU1OGVkNzJkY2NiOWJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkzMTQ0NDIzYWNlMzQ1MWVkMjllMGZiOWFjMmFmMjExY2I2ZTg0YTYwMWRmNTk5M2M0MTk4NTlmZmY1ZGYwNGEnLFxuICAgICAgICAnN2MxMGRmYjE2NGMzNDI1ZjVjNzFhM2Y5ZDc5OTIwMzhmMTA2NTIyNGY3MmJiOWQxZDkwMmE2ZDEzMDM3YjQ3YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMDE1ZjgwNDRmNWZjYmRjZjIxY2EyNmQ2YzM0ZmI4MTk3ODI5MjA1YzdiN2QyYTdjYjY2NDE4YzE1N2IxMTJjJyxcbiAgICAgICAgJ2FiOGMxZTA4NmQwNGU4MTM3NDRhNjU1YjJkZjhkNWY4M2IzY2RjNmZhYTMwODhjMWQzYWVhMTQ1NGUzYTFkNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDVlOWUxZGE2NDlkOTdkODllNDg2ODExN2E0NjVhM2E0ZjhhMThkZTU3YTE0MGQzNmIzZjJhZjM0MWEyMWI1MicsXG4gICAgICAgICc0Y2IwNDQzN2YzOTFlZDczMTExYTEzY2MxZDRkZDBkYjE2OTM0NjVjMjI0MDQ4MGQ4OTU1ZTg1OTJmMjc0NDdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzYWU0MTA0N2RkN2NhMDY1ZGJmOGVkNzdiOTkyNDM5OTgzMDA1Y2Q3MmUxNmQ2Zjk5NmE1MzE2ZDM2OTY2YmInLFxuICAgICAgICAnYmQxYWViMjFhZDIyZWJiMjJhMTBmMDMwMzQxN2M2ZDk2NGY4Y2RkN2RmMGFjYTYxNGIxMGRjMTRkMTI1YWM0NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNlMjc2M2Q4ODVmOTU4ZmM2NmNkZDIyODAwZjBhNDg3MTk3ZDBhODJlMzc3YjQ5ZjgwYWY4N2M4OTdiMDY1JyxcbiAgICAgICAgJ2JmZWZhY2RiMGU1ZDBmZDdkZjNhMzExYTk0ZGUwNjJiMjZiODBjNjFmYmM5NzUwOGI3OTk5MjY3MWVmN2NhN2YnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk4NWZkZmQxMjdjMDU2N2M2ZjUzZWMxYmI2M2VjMzE1OGU1OTdjNDBiZmU3NDdjODNjZGRmYzkxMDY0MTkxNycsXG4gICAgICAgICc2MDNjMTJkYWYzZDk4NjJlZjJiMjVmZTFkZTI4OWFlZDI0ZWQyOTFlMGVjNjcwODcwM2E1YmQ1NjdmMzJlZDAzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0YTFhZDZiNWY3NmUzOWRiMmRkMjQ5NDEwZWFjN2Y5OWU3NGM1OWNiODNkMmQwZWQ1ZmYxNTQzZGE3NzAzZTknLFxuICAgICAgICAnY2M2MTU3ZWYxOGM5YzYzY2Q2MTkzZDgzNjMxYmJlYTAwOTNlMDk2ODk0MmU4YzMzZDU3MzdmZDc5MGUwZGIwOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMDY4MmE1MDcwMzM3NWY2MDJkNDE2NjY0YmExOWI3ZmM5YmFiNDJjNzI3NDc0NjNhNzFkMDg5NmIyMmY2ZGEzJyxcbiAgICAgICAgJzU1M2UwNGY2YjAxOGI0ZmE2YzhmMzllN2YzMTFkMzE3NjI5MGQwZTBmMTljYTczZjE3NzE0ZDk5NzdhMjJmZjgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWUyMTU4ZjBkN2MwZDVmMjZjMzc5MWVmZWZhNzk1OTc2NTRlN2EyYjI0NjRmNTJiMWVlNmMxMzQ3NzY5ZWY1NycsXG4gICAgICAgICc3MTJmY2RkMWI5MDUzZjA5MDAzYTM0ODFmYTc3NjJlOWZmZDdjOGVmMzVhMzg1MDllMmZiZjI2MjkwMDgzNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc2ZTI2OTg5YTQzYzljZmViYTQwMjljMjAyNTM4YzI4MTcyZTU2NmUzYzRmY2U3MzIyODU3ZjNiZTMyN2Q2NicsXG4gICAgICAgICdlZDhjYzlkMDRiMjllYjg3N2QyNzBiNDg3OGRjNDNjMTlhZWZkMzFmNGVlZTA5ZWU3YjQ3ODM0YzFmYTRiMWMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1ZDQ2ZWZlYTM3NzFlNmU2OGFiYjg5YTEzYWQ3NDdlY2YxODkyMzkzZGZjNGYxYjcwMDQ3ODhjNTAzNzRkYTgnLFxuICAgICAgICAnOTg1MjM5MGE5OTUwNzY3OWZkMGI4NmZkMmIzOWE4NjhkN2VmYzIyMTUxMzQ2ZTFhM2NhNDcyNjU4NmE2YmVkOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MDlhMjBjNjdkNjQ5MDBmZmI2OThjNGM4MjVmNmQ1ZjIzMTBmYjA0NTFjODY5MzQ1YjczMTlmNjQ1NjA1NzIxJyxcbiAgICAgICAgJzllOTk0OTgwZDk5MTdlMjJiNzZiMDYxOTI3ZmEwNDE0M2QwOTZjY2M1NDk2M2U2YTVlYmZhNWYzZjhlMjg2YzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWIzODkwM2E0M2Y3ZjExNGVkNDUwMGI0ZWFjNzA4M2ZkZWZlY2UxY2YyOWM2MzUyOGQ1NjM0NDZmOTcyYzE4MCcsXG4gICAgICAgICc0MDM2ZWRjOTMxYTYwYWU4ODkzNTNmNzdmZDUzZGU0YTI3MDhiMjZiNmY1ZGE3MmFkMzM5NDExOWRhZjQwOGY5J1xuICAgICAgXVxuICAgIF1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbWluQXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIG1pblV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xuXG51dGlscy5hc3NlcnQgPSBtaW5Bc3NlcnQ7XG51dGlscy50b0FycmF5ID0gbWluVXRpbHMudG9BcnJheTtcbnV0aWxzLnplcm8yID0gbWluVXRpbHMuemVybzI7XG51dGlscy50b0hleCA9IG1pblV0aWxzLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gbWluVXRpbHMuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdykge1xuICB2YXIgbmFmID0gW107XG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcbiAgd2hpbGUgKGsuY21wbigxKSA+PSAwKSB7XG4gICAgdmFyIHo7XG4gICAgaWYgKGsuaXNPZGQoKSkge1xuICAgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuICAgIG5hZi5wdXNoKHopO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uLCBzaGlmdCBieSB3b3JkIGlmIHBvc3NpYmxlXG4gICAgdmFyIHNoaWZ0ID0gKGsuY21wbigwKSAhPT0gMCAmJiBrLmFuZGxuKHdzIC0gMSkgPT09IDApID8gKHcgKyAxKSA6IDE7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGlmdDsgaSsrKVxuICAgICAgbmFmLnB1c2goMCk7XG4gICAgay5pdXNocm4oc2hpZnQpO1xuICB9XG5cbiAgcmV0dXJuIG5hZjtcbn1cbnV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuLy8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gIHZhciBqc2YgPSBbXG4gICAgW10sXG4gICAgW11cbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgIHUxID0gLW0xNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTEgPSBtMTQ7XG4gICAgfVxuICAgIGpzZlswXS5wdXNoKHUxKTtcblxuICAgIHZhciB1MjtcbiAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICB1MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IEJOKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlCaXRzLCBpdkxlbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsICdiaW5hcnknKVxuICBpZiAoc2FsdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgJ2JpbmFyeScpXG4gICAgaWYgKHNhbHQubGVuZ3RoICE9PSA4KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2FsdCBzaG91bGQgYmUgQnVmZmVyIHdpdGggOCBieXRlIGxlbmd0aCcpXG4gIH1cblxuICB2YXIga2V5TGVuID0ga2V5Qml0cyAvIDhcbiAgdmFyIGtleSA9IEJ1ZmZlci5hbGxvYyhrZXlMZW4pXG4gIHZhciBpdiA9IEJ1ZmZlci5hbGxvYyhpdkxlbiB8fCAwKVxuICB2YXIgdG1wID0gQnVmZmVyLmFsbG9jKDApXG5cbiAgd2hpbGUgKGtleUxlbiA+IDAgfHwgaXZMZW4gPiAwKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgTUQ1KClcbiAgICBoYXNoLnVwZGF0ZSh0bXApXG4gICAgaGFzaC51cGRhdGUocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIGhhc2gudXBkYXRlKHNhbHQpXG4gICAgdG1wID0gaGFzaC5kaWdlc3QoKVxuXG4gICAgdmFyIHVzZWQgPSAwXG5cbiAgICBpZiAoa2V5TGVuID4gMCkge1xuICAgICAgdmFyIGtleVN0YXJ0ID0ga2V5Lmxlbmd0aCAtIGtleUxlblxuICAgICAgdXNlZCA9IE1hdGgubWluKGtleUxlbiwgdG1wLmxlbmd0aClcbiAgICAgIHRtcC5jb3B5KGtleSwga2V5U3RhcnQsIDAsIHVzZWQpXG4gICAgICBrZXlMZW4gLT0gdXNlZFxuICAgIH1cblxuICAgIGlmICh1c2VkIDwgdG1wLmxlbmd0aCAmJiBpdkxlbiA+IDApIHtcbiAgICAgIHZhciBpdlN0YXJ0ID0gaXYubGVuZ3RoIC0gaXZMZW5cbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihpdkxlbiwgdG1wLmxlbmd0aCAtIHVzZWQpXG4gICAgICB0bXAuY29weShpdiwgaXZTdGFydCwgdXNlZCwgdXNlZCArIGxlbmd0aClcbiAgICAgIGl2TGVuIC09IGxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHRtcC5maWxsKDApXG4gIHJldHVybiB7IGtleToga2V5LCBpdjogaXYgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVWUF9CeXRlc1RvS2V5XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIgKHZhbCwgcHJlZml4KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkgJiYgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHByZWZpeCArICcgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2NrU2l6ZSlcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB0aGlzLl9sZW5ndGggPSBbMCwgMCwgMCwgMF1cblxuICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhIYXNoQmFzZSwgVHJhbnNmb3JtKVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yID0gZXJyXG4gIH1cblxuICBjYWxsYmFjayhlcnJvcilcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIoZGF0YSwgJ0RhdGEnKVxuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgLy8gY29uc3VtZSBkYXRhXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBvZmZzZXQgPSAwXG4gIHdoaWxlICh0aGlzLl9ibG9ja09mZnNldCArIGRhdGEubGVuZ3RoIC0gb2Zmc2V0ID49IHRoaXMuX2Jsb2NrU2l6ZSkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9ibG9ja09mZnNldDsgaSA8IHRoaXMuX2Jsb2NrU2l6ZTspIGJsb2NrW2krK10gPSBkYXRhW29mZnNldCsrXVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cbiAgd2hpbGUgKG9mZnNldCA8IGRhdGEubGVuZ3RoKSBibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IGRhdGFbb2Zmc2V0KytdXG5cbiAgLy8gdXBkYXRlIGxlbmd0aFxuICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBkYXRhLmxlbmd0aCAqIDg7IGNhcnJ5ID4gMDsgKytqKSB7XG4gICAgdGhpcy5fbGVuZ3RoW2pdICs9IGNhcnJ5XG4gICAgY2FycnkgPSAodGhpcy5fbGVuZ3RoW2pdIC8gMHgwMTAwMDAwMDAwKSB8IDBcbiAgICBpZiAoY2FycnkgPiAwKSB0aGlzLl9sZW5ndGhbal0gLT0gMHgwMTAwMDAwMDAwICogY2FycnlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXG4gIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICB2YXIgZGlnZXN0ID0gdGhpcy5fZGlnZXN0KClcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIGRpZ2VzdCA9IGRpZ2VzdC50b1N0cmluZyhlbmNvZGluZylcblxuICAvLyByZXNldCBzdGF0ZVxuICB0aGlzLl9ibG9jay5maWxsKDApXG4gIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkgdGhpcy5fbGVuZ3RoW2ldID0gMFxuXG4gIHJldHVybiBkaWdlc3Rcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX2RpZ2VzdCBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hCYXNlXG4iLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nVG90YWwgPSAwO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG4gIHRoaXMuaG1hY1N0cmVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7XG4gIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuICB0aGlzLmVuZGlhbiA9ICdiaWcnO1xuXG4gIHRoaXMuX2RlbHRhOCA9IHRoaXMuYmxvY2tTaXplIC8gODtcbiAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG59XG5leHBvcnRzLkJsb2NrSGFzaCA9IEJsb2NrSGFzaDtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG4gIG1zZyA9IHV0aWxzLnRvQXJyYXkobXNnLCBlbmMpO1xuICBpZiAoIXRoaXMucGVuZGluZylcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG4gIGVsc2VcbiAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuY29uY2F0KG1zZyk7XG4gIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cbiAgLy8gRW5vdWdoIGRhdGEsIHRyeSB1cGRhdGluZ1xuICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcbiAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cbiAgICAvLyBQcm9jZXNzIHBlbmRpbmcgZGF0YSBpbiBibG9ja3NcbiAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cbiAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgdGhpcy5fdXBkYXRlKG1zZywgaSwgaSArIHRoaXMuX2RlbHRhMzIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpO1xuICBhc3NlcnQodGhpcy5wZW5kaW5nID09PSBudWxsKTtcblxuICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG59O1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcbiAgdmFyIGJ5dGVzID0gdGhpcy5fZGVsdGE4O1xuICB2YXIgayA9IGJ5dGVzIC0gKChsZW4gKyB0aGlzLnBhZExlbmd0aCkgJSBieXRlcyk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcbiAgcmVzWzBdID0gMHg4MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG4gICAgcmVzW2ldID0gMDtcblxuICAvLyBBcHBlbmQgbGVuZ3RoXG4gIGxlbiA8PD0gMztcbiAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcblxuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG5cbiAgICBmb3IgKHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4MzY7XG4gIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cbiAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhLzEnKTtcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEvMjI0Jyk7XG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhLzI1NicpO1xuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYS8zODQnKTtcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGEvNTEyJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgc2hhQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIGZ0XzEgPSBzaGFDb21tb24uZnRfMTtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMV9LID0gW1xuICAweDVBODI3OTk5LCAweDZFRDlFQkExLFxuICAweDhGMUJCQ0RDLCAweENBNjJDMUQ2XG5dO1xuXG5mdW5jdGlvbiBTSEExKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG4gICAgcmV0dXJuIG5ldyBTSEExKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLFxuICAgIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5XID0gbmV3IEFycmF5KDgwKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoU0hBMSwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMTtcblxuU0hBMS5ibG9ja1NpemUgPSA1MTI7XG5TSEExLm91dFNpemUgPSAxNjA7XG5TSEExLmhtYWNTdHJlbmd0aCA9IDgwO1xuU0hBMS5wYWRMZW5ndGggPSA2NDtcblxuU0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG4gIGZvcig7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSByb3RsMzIoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSB+fihpIC8gMjApO1xuICAgIHZhciB0ID0gc3VtMzJfNShyb3RsMzIoYSwgNSksIGZ0XzEocywgYiwgYywgZCksIGUsIFdbaV0sIHNoYTFfS1tzXSk7XG4gICAgZSA9IGQ7XG4gICAgZCA9IGM7XG4gICAgYyA9IHJvdGwzMihiLCAzMCk7XG4gICAgYiA9IGE7XG4gICAgYSA9IHQ7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xufTtcblxuU0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgU0hBMjU2ID0gcmVxdWlyZSgnLi8yNTYnKTtcblxuZnVuY3Rpb24gU0hBMjI0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcbiAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuXG4gIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcbiAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEyMjQsIFNIQTI1Nik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTIyNDtcblxuU0hBMjI0LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTIyNC5vdXRTaXplID0gMjI0O1xuU0hBMjI0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTIyNC5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjI0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAvLyBKdXN0IHRydW5jYXRlIG91dHB1dFxuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBjaDMyID0gc2hhQ29tbW9uLmNoMzI7XG52YXIgbWFqMzIgPSBzaGFDb21tb24ubWFqMzI7XG52YXIgczBfMjU2ID0gc2hhQ29tbW9uLnMwXzI1NjtcbnZhciBzMV8yNTYgPSBzaGFDb21tb24uczFfMjU2O1xudmFyIGcwXzI1NiA9IHNoYUNvbW1vbi5nMF8yNTY7XG52YXIgZzFfMjU2ID0gc2hhQ29tbW9uLmcxXzI1NjtcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGEyNTZfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcbiAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcbiAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXTtcblxuZnVuY3Rpb24gU0hBMjU2KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjU2KSlcbiAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSxcbiAgICAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG4gIF07XG4gIHRoaXMuayA9IHNoYTI1Nl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoNjQpO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjU2LCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyNTY7XG5cblNIQTI1Ni5ibG9ja1NpemUgPSA1MTI7XG5TSEEyNTYub3V0U2l6ZSA9IDI1NjtcblNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyNTYucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHN1bTMyXzQoZzFfMjU2KFdbaSAtIDJdKSwgV1tpIC0gN10sIGcwXzI1NihXW2kgLSAxNV0pLCBXW2kgLSAxNl0pO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcbiAgdmFyIGYgPSB0aGlzLmhbNV07XG4gIHZhciBnID0gdGhpcy5oWzZdO1xuICB2YXIgaCA9IHRoaXMuaFs3XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBUMSA9IHN1bTMyXzUoaCwgczFfMjU2KGUpLCBjaDMyKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgIGggPSBnO1xuICAgIGcgPSBmO1xuICAgIGYgPSBlO1xuICAgIGUgPSBzdW0zMihkLCBUMSk7XG4gICAgZCA9IGM7XG4gICAgYyA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHN1bTMyKFQxLCBUMik7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xuICB0aGlzLmhbNV0gPSBzdW0zMih0aGlzLmhbNV0sIGYpO1xuICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICB0aGlzLmhbN10gPSBzdW0zMih0aGlzLmhbN10sIGgpO1xufTtcblxuU0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vNTEyJyk7XG5cbmZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG4gICAgcmV0dXJuIG5ldyBTSEEzODQoKTtcblxuICBTSEE1MTIuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsXG4gICAgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyxcbiAgICAweDkxNTkwMTVhLCAweDMwNzBkZDE3LFxuICAgIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSxcbiAgICAweDhlYjQ0YTg3LCAweDY4NTgxNTExLFxuICAgIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsXG4gICAgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMzg0LCBTSEE1MTIpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEzODQ7XG5cblNIQTM4NC5ibG9ja1NpemUgPSAxMDI0O1xuU0hBMzg0Lm91dFNpemUgPSAzODQ7XG5TSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMzg0LnBhZExlbmd0aCA9IDEyODtcblxuU0hBMzg0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgMTIpLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHJvdHI2NF9oaSA9IHV0aWxzLnJvdHI2NF9oaTtcbnZhciByb3RyNjRfbG8gPSB1dGlscy5yb3RyNjRfbG87XG52YXIgc2hyNjRfaGkgPSB1dGlscy5zaHI2NF9oaTtcbnZhciBzaHI2NF9sbyA9IHV0aWxzLnNocjY0X2xvO1xudmFyIHN1bTY0ID0gdXRpbHMuc3VtNjQ7XG52YXIgc3VtNjRfaGkgPSB1dGlscy5zdW02NF9oaTtcbnZhciBzdW02NF9sbyA9IHV0aWxzLnN1bTY0X2xvO1xudmFyIHN1bTY0XzRfaGkgPSB1dGlscy5zdW02NF80X2hpO1xudmFyIHN1bTY0XzRfbG8gPSB1dGlscy5zdW02NF80X2xvO1xudmFyIHN1bTY0XzVfaGkgPSB1dGlscy5zdW02NF81X2hpO1xudmFyIHN1bTY0XzVfbG8gPSB1dGlscy5zdW02NF81X2xvO1xuXG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTUxMl9LID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG5mdW5jdGlvbiBTSEE1MTIoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEE1MTIpKVxuICAgIHJldHVybiBuZXcgU0hBNTEyKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuICAgIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsXG4gICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcbiAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsXG4gICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcbiAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuICAgIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkgXTtcbiAgdGhpcy5rID0gc2hhNTEyX0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEE1MTI7XG5cblNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuU0hBNTEyLm91dFNpemUgPSA1MTI7XG5TSEE1MTIuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuU0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIC8vIDMyIHggMzJiaXQgd29yZHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuICAgIHZhciBjMF9sbyA9IGcxXzUxMl9sbyhXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG4gICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuICAgIHZhciBjMl9oaSA9IGcwXzUxMl9oaShXW2kgLSAzMF0sIFdbaSAtIDI5XSk7ICAvLyBpIC0gMTVcbiAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcblxuICAgIFdbaV0gPSBzdW02NF80X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8oXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8pO1xuICB9XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdGhpcy5fcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpO1xuXG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIHZhciBhaCA9IHRoaXMuaFswXTtcbiAgdmFyIGFsID0gdGhpcy5oWzFdO1xuICB2YXIgYmggPSB0aGlzLmhbMl07XG4gIHZhciBibCA9IHRoaXMuaFszXTtcbiAgdmFyIGNoID0gdGhpcy5oWzRdO1xuICB2YXIgY2wgPSB0aGlzLmhbNV07XG4gIHZhciBkaCA9IHRoaXMuaFs2XTtcbiAgdmFyIGRsID0gdGhpcy5oWzddO1xuICB2YXIgZWggPSB0aGlzLmhbOF07XG4gIHZhciBlbCA9IHRoaXMuaFs5XTtcbiAgdmFyIGZoID0gdGhpcy5oWzEwXTtcbiAgdmFyIGZsID0gdGhpcy5oWzExXTtcbiAgdmFyIGdoID0gdGhpcy5oWzEyXTtcbiAgdmFyIGdsID0gdGhpcy5oWzEzXTtcbiAgdmFyIGhoID0gdGhpcy5oWzE0XTtcbiAgdmFyIGhsID0gdGhpcy5oWzE1XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBoaDtcbiAgICB2YXIgYzBfbG8gPSBobDtcbiAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcbiAgICB2YXIgYzFfbG8gPSBzMV81MTJfbG8oZWgsIGVsKTtcbiAgICB2YXIgYzJfaGkgPSBjaDY0X2hpKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMzX2hpID0gdGhpcy5rW2ldO1xuICAgIHZhciBjM19sbyA9IHRoaXMua1tpICsgMV07XG4gICAgdmFyIGM0X2hpID0gV1tpXTtcbiAgICB2YXIgYzRfbG8gPSBXW2kgKyAxXTtcblxuICAgIHZhciBUMV9oaSA9IHN1bTY0XzVfaGkoXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8sXG4gICAgICBjNF9oaSwgYzRfbG8pO1xuICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8sXG4gICAgICBjNF9oaSwgYzRfbG8pO1xuXG4gICAgYzBfaGkgPSBzMF81MTJfaGkoYWgsIGFsKTtcbiAgICBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuICAgIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG4gICAgYzFfbG8gPSBtYWo2NF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcblxuICAgIHZhciBUMl9oaSA9IHN1bTY0X2hpKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcbiAgICB2YXIgVDJfbG8gPSBzdW02NF9sbyhjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG5cbiAgICBoaCA9IGdoO1xuICAgIGhsID0gZ2w7XG5cbiAgICBnaCA9IGZoO1xuICAgIGdsID0gZmw7XG5cbiAgICBmaCA9IGVoO1xuICAgIGZsID0gZWw7XG5cbiAgICBlaCA9IHN1bTY0X2hpKGRoLCBkbCwgVDFfaGksIFQxX2xvKTtcbiAgICBlbCA9IHN1bTY0X2xvKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuICAgIGRoID0gY2g7XG4gICAgZGwgPSBjbDtcblxuICAgIGNoID0gYmg7XG4gICAgY2wgPSBibDtcblxuICAgIGJoID0gYWg7XG4gICAgYmwgPSBhbDtcblxuICAgIGFoID0gc3VtNjRfaGkoVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICAgIGFsID0gc3VtNjRfbG8oVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICB9XG5cbiAgc3VtNjQodGhpcy5oLCAwLCBhaCwgYWwpO1xuICBzdW02NCh0aGlzLmgsIDIsIGJoLCBibCk7XG4gIHN1bTY0KHRoaXMuaCwgNCwgY2gsIGNsKTtcbiAgc3VtNjQodGhpcy5oLCA2LCBkaCwgZGwpO1xuICBzdW02NCh0aGlzLmgsIDgsIGVoLCBlbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTAsIGZoLCBmbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTIsIGdoLCBnbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTQsIGhoLCBobCk7XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBjaDY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjaDY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDgpO1xuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDgpO1xuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgcm90cjMyID0gdXRpbHMucm90cjMyO1xuXG5mdW5jdGlvbiBmdF8xKHMsIHgsIHksIHopIHtcbiAgaWYgKHMgPT09IDApXG4gICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAxIHx8IHMgPT09IDMpXG4gICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDIpXG4gICAgcmV0dXJuIG1hajMyKHgsIHksIHopO1xufVxuZXhwb3J0cy5mdF8xID0gZnRfMTtcblxuZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKCh+eCkgJiB6KTtcbn1cbmV4cG9ydHMuY2gzMiA9IGNoMzI7XG5cbmZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KTtcbn1cbmV4cG9ydHMubWFqMzIgPSBtYWozMjtcblxuZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcbiAgcmV0dXJuIHggXiB5IF4gejtcbn1cbmV4cG9ydHMucDMyID0gcDMyO1xuXG5mdW5jdGlvbiBzMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDIpIF4gcm90cjMyKHgsIDEzKSBeIHJvdHIzMih4LCAyMik7XG59XG5leHBvcnRzLnMwXzI1NiA9IHMwXzI1NjtcblxuZnVuY3Rpb24gczFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA2KSBeIHJvdHIzMih4LCAxMSkgXiByb3RyMzIoeCwgMjUpO1xufVxuZXhwb3J0cy5zMV8yNTYgPSBzMV8yNTY7XG5cbmZ1bmN0aW9uIGcwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNykgXiByb3RyMzIoeCwgMTgpIF4gKHggPj4+IDMpO1xufVxuZXhwb3J0cy5nMF8yNTYgPSBnMF8yNTY7XG5cbmZ1bmN0aW9uIGcxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMTcpIF4gcm90cjMyKHgsIDE5KSBeICh4ID4+PiAxMCk7XG59XG5leHBvcnRzLmcxXzI1NiA9IGcxXzI1NjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkge1xuICBpZiAoKG1zZy5jaGFyQ29kZUF0KGkpICYgMHhGQzAwKSAhPT0gMHhEODAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpIDwgMCB8fCBpICsgMSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAobXNnLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIC8vIEluc3BpcmVkIGJ5IHN0cmluZ1RvVXRmOEJ5dGVBcnJheSgpIGluIGNsb3N1cmUtbGlicmFyeSBieSBHb29nbGVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvODU5OGQ4NzI0MmFmNTlhYWMyMzMyNzA3NDJjODk4NGUyYjJiZGJlMC9jbG9zdXJlL2dvb2cvY3J5cHQvY3J5cHQuanMjTDExNy1MMTQzXG4gICAgICAvLyBBcGFjaGUgTGljZW5zZSAyLjBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3Vycm9nYXRlUGFpcihtc2csIGkpKSB7XG4gICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzRkYpIDw8IDEwKSArIChtc2cuY2hhckNvZGVBdCgrK2kpICYgMHgwM0ZGKTtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG5leHBvcnRzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufVxuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5fcmVzZWVkID0gbnVsbDtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMuSyA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG5cbiAgdmFyIGVudHJvcHkgPSB1dGlscy50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcbiAgdmFyIG5vbmNlID0gdXRpbHMudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlscy50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jIHx8ICdoZXgnKTtcbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcbiAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlscy50b0FycmF5KGVudHJvcHksIGVudHJvcHlFbmMpO1xuICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaEJhc2UgPSByZXF1aXJlKCdoYXNoLWJhc2UnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBBUlJBWTE2ID0gbmV3IEFycmF5KDE2KVxuXG5mdW5jdGlvbiBNRDUgKCkge1xuICBIYXNoQmFzZS5jYWxsKHRoaXMsIDY0KVxuXG4gIC8vIHN0YXRlXG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG59XG5cbmluaGVyaXRzKE1ENSwgSGFzaEJhc2UpXG5cbk1ENS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIE0gPSBBUlJBWTE2XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgTVtpXSA9IHRoaXMuX2Jsb2NrLnJlYWRJbnQzMkxFKGkgKiA0KVxuXG4gIHZhciBhID0gdGhpcy5fYVxuICB2YXIgYiA9IHRoaXMuX2JcbiAgdmFyIGMgPSB0aGlzLl9jXG4gIHZhciBkID0gdGhpcy5fZFxuXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVswXSwgMHhkNzZhYTQ3OCwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzFdLCAweGU4YzdiNzU2LCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzJdLCAweDI0MjA3MGRiLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzNdLCAweGMxYmRjZWVlLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzRdLCAweGY1N2MwZmFmLCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bNV0sIDB4NDc4N2M2MmEsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTgzMDQ2MTMsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bN10sIDB4ZmQ0Njk1MDEsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bOF0sIDB4Njk4MDk4ZDgsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVs5XSwgMHg4YjQ0ZjdhZiwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsxMF0sIDB4ZmZmZjViYjEsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bMTFdLCAweDg5NWNkN2JlLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzEyXSwgMHg2YjkwMTEyMiwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzEzXSwgMHhmZDk4NzE5MywgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsxNF0sIDB4YTY3OTQzOGUsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bMTVdLCAweDQ5YjQwODIxLCAyMilcblxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bMV0sIDB4ZjYxZTI1NjIsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVs2XSwgMHhjMDQwYjM0MCwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzExXSwgMHgyNjVlNWE1MSwgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVswXSwgMHhlOWI2YzdhYSwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVs1XSwgMHhkNjJmMTA1ZCwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzEwXSwgMHgwMjQ0MTQ1MywgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzE1XSwgMHhkOGExZTY4MSwgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs0XSwgMHhlN2QzZmJjOCwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVs5XSwgMHgyMWUxY2RlNiwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzE0XSwgMHhjMzM3MDdkNiwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzNdLCAweGY0ZDUwZDg3LCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzhdLCAweDQ1NWExNGVkLCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzEzXSwgMHhhOWUzZTkwNSwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzJdLCAweGZjZWZhM2Y4LCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bN10sIDB4Njc2ZjAyZDksIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMTJdLCAweDhkMmE0YzhhLCAyMClcblxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bNV0sIDB4ZmZmYTM5NDIsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVs4XSwgMHg4NzcxZjY4MSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxMV0sIDB4NmQ5ZDYxMjIsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMTRdLCAweGZkZTUzODBjLCAyMylcbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzFdLCAweGE0YmVlYTQ0LCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bNF0sIDB4NGJkZWNmYTksIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bN10sIDB4ZjZiYjRiNjAsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMTBdLCAweGJlYmZiYzcwLCAyMylcbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzEzXSwgMHgyODliN2VjNiwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzBdLCAweGVhYTEyN2ZhLCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzNdLCAweGQ0ZWYzMDg1LCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzZdLCAweDA0ODgxZDA1LCAyMylcbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzldLCAweGQ5ZDRkMDM5LCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bMTJdLCAweGU2ZGI5OWU1LCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzE1XSwgMHgxZmEyN2NmOCwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsyXSwgMHhjNGFjNTY2NSwgMjMpXG5cbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzBdLCAweGY0MjkyMjQ0LCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bN10sIDB4NDMyYWZmOTcsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bMTRdLCAweGFiOTQyM2E3LCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzVdLCAweGZjOTNhMDM5LCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzEyXSwgMHg2NTViNTljMywgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzNdLCAweDhmMGNjYzkyLCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmVmZjQ3ZCwgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVsxXSwgMHg4NTg0NWRkMSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVs4XSwgMHg2ZmE4N2U0ZiwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzE1XSwgMHhmZTJjZTZlMCwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVs2XSwgMHhhMzAxNDMxNCwgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVsxM10sIDB4NGUwODExYTEsIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bNF0sIDB4Zjc1MzdlODIsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVsxMV0sIDB4YmQzYWYyMzUsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bMl0sIDB4MmFkN2QyYmIsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bOV0sIDB4ZWI4NmQzOTEsIDIxKVxuXG4gIHRoaXMuX2EgPSAodGhpcy5fYSArIGEpIHwgMFxuICB0aGlzLl9iID0gKHRoaXMuX2IgKyBiKSB8IDBcbiAgdGhpcy5fYyA9ICh0aGlzLl9jICsgYykgfCAwXG4gIHRoaXMuX2QgPSAodGhpcy5fZCArIGQpIHwgMFxufVxuXG5NRDUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9hLCAwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2IsIDQpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYywgOClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9kLCAxMilcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gZm5GIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkcgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgZCkgfCAoYyAmICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuSCAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIGMgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuSSAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGMgXiAoYiB8ICh+ZCkpKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1ENVxuIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBicm9yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuXG5mdW5jdGlvbiBNaWxsZXJSYWJpbihyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQgfHwgbmV3IGJyb3JhbmQuUmFuZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNaWxsZXJSYWJpbjtcblxuTWlsbGVyUmFiaW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHJhbmQpIHtcbiAgcmV0dXJuIG5ldyBNaWxsZXJSYWJpbihyYW5kKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZGJlbG93ID0gZnVuY3Rpb24gX3JhbmRiZWxvdyhuKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgbWluX2J5dGVzID0gTWF0aC5jZWlsKGxlbiAvIDgpO1xuXG4gIC8vIEdlbmVyYWdlIHJhbmRvbSBieXRlcyB1bnRpbCBhIG51bWJlciBsZXNzIHRoYW4gbiBpcyBmb3VuZC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgMC4ubi0xIGhhdmUgYW4gZXF1YWwgcHJvYmFiaWxpdHkgb2YgYmVpbmcgc2VsZWN0ZWQuXG4gIGRvXG4gICAgdmFyIGEgPSBuZXcgYm4odGhpcy5yYW5kLmdlbmVyYXRlKG1pbl9ieXRlcykpO1xuICB3aGlsZSAoYS5jbXAobikgPj0gMCk7XG5cbiAgcmV0dXJuIGE7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuX3JhbmRyYW5nZSA9IGZ1bmN0aW9uIF9yYW5kcmFuZ2Uoc3RhcnQsIHN0b3ApIHtcbiAgLy8gR2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBzdGFydCBhbmQgbGVzcyB0aGFuIHN0b3AuXG4gIHZhciBzaXplID0gc3RvcC5zdWIoc3RhcnQpO1xuICByZXR1cm4gc3RhcnQuYWRkKHRoaXMuX3JhbmRiZWxvdyhzaXplKSk7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QobiwgaywgY2IpIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciByZWQgPSBibi5tb250KG4pO1xuICB2YXIgcm9uZSA9IG5ldyBibigxKS50b1JlZChyZWQpO1xuXG4gIGlmICghaylcbiAgICBrID0gTWF0aC5tYXgoMSwgKGxlbiAvIDQ4KSB8IDApO1xuXG4gIC8vIEZpbmQgZCBhbmQgcywgKG4gLSAxKSA9ICgyIF4gcykgKiBkO1xuICB2YXIgbjEgPSBuLnN1Ym4oMSk7XG4gIGZvciAodmFyIHMgPSAwOyAhbjEudGVzdG4ocyk7IHMrKykge31cbiAgdmFyIGQgPSBuLnNocm4ocyk7XG5cbiAgdmFyIHJuMSA9IG4xLnRvUmVkKHJlZCk7XG5cbiAgdmFyIHByaW1lID0gdHJ1ZTtcbiAgZm9yICg7IGsgPiAwOyBrLS0pIHtcbiAgICB2YXIgYSA9IHRoaXMuX3JhbmRyYW5nZShuZXcgYm4oMiksIG4xKTtcbiAgICBpZiAoY2IpXG4gICAgICBjYihhKTtcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5nZXREaXZpc29yID0gZnVuY3Rpb24gZ2V0RGl2aXNvcihuLCBrKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kcmFuZ2UobmV3IGJuKDIpLCBuMSk7XG5cbiAgICB2YXIgZyA9IG4uZ2NkKGEpO1xuICAgIGlmIChnLmNtcG4oMSkgIT09IDApXG4gICAgICByZXR1cm4gZztcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG4gICAgICByZXR1cm4geC5mcm9tUmVkKCkuc3VibigxKS5nY2Qobik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL2FzbjEuanNcbi8vIEZlZG9yLCB5b3UgYXJlIGFtYXppbmcuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJylcblxuZXhwb3J0cy5jZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4vY2VydGlmaWNhdGUnKVxuXG52YXIgUlNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdSU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MScpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnY29lZmZpY2llbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQcml2YXRlS2V5ID0gUlNBUHJpdmF0ZUtleVxuXG52YXIgUlNBUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVB1YmxpY0tleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQdWJsaWNLZXkgPSBSU0FQdWJsaWNLZXlcblxudmFyIFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlB1YmxpY0tleSA9IFB1YmxpY0tleVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbjEuZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnbm9uZScpLm51bGxfKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ2cnKS5pbnQoKVxuICAgICkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuZXhwb3J0cy5Qcml2YXRlS2V5ID0gUHJpdmF0ZUtleUluZm9cbnZhciBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICB0aGlzLmtleSgnZGVjcnlwdCcpLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2tkZScpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdrZGVwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgICAgICB0aGlzLmtleSgnc2FsdCcpLm9jdHN0cigpLFxuICAgICAgICAgICAgdGhpcy5rZXkoJ2l0ZXJzJykuaW50KClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRoaXMua2V5KCdjaXBoZXInKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2FsZ28nKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdpdicpLm9jdHN0cigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5cbmV4cG9ydHMuRW5jcnlwdGVkUHJpdmF0ZUtleSA9IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXG5cbnZhciBEU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0RTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgIHRoaXMua2V5KCdnJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1Yl9rZXknKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdl9rZXknKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5EU0FQcml2YXRlS2V5ID0gRFNBUHJpdmF0ZUtleVxuXG5leHBvcnRzLkRTQXBhcmFtID0gYXNuMS5kZWZpbmUoJ0RTQXBhcmFtJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmludCgpXG59KVxuXG52YXIgRUNQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKS5leHBsaWNpdCgwKS51c2UoRUNQYXJhbWV0ZXJzKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5Jykub3B0aW9uYWwoKS5leHBsaWNpdCgxKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5FQ1ByaXZhdGVLZXkgPSBFQ1ByaXZhdGVLZXlcblxudmFyIEVDUGFyYW1ldGVycyA9IGFzbjEuZGVmaW5lKCdFQ1BhcmFtZXRlcnMnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICBuYW1lZEN1cnZlOiB0aGlzLm9iamlkKClcbiAgfSlcbn0pXG5cbmV4cG9ydHMuc2lnbmF0dXJlID0gYXNuMS5kZWZpbmUoJ3NpZ25hdHVyZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3InKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncycpLmludCgpXG4gIClcbn0pXG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9SYW50YW5lbi9ub2RlLWR0bHMvYmxvYi8yNWE3ZGM4NjFiZGEzOGNmZWFjOTNhNzIzNTAwZWVhNGYwYWMyZTg2L0NlcnRpZmljYXRlLmpzXG4vLyB0aGFua3MgdG8gQFJhbnRhbmVuXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYXNuID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbnZhciBUaW1lID0gYXNuLmRlZmluZSgnVGltZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIHV0Y1RpbWU6IHRoaXMudXRjdGltZSgpLFxuICAgIGdlbmVyYWxUaW1lOiB0aGlzLmdlbnRpbWUoKVxuICB9KVxufSlcblxudmFyIEF0dHJpYnV0ZVR5cGVWYWx1ZSA9IGFzbi5kZWZpbmUoJ0F0dHJpYnV0ZVR5cGVWYWx1ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3R5cGUnKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCd2YWx1ZScpLmFueSgpXG4gIClcbn0pXG5cbnZhciBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuLmRlZmluZSgnQWxnb3JpdGhtSWRlbnRpZmllcicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdjdXJ2ZScpLm9iamlkKCkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgU3ViamVjdFB1YmxpY0tleUluZm8gPSBhc24uZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5cbnZhciBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lID0gYXNuLmRlZmluZSgnUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRvZihBdHRyaWJ1dGVUeXBlVmFsdWUpXG59KVxuXG52YXIgUkROU2VxdWVuY2UgPSBhc24uZGVmaW5lKCdSRE5TZXF1ZW5jZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXFvZihSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lKVxufSlcblxudmFyIE5hbWUgPSBhc24uZGVmaW5lKCdOYW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgcmRuU2VxdWVuY2U6IHRoaXMudXNlKFJETlNlcXVlbmNlKVxuICB9KVxufSlcblxudmFyIFZhbGlkaXR5ID0gYXNuLmRlZmluZSgnVmFsaWRpdHknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdub3RCZWZvcmUnKS51c2UoVGltZSksXG4gICAgdGhpcy5rZXkoJ25vdEFmdGVyJykudXNlKFRpbWUpXG4gIClcbn0pXG5cbnZhciBFeHRlbnNpb24gPSBhc24uZGVmaW5lKCdFeHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdleHRuSUQnKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdjcml0aWNhbCcpLmJvb2woKS5kZWYoZmFsc2UpLFxuICAgIHRoaXMua2V5KCdleHRuVmFsdWUnKS5vY3RzdHIoKVxuICApXG59KVxuXG52YXIgVEJTQ2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdUQlNDZXJ0aWZpY2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5leHBsaWNpdCgwKS5pbnQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdzZXJpYWxOdW1iZXInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdpc3N1ZXInKS51c2UoTmFtZSksXG4gICAgdGhpcy5rZXkoJ3ZhbGlkaXR5JykudXNlKFZhbGlkaXR5KSxcbiAgICB0aGlzLmtleSgnc3ViamVjdCcpLnVzZShOYW1lKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleUluZm8nKS51c2UoU3ViamVjdFB1YmxpY0tleUluZm8pLFxuICAgIHRoaXMua2V5KCdpc3N1ZXJVbmlxdWVJRCcpLmltcGxpY2l0KDEpLmJpdHN0cigpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RVbmlxdWVJRCcpLmltcGxpY2l0KDIpLmJpdHN0cigpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2V4dGVuc2lvbnMnKS5leHBsaWNpdCgzKS5zZXFvZihFeHRlbnNpb24pLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFg1MDlDZXJ0aWZpY2F0ZSA9IGFzbi5kZWZpbmUoJ1g1MDlDZXJ0aWZpY2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3Ric0NlcnRpZmljYXRlJykudXNlKFRCU0NlcnRpZmljYXRlKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlQWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmVWYWx1ZScpLmJpdHN0cigpXG4gIClcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gWDUwOUNlcnRpZmljYXRlXG4iLCIvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FwYXRpbC9wZW1zdHJpcFxudmFyIGZpbmRQcm9jID0gL1Byb2MtVHlwZTogNCxFTkNSWVBURURbXFxuXFxyXStERUstSW5mbzogQUVTLSgoPzoxMjgpfCg/OjE5Mil8KD86MjU2KSktQ0JDLChbMC05QS1IXSspW1xcblxccl0rKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylbXFxuXFxyXSsvbVxudmFyIHN0YXJ0UmVnZXggPSAvXi0tLS0tQkVHSU4gKCg/Oi4qPyBLRVkpfENFUlRJRklDQVRFKS0tLS0tL21cbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKCg/Oi4qPyBLRVkpfENFUlRJRklDQVRFKS0tLS0tKFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKyktLS0tLUVORCBcXDEtLS0tLSQvbVxudmFyIGV2cCA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChva2V5LCBwYXNzd29yZCkge1xuICB2YXIga2V5ID0gb2tleS50b1N0cmluZygpXG4gIHZhciBtYXRjaCA9IGtleS5tYXRjaChmaW5kUHJvYylcbiAgdmFyIGRlY3J5cHRlZFxuICBpZiAoIW1hdGNoKSB7XG4gICAgdmFyIG1hdGNoMiA9IGtleS5tYXRjaChmdWxsUmVnZXgpXG4gICAgZGVjcnlwdGVkID0gbmV3IEJ1ZmZlcihtYXRjaDJbMl0ucmVwbGFjZSgvW1xcclxcbl0vZywgJycpLCAnYmFzZTY0JylcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3VpdGUgPSAnYWVzJyArIG1hdGNoWzFdXG4gICAgdmFyIGl2ID0gQnVmZmVyLmZyb20obWF0Y2hbMl0sICdoZXgnKVxuICAgIHZhciBjaXBoZXJUZXh0ID0gQnVmZmVyLmZyb20obWF0Y2hbM10ucmVwbGFjZSgvW1xcclxcbl0vZywgJycpLCAnYmFzZTY0JylcbiAgICB2YXIgY2lwaGVyS2V5ID0gZXZwKHBhc3N3b3JkLCBpdi5zbGljZSgwLCA4KSwgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkua2V5XG4gICAgdmFyIG91dCA9IFtdXG4gICAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwgY2lwaGVyS2V5LCBpdilcbiAgICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICAgIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICAgIGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQob3V0KVxuICB9XG4gIHZhciB0YWcgPSBrZXkubWF0Y2goc3RhcnRSZWdleClbMV1cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBkYXRhOiBkZWNyeXB0ZWRcbiAgfVxufVxuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKVxudmFyIGFlc2lkID0gcmVxdWlyZSgnLi9hZXNpZC5qc29uJylcbnZhciBmaXhQcm9jID0gcmVxdWlyZSgnLi9maXhQcm9jJylcbnZhciBjaXBoZXJzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMnKVxudmFyIGNvbXBhdCA9IHJlcXVpcmUoJ3Bia2RmMicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpXG4gIH1cblxuICB2YXIgc3RyaXBwZWQgPSBmaXhQcm9jKGJ1ZmZlciwgcGFzc3dvcmQpXG5cbiAgdmFyIHR5cGUgPSBzdHJpcHBlZC50YWdcbiAgdmFyIGRhdGEgPSBzdHJpcHBlZC5kYXRhXG4gIHZhciBzdWJ0eXBlLCBuZGF0YVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdDRVJUSUZJQ0FURSc6XG4gICAgICBuZGF0YSA9IGFzbjEuY2VydGlmaWNhdGUuZGVjb2RlKGRhdGEsICdkZXInKS50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0UHVibGljS2V5SW5mb1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgJ1BVQkxJQyBLRVknOlxuICAgICAgaWYgKCFuZGF0YSkge1xuICAgICAgICBuZGF0YSA9IGFzbjEuUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH1cbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICBuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSA9IG5kYXRhLnN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2VjJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wdWJfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FbmNyeXB0ZWRQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIGRhdGEgPSBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkKVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgJ1BSSVZBVEUgS0VZJzpcbiAgICAgIG5kYXRhID0gYXNuMS5Qcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHN1YnR5cGUgPSBuZGF0YS5hbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKVxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcbiAgICAgICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuMi4xJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VydmU6IG5kYXRhLmFsZ29yaXRobS5jdXJ2ZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpLnByaXZhdGVLZXlcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnByaXZfa2V5ID0gYXNuMS5EU0FwYXJhbS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIHBhcmFtczogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdSU0EgUFVCTElDIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ1JTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4gYXNuMS5SU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdEU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgIHBhcmFtczogYXNuMS5EU0FQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIH1cbiAgICBjYXNlICdFQyBQUklWQVRFIEtFWSc6XG4gICAgICBkYXRhID0gYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VydmU6IGRhdGEucGFyYW1ldGVycy52YWx1ZSxcbiAgICAgICAgcHJpdmF0ZUtleTogZGF0YS5wcml2YXRlS2V5XG4gICAgICB9XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICB9XG59XG5wYXJzZUtleXMuc2lnbmF0dXJlID0gYXNuMS5zaWduYXR1cmVcbmZ1bmN0aW9uIGRlY3J5cHQgKGRhdGEsIHBhc3N3b3JkKSB7XG4gIHZhciBzYWx0ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLnNhbHRcbiAgdmFyIGl0ZXJzID0gcGFyc2VJbnQoZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5rZGUua2RlcGFyYW1zLml0ZXJzLnRvU3RyaW5nKCksIDEwKVxuICB2YXIgYWxnbyA9IGFlc2lkW2RhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLmFsZ28uam9pbignLicpXVxuICB2YXIgaXYgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5pdlxuICB2YXIgY2lwaGVyVGV4dCA9IGRhdGEuc3ViamVjdFByaXZhdGVLZXlcbiAgdmFyIGtleWxlbiA9IHBhcnNlSW50KGFsZ28uc3BsaXQoJy0nKVsxXSwgMTApIC8gOFxuICB2YXIga2V5ID0gY29tcGF0LnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJzLCBrZXlsZW4sICdzaGExJylcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KVxuICB2YXIgb3V0ID0gW11cbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbiIsImV4cG9ydHMucGJrZGYyID0gcmVxdWlyZSgnLi9saWIvYXN5bmMnKVxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcmVxdWlyZSgnLi9saWIvc3luYycpXG4iLCJ2YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxudmFyIGRlZmF1bHRFbmNvZGluZyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1lbmNvZGluZycpXG52YXIgc3luYyA9IHJlcXVpcmUoJy4vc3luYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFpFUk9fQlVGXG52YXIgc3VidGxlID0gZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLnN1YnRsZVxudmFyIHRvQnJvd3NlciA9IHtcbiAgJ3NoYSc6ICdTSEEtMScsXG4gICdzaGEtMSc6ICdTSEEtMScsXG4gICdzaGExJzogJ1NIQS0xJyxcbiAgJ3NoYTI1Nic6ICdTSEEtMjU2JyxcbiAgJ3NoYS0yNTYnOiAnU0hBLTI1NicsXG4gICdzaGEzODQnOiAnU0hBLTM4NCcsXG4gICdzaGEtMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTUxMic6ICdTSEEtNTEyJyxcbiAgJ3NoYTUxMic6ICdTSEEtNTEyJ1xufVxudmFyIGNoZWNrcyA9IFtdXG5mdW5jdGlvbiBjaGVja05hdGl2ZSAoYWxnbykge1xuICBpZiAoZ2xvYmFsLnByb2Nlc3MgJiYgIWdsb2JhbC5wcm9jZXNzLmJyb3dzZXIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmICghc3VidGxlIHx8ICFzdWJ0bGUuaW1wb3J0S2V5IHx8ICFzdWJ0bGUuZGVyaXZlQml0cykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gIH1cbiAgaWYgKGNoZWNrc1thbGdvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNoZWNrc1thbGdvXVxuICB9XG4gIFpFUk9fQlVGID0gWkVST19CVUYgfHwgQnVmZmVyLmFsbG9jKDgpXG4gIHZhciBwcm9tID0gYnJvd3NlclBia2RmMihaRVJPX0JVRiwgWkVST19CVUYsIDEwLCAxMjgsIGFsZ28pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICBjaGVja3NbYWxnb10gPSBwcm9tXG4gIHJldHVybiBwcm9tXG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJQYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBsZW5ndGgsIGFsZ28pIHtcbiAgcmV0dXJuIHN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsIHBhc3N3b3JkLCB7bmFtZTogJ1BCS0RGMid9LCBmYWxzZSwgWydkZXJpdmVCaXRzJ11cbiAgKS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3VidGxlLmRlcml2ZUJpdHMoe1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICBzYWx0OiBzYWx0LFxuICAgICAgaXRlcmF0aW9uczogaXRlcmF0aW9ucyxcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogYWxnb1xuICAgICAgfVxuICAgIH0sIGtleSwgbGVuZ3RoIDw8IDMpXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9taXNlIChwcm9taXNlLCBjYWxsYmFjaykge1xuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG91dCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgb3V0KVxuICAgIH0pXG4gIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH0pXG4gIH0pXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcbiAgdmFyIGFsZ28gPSB0b0Jyb3dzZXJbZGlnZXN0LnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFhbGdvIHx8IHR5cGVvZiBnbG9iYWwuUHJvbWlzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvdXRcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9XG5cbiAgY2hlY2tQYXJhbWV0ZXJzKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIHJlc29sdmVQcm9taXNlKGNoZWNrTmF0aXZlKGFsZ28pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBpZiAocmVzcCkgcmV0dXJuIGJyb3dzZXJQYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbylcblxuICAgIHJldHVybiBzeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgfSksIGNhbGxiYWNrKVxufVxuIiwidmFyIGRlZmF1bHRFbmNvZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZGVmYXVsdEVuY29kaW5nID0gJ3V0Zi04J1xufSBlbHNlIHtcbiAgdmFyIHBWZXJzaW9uTWFqb3IgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKVswXS5zbGljZSgxKSwgMTApXG5cbiAgZGVmYXVsdEVuY29kaW5nID0gcFZlcnNpb25NYWpvciA+PSA2ID8gJ3V0Zi04JyA6ICdiaW5hcnknXG59XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRFbmNvZGluZ1xuIiwidmFyIE1BWF9BTExPQyA9IE1hdGgucG93KDIsIDMwKSAtIDEgLy8gZGVmYXVsdCBpbiBpb2pzXG5cbmZ1bmN0aW9uIGNoZWNrQnVmZmVyIChidWYsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBidWYgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZSArICcgbXVzdCBiZSBhIGJ1ZmZlciBvciBzdHJpbmcnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pIHtcbiAgY2hlY2tCdWZmZXIocGFzc3dvcmQsICdQYXNzd29yZCcpXG4gIGNoZWNrQnVmZmVyKHNhbHQsICdTYWx0JylcblxuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXlsZW4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGtleWxlbiA8IDAgfHwga2V5bGVuID4gTUFYX0FMTE9DIHx8IGtleWxlbiAhPT0ga2V5bGVuKSB7IC8qIGVzbGludCBuby1zZWxmLWNvbXBhcmU6IDAgKi9cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cbn1cbiIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIGNoZWNrUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9uJylcbnZhciBkZWZhdWx0RW5jb2RpbmcgPSByZXF1aXJlKCcuL2RlZmF1bHQtZW5jb2RpbmcnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxudmFyIHNpemVzID0ge1xuICBtZDU6IDE2LFxuICBzaGExOiAyMCxcbiAgc2hhMjI0OiAyOCxcbiAgc2hhMjU2OiAzMixcbiAgc2hhMzg0OiA0OCxcbiAgc2hhNTEyOiA2NCxcbiAgcm1kMTYwOiAyMCxcbiAgcmlwZW1kMTYwOiAyMFxufVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSwgc2FsdExlbikge1xuICB2YXIgaGFzaCA9IGdldERpZ2VzdChhbGcpXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBoYXNoKGtleSlcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIHZhciBvcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNpemVzW2FsZ10pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB2YXIgaXBhZDEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplICsgc2FsdExlbiArIDQpXG4gIGlwYWQuY29weShpcGFkMSwgMCwgMCwgYmxvY2tzaXplKVxuICB0aGlzLmlwYWQxID0gaXBhZDFcbiAgdGhpcy5pcGFkMiA9IGlwYWRcbiAgdGhpcy5vcGFkID0gb3BhZFxuICB0aGlzLmFsZyA9IGFsZ1xuICB0aGlzLmJsb2Nrc2l6ZSA9IGJsb2Nrc2l6ZVxuICB0aGlzLmhhc2ggPSBoYXNoXG4gIHRoaXMuc2l6ZSA9IHNpemVzW2FsZ11cbn1cblxuSG1hYy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGRhdGEsIGlwYWQpIHtcbiAgZGF0YS5jb3B5KGlwYWQsIHRoaXMuYmxvY2tzaXplKVxuICB2YXIgaCA9IHRoaXMuaGFzaChpcGFkKVxuICBoLmNvcHkodGhpcy5vcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgcmV0dXJuIHRoaXMuaGFzaCh0aGlzLm9wYWQpXG59XG5cbmZ1bmN0aW9uIGdldERpZ2VzdCAoYWxnKSB7XG4gIGZ1bmN0aW9uIHNoYUZ1bmMgKGRhdGEpIHtcbiAgICByZXR1cm4gc2hhKGFsZykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cbiAgZnVuY3Rpb24gcm1kMTYwRnVuYyAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIH1cblxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSByZXR1cm4gcm1kMTYwRnVuY1xuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG1kNVxuICByZXR1cm4gc2hhRnVuY1xufVxuXG5mdW5jdGlvbiBwYmtkZjIgKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBjaGVja1BhcmFtZXRlcnMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbilcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIGRlZmF1bHRFbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCBkZWZhdWx0RW5jb2RpbmcpXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIHZhciBobWFjID0gbmV3IEhtYWMoZGlnZXN0LCBwYXNzd29yZCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIERLID0gQnVmZmVyLmFsbG9jVW5zYWZlKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzYWx0Lmxlbmd0aCArIDQpXG4gIHNhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciBkZXN0UG9zID0gMFxuICB2YXIgaExlbiA9IHNpemVzW2RpZ2VzdF1cbiAgdmFyIGwgPSBNYXRoLmNlaWwoa2V5bGVuIC8gaExlbilcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICBibG9jazEud3JpdGVVSW50MzJCRShpLCBzYWx0Lmxlbmd0aClcblxuICAgIHZhciBUID0gaG1hYy5ydW4oYmxvY2sxLCBobWFjLmlwYWQxKVxuICAgIHZhciBVID0gVFxuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcbiAgICAgIFUgPSBobWFjLnJ1bihVLCBobWFjLmlwYWQyKVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIFRba10gXj0gVVtrXVxuICAgIH1cblxuICAgIFQuY29weShESywgZGVzdFBvcylcbiAgICBkZXN0UG9zICs9IGhMZW5cbiAgfVxuXG4gIHJldHVybiBES1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBia2RmMlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiZXhwb3J0cy5wdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgnLi9wdWJsaWNFbmNyeXB0JylcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSByZXF1aXJlKCcuL3ByaXZhdGVEZWNyeXB0JylcblxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IGZ1bmN0aW9uIHByaXZhdGVFbmNyeXB0IChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNFbmNyeXB0KGtleSwgYnVmLCB0cnVlKVxufVxuXG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBmdW5jdGlvbiBwdWJsaWNEZWNyeXB0IChrZXksIGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5wcml2YXRlRGVjcnlwdChrZXksIGJ1ZiwgdHJ1ZSlcbn1cbiIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IEJ1ZmZlci5hbGxvYygwKVxuICB2YXIgaSA9IDBcbiAgdmFyIGNcbiAgd2hpbGUgKHQubGVuZ3RoIDwgbGVuKSB7XG4gICAgYyA9IGkyb3BzKGkrKylcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKVxuICB9XG4gIHJldHVybiB0LnNsaWNlKDAsIGxlbilcbn1cblxuZnVuY3Rpb24gaTJvcHMgKGMpIHtcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBvdXQud3JpdGVVSW50MzJCRShjLCAwKVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKVxudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJylcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByaXZhdGVEZWNyeXB0IChwcml2YXRlS2V5LCBlbmMsIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmdcbiAgaWYgKHByaXZhdGVLZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwcml2YXRlS2V5LnBhZGRpbmdcbiAgfSBlbHNlIGlmIChyZXZlcnNlKSB7XG4gICAgcGFkZGluZyA9IDFcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNFxuICB9XG5cbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwcml2YXRlS2V5KVxuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICBpZiAoZW5jLmxlbmd0aCA+IGsgfHwgbmV3IEJOKGVuYykuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgbXNnXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbXNnID0gd2l0aFB1YmxpYyhuZXcgQk4oZW5jKSwga2V5KVxuICB9IGVsc2Uge1xuICAgIG1zZyA9IGNydChlbmMsIGtleSlcbiAgfVxuICB2YXIgekJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhrIC0gbXNnLmxlbmd0aClcbiAgbXNnID0gQnVmZmVyLmNvbmNhdChbekJ1ZmZlciwgbXNnXSwgaylcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICByZXR1cm4gb2FlcChrZXksIG1zZylcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcmV0dXJuIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDMpIHtcbiAgICByZXR1cm4gbXNnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9hZXAgKGtleSwgbXNnKSB7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmFsbG9jKDApKS5kaWdlc3QoKVxuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aFxuICBpZiAobXNnWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgbWFza2VkU2VlZCA9IG1zZy5zbGljZSgxLCBoTGVuICsgMSlcbiAgdmFyIG1hc2tlZERiID0gbXNnLnNsaWNlKGhMZW4gKyAxKVxuICB2YXIgc2VlZCA9IHhvcihtYXNrZWRTZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKVxuICB2YXIgZGIgPSB4b3IobWFza2VkRGIsIG1nZihzZWVkLCBrIC0gaExlbiAtIDEpKVxuICBpZiAoY29tcGFyZShpSGFzaCwgZGIuc2xpY2UoMCwgaExlbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICB2YXIgaSA9IGhMZW5cbiAgd2hpbGUgKGRiW2ldID09PSAwKSB7XG4gICAgaSsrXG4gIH1cbiAgaWYgKGRiW2krK10gIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHJldHVybiBkYi5zbGljZShpKVxufVxuXG5mdW5jdGlvbiBwa2NzMSAoa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHAxID0gbXNnLnNsaWNlKDAsIDIpXG4gIHZhciBpID0gMlxuICB2YXIgc3RhdHVzID0gMFxuICB3aGlsZSAobXNnW2krK10gIT09IDApIHtcbiAgICBpZiAoaSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgICBzdGF0dXMrK1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgdmFyIHBzID0gbXNnLnNsaWNlKDIsIGkgLSAxKVxuXG4gIGlmICgocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMicgJiYgIXJldmVyc2UpIHx8IChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAxJyAmJiByZXZlcnNlKSkge1xuICAgIHN0YXR1cysrXG4gIH1cbiAgaWYgKHBzLmxlbmd0aCA8IDgpIHtcbiAgICBzdGF0dXMrK1xuICB9XG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHJldHVybiBtc2cuc2xpY2UoaSlcbn1cbmZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgYSA9IEJ1ZmZlci5mcm9tKGEpXG4gIGIgPSBCdWZmZXIuZnJvbShiKVxuICB2YXIgZGlmID0gMFxuICB2YXIgbGVuID0gYS5sZW5ndGhcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIGRpZisrXG4gICAgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICB9XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGRpZiArPSAoYVtpXSBeIGJbaV0pXG4gIH1cbiAgcmV0dXJuIGRpZlxufVxuIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgbWdmID0gcmVxdWlyZSgnLi9tZ2YnKVxudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJylcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWJsaWNFbmNyeXB0IChwdWJsaWNLZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZ1xuICBpZiAocHVibGljS2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHVibGljS2V5LnBhZGRpbmdcbiAgfSBlbHNlIGlmIChyZXZlcnNlKSB7XG4gICAgcGFkZGluZyA9IDFcbiAgfSBlbHNlIHtcbiAgICBwYWRkaW5nID0gNFxuICB9XG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHVibGljS2V5KVxuICB2YXIgcGFkZGVkTXNnXG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcGFkZGVkTXNnID0gb2FlcChrZXksIG1zZylcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcGFkZGVkTXNnID0gcGtjczEoa2V5LCBtc2csIHJldmVyc2UpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHBhZGRlZE1zZyA9IG5ldyBCTihtc2cpXG4gICAgaWYgKHBhZGRlZE1zZy5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSB0b28gbG9uZyBmb3IgbW9kdWx1cycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwYWRkaW5nJylcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHJldHVybiBjcnQocGFkZGVkTXNnLCBrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gb2FlcCAoa2V5LCBtc2cpIHtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoXG4gIHZhciBpSGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoQnVmZmVyLmFsbG9jKDApKS5kaWdlc3QoKVxuICB2YXIgaExlbiA9IGlIYXNoLmxlbmd0aFxuICB2YXIgaExlbjIgPSAyICogaExlblxuICBpZiAobUxlbiA+IGsgLSBoTGVuMiAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKVxuICB9XG4gIHZhciBwcyA9IEJ1ZmZlci5hbGxvYyhrIC0gbUxlbiAtIGhMZW4yIC0gMilcbiAgdmFyIGRibGVuID0gayAtIGhMZW4gLSAxXG4gIHZhciBzZWVkID0gcmFuZG9tQnl0ZXMoaExlbilcbiAgdmFyIG1hc2tlZERiID0geG9yKEJ1ZmZlci5jb25jYXQoW2lIYXNoLCBwcywgQnVmZmVyLmFsbG9jKDEsIDEpLCBtc2ddLCBkYmxlbiksIG1nZihzZWVkLCBkYmxlbikpXG4gIHZhciBtYXNrZWRTZWVkID0geG9yKHNlZWQsIG1nZihtYXNrZWREYiwgaExlbikpXG4gIHJldHVybiBuZXcgQk4oQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEpLCBtYXNrZWRTZWVkLCBtYXNrZWREYl0sIGspKVxufVxuZnVuY3Rpb24gcGtjczEgKGtleSwgbXNnLCByZXZlcnNlKSB7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aFxuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICBpZiAobUxlbiA+IGsgLSAxMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpXG4gIH1cbiAgdmFyIHBzXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcHMgPSBCdWZmZXIuYWxsb2MoayAtIG1MZW4gLSAzLCAweGZmKVxuICB9IGVsc2Uge1xuICAgIHBzID0gbm9uWmVybyhrIC0gbUxlbiAtIDMpXG4gIH1cbiAgcmV0dXJuIG5ldyBCTihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMCwgcmV2ZXJzZSA/IDEgOiAyXSksIHBzLCBCdWZmZXIuYWxsb2MoMSksIG1zZ10sIGspKVxufVxuZnVuY3Rpb24gbm9uWmVybyAobGVuKSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IDBcbiAgdmFyIGNhY2hlID0gcmFuZG9tQnl0ZXMobGVuICogMilcbiAgdmFyIGN1ciA9IDBcbiAgdmFyIG51bVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChjdXIgPT09IGNhY2hlLmxlbmd0aCkge1xuICAgICAgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4gKiAyKVxuICAgICAgY3VyID0gMFxuICAgIH1cbiAgICBudW0gPSBjYWNoZVtjdXIrK11cbiAgICBpZiAobnVtKSB7XG4gICAgICBvdXRbaSsrXSA9IG51bVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gd2l0aFB1YmxpYyAocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZGRlZE1zZ1xuICAgIC50b1JlZChCTi5tb250KGtleS5tb2R1bHVzKSlcbiAgICAucmVkUG93KG5ldyBCTihrZXkucHVibGljRXhwb25lbnQpKVxuICAgIC5mcm9tUmVkKClcbiAgICAudG9BcnJheSgpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWNcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhW2ldIF49IGJbaV1cbiAgfVxuICByZXR1cm4gYVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbnZhciBNQVhfQllURVMgPSA2NTUzNlxuXG4vLyBOb2RlIHN1cHBvcnRzIHJlcXVlc3RpbmcgdXAgdG8gdGhpcyBudW1iZXIgb2YgYnl0ZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcbnZhciBNQVhfVUlOVDMyID0gNDI5NDk2NzI5NVxuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHsgLy8gdGhpcyBpcyB0aGUgbWF4IGJ5dGVzIGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIGZvciAodmFyIGdlbmVyYXRlZCA9IDA7IGdlbmVyYXRlZCA8IHNpemU7IGdlbmVyYXRlZCArPSBNQVhfQllURVMpIHtcbiAgICAgICAgLy8gYnVmZmVyLnNsaWNlIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBlbmQgaXMgcGFzdCB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMuc2xpY2UoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbnVzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxudmFyIHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpXG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG52YXIgQnVmZmVyID0gc2FmZUJ1ZmZlci5CdWZmZXJcbnZhciBrQnVmZmVyTWF4TGVuZ3RoID0gc2FmZUJ1ZmZlci5rTWF4TGVuZ3RoXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cbnZhciBrTWF4VWludDMyID0gTWF0aC5wb3coMiwgMzIpIC0gMVxuZnVuY3Rpb24gYXNzZXJ0T2Zmc2V0IChvZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICE9PSBvZmZzZXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAob2Zmc2V0ID4ga01heFVpbnQzMiB8fCBvZmZzZXQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgYSB1aW50MzInKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+IGtCdWZmZXJNYXhMZW5ndGggfHwgb2Zmc2V0ID4gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBvdXQgb2YgcmFuZ2UnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSAhPT0gc2l6ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoc2l6ZSA+IGtNYXhVaW50MzIgfHwgc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSB1aW50MzInKVxuICB9XG5cbiAgaWYgKHNpemUgKyBvZmZzZXQgPiBsZW5ndGggfHwgc2l6ZSA+IGtCdWZmZXJNYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnVmZmVyIHRvbyBzbWFsbCcpXG4gIH1cbn1cbmlmICgoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHx8ICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgZXhwb3J0cy5yYW5kb21GaWxsID0gcmFuZG9tRmlsbFxuICBleHBvcnRzLnJhbmRvbUZpbGxTeW5jID0gcmFuZG9tRmlsbFN5bmNcbn0gZWxzZSB7XG4gIGV4cG9ydHMucmFuZG9tRmlsbCA9IG9sZEJyb3dzZXJcbiAgZXhwb3J0cy5yYW5kb21GaWxsU3luYyA9IG9sZEJyb3dzZXJcbn1cbmZ1bmN0aW9uIHJhbmRvbUZpbGwgKGJ1Ziwgb2Zmc2V0LCBzaXplLCBjYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpICYmICEoYnVmIGluc3RhbmNlb2YgZ2xvYmFsLlVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9mZnNldFxuICAgIG9mZnNldCA9IDBcbiAgICBzaXplID0gYnVmLmxlbmd0aFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBzaXplXG4gICAgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNiXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuICBhc3NlcnRPZmZzZXQob2Zmc2V0LCBidWYubGVuZ3RoKVxuICBhc3NlcnRTaXplKHNpemUsIG9mZnNldCwgYnVmLmxlbmd0aClcbiAgcmV0dXJuIGFjdHVhbEZpbGwoYnVmLCBvZmZzZXQsIHNpemUsIGNiKVxufVxuXG5mdW5jdGlvbiBhY3R1YWxGaWxsIChidWYsIG9mZnNldCwgc2l6ZSwgY2IpIHtcbiAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgIHZhciBvdXJCdWYgPSBidWYuYnVmZmVyXG4gICAgdmFyIHVpbnQgPSBuZXcgVWludDhBcnJheShvdXJCdWYsIG9mZnNldCwgc2l6ZSlcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHVpbnQpXG4gICAgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IobnVsbCwgYnVmKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgcmFuZG9tYnl0ZXMoc2l6ZSwgZnVuY3Rpb24gKGVyciwgYnl0ZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIGJ5dGVzLmNvcHkoYnVmLCBvZmZzZXQpXG4gICAgICBjYihudWxsLCBidWYpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYnl0ZXMgPSByYW5kb21ieXRlcyhzaXplKVxuICBieXRlcy5jb3B5KGJ1Ziwgb2Zmc2V0KVxuICByZXR1cm4gYnVmXG59XG5mdW5jdGlvbiByYW5kb21GaWxsU3luYyAoYnVmLCBvZmZzZXQsIHNpemUpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgJiYgIShidWYgaW5zdGFuY2VvZiBnbG9iYWwuVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZlwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgb3IgVWludDhBcnJheScpXG4gIH1cblxuICBhc3NlcnRPZmZzZXQob2Zmc2V0LCBidWYubGVuZ3RoKVxuXG4gIGlmIChzaXplID09PSB1bmRlZmluZWQpIHNpemUgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG5cbiAgYXNzZXJ0U2l6ZShzaXplLCBvZmZzZXQsIGJ1Zi5sZW5ndGgpXG5cbiAgcmV0dXJuIGFjdHVhbEZpbGwoYnVmLCBvZmZzZXQsIHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlXVxudmFyIGhyID0gWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcbn1cblxuaW5oZXJpdHMoUklQRU1EMTYwLCBIYXNoQmFzZSlcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd29yZHMgPSBBUlJBWTE2XG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikgd29yZHNbal0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShqICogNClcblxuICB2YXIgYWwgPSB0aGlzLl9hIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9iIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lIHwgMFxuXG4gIHZhciBhciA9IHRoaXMuX2EgfCAwXG4gIHZhciBiciA9IHRoaXMuX2IgfCAwXG4gIHZhciBjciA9IHRoaXMuX2MgfCAwXG4gIHZhciBkciA9IHRoaXMuX2QgfCAwXG4gIHZhciBlciA9IHRoaXMuX2UgfCAwXG5cbiAgLy8gY29tcHV0YXRpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdmFyIHRsXG4gICAgdmFyIHRyXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdGwgPSBmbjEoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzBdLCBzbFtpXSlcbiAgICAgIHRyID0gZm41KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclswXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHRsID0gZm4yKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsxXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuNChhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMV0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0bCA9IGZuMyhhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMl0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjMoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzJdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdGwgPSBmbjQoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzNdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4yKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclszXSwgc3JbaV0pXG4gICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcbiAgICAgIHRsID0gZm41KGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFs0XSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMShhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbNF0sIHNyW2ldKVxuICAgIH1cblxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0bFxuXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRyXG4gIH1cblxuICAvLyB1cGRhdGUgc3RhdGVcbiAgdmFyIHQgPSAodGhpcy5fYiArIGNsICsgZHIpIHwgMFxuICB0aGlzLl9iID0gKHRoaXMuX2MgKyBkbCArIGVyKSB8IDBcbiAgdGhpcy5fYyA9ICh0aGlzLl9kICsgZWwgKyBhcikgfCAwXG4gIHRoaXMuX2QgPSAodGhpcy5fZSArIGFsICsgYnIpIHwgMFxuICB0aGlzLl9lID0gKHRoaXMuX2EgKyBibCArIGNyKSB8IDBcbiAgdGhpcy5fYSA9IHRcbn1cblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoMjApIDogbmV3IEJ1ZmZlcigyMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9hLCAwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2IsIDQpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYywgOClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9kLCAxMilcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9lLCAxNilcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gZm4xIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4yIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjMgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiIHwgKH5jKSkgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNCAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm41IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gKGMgfCAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJJUEVNRDE2MFxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBibG9ja1NpemUgPSB0aGlzLl9ibG9ja1NpemVcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGJsb2NrU2l6ZSAtIGFzc2lnbmVkKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgYmxvY2tbYXNzaWduZWQgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV1cbiAgICB9XG5cbiAgICBhY2N1bSArPSByZW1haW5kZXJcbiAgICBvZmZzZXQgKz0gcmVtYWluZGVyXG5cbiAgICBpZiAoKGFjY3VtICUgYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgcmVtID0gdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXG5cbiAgdGhpcy5fYmxvY2tbcmVtXSA9IDB4ODBcblxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XG4gIC8vIG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGxlbmd0aCArIDEgKyAocmVtICsgMSkpID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHJlbSArIDEpXG5cbiAgaWYgKHJlbSA+PSB0aGlzLl9maW5hbFNpemUpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gdWludDMyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgLy8gdWludDY0XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd0JpdHMgPSAoYml0cyAmIDB4ZmZmZmZmZmYpID4+PiAwXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXG5cbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGhpZ2hCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA4KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwidmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNIQSAoYWxnb3JpdGhtKSB7XG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIEFsZ29yaXRobSA9IGV4cG9ydHNbYWxnb3JpdGhtXVxuICBpZiAoIUFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCAod2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMpJylcblxuICByZXR1cm4gbmV3IEFsZ29yaXRobSgpXG59XG5cbmV4cG9ydHMuc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJylcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEyMjQnKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhMzg0JylcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgZGVyaXZlZCBmcm9tIHNoYTEuanMgb2YgdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XG4gKiBvcGVyYXRpb24gd2FzIGFkZGVkLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYSwgSGFzaClcblxuU2hhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYTEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTEsIEhhc2gpXG5cblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDEgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAxKSB8IChudW0gPj4+IDMxKVxufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gcm90bDEoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSlcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYiA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZSA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcbiAgdGhpcy5faCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhMzg0ICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTM4NCwgU0hBNTEyKVxuXG5TaGEzODQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHhjYmJiOWQ1ZFxuICB0aGlzLl9iaCA9IDB4NjI5YTI5MmFcbiAgdGhpcy5fY2ggPSAweDkxNTkwMTVhXG4gIHRoaXMuX2RoID0gMHgxNTJmZWNkOFxuICB0aGlzLl9laCA9IDB4NjczMzI2NjdcbiAgdGhpcy5fZmggPSAweDhlYjQ0YTg3XG4gIHRoaXMuX2doID0gMHhkYjBjMmUwZFxuICB0aGlzLl9oaCA9IDB4NDdiNTQ4MWRcblxuICB0aGlzLl9hbCA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kbCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nbCA9IDB4NjRmOThmYTdcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNDgpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMzg0XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iaCA9IDB4YmI2N2FlODVcbiAgdGhpcy5fY2ggPSAweDNjNmVmMzcyXG4gIHRoaXMuX2RoID0gMHhhNTRmZjUzYVxuICB0aGlzLl9laCA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZmggPSAweDliMDU2ODhjXG4gIHRoaXMuX2doID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oaCA9IDB4NWJlMGNkMTlcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDhcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiXG4gIHRoaXMuX2NsID0gMHhmZTk0ZjgyYlxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjFcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxXG4gIHRoaXMuX2ZsID0gMHgyYjNlNmMxZlxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmJcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDI4IHwgeGwgPDwgNCkgXiAoeGwgPj4+IDIgfCB4IDw8IDMwKSBeICh4bCA+Pj4gNyB8IHggPDwgMjUpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxNCB8IHhsIDw8IDE4KSBeICh4ID4+PiAxOCB8IHhsIDw8IDE0KSBeICh4bCA+Pj4gOSB8IHggPDwgMjMpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNylcbn1cblxuZnVuY3Rpb24gR2FtbWEwbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNyB8IHhsIDw8IDI1KVxufVxuXG5mdW5jdGlvbiBHYW1tYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2KVxufVxuXG5mdW5jdGlvbiBHYW1tYTFsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNiB8IHhsIDw8IDI2KVxufVxuXG5mdW5jdGlvbiBnZXRDYXJyeSAoYSwgYikge1xuICByZXR1cm4gKGEgPj4+IDApIDwgKGIgPj4+IDApID8gMSA6IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGFoID0gdGhpcy5fYWggfCAwXG4gIHZhciBiaCA9IHRoaXMuX2JoIHwgMFxuICB2YXIgY2ggPSB0aGlzLl9jaCB8IDBcbiAgdmFyIGRoID0gdGhpcy5fZGggfCAwXG4gIHZhciBlaCA9IHRoaXMuX2VoIHwgMFxuICB2YXIgZmggPSB0aGlzLl9maCB8IDBcbiAgdmFyIGdoID0gdGhpcy5fZ2ggfCAwXG4gIHZhciBoaCA9IHRoaXMuX2hoIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgICBXW2kgKyAxXSA9IE0ucmVhZEludDMyQkUoaSAqIDQgKyA0KVxuICB9XG4gIGZvciAoOyBpIDwgMTYwOyBpICs9IDIpIHtcbiAgICB2YXIgeGggPSBXW2kgLSAxNSAqIDJdXG4gICAgdmFyIHhsID0gV1tpIC0gMTUgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWEwID0gR2FtbWEwKHhoLCB4bClcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHhoKVxuXG4gICAgeGggPSBXW2kgLSAyICogMl1cbiAgICB4bCA9IFdbaSAtIDIgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWExID0gR2FtbWExKHhoLCB4bClcbiAgICB2YXIgZ2FtbWExbCA9IEdhbW1hMWwoeGwsIHhoKVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpN2ggPSBXW2kgLSA3ICogMl1cbiAgICB2YXIgV2k3bCA9IFdbaSAtIDcgKiAyICsgMV1cblxuICAgIHZhciBXaTE2aCA9IFdbaSAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2kgLSAxNiAqIDIgKyAxXVxuXG4gICAgdmFyIFdpbCA9IChnYW1tYTBsICsgV2k3bCkgfCAwXG4gICAgdmFyIFdpaCA9IChnYW1tYTAgKyBXaTdoICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTBsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIGdhbW1hMWwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBnYW1tYTEgKyBnZXRDYXJyeShXaWwsIGdhbW1hMWwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgV2kxNmwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBXaTE2aCArIGdldENhcnJ5KFdpbCwgV2kxNmwpKSB8IDBcblxuICAgIFdbaV0gPSBXaWhcbiAgICBXW2kgKyAxXSA9IFdpbFxuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjA7IGogKz0gMikge1xuICAgIFdpaCA9IFdbal1cbiAgICBXaWwgPSBXW2ogKyAxXVxuXG4gICAgdmFyIG1hamggPSBtYWooYWgsIGJoLCBjaClcbiAgICB2YXIgbWFqbCA9IG1haihhbCwgYmwsIGNsKVxuXG4gICAgdmFyIHNpZ21hMGggPSBzaWdtYTAoYWgsIGFsKVxuICAgIHZhciBzaWdtYTBsID0gc2lnbWEwKGFsLCBhaClcbiAgICB2YXIgc2lnbWExaCA9IHNpZ21hMShlaCwgZWwpXG4gICAgdmFyIHNpZ21hMWwgPSBzaWdtYTEoZWwsIGVoKVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2pdICsgV1tqXVxuICAgIHZhciBLaWggPSBLW2pdXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICB2YXIgY2hoID0gQ2goZWgsIGZoLCBnaClcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgIHZhciB0MWwgPSAoaGwgKyBzaWdtYTFsKSB8IDBcbiAgICB2YXIgdDFoID0gKGhoICsgc2lnbWExaCArIGdldENhcnJ5KHQxbCwgaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgY2hsKSB8IDBcbiAgICB0MWggPSAodDFoICsgY2hoICsgZ2V0Q2FycnkodDFsLCBjaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgS2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgS2loICsgZ2V0Q2FycnkodDFsLCBLaWwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgV2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgV2loICsgZ2V0Q2FycnkodDFsLCBXaWwpKSB8IDBcblxuICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgdmFyIHQybCA9IChzaWdtYTBsICsgbWFqbCkgfCAwXG4gICAgdmFyIHQyaCA9IChzaWdtYTBoICsgbWFqaCArIGdldENhcnJ5KHQybCwgc2lnbWEwbCkpIHwgMFxuXG4gICAgaGggPSBnaFxuICAgIGhsID0gZ2xcbiAgICBnaCA9IGZoXG4gICAgZ2wgPSBmbFxuICAgIGZoID0gZWhcbiAgICBmbCA9IGVsXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgIGVoID0gKGRoICsgdDFoICsgZ2V0Q2FycnkoZWwsIGRsKSkgfCAwXG4gICAgZGggPSBjaFxuICAgIGRsID0gY2xcbiAgICBjaCA9IGJoXG4gICAgY2wgPSBibFxuICAgIGJoID0gYWhcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhaCA9ICh0MWggKyB0MmggKyBnZXRDYXJyeShhbCwgdDFsKSkgfCAwXG4gIH1cblxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgdGhpcy5fYWggPSAodGhpcy5fYWggKyBhaCArIGdldENhcnJ5KHRoaXMuX2FsLCBhbCkpIHwgMFxuICB0aGlzLl9iaCA9ICh0aGlzLl9iaCArIGJoICsgZ2V0Q2FycnkodGhpcy5fYmwsIGJsKSkgfCAwXG4gIHRoaXMuX2NoID0gKHRoaXMuX2NoICsgY2ggKyBnZXRDYXJyeSh0aGlzLl9jbCwgY2wpKSB8IDBcbiAgdGhpcy5fZGggPSAodGhpcy5fZGggKyBkaCArIGdldENhcnJ5KHRoaXMuX2RsLCBkbCkpIHwgMFxuICB0aGlzLl9laCA9ICh0aGlzLl9laCArIGVoICsgZ2V0Q2FycnkodGhpcy5fZWwsIGVsKSkgfCAwXG4gIHRoaXMuX2ZoID0gKHRoaXMuX2ZoICsgZmggKyBnZXRDYXJyeSh0aGlzLl9mbCwgZmwpKSB8IDBcbiAgdGhpcy5fZ2ggPSAodGhpcy5fZ2ggKyBnaCArIGdldENhcnJ5KHRoaXMuX2dsLCBnbCkpIHwgMFxuICB0aGlzLl9oaCA9ICh0aGlzLl9oaCArIGhoICsgZ2V0Q2FycnkodGhpcy5faGwsIGhsKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oaCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gLTE7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwKTtcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAxKTtcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwICsgMik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKVxuLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJy5yZXBlYXQodGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG5cbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi5ldmFsKCkgbWFnaWNhbGx5IGFwcGVhcnMgd2hlbiB0aGlzIGlzIGNhbGxlZCBpbiBJRTpcbiAgICAgICAgd0V4ZWNTY3JpcHQuY2FsbCh3aW4sICdudWxsJyk7XG4gICAgICAgIHdFdmFsID0gd2luLmV2YWw7XG4gICAgfVxuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgfSk7XG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChjb250ZXh0W2tleV0pIHtcbiAgICAgICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHdpbktleXMgPSBPYmplY3Rfa2V5cyh3aW4pO1xuXG4gICAgdmFyIHJlcyA9IHdFdmFsLmNhbGwod2luLCB0aGlzLmNvZGUpO1xuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMod2luKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGNpcmN1bGFyIG9iamVjdHMgbGlrZSBgdG9wYCBhbmQgYHdpbmRvd2AgYnkgb25seVxuICAgICAgICAvLyB1cGRhdGluZyBleGlzdGluZyBjb250ZXh0IHByb3BlcnRpZXMgb3IgbmV3IHByb3BlcnRpZXMgaW4gdGhlIGB3aW5gXG4gICAgICAgIC8vIHRoYXQgd2FzIG9ubHkgaW50cm9kdWNlZCBhZnRlciB0aGUgZXZhbC5cbiAgICAgICAgaWYgKGtleSBpbiBjb250ZXh0IHx8IGluZGV4T2Yod2luS2V5cywga2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHdpbltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wKGNvbnRleHQsIGtleSwgd2luW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHJldHVybiByZXM7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluVGhpc0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2YWwodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiLyoqXG4gKiBTdXBwb3J0IG1vZHVsZXMgdXNlZCBieSBTa2V0Y2hSTk5cbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIERlYWxzIHdpdGggZGVjb21wcmVzc2luZyBiNjQgbW9kZWxzIHRvIHVpbnQ4IGFycmF5cy5cbiAqXG4gKiBAcGFyYW0gYjY0ZW5jb2RlZCBTdHJpbmcgb2YgYjY0IGVuY29kZWQgZGF0YS5cbiAqIEByZXR1cm5zIHVpbnQ4IHZlcnNpb24gb2YgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVWludDhhcnJheShiNjRlbmNvZGVkOiBzdHJpbmcpIHtcbiAgY29uc3QgdTg6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShhdG9iKGI2NGVuY29kZWQpXG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLm1hcCgoYzogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgfSkpO1xuICByZXR1cm4gdTg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYjY0IGRhdGEgaW50byBpbnQxNiBhcnJheSB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBiNjRlbmNvZGVkIFN0cmluZyBvZiBiNjQgZW5jb2RlZCBkYXRhLlxuICogQHJldHVybnMgaW50MTYgdmVyc2lvbiBvZiBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShiNjRlbmNvZGVkOiBzdHJpbmcpIHtcbiAgY29uc3QgdTogVWludDhBcnJheSA9IHN0cmluZ1RvVWludDhhcnJheShiNjRlbmNvZGVkKTtcbiAgY29uc3QgcmVzdWx0OiBJbnQxNkFycmF5ID0gbmV3IEludDE2QXJyYXkodS5idWZmZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBGdW5jdGlvbnMgZm9yIHNhbXBsaW5nIG5vcm1hbCBvciBiaS1ub3JtYWxzXG5cbi8vIFJhbmRvbSBudW1iZXJzIHV0aWwgKGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thcnBhdGh5L3JlY3VycmVudGpzKVxubGV0IHJldHVyblYgPSBmYWxzZTtcbmxldCB2VmFsID0gMC4wO1xuZXhwb3J0IGZ1bmN0aW9uIGdhdXNzUmFuZG9tKCk6IG51bWJlciB7XG4gIGlmIChyZXR1cm5WKSB7XG4gICAgcmV0dXJuViA9IGZhbHNlO1xuICAgIHJldHVybiB2VmFsO1xuICB9XG4gIGNvbnN0IHUgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gIGNvbnN0IHYgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gIGNvbnN0IHIgPSB1ICogdSArIHYgKiB2O1xuICBpZiAociA9PT0gMCB8fCByID4gMSkge1xuICAgIHJldHVybiBnYXVzc1JhbmRvbSgpO1xuICB9XG4gIGNvbnN0IGMgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICB2VmFsID0gdiAqIGM7IC8vIGNhY2hlIHRoaXNcbiAgcmV0dXJuViA9IHRydWU7XG4gIHJldHVybiB1ICogYztcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kZihhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogKGIgLSBhKSArIGE7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZGkoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGIgLSBhKSArIGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRuKG11OiBudW1iZXIsIHN0ZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIG11ICsgZ2F1c3NSYW5kb20oKSAqIHN0ZDtcbn1cbi8vIEZyb20gaHR0cDovL3d3dy5tYXRoLmdyaW4uZWR1L35tb29yZXQvY291cnNlcy9tYXRoMzM2L2JpdmFyaWF0ZS1ub3JtYWwuaHRtbFxuZXhwb3J0IGZ1bmN0aW9uIGJpcmFuZG4oXG4gIG11MTogbnVtYmVyLFxuICBtdTI6IG51bWJlcixcbiAgc3RkMTogbnVtYmVyLFxuICBzdGQyOiBudW1iZXIsXG4gIHJobzogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCB6MSA9IHJhbmRuKDAsIDEpO1xuICBjb25zdCB6MiA9IHJhbmRuKDAsIDEpO1xuICBjb25zdCB4ID0gTWF0aC5zcXJ0KDEgLSByaG8gKiByaG8pICogc3RkMSAqIHoxICsgcmhvICogc3RkMSAqIHoyICsgbXUxO1xuICBjb25zdCB5ID0gc3RkMiAqIHoyICsgbXUyO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIFNhbXBsZSBmcm9tIGEgY2F0ZWdvcmlhbCBkaXN0cmlidXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbXBsZVNvZnRtYXgoelNhbXBsZTogbnVtYmVyW10gfCBGbG9hdDMyQXJyYXkpOiBudW1iZXIge1xuICBjb25zdCB4ID0gcmFuZGYoMCwgMSk7XG4gIGNvbnN0IE4gPSB6U2FtcGxlLmxlbmd0aDtcbiAgbGV0IGFjY3VtdWxhdGUgPSAwO1xuICBsZXQgaTogbnVtYmVyO1xuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgYWNjdW11bGF0ZSArPSB6U2FtcGxlW2ldO1xuICAgIGlmIChhY2N1bXVsYXRlID49IHgpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICBjb25zb2xlLmxvZygnZXJyb3Igc2FtcGxpbmcgcGkgaW5kZXgnKTtcbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBMZWdhY3kgUkRQIGFsZ29yaXRobSBpbXBsZW1lbnRhdGlvbiwgcG9ydGVkIG92ZXIgdG8gVHlwZVNjcmlwdC5cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5TGluZShWOiBudW1iZXJbXVtdLCB0b2xlcmFuY2U9Mi4wKTogbnVtYmVyW11bXSB7XG4gIC8qXG4gIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWRhbW1pbGxlci84MjYxNDhcbiAgViAuLi4gW1t4MSx5MV0sW3gyLHkyXSwuLi5dIHBvbHlsaW5lXG4gIHRvbCAgLi4uIGFwcHJveGltYXRpb24gdG9sZXJhbmNlXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgQ29weXJpZ2h0IDIwMDIsIHNvZnRTdXJmZXIgKHd3dy5zb2Z0c3VyZmVyLmNvbSlcbiAgVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgdXNlZCBhbmQgbW9kaWZpZWQgZm9yIGFueSBwdXJwb3NlXG4gIHByb3ZpZGluZyB0aGF0IHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBpbmNsdWRlZCB3aXRoIGl0LlxuICBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuICBsaWFibGUgZm9yIGFueSByZWFsIG9yIGltYWdpbmVkIGRhbWFnZSByZXN1bHRpbmcgZnJvbSBpdHMgdXNlLlxuICBVc2VycyBvZiB0aGlzIGNvZGUgbXVzdCB2ZXJpZnkgY29ycmVjdG5lc3MgZm9yIHRoZWlyIGFwcGxpY2F0aW9uLlxuICBodHRwOi8vc29mdHN1cmZlci5jb20vQXJjaGl2ZS9hbGdvcml0aG1fMDIwNS9hbGdvcml0aG1fMDIwNS5odG1cbiAgKi9cblxuICBjb25zdCB0b2wgPSB0b2xlcmFuY2U7XG5cbiAgZnVuY3Rpb24gZGlmZih1OiBudW1iZXJbXSwgdjogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFt1WzBdIC0gdlswXSwgdVsxXSAtIHZbMV1dO1xuICB9XG4gIGZ1bmN0aW9uIGRvdCh1OiBudW1iZXJbXSwgdjogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiB1WzBdICogdlswXSArIHVbMV0gKiB2WzFdO1xuICB9XG4gIGZ1bmN0aW9uIG5vcm0yKHY6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbiAgfVxuICBmdW5jdGlvbiBkMih1OiBudW1iZXJbXSwgdjogbnVtYmVyW10pOiBudW1iZXIge3JldHVybiBub3JtMihkaWZmKHUsIHYpKTt9XG5cbiAgZnVuY3Rpb24gc2ltcGxpZnlEUCh0b2w6IG51bWJlciwgdjogbnVtYmVyW11bXSxcbiAgICBqOiBudW1iZXIsIGs6IG51bWJlciwgbWs6IG51bWJlcltdKSB7XG4gICAgLypcbiAgICBUaGlzIGlzIHRoZSBEb3VnbGFzLVBldWNrZXIgcmVjdXJzaXZlIHNpbXBsaWZpY2F0aW9uIHJvdXRpbmVcbiAgICBJdCBqdXN0IG1hcmtzIHZlcnRpY2VzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHNpbXBsaWZpZWQgcG9seWxpbmVcbiAgICBmb3IgYXBwcm94aW1hdGluZyB0aGUgcG9seWxpbmUgc3ViY2hhaW4gdltqXSB0byB2W2tdLlxuICAgIG1rW10gLi4uIGFycmF5IG9mIG1hcmtlcnMgbWF0Y2hpbmcgdmVydGV4IGFycmF5IHZbXVxuICAgICovXG4gICAgaWYgKGsgPD0gaiArIDEpIHsgLy8gdGhlcmUgaXMgbm90aGluZyB0byBzaW1wbGlmeVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgYWRlcXVhdGUgYXBwcm94aW1hdGlvbiBieSBzZWdtZW50IFMgZnJvbSB2W2pdIHRvIHZba11cbiAgICBsZXQgbWF4aSA9IGo7IC8vIGluZGV4IG9mIHZlcnRleCBmYXJ0aGVzdCBmcm9tIFNcbiAgICBsZXQgbWF4ZDIgPSAwOyAvLyBkaXN0YW5jZSBzcXVhcmVkIG9mIGZhcnRoZXN0IHZlcnRleFxuICAgIGNvbnN0IHRvbDIgPSB0b2wgKiB0b2w7IC8vIHRvbGVyYW5jZSBzcXVhcmVkXG4gICAgY29uc3QgUzogbnVtYmVyW11bXSA9IFt2W2pdLCB2W2tdXTsgLy8gc2VnbWVudCBmcm9tIHZbal0gdG8gdltrXVxuICAgIGNvbnN0IHU6IG51bWJlcltdID0gZGlmZihTWzFdLCBTWzBdKTsgLy8gc2VnbWVudCBkaXJlY3Rpb24gdmVjdG9yXG4gICAgY29uc3QgY3U6IG51bWJlciA9IG5vcm0yKHUpOyAvLyBzZWdtZW50IGxlbmd0aCBzcXVhcmVkXG4gICAgLypcbiAgICB0ZXN0IGVhY2ggdmVydGV4IHZbaV0gZm9yIG1heCBkaXN0YW5jZSBmcm9tIFNcbiAgICBjb21wdXRlIHVzaW5nIHRoZSBGZWIgMjAwMSBBbGdvcml0aG0ncyBkaXN0X1BvaW50X3RvX1NlZ21lbnQoKVxuICAgIE5vdGU6IHRoaXMgd29ya3MgaW4gYW55IGRpbWVuc2lvbiAoMkQsIDNELCAuLi4pXG4gICAgKi9cbiAgICBsZXQgdzogbnVtYmVyW107IC8vIHZlY3RvclxuICAgIGxldCBwYjogbnVtYmVyW107IC8vIHBvaW50LCBiYXNlIG9mIHBlcnBlbmRpY3VsYXIgZnJvbSB2W2ldIHRvIFNcbiAgICBsZXQgYjogbnVtYmVyLCBjdzogbnVtYmVyLCBkdjI6IG51bWJlcjsgLy8gZHYyID0gZGlzdGFuY2UgdltpXSB0byBTIHNxdWFyZWRcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBqICsgMTsgaSA8IGs7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSBkaXN0YW5jZSBzcXVhcmVkXG4gICAgICB3ID0gZGlmZih2W2ldLCBTWzBdKTtcbiAgICAgIGN3ID0gZG90KHcsIHUpO1xuICAgICAgaWYgKGN3IDw9IDApIHtcbiAgICAgICAgZHYyID0gZDIodltpXSwgU1swXSk7XG4gICAgICB9IGVsc2UgaWYgKGN1IDw9IGN3KSB7XG4gICAgICAgIGR2MiA9IGQyKHZbaV0sIFNbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IGN3IC8gY3U7XG4gICAgICAgIHBiID0gW1NbMF1bMF0gKyBiICogdVswXSwgU1swXVsxXSArIGIgKiB1WzFdXTtcbiAgICAgICAgZHYyID0gZDIodltpXSwgcGIpO1xuICAgICAgfVxuICAgICAgLy8gdGVzdCB3aXRoIGN1cnJlbnQgbWF4IGRpc3RhbmNlIHNxdWFyZWRcbiAgICAgIGlmIChkdjIgPD0gbWF4ZDIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyB2W2ldIGlzIGEgbmV3IG1heCB2ZXJ0ZXhcbiAgICAgIG1heGkgPSBpO1xuICAgICAgbWF4ZDIgPSBkdjI7XG4gICAgfVxuICAgIGlmIChtYXhkMiA+IHRvbDIpIHsgLy8gZXJyb3IgaXMgd29yc2UgdGhhbiB0aGUgdG9sZXJhbmNlXG4gICAgICAvLyBzcGxpdCB0aGUgcG9seWxpbmUgYXQgdGhlIGZhcnRoZXN0IHZlcnRleCBmcm9tIFNcbiAgICAgIG1rW21heGldID0gMTsgLy8gbWFyayB2W21heGldIGZvciB0aGUgc2ltcGxpZmllZCBwb2x5bGluZVxuICAgICAgLy8gcmVjdXJzaXZlbHkgc2ltcGxpZnkgdGhlIHR3byBzdWJwb2x5bGluZXMgYXQgdlttYXhpXVxuICAgICAgc2ltcGxpZnlEUCh0b2wsIHYsIGosIG1heGksIG1rKTsgLy8gcG9seWxpbmUgdltqXSB0byB2W21heGldXG4gICAgICBzaW1wbGlmeURQKHRvbCwgdiwgbWF4aSwgaywgbWspOyAvLyBwb2x5bGluZSB2W21heGldIHRvIHZba11cbiAgICB9XG4gICAgLy8gZWxzZSB0aGUgYXBwcm94aW1hdGlvbiBpcyBPSywgc28gaWdub3JlIGludGVybWVkaWF0ZSB2ZXJ0aWNlc1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG4gPSBWLmxlbmd0aDtcbiAgY29uc3Qgc1Y6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IGk6IG51bWJlciwgazogbnVtYmVyLCBtOiBudW1iZXIsIHB2OiBudW1iZXI7IC8vIG1pc2MgY291bnRlcnNcbiAgY29uc3QgdG9sMjogbnVtYmVyID0gdG9sICogdG9sOyAvLyB0b2xlcmFuY2Ugc3F1YXJlZFxuICBjb25zdCB2dDogbnVtYmVyW11bXSA9IFtdOyAvLyB2ZXJ0ZXggYnVmZmVyLCBwb2ludHNcbiAgY29uc3QgbWs6IG51bWJlcltdID0gW107IC8vIG1hcmtlciBidWZmZXIsIGludHNcblxuICAvLyBTVEFHRSAxLiBWZXJ0ZXggUmVkdWN0aW9uIHdpdGhpbiB0b2xlcmFuY2Ugb2YgcHJpb3IgdmVydGV4IGNsdXN0ZXJcbiAgdnRbMF0gPSBWWzBdOyAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nXG4gIGZvciAoaSA9IGsgPSAxLCBwdiA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoZDIoVltpXSwgVltwdl0pIDwgdG9sMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZ0W2srK10gPSBWW2ldO1xuICAgIHB2ID0gaTtcbiAgfVxuICBpZiAocHYgPCBuIC0gMSkge1xuICAgIHZ0W2srK10gPSBWW24gLSAxXTsgLy8gZmluaXNoIGF0IHRoZSBlbmRcbiAgfVxuXG4gIC8vIFNUQUdFIDIuICBEb3VnbGFzLVBldWNrZXIgcG9seWxpbmUgc2ltcGxpZmljYXRpb25cbiAgbWtbMF0gPSBta1trIC0gMV0gPSAxOyAvLyBtYXJrIHRoZSBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlc1xuICBzaW1wbGlmeURQKHRvbCwgdnQsIDAsIGsgLSAxLCBtayk7XG5cbiAgLy8gY29weSBtYXJrZWQgdmVydGljZXMgdG8gdGhlIG91dHB1dCBzaW1wbGlmaWVkIHBvbHlsaW5lXG4gIGZvciAoaSA9IG0gPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgaWYgKG1rW2ldKSB7XG4gICAgICBzVlttKytdID0gdnRbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzVjtcbn1cblxuLyoqXG4gKiBDbGVhbiB3cmFwcGVyIG1ldGhvZCB0byB1c2UgUkRQIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lcyhsaW5lczogbnVtYmVyW11bXVtdLFxuICB0b2xlcmFuY2U/OiBudW1iZXIpOiBudW1iZXJbXVtdW10ge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdW11bXSA9IFtdO1xuICBsZXQgdG9sID0gMi4wO1xuICBpZiAodG9sZXJhbmNlKSB7XG4gICAgdG9sID0gdG9sZXJhbmNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChzaW1wbGlmeUxpbmUobGluZXNbaV0sIHRvbCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydCBmcm9tIHBvbHlsaW5lcyB0byBzdHJva2UtNSBmb3JtYXQgdGhhdCBza2V0Y2gtcm5uIHVzZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVzVG9TdHJva2VzKHJhd0RhdGE6IG51bWJlcltdW11bXSk6IG51bWJlcltdW10ge1xuICBsZXQgeDogbnVtYmVyLCB5OiBudW1iZXI7XG4gIGxldCBweCA9IDAsIHB5ID0gMDtcbiAgbGV0IGR4OiBudW1iZXIsIGR5OiBudW1iZXI7XG4gIGxldCBwb246IG51bWJlciwgcG9mZjogbnVtYmVyO1xuICBjb25zdCBzdHJva2U6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyO1xuICBsZXQgbGVuOiBudW1iZXI7XG4gIGxldCBwOiBudW1iZXJbXTtcbiAgZm9yIChpID0gMDsgaSA8IHJhd0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gPSByYXdEYXRhW2ldLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHAgPSByYXdEYXRhW2ldW2pdO1xuICAgICAgICB4ID0gcFswXTtcbiAgICAgICAgeSA9IHBbMV07XG4gICAgICAgIGlmIChqID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgcG9mZiA9IDE7XG4gICAgICAgICAgcG9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ZmID0gMDtcbiAgICAgICAgICBwb24gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtIHB4O1xuICAgICAgICBkeSA9IHkgLSBweTtcbiAgICAgICAgcHggPSB4O1xuICAgICAgICBweSA9IHk7XG4gICAgICAgIHN0cm9rZS5wdXNoKFtkeCwgZHksIHBvbiwgcG9mZiwgMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdHJva2UucHVzaChbMCwgMCwgMCwgMCwgMV0pO1xuICByZXR1cm4gc3Ryb2tlLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdG8gc3Ryb2tlLTUgZm9ybWF0IHRvIHBvbHlsaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lVG9TdHJva2UobGluZTogbnVtYmVyW11bXSxcbiAgbGFzdFBvaW50OiBudW1iZXJbXSk6IG51bWJlcltdW10ge1xuICBsZXQgcG9uOiBudW1iZXIsIHBvZmY6IG51bWJlcjtcbiAgY29uc3Qgc3Ryb2tlOiBudW1iZXJbXVtdID0gW107XG4gIGxldCBsZW46IG51bWJlcjtcbiAgbGV0IHA6IG51bWJlcltdO1xuICBsZXQgZHg6IG51bWJlciwgZHk6IG51bWJlcjtcbiAgbGV0IHg6IG51bWJlciwgeTogbnVtYmVyO1xuICBsZXQgcHg6IG51bWJlciwgcHk6IG51bWJlcjtcbiAgbGV0IGo6IG51bWJlcjtcbiAgcHggPSBsYXN0UG9pbnRbMF07XG4gIHB5ID0gbGFzdFBvaW50WzFdO1xuICBsZW4gPSBsaW5lLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDEpIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHAgPSBsaW5lW2pdO1xuICAgICAgeCA9IHBbMF07XG4gICAgICB5ID0gcFsxXTtcbiAgICAgIGlmIChqID09PSBsZW4gLSAxKSB7XG4gICAgICAgIHBvZmYgPSAxO1xuICAgICAgICBwb24gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9mZiA9IDA7XG4gICAgICAgIHBvbiA9IDE7XG4gICAgICB9XG4gICAgICBkeCA9IHggLSBweDtcbiAgICAgIGR5ID0geSAtIHB5O1xuICAgICAgcHggPSB4O1xuICAgICAgcHkgPSB5O1xuICAgICAgc3Ryb2tlLnB1c2goW2R4LCBkeSwgcG9uLCBwb2ZmLCAwXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJva2U7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMnO1xuZXhwb3J0IHt0Zn07XG5cbmV4cG9ydCAqIGZyb20gJy4vc2tldGNoX3Jubic7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmV4cG9ydCB7U2tldGNoUk5OfSBmcm9tICcuL21vZGVsJztcbiIsIi8qKlxuICogQ29yZSBpbXBsZW1lbnRhdGlvbiBmb3IgUk5OLWJhc2VkIE1hZ2VudGEgc2tldGNoIG1vZGVscyBzdWNoIGFzIFNrZXRjaFJOTi5cbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogSW1wb3J0c1xuICovXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQgKiBhcyBzdXBwb3J0IGZyb20gJy4uL2NvcmUvc2tldGNoX3N1cHBvcnQnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgSlNPTiBzcGVjaWZpY2F0aW9uIG9mIGEgYE11c2ljVkFFYCBtb2RlbC5cbiAqXG4gKiBAcHJvcGVydHkgbWF4X3NlcV9sZW46IE1vZGVsIHRyYWluZWQgb24gZGF0YXNldCB3LyB0aGlzIG1heCBzZXF1ZW5jZSBsZW5ndGguXG4gKiBAcHJvcGVydHkgbW9kZTogUHJlLXRyYWluZWQgbW9kZWxzIGhhdmUgdGhpcyBwYXJhbWV0ZXIgZm9yIGxlZ2FjeSByZWFzb25zLlxuICogMCBmb3IgVkFFLCAxIGZvciBEZWNvZGVyIG9ubHkuIFRoaXMgbW9kZWwgaXMgRGVjb2RlciBvbmx5IChub3QgdXNlZCkuXG4gKiBAcHJvcGVydHkgbmFtZTogUXVpY2tEcmF3IG5hbWUsIGxpa2UgY2F0LCBkb2csIGVsZXBoYW50LCBldGNcbiAqIEBwcm9wZXJ0eSBzY2FsZV9mYWN0b3I6IHRoZSBmYWN0b3IgdG8gY29udmVydCBmcm9tIG5ldXJhbC1uZXR3b3JrIHNwYWNlIHRvXG4gKiBwaXhlbCBzcGFjZS4gTW9zdCBwcmUtdHJhaW5lZCBtb2RlbHMgaGF2ZSB0aGlzIG51bWJlciBiZXR3ZWVuIDgwLTEyMFxuICogQHByb3BlcnR5IHZlcnNpb246IFByZS10cmFpbmVkIG1vZGVscyBoYXZlIGEgdmVyc2lvbiBiZXR3ZWVuIDEtNiwgZm9yXG4gKiB0aGUgcHVycG9zZSBvZiBleHBlcmltZW50YWwgcmVzZWFyY2ggbG9nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNrZXRjaFJOTkluZm8ge1xuICBtYXhfc2VxX2xlbjogbnVtYmVyO1xuICBtb2RlOiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgc2NhbGVfZmFjdG9yOiBudW1iZXI7XG4gIHZlcnNpb246IG51bWJlcjtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHNwZWNpZmljYXRpb24gb2YgdGhlIFByb2JhYmlsaXR5IERpc3RyaWJ1dGlvbiBGdW5jdGlvblxuICogb2YgYSBwZW4gc3Ryb2tlLlxuICogXG4gKiBQbGVhc2UgcmVmZXIgdG8gXCJBIE5ldXJhbCBSZXByZXNlbnRhdGlvbiBvZiBTa2V0Y2ggRHJhd2luZ3NcIlxuICogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDQuMDM0NzdcbiAqIFxuICogSW4gRXEuMyBpcyBhbiBleHBsYW5hdGlvbiBvZiBhbGwgb2YgdGhlc2UgcGFyYW1ldGVycy5cbiAqIFxuICogQmVsb3cgaXMgYSBicmllZiBkZXNjcmlwdGlvbjpcbiAqIFxuICogQHByb3BlcnR5IHBpOiBjYXRlZ29yaWFsIGRpc3RyaWJ1dGlvbiBmb3IgbWl4dHVyZSBvZiBHYXVzc2lhblxuICogQHByb3BlcnR5IG11WDogbWVhbiBmb3IgeC1heGlzXG4gKiBAcHJvcGVydHkgbXVZOiBtZWFuIGZvciB5LWF4aXNcbiAqIEBwcm9wZXJ0eSBzaWdtYVg6IHN0YW5kYXJkIGRldmlhdGlvbiBvZiB4LWF4aXNcbiAqIEBwcm9wZXJ0eSBzaWdtYVk6IHN0YW5kYXJkIGRldmlhdGlvbiBvZiB5LWF4aXNcbiAqIEBwcm9wZXJ0eSBjb3JyOiBjb3JyZWxhdGlvbiBwYXJhbWV0ZXIgYmV0d2VlbiB4IGFuZCB5XG4gKiBAcHJvcGVydHkgcGVuOiBjYXRlZ29yaWNhbCBkaXN0cmlidXRpb24gZm9yIHRoZSAzIHBlbiBzdGF0ZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJva2VQREYge1xuICBwaTogRmxvYXQzMkFycmF5O1xuICBtdVg6IEZsb2F0MzJBcnJheTtcbiAgbXVZOiBGbG9hdDMyQXJyYXk7XG4gIHNpZ21hWDogRmxvYXQzMkFycmF5O1xuICBzaWdtYVk6IEZsb2F0MzJBcnJheTtcbiAgY29ycjogRmxvYXQzMkFycmF5O1xuICBwZW46IEZsb2F0MzJBcnJheTtcbn1cblxuLyoqXG4gKiBTdGF0ZXMgb2YgdGhlIExTVE0gQ2VsbFxuICogXG4gKiBMb25nLVNob3J0IFRlcm0gTWVtb3J5OiBmdHA6Ly9mdHAuaWRzaWEuY2gvcHViL2p1ZXJnZW4vbHN0bS5wZGZcbiAqIFxuICogQHByb3BlcnR5IGM6IG1lbW9yeSBcImNlbGxcIiBvZiB0aGUgTFNUTS5cbiAqIEBwcm9wZXJ0eSBoOiBoaWRkZW4gc3RhdGUgKGFsc28gdGhlIG91dHB1dCkgb2YgdGhlIExTVE0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTFNUTVN0YXRlIHtcbiAgYzogRmxvYXQzMkFycmF5O1xuICBoOiBGbG9hdDMyQXJyYXk7XG59XG5cbi8qKlxuICogTWFpbiBTa2V0Y2hSTk4gbW9kZWwgY2xhc3MuXG4gKlxuICogSW1wbGVtZW50YXRpb24gb2YgZGVjb2RlciBtb2RlbCBpbiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNC4wMzQ3N1xuICogXG4gKiBUT0RPKGhhcmRtYXJ1KTogbWFrZSBhIFwiYmF0Y2hcIiBjb250aW51ZVNlcXVlbmNlLWxpa2UgbWV0aG9kXG4gKiB0aGF0IHJ1bnMgZnVsbHkgb24gR1BVLlxuICovXG5leHBvcnQgY2xhc3MgU2tldGNoUk5OIHtcbiAgcHJpdmF0ZSBjaGVja3BvaW50VVJMOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBmb3JnZXRCaWFzOiB0Zi5TY2FsYXI7XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuICBwdWJsaWMgaW5mbzogU2tldGNoUk5OSW5mbztcbiAgcHVibGljIG51bVVuaXRzOiBudW1iZXI7XG5cbiAgcHVibGljIHBpeGVsRmFjdG9yOiBudW1iZXI7XG4gIHB1YmxpYyBzY2FsZUZhY3RvcjogbnVtYmVyO1xuXG4gIC8vIHJhdyB3ZWlnaHRzIGFuZCBkaW1lbnNpb25zIGRpcmVjdGx5IGZyb20gSlNPTlxuICBwcml2YXRlIHdlaWdodHM6IEZsb2F0MzJBcnJheVtdO1xuICBwcml2YXRlIHdlaWdodERpbXM6IG51bWJlcltdW107XG5cbiAgLy8gVGVuc29yRmxvdy5qcyB3ZWlnaHQgbWF0cmljZXNcbiAgcHJpdmF0ZSBvdXRwdXRLZXJuZWw6IHRmLlRlbnNvcjJEO1xuICBwcml2YXRlIG91dHB1dEJpYXM6IHRmLlRlbnNvcjFEO1xuICBwcml2YXRlIGxzdG1LZXJuZWw6IHRmLlRlbnNvcjJEO1xuICBwcml2YXRlIGxzdG1CaWFzOiB0Zi5UZW5zb3IxRDtcblxuICBwcml2YXRlIHJhd1ZhcnM6IHRmLlRlbnNvcltdO1xuXG4gIHByaXZhdGUgTk1JWFRVUkUgPSAyMDtcblxuICAvKipcbiAgICogYFNrZXRjaFJOTmAgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBjaGVja3BvaW50VVJMIFBhdGggdG8gdGhlIGNoZWNrcG9pbnQgZGlyZWN0b3J5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2hlY2twb2ludFVSTDogc3RyaW5nKSB7XG4gICAgdGhpcy5jaGVja3BvaW50VVJMID0gY2hlY2twb2ludFVSTDtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG1vZGVsIGlzIGludGlhbGl6ZWQuXG4gICAqL1xuICBpc0luaXRpYWxpemVkKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBjbGFzcyBpbmZvcm1hdGlvbiBpbnB1dHMgZnJvbSB0aGUgSlNPTiBtb2RlbC5cbiAgICogVE9ETyhoYXJkbWFydSk6IHRvIGFkZCBzdXBwb3J0IGZvciBuZXcgdGZqcyBjaGVja3BvaW50cy5cbiAgICovXG4gIHByaXZhdGUgaW5zdGFudGlhdGVGcm9tSlNPTihpbmZvOiBTa2V0Y2hSTk5JbmZvLFxuICAgIHdlaWdodERpbXM6IG51bWJlcltdW10sXG4gICAgd2VpZ2h0U3RyaW5nczogc3RyaW5nW10pIHtcblxuICAgIHRoaXMuZm9yZ2V0QmlhcyA9IHRmLnNjYWxhcigxLjApO1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgdGhpcy5zZXRQaXhlbEZhY3RvcigyLjApO1xuICAgIHRoaXMud2VpZ2h0RGltcyA9IHdlaWdodERpbXM7XG4gICAgdGhpcy5udW1Vbml0cyA9IHRoaXMud2VpZ2h0RGltc1swXVswXTsgLy8gc2l6ZSBvZiBMU1RNXG4gICAgbGV0IHJhd1dlaWdodHM6IEZsb2F0MzJBcnJheTtcbiAgICBjb25zdCBtYXhXZWlnaHQgPSAxMC4wO1xuICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0U3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmF3V2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoc3VwcG9ydC5zdHJpbmdUb0FycmF5KHdlaWdodFN0cmluZ3NbaV0pKTtcbiAgICAgIGNvbnN0IE46IG51bWJlciA9IHJhd1dlaWdodHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBOOyBqKyspIHtcbiAgICAgICAgcmF3V2VpZ2h0c1tqXSA9IG1heFdlaWdodCAqIHJhd1dlaWdodHNbal0gLyAzMjc2NztcbiAgICAgIH1cbiAgICAgIHRoaXMud2VpZ2h0cy5wdXNoKHJhd1dlaWdodHMpO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dEtlcm5lbCA9IHRmLnRlbnNvcjJkKHRoaXMud2VpZ2h0c1swXSxcbiAgICAgIFt0aGlzLndlaWdodERpbXNbMF1bMF0sIHRoaXMud2VpZ2h0RGltc1swXVsxXV0pO1xuICAgIHRoaXMub3V0cHV0QmlhcyA9IHRmLnRlbnNvcjFkKHRoaXMud2VpZ2h0c1sxXSk7XG4gICAgY29uc3QgbHN0bUtlcm5lbFhIID0gdGYudGVuc29yMmQodGhpcy53ZWlnaHRzWzJdLFxuICAgICAgW3RoaXMud2VpZ2h0RGltc1syXVswXSwgdGhpcy53ZWlnaHREaW1zWzJdWzFdXSk7XG4gICAgY29uc3QgbHN0bUtlcm5lbEhIID0gdGYudGVuc29yMmQodGhpcy53ZWlnaHRzWzNdLFxuICAgICAgW3RoaXMud2VpZ2h0RGltc1szXVswXSwgdGhpcy53ZWlnaHREaW1zWzNdWzFdXSk7XG4gICAgY29uc3QgYXhpcyA9IDA7XG4gICAgdGhpcy5sc3RtS2VybmVsID0gdGYuY29uY2F0MmQoW2xzdG1LZXJuZWxYSCwgbHN0bUtlcm5lbEhIXSwgYXhpcyk7XG4gICAgdGhpcy5sc3RtQmlhcyA9IHRmLnRlbnNvcjFkKHRoaXMud2VpZ2h0c1s0XSk7XG5cbiAgICB0aGlzLnJhd1ZhcnMgPSBbXG4gICAgICB0aGlzLm91dHB1dEtlcm5lbCxcbiAgICAgIHRoaXMub3V0cHV0QmlhcyxcbiAgICAgIHRoaXMubHN0bUtlcm5lbCxcbiAgICAgIHRoaXMubHN0bUJpYXNcbiAgICBdO1xuXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdmFyaWFibGVzIGZyb20gdGhlIEpTT04gbW9kZWxcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG5cbiAgICBjb25zdCB2YXJzID0gYXdhaXQgZmV0Y2godGhpcy5jaGVja3BvaW50VVJMKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuXG4gICAgdGhpcy5pbnN0YW50aWF0ZUZyb21KU09OKHZhcnNbMF0sIHZhcnNbMV0sIHZhcnNbMl0pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemVkIFNrZXRjaFJOTi4nKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMucmF3VmFycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhd1ZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yYXdWYXJzW2ldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmF3VmFycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9yZ2V0Qmlhcykge1xuICAgICAgdGhpcy5mb3JnZXRCaWFzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZm9yZ2V0QmlhcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVybmFsIEVYVFJBIGZhY3RvciBvZiB0aGlzIG1vZGVsIChwaXhlbCB0byBtb2RlbCBzcGFjZSlcbiAgICpcbiAgICogQHBhcmFtIHNjYWxlICh0aGUgZXh0cmEgc2NhbGUgZmFjdG9yIGZvciBwaXhlbCB0byBtb2RlbCBzcGFjZSlcbiAgICpcbiAgICogQHJldHVybnMgbm90aGluZ1xuICAgKi9cbiAgc2V0UGl4ZWxGYWN0b3Ioc2NhbGU6IG51bWJlcikge1xuICAgIC8vIGZvciBiZXN0IGVmZmVjdCwgc2V0IHRvIDEuMCBmb3IgZDMgb3IgcGFwZXIuanMsIDIuMCBmb3IgcDUuanNcbiAgICB0aGlzLnBpeGVsRmFjdG9yID0gc2NhbGU7XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IHRoaXMuaW5mby5zY2FsZV9mYWN0b3IgLyB0aGlzLnBpeGVsRmFjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFJOTiwgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0cm9rZSBbZHgsIGR5LCBwZW5Eb3duLCBwZW5VcCwgcGVuRW5kXS5cbiAgICogQHBhcmFtIHN0YXRlIHByZXZpb3VzIExTVE1TdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMgbmV4dCBMU1RNU3RhdGUuXG4gICAqL1xuICB1cGRhdGUoc3Ryb2tlOiBudW1iZXJbXSwgc3RhdGU6IExTVE1TdGF0ZSkge1xuICAgIGNvbnN0IG91dCA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgbnVtVW5pdHMgPSB0aGlzLm51bVVuaXRzO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2NhbGVGYWN0b3I7XG4gICAgICBjb25zdCBub3JtU3Ryb2tlID1cbiAgICAgICAgW3N0cm9rZVswXS9zLCBzdHJva2VbMV0vcywgc3Ryb2tlWzJdLCBzdHJva2VbM10sIHN0cm9rZVs0XV07XG4gICAgICBjb25zdCB4ID0gdGYudGVuc29yMmQobm9ybVN0cm9rZSwgWzEsIDVdKTtcbiAgICAgIGNvbnN0IGMgPSB0Zi50ZW5zb3IyZChzdGF0ZS5jLCBbMSwgbnVtVW5pdHNdKTtcbiAgICAgIGNvbnN0IGggPSB0Zi50ZW5zb3IyZChzdGF0ZS5oLCBbMSwgbnVtVW5pdHNdKTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGYuYmFzaWNMU1RNQ2VsbChcbiAgICAgICAgdGhpcy5mb3JnZXRCaWFzLFxuICAgICAgICB0aGlzLmxzdG1LZXJuZWwsXG4gICAgICAgIHRoaXMubHN0bUJpYXMsXG4gICAgICAgIHgsXG4gICAgICAgIGMsXG4gICAgICAgIGgpO1xuICAgICAgcmV0dXJuIHRmLmNvbmNhdChuZXdTdGF0ZSwgMSk7XG4gICAgfSk7XG4gICAgY29uc3QgbmV3Q0ggPSBvdXQuZGF0YVN5bmMoKTtcbiAgICBvdXQuZGlzcG9zZSgpO1xuICAgIGNvbnN0IG5ld0MgPSBuZXdDSC5zbGljZSgwLCB0aGlzLm51bVVuaXRzKTtcbiAgICBjb25zdCBuZXdIID0gbmV3Q0guc2xpY2UodGhpcy5udW1Vbml0cywgdGhpcy5udW1Vbml0cyAqIDIpO1xuICAgIGNvbnN0IGZpbmFsU3RhdGU6TFNUTVN0YXRlID0ge1xuICAgICAgYzogbmV3IEZsb2F0MzJBcnJheShuZXdDKSxcbiAgICAgIGg6IG5ldyBGbG9hdDMyQXJyYXkobmV3SClcbiAgICB9O1xuICAgIHJldHVybiBmaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFJOTiBvbiBhIHNlcmllcyBvZiBTdHJva2VzLCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gc3Ryb2tlcyBsaXN0IG9mIFtkeCwgZHksIHBlbkRvd24sIHBlblVwLCBwZW5FbmRdLlxuICAgKiBAcGFyYW0gc3RhdGUgcHJldmlvdXMgTFNUTVN0YXRlLlxuICAgKiBAcGFyYW0gc3RlcHMgKE9wdGlvbmFsKSBudW1iZXIgb2Ygc3RlcHMgb2YgdGhlIHN0cm9rZSB0byB1cGRhdGVcbiAgICogKGRlZmF1bHQgaXMgbGVuZ3RoIG9mIHN0cm9rZXMgbGlzdClcbiAgICogXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBmaW5hbCBMU1RNU3RhdGUuXG4gICAqL1xuICB1cGRhdGVTdHJva2VzKHN0cm9rZXM6IG51bWJlcltdW10sIHN0YXRlOiBMU1RNU3RhdGUsIHN0ZXBzPzogbnVtYmVyKSB7XG4gICAgY29uc3Qgb3V0ID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBudW1Vbml0cyA9IHRoaXMubnVtVW5pdHM7XG4gICAgICBjb25zdCBzID0gdGhpcy5zY2FsZUZhY3RvcjtcbiAgICAgIGxldCBub3JtU3Ryb2tlOm51bWJlcltdO1xuICAgICAgbGV0IHg6IHRmLlRlbnNvcjJEO1xuICAgICAgbGV0IGM6IHRmLlRlbnNvcjJEO1xuICAgICAgbGV0IGg6IHRmLlRlbnNvcjJEO1xuICAgICAgbGV0IG5ld1N0YXRlOiB0Zi5UZW5zb3IyRFtdO1xuICAgICAgbGV0IG51bVN0ZXBzID0gc3Ryb2tlcy5sZW5ndGg7XG4gICAgICBpZiAoc3RlcHMpIHtcbiAgICAgICAgbnVtU3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIGMgPSB0Zi50ZW5zb3IyZChzdGF0ZS5jLCBbMSwgbnVtVW5pdHNdKTtcbiAgICAgIGggPSB0Zi50ZW5zb3IyZChzdGF0ZS5oLCBbMSwgbnVtVW5pdHNdKTtcbiAgICAgIGZvciAobGV0IGk9MDtpPG51bVN0ZXBzO2krKykge1xuICAgICAgICBub3JtU3Ryb2tlID0gW3N0cm9rZXNbaV1bMF0vcyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VzW2ldWzFdL3MsXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlc1tpXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VzW2ldWzNdLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZXNbaV1bNF1dO1xuICAgICAgICB4ID0gdGYudGVuc29yMmQobm9ybVN0cm9rZSwgWzEsIDVdKTtcbiAgICAgICAgbmV3U3RhdGUgPSB0Zi5iYXNpY0xTVE1DZWxsKFxuICAgICAgICAgIHRoaXMuZm9yZ2V0QmlhcyxcbiAgICAgICAgICB0aGlzLmxzdG1LZXJuZWwsXG4gICAgICAgICAgdGhpcy5sc3RtQmlhcyxcbiAgICAgICAgICB4LFxuICAgICAgICAgIGMsXG4gICAgICAgICAgaCk7XG4gICAgICAgIGMgPSBuZXdTdGF0ZVswXTtcbiAgICAgICAgaCA9IG5ld1N0YXRlWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRmLmNvbmNhdChuZXdTdGF0ZSwgMSk7XG4gICAgfSk7XG4gICAgY29uc3QgbmV3Q0ggPSBvdXQuZGF0YVN5bmMoKTtcbiAgICBvdXQuZGlzcG9zZSgpO1xuICAgIGNvbnN0IG5ld0MgPSBuZXdDSC5zbGljZSgwLCB0aGlzLm51bVVuaXRzKTtcbiAgICBjb25zdCBuZXdIID0gbmV3Q0guc2xpY2UodGhpcy5udW1Vbml0cywgdGhpcy5udW1Vbml0cyAqIDIpO1xuICAgIGNvbnN0IGZpbmFsU3RhdGU6TFNUTVN0YXRlID0ge1xuICAgICAgYzogbmV3IEZsb2F0MzJBcnJheShuZXdDKSxcbiAgICAgIGg6IG5ldyBGbG9hdDMyQXJyYXkobmV3SClcbiAgICB9O1xuICAgIHJldHVybiBmaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBSTk4gc3RhdGUsIHJldHVybnMgdGhlIHByb2JhYmlsdHkgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uIChwZGYpXG4gICAqIG9mIHRoZSBuZXh0IHN0cm9rZS4gT3B0aW9uYWxseSBhZGp1c3QgdGhlIHRlbXBlcmF0dXJlIG9mIHRoZSBwZGYgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIHByZXZpb3VzIExTVE1TdGF0ZS5cbiAgICogQHBhcmFtIHRlbXBlcmF0dXJlIChPcHRpb25hbCkgZm9yIGR4IGFuZCBkeSAoZGVmYXVsdCAwLjY1KVxuICAgKiBAcGFyYW0gc29mdG1heFRlbXBlcmF0dXJlIChPcHRpb25hbCkgZm9yIFBpIGFuZCBQZW4gZGlzY3JldGUgc3RhdGVzXG4gICAqIChkZWZhdWx0IGlzIHRlbXBlcmF0dXJlICogMC41ICsgMC41LCB3aGljaCBpcyBhIG5pY2UgaGV1cmlzdGljLilcbiAgICpcbiAgICogQHJldHVybnMgU3Ryb2tlUERGIChwaSwgbXVYLCBtdVksIHNpZ21hWCwgc2lnbWFZLCBjb3JyLCBwZW4pXG4gICAqL1xuICBnZXRQREYoc3RhdGU6IExTVE1TdGF0ZSxcbiAgICB0ZW1wZXJhdHVyZT0wLjY1LFxuICAgIHNvZnRtYXhUZW1wZXJhdHVyZT86IG51bWJlcikge1xuICAgIGNvbnN0IHRlbXAgPSB0ZW1wZXJhdHVyZTtcbiAgICBsZXQgZGlzY3JldGVUZW1wOiBudW1iZXIgPSAwLjUgKyB0ZW1wICogMC41OyAvLyBnb29kIGhldXJpc3RpYy5cbiAgICBpZiAoc29mdG1heFRlbXBlcmF0dXJlKSB7XG4gICAgICBkaXNjcmV0ZVRlbXAgPSBzb2Z0bWF4VGVtcGVyYXR1cmU7XG4gICAgfVxuICAgIGNvbnN0IE5PVVQgPSB0aGlzLk5NSVhUVVJFO1xuICAgIGNvbnN0IG91dCA9IHRmLnRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgbnVtVW5pdHMgPSB0aGlzLm51bVVuaXRzO1xuICAgICAgY29uc3QgaCA9IHRmLnRlbnNvcjJkKHN0YXRlLmgsIFsxLCBudW1Vbml0c10pO1xuXG4gICAgICBjb25zdCBzcXJ0dGVtcCA9IHRmLnNjYWxhcihNYXRoLnNxcnQodGVtcCkpO1xuICAgICAgY29uc3Qgc29mdHRlbXAgPSB0Zi5zY2FsYXIoZGlzY3JldGVUZW1wKTtcblxuICAgICAgY29uc3QgeiA9IHRmLmFkZCh0Zi5tYXRNdWwoaCwgdGhpcy5vdXRwdXRLZXJuZWwpLCB0aGlzLm91dHB1dEJpYXMpXG4gICAgICAgIC5zcXVlZXplKCk7XG5cbiAgICAgIGNvbnN0IFtyYXdQZW4sIHJzdF0gPSB0Zi5zcGxpdCh6LCBbMywgTk9VVCo2XSk7XG4gICAgICBjb25zdCBbcmF3UGksIG11MSwgbXUyLCByYXdTaWdtYTEsIHJhd1NpZ21hMiwgcmF3Q29ycl0gPSB0Zi5zcGxpdChyc3QsIDYpO1xuICAgICAgY29uc3QgcGVuID0gdGYuc29mdG1heChyYXdQZW4uZGl2KHNvZnR0ZW1wKSk7XG4gICAgICBjb25zdCBwaSA9IHRmLnNvZnRtYXgocmF3UGkuZGl2KHNvZnR0ZW1wKSk7XG4gICAgICBjb25zdCBzaWdtYTEgPSB0Zi5leHAocmF3U2lnbWExKS5tdWwoc3FydHRlbXApO1xuICAgICAgY29uc3Qgc2lnbWEyID0gdGYuZXhwKHJhd1NpZ21hMikubXVsKHNxcnR0ZW1wKTtcbiAgICAgIGNvbnN0IGNvcnIgPSB0Zi50YW5oKHJhd0NvcnIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW3BpLCBtdTEsIG11Miwgc2lnbWExLCBzaWdtYTIsIGNvcnIsIHBlbl07XG4gICAgICAvLyBjb25jYXQsIGFuZCB0aGVuIHVucGFjayBhZnRlciBkYXRhU3luY1xuICAgICAgcmV0dXJuIHRmLmNvbmNhdChyZXN1bHQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG91dC5kYXRhU3luYygpO1xuICAgIG91dC5kaXNwb3NlKCk7XG4gICAgY29uc3QgcGRmOlN0cm9rZVBERiA9IHsgLy8gbm90ZTogSlMgZG9lc24ndCBoYXZlIGEgbmljZSBcInNwbGl0XCIgbWV0aG9kLlxuICAgICAgcGk6IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnNsaWNlKDAsIE5PVVQpKSxcbiAgICAgIG11WDogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoMSpOT1VULCAyKk5PVVQpKSxcbiAgICAgIG11WTogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoMipOT1VULCAzKk5PVVQpKSxcbiAgICAgIHNpZ21hWDogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoMypOT1VULCA0Kk5PVVQpKSxcbiAgICAgIHNpZ21hWTogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoNCpOT1VULCAxNSpOT1VUKSksXG4gICAgICBjb3JyOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSg1Kk5PVVQsIDYqTk9VVCkpLFxuICAgICAgcGVuOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSg2Kk5PVVQsIDYqTk9VVCszKSlcbiAgICB9O1xuICAgIHJldHVybiBwZGY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgemVyby9pbml0aWFsIHN0YXRlIG9mIHRoZSBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyB6ZXJvIHN0YXRlIG9mIHRoZSBsc3RtOiBbYywgaF0sIHdoZXJlIGMgYW5kIGggYXJlIHplcm8gdmVjdG9ycy5cbiAgICovXG4gIHplcm9TdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQ6TFNUTVN0YXRlID0ge1xuICAgICAgYzogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bVVuaXRzKSxcbiAgICAgIGg6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1Vbml0cylcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBjb3B5IG9mIHRoZSBybm4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHJublN0YXRlIG9yaWdpbmFsIExTVE1TdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyBjb3B5IG9mIExTVE1TdGF0ZVxuICAgKi9cbiAgY29weVN0YXRlKHJublN0YXRlOiBMU1RNU3RhdGUpIHtcbiAgICBjb25zdCByZXN1bHQ6TFNUTVN0YXRlID0ge1xuICAgICAgYzogbmV3IEZsb2F0MzJBcnJheShybm5TdGF0ZS5jKSxcbiAgICAgIGg6IG5ldyBGbG9hdDMyQXJyYXkocm5uU3RhdGUuaClcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgemVybyBpbnB1dCBzdGF0ZSBvZiB0aGUgbW9kZWxcbiAgICpcbiAgICogQHJldHVybnMgWzAsIDAsIDEsIDAsIDBdLlxuICAgKi9cbiAgemVyb0lucHV0KCkge1xuICAgIHJldHVybiBbMCwgMCwgMSwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogU2FtcGxlcyB0aGUgbmV4dCBwb2ludCBvZiB0aGUgc2tldGNoIGdpdmVuIHBkZiBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBwZGYgcmVzdWx0IGZyb20gZ2V0UERGKCkgY2FsbFxuICAgKlxuICAgKiBAcmV0dXJucyBbZHgsIGR5LCBwZW5Eb3duLCBwZW5VcCwgcGVuRW5kXVxuICAgKi9cbiAgc2FtcGxlKHBkZjogU3Ryb2tlUERGKSB7XG4gICAgLy8gcGRmIGlzIGEgU3Ryb2tlUERGIEludGVyZmFjZVxuICAgIC8vIHJldHVybnMgW3gsIHksIGVvc11cbiAgICBjb25zdCBpZHggPSBzdXBwb3J0LnNhbXBsZVNvZnRtYXgocGRmLnBpKTtcbiAgICBjb25zdCBtdTEgPSBwZGYubXVYW2lkeF07XG4gICAgY29uc3QgbXUyID0gcGRmLm11WVtpZHhdO1xuICAgIGNvbnN0IHNpZ21hMSA9IHBkZi5zaWdtYVhbaWR4XTtcbiAgICBjb25zdCBzaWdtYTIgPSBwZGYuc2lnbWFZW2lkeF07XG4gICAgY29uc3QgY29yciA9IHBkZi5jb3JyW2lkeF07XG4gICAgY29uc3QgcGVuSWR4ID0gc3VwcG9ydC5zYW1wbGVTb2Z0bWF4KHBkZi5wZW4pO1xuICAgIGNvbnN0IHBlbnN0YXRlID0gWzAsIDAsIDBdO1xuICAgIHBlbnN0YXRlW3BlbklkeF0gPSAxO1xuICAgIGNvbnN0IGRlbHRhID0gc3VwcG9ydC5iaXJhbmRuKG11MSwgbXUyLCBzaWdtYTEsIHNpZ21hMiwgY29ycik7XG4gICAgY29uc3Qgc3Ryb2tlID0gW1xuICAgICAgZGVsdGFbMF0gKiB0aGlzLnNjYWxlRmFjdG9yLFxuICAgICAgZGVsdGFbMV0gKiB0aGlzLnNjYWxlRmFjdG9yLFxuICAgICAgcGVuc3RhdGVbMF0sXG4gICAgICBwZW5zdGF0ZVsxXSxcbiAgICAgIHBlbnN0YXRlWzJdXG4gICAgXTtcbiAgICByZXR1cm4gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsaWZpZXMgbGluZSB1c2luZyBSRFAgYWxnb3JpdGhtXG4gICAqXG4gICAqIEBwYXJhbSBsaW5lIGxpc3Qgb2YgcG9pbnRzIFtbeDAsIHkwXSwgW3gxLCB5MV0sIC4uLl1cbiAgICogQHBhcmFtIHRvbGVyYW5jZSAoT3B0aW9uYWwpIGRlZmF1bHQgMi4wXG4gICAqXG4gICAqIEByZXR1cm5zIHNpbXBpZmllZCBsaW5lIFtbeDAnLCB5MCddLCBbeDEnLCB5MSddLCAuLi5dXG4gICAqL1xuICBzaW1wbGlmeUxpbmUobGluZTogbnVtYmVyW11bXSwgdG9sZXJhbmNlPzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHN1cHBvcnQuc2ltcGxpZnlMaW5lKGxpbmUsIHRvbGVyYW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxpZmllcyBsaW5lcyB1c2luZyBSRFAgYWxnb3JpdGhtXG4gICAqXG4gICAqIEBwYXJhbSBsaW5lIGxpc3Qgb2YgbGluZXMgKGVhY2ggZWxlbWVudCBpcyBbW3gwLCB5MF0sIFt4MSwgeTFdLCAuLi5dKVxuICAgKiBAcGFyYW0gdG9sZXJhbmNlIChPcHRpb25hbCkgZGVmYXVsdCAyLjBcbiAgICpcbiAgICogQHJldHVybnMgc2ltcGlmaWVkIGxpbmVzIChlYWNoIGVsZW0gaXMgW1t4MCcsIHkwJ10sIFt4MScsIHkxJ10sIC4uLl0pXG4gICAqL1xuICBzaW1wbGlmeUxpbmVzKGxpbmVzOiBudW1iZXJbXVtdW10sIHRvbGVyYW5jZT86IG51bWJlcikge1xuICAgIHJldHVybiBzdXBwb3J0LnNpbXBsaWZ5TGluZXMobGluZXMsIHRvbGVyYW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBmcm9tIHBvbHlsaW5lcyB0byBzdHJva2UtNSBmb3JtYXQgdGhhdCBza2V0Y2gtcm5uIHVzZXNcbiAgICpcbiAgICogQHBhcmFtIGxpbmVzIGxpc3Qgb2YgcG9pbnRzIGVhY2ggZWxlbSBpcyAoW1t4MCwgeTBdLCBbeDEsIHkxXSwgLi4uXSlcbiAgICpcbiAgICogQHJldHVybnMgc3Ryb2tlLTUgZm9ybWF0IG9mIHRoZSBsaW5lLCBsaXN0IG9mIFtkeCwgZHksIHAwLCBwMSwgcDJdXG4gICAqL1xuICBsaW5lc1RvU3Ryb2tlKGxpbmVzOiBudW1iZXJbXVtdW10pIHtcbiAgICByZXR1cm4gc3VwcG9ydC5saW5lc1RvU3Ryb2tlcyhsaW5lcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBmcm9tIGEgbGluZSBmb3JtYXQgdG8gc3Ryb2tlLTVcbiAgICpcbiAgICogQHBhcmFtIGxpbmUgbGlzdCBvZiBwb2ludHMgW1t4MCwgeTBdLCBbeDEsIHkxXSwgLi4uXVxuICAgKiBAcGFyYW0gbGFzdFBvaW50IHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBwb2ludFxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJva2UtNSBmb3JtYXQgb2YgdGhlIGxpbmUsIGxpc3Qgb2YgW2R4LCBkeSwgcDAsIHAxLCBwMl1cbiAgICovXG4gIGxpbmVUb1N0cm9rZShsaW5lOiBudW1iZXJbXVtdLCBsYXN0UG9pbnQ6IG51bWJlcltdKSB7XG4gICAgcmV0dXJuIHN1cHBvcnQubGluZVRvU3Ryb2tlKGxpbmUsIGxhc3RQb2ludCk7XG4gIH1cblxufVxuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==